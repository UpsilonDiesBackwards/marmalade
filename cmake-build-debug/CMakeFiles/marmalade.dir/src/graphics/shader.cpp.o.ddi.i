# 0 "/home/tayler/projects/marmalade/src/graphics/shader.cpp"
# 1 "/home/tayler/projects/marmalade/cmake-build-debug//"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "/home/tayler/projects/marmalade/src/graphics/shader.cpp"
# 1 "/usr/include/c++/14.2.1/fstream" 1 3
# 36 "/usr/include/c++/14.2.1/fstream" 3
       
# 37 "/usr/include/c++/14.2.1/fstream" 3

# 1 "/usr/include/c++/14.2.1/bits/requires_hosted.h" 1 3
# 31 "/usr/include/c++/14.2.1/bits/requires_hosted.h" 3
# 1 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 1 3
# 33 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
       
# 34 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 308 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3

# 308 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;


#pragma GCC visibility push(default)


  extern "C++" __attribute__ ((__noreturn__, __always_inline__))
  inline void __terminate() noexcept
  {
    void terminate() noexcept __attribute__ ((__noreturn__,__cold__));
    terminate();
  }
#pragma GCC visibility pop
}
# 341 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 534 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
#pragma GCC visibility push(default)




  __attribute__((__always_inline__))
  constexpr inline bool
  __is_constant_evaluated() noexcept
  {





    return __builtin_is_constant_evaluated();



  }
#pragma GCC visibility pop
}
# 573 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
#pragma GCC visibility push(default)

  extern "C++" __attribute__ ((__noreturn__))
  void
  __glibcxx_assert_fail
    (const char* __file, int __line, const char* __function,
     const char* __condition)
  noexcept;
#pragma GCC visibility pop
}
# 601 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  __attribute__((__always_inline__,__visibility__("default")))
  inline void
  __glibcxx_assert_fail()
  { }
}
# 680 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 1 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/os_defines.h" 1 3
# 39 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 402 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/bits/timesize.h" 1 3 4
# 19 "/usr/include/bits/timesize.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 20 "/usr/include/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 403 "/usr/include/features.h" 2 3 4
# 511 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 730 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 731 "/usr/include/sys/cdefs.h" 2 3 4
# 1 "/usr/include/bits/long-double.h" 1 3 4
# 732 "/usr/include/sys/cdefs.h" 2 3 4
# 512 "/usr/include/features.h" 2 3 4
# 535 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 3 4
# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/gnu/stubs.h" 2 3 4
# 536 "/usr/include/features.h" 2 3 4
# 40 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/os_defines.h" 2 3
# 681 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 2 3


# 1 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/cpu_defines.h" 1 3
# 684 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 2 3
# 825 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace __gnu_cxx
{
  typedef __decltype(0.0bf16) __bfloat16_t;
}
# 887 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 1 "/usr/include/c++/14.2.1/pstl/pstl_config.h" 1 3
# 888 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 2 3
# 32 "/usr/include/c++/14.2.1/bits/requires_hosted.h" 2 3
# 39 "/usr/include/c++/14.2.1/fstream" 2 3

# 1 "/usr/include/c++/14.2.1/istream" 1 3
# 36 "/usr/include/c++/14.2.1/istream" 3
       
# 37 "/usr/include/c++/14.2.1/istream" 3



# 1 "/usr/include/c++/14.2.1/ios" 1 3
# 36 "/usr/include/c++/14.2.1/ios" 3
       
# 37 "/usr/include/c++/14.2.1/ios" 3



# 1 "/usr/include/c++/14.2.1/iosfwd" 1 3
# 36 "/usr/include/c++/14.2.1/iosfwd" 3
       
# 37 "/usr/include/c++/14.2.1/iosfwd" 3




# 1 "/usr/include/c++/14.2.1/bits/stringfwd.h" 1 3
# 37 "/usr/include/c++/14.2.1/bits/stringfwd.h" 3
       
# 38 "/usr/include/c++/14.2.1/bits/stringfwd.h" 3


# 1 "/usr/include/c++/14.2.1/bits/memoryfwd.h" 1 3
# 46 "/usr/include/c++/14.2.1/bits/memoryfwd.h" 3
       
# 47 "/usr/include/c++/14.2.1/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 64 "/usr/include/c++/14.2.1/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;



  template<typename, typename>
    struct uses_allocator;

  template<typename>
    struct allocator_traits;





}
# 41 "/usr/include/c++/14.2.1/bits/stringfwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{








  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;

  template<> struct char_traits<wchar_t>;


  template<> struct char_traits<char8_t>;



  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

}


  typedef basic_string<char> string;


  typedef basic_string<wchar_t> wstring;



  typedef basic_string<char8_t> u8string;




  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;





}
# 42 "/usr/include/c++/14.2.1/iosfwd" 2 3
# 1 "/usr/include/c++/14.2.1/bits/postypes.h" 1 3
# 38 "/usr/include/c++/14.2.1/bits/postypes.h" 3
       
# 39 "/usr/include/c++/14.2.1/bits/postypes.h" 3

# 1 "/usr/include/c++/14.2.1/cwchar" 1 3
# 39 "/usr/include/c++/14.2.1/cwchar" 3
       
# 40 "/usr/include/c++/14.2.1/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 27 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/bits/floatn.h" 1 3 4
# 119 "/usr/include/bits/floatn.h" 3 4
# 1 "/usr/include/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/bits/floatn-common.h" 3 4
# 1 "/usr/include/bits/long-double.h" 1 3 4
# 25 "/usr/include/bits/floatn-common.h" 2 3 4
# 120 "/usr/include/bits/floatn.h" 2 3 4
# 31 "/usr/include/wchar.h" 2 3 4




# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 214 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 36 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 39 "/usr/include/wchar.h" 2 3 4




typedef __gnuc_va_list va_list;







# 1 "/usr/include/bits/wchar.h" 1 3 4
# 52 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/bits/types/wint_t.h" 1 3 4
# 20 "/usr/include/bits/types/wint_t.h" 3 4
typedef unsigned int wint_t;
# 53 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/bits/types/mbstate_t.h" 1 3 4



# 1 "/usr/include/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 5 "/usr/include/bits/types/mbstate_t.h" 2 3 4

typedef __mbstate_t mbstate_t;
# 54 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 55 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 58 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/bits/types/locale_t.h" 3 4
# 1 "/usr/include/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 61 "/usr/include/wchar.h" 2 3 4
# 90 "/usr/include/wchar.h" 3 4
extern "C" {



struct tm;



extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern size_t wcslcpy (wchar_t *__restrict __dest,
         const wchar_t *__restrict __src, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 3)));



extern size_t wcslcat (wchar_t *__restrict __dest,
         const wchar_t *__restrict __src, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__read_write__, 1, 3)));



extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) noexcept (true);


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) noexcept (true);



extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    locale_t __loc) noexcept (true);

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, locale_t __loc) noexcept (true);




extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) noexcept (true);



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) noexcept (true);







extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        locale_t __loc) noexcept (true);




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, locale_t __loc) noexcept (true);


extern wchar_t *wcsdup (const wchar_t *__s) noexcept (true)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (__builtin_free, 1)));




extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     noexcept (true) __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     noexcept (true) __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     noexcept (true) __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     noexcept (true) __asm ("wcsrchr") __attribute__ ((__pure__));
# 206 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     noexcept (true) __attribute__ ((__pure__));




extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     noexcept (true) __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     noexcept (true) __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
     noexcept (true) __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
         const wchar_t *__accept)
     noexcept (true) __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
     noexcept (true) __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
        const wchar_t *__needle)
     noexcept (true) __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) noexcept (true);


extern size_t wcslen (const wchar_t *__s) noexcept (true) __attribute__ ((__pure__));




extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
     noexcept (true) __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
        const wchar_t *__needle)
     noexcept (true) __asm ("wcswcs") __attribute__ ((__pure__));
# 265 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     noexcept (true) __attribute__ ((__pure__));





extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     noexcept (true) __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
         size_t __n)
     noexcept (true) __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) noexcept (true);



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     noexcept (true);


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) noexcept (true);




extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     noexcept (true);





extern wint_t btowc (int __c) noexcept (true);



extern int wctob (wint_t __c) noexcept (true);



extern int mbsinit (const mbstate_t *__ps) noexcept (true) __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) noexcept (true);


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) noexcept (true);


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) noexcept (true);
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) noexcept (true);
# 362 "/usr/include/wchar.h" 3 4
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) noexcept (true);



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) noexcept (true);





extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) noexcept (true);



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) noexcept (true);






extern int wcwidth (wchar_t __c) noexcept (true);



extern int wcswidth (const wchar_t *__s, size_t __n) noexcept (true);





extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) noexcept (true);



extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);
# 422 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) noexcept (true);



extern _Float64 wcstof64 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) noexcept (true);



extern _Float128 wcstof128 (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);



extern _Float32x wcstof32x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);



extern _Float64x wcstof64x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);
# 455 "/usr/include/wchar.h" 3 4
extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) noexcept (true);



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     noexcept (true);




__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     noexcept (true);



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) noexcept (true);





__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     noexcept (true);



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) noexcept (true);






extern long int wcstol (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_wcstol")

                                   ;
extern unsigned long int wcstoul (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_wcstoul")


                                     ;
__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_wcstoll")


                                        ;
__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_wcstoull")


                                           ;

__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_wcstoll")

                                         ;
__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_wcstoull")


                                           ;
# 561 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     locale_t __loc) noexcept (true);

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, locale_t __loc) noexcept (true);

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, locale_t __loc) noexcept (true);

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, locale_t __loc)
     noexcept (true);





extern long int wcstol_l (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_wcstol_l")


                      ;
extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_wcstoul_l")



                         ;
__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_wcstoll_l")



                            ;
__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_wcstoull_l")



                               ;
# 630 "/usr/include/wchar.h" 3 4
extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, locale_t __loc)
     noexcept (true);

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, locale_t __loc)
     noexcept (true);

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) noexcept (true);
# 649 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) noexcept (true);



extern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) noexcept (true);



extern _Float128 wcstof128_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) noexcept (true);



extern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) noexcept (true);



extern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) noexcept (true);
# 689 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) noexcept (true);



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     noexcept (true);
# 718 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) noexcept (true)
  __attribute__ ((__malloc__)) ;





extern int fwide (__FILE *__fp, int __mode) noexcept (true);






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     noexcept (true) ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     noexcept (true) ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     noexcept (true) ;
# 795 "/usr/include/wchar.h" 3 4
extern int fwscanf (__FILE *__restrict __stream, const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc23_fwscanf")


                                                          ;
extern int wscanf (const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc23_wscanf")

                                                          ;
extern int swscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) noexcept (true) __asm__ ("" "__isoc23_swscanf")


                                                          ;
# 851 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     noexcept (true) ;
# 875 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc23_vfwscanf")


                                                          ;
extern int vwscanf (const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc23_vwscanf")

                                                          ;
extern int vswscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) noexcept (true) __asm__ ("" "__isoc23_vswscanf")


                                                          ;
# 935 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 990 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 1016 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 1026 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);






extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) noexcept (true);




extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) noexcept (true);
# 1073 "/usr/include/wchar.h" 3 4
}
# 45 "/usr/include/c++/14.2.1/cwchar" 2 3
# 62 "/usr/include/c++/14.2.1/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "/usr/include/c++/14.2.1/cwchar" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
# 234 "/usr/include/c++/14.2.1/cwchar" 3

}
}







namespace __gnu_cxx
{





  using ::wcstold;
# 260 "/usr/include/c++/14.2.1/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 280 "/usr/include/c++/14.2.1/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "/usr/include/c++/14.2.1/bits/postypes.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 62 "/usr/include/c++/14.2.1/bits/postypes.h" 3
  typedef long int streamoff;





  typedef ptrdiff_t streamsize;
# 81 "/usr/include/c++/14.2.1/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 103 "/usr/include/c++/14.2.1/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      fpos(const fpos&) = default;
      fpos& operator=(const fpos&) = default;
      ~fpos() = default;



      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u8streampos;




  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 43 "/usr/include/c++/14.2.1/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 76 "/usr/include/c++/14.2.1/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;



  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Allocator = allocator<_CharT>>
    class basic_syncbuf;
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Allocator = allocator<_CharT>>
    class basic_osyncstream;

  using syncbuf = basic_syncbuf<char>;
  using osyncstream = basic_osyncstream<char>;


  using wsyncbuf = basic_syncbuf<wchar_t>;
  using wosyncstream = basic_osyncstream<wchar_t>;
# 255 "/usr/include/c++/14.2.1/iosfwd" 3

}
# 41 "/usr/include/c++/14.2.1/ios" 2 3
# 1 "/usr/include/c++/14.2.1/exception" 1 3
# 33 "/usr/include/c++/14.2.1/exception" 3
       
# 34 "/usr/include/c++/14.2.1/exception" 3


# 1 "/usr/include/c++/14.2.1/bits/exception.h" 1 3
# 34 "/usr/include/c++/14.2.1/bits/exception.h" 3
       
# 35 "/usr/include/c++/14.2.1/bits/exception.h" 3



extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{
# 59 "/usr/include/c++/14.2.1/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;

    exception(const exception&) = default;
    exception& operator=(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(exception&&) = default;




    virtual const char*
    what() const noexcept;
  };



}

}
# 37 "/usr/include/c++/14.2.1/exception" 2 3


# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 40 "/usr/include/c++/14.2.1/exception" 2 3

extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{
# 54 "/usr/include/c++/14.2.1/exception" 3
  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__,__cold__));



  typedef void (*__attribute__ ((__deprecated__)) unexpected_handler) ();





  __attribute__ ((__deprecated__))
  unexpected_handler set_unexpected(unexpected_handler) noexcept;







  __attribute__ ((__deprecated__))
  unexpected_handler get_unexpected() noexcept;







  __attribute__ ((__deprecated__))
  void unexpected() __attribute__ ((__noreturn__,__cold__));
# 124 "/usr/include/c++/14.2.1/exception" 3
  __attribute__ ((__deprecated__ ("use '" "std::uncaught_exceptions()" "' instead")))
  bool uncaught_exception() noexcept __attribute__ ((__pure__));






  int uncaught_exceptions() noexcept __attribute__ ((__pure__));



}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 158 "/usr/include/c++/14.2.1/exception" 3
  void __verbose_terminate_handler();


}

}


# 1 "/usr/include/c++/14.2.1/bits/exception_ptr.h" 1 3
# 35 "/usr/include/c++/14.2.1/bits/exception_ptr.h" 3
# 1 "/usr/include/c++/14.2.1/bits/exception_defines.h" 1 3
# 36 "/usr/include/c++/14.2.1/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/cxxabi_init_exception.h" 1 3
# 34 "/usr/include/c++/14.2.1/bits/cxxabi_init_exception.h" 3
       
# 35 "/usr/include/c++/14.2.1/bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 145 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 425 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 436 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 39 "/usr/include/c++/14.2.1/bits/cxxabi_init_exception.h" 2 3
# 50 "/usr/include/c++/14.2.1/bits/cxxabi_init_exception.h" 3
namespace std
{
  class type_info;
}

namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;

  extern "C"
    {

      void*
      __cxa_allocate_exception(size_t) noexcept;

      void
      __cxa_free_exception(void*) noexcept;


      __cxa_refcounted_exception*
      __cxa_init_primary_exception(void *__object, std::type_info *__tinfo,
                void ( *__dest) (void *))
 noexcept;

    }
}



#pragma GCC visibility pop
# 37 "/usr/include/c++/14.2.1/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/14.2.1/typeinfo" 1 3
# 32 "/usr/include/c++/14.2.1/typeinfo" 3
       
# 33 "/usr/include/c++/14.2.1/typeinfo" 3



# 1 "/usr/include/c++/14.2.1/bits/hash_bytes.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/hash_bytes.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "/usr/include/c++/14.2.1/typeinfo" 2 3



# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 41 "/usr/include/c++/14.2.1/typeinfo" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 83 "/usr/include/c++/14.2.1/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }



    bool before(const type_info& __arg) const noexcept;

   
    bool operator==(const type_info& __arg) const noexcept;







    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:


    type_info& operator=(const type_info&) = delete;
    type_info(const type_info&) = delete;
# 166 "/usr/include/c++/14.2.1/typeinfo" 3
  };


  inline bool
  type_info::before(const type_info& __arg) const noexcept
  {




    if (__name[0] != '*' || __arg.__name[0] != '*')
      return __builtin_strcmp (__name, __arg.__name) < 0;
# 186 "/usr/include/c++/14.2.1/typeinfo" 3
    return __name < __arg.__name;
  }



  inline bool
  type_info::operator==(const type_info& __arg) const noexcept
  {
    if (std::__is_constant_evaluated())
      return this == &__arg;

    if (__name == __arg.__name)
      return true;






    return __name[0] != '*' && __builtin_strcmp (__name, __arg.name()) == 0;



  }
# 219 "/usr/include/c++/14.2.1/typeinfo" 3
  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 38 "/usr/include/c++/14.2.1/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/14.2.1/new" 1 3
# 38 "/usr/include/c++/14.2.1/new" 3
       
# 39 "/usr/include/c++/14.2.1/new" 3







# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 47 "/usr/include/c++/14.2.1/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    bad_alloc(const bad_alloc&) = default;
    bad_alloc& operator=(const bad_alloc&) = default;




    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };



  enum class align_val_t: size_t {};


  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 131 "/usr/include/c++/14.2.1/new" 3
[[__nodiscard__]] void* operator new(std::size_t)
  __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t)
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete(void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete(void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t)
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete[](void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));

void operator delete(void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));




[[__nodiscard__]] inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
[[__nodiscard__]] inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}


namespace std
{


  template<typename _Tp>
    [[nodiscard]] constexpr _Tp*
    launder(_Tp* __p) noexcept
    { return __builtin_launder(__p); }




  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args...) noexcept (_NE)) = delete;
  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args......) noexcept (_NE)) = delete;

  void launder(void*) = delete;
  void launder(const void*) = delete;
  void launder(volatile void*) = delete;
  void launder(const volatile void*) = delete;



  inline constexpr size_t hardware_destructive_interference_size = 64;
  inline constexpr size_t hardware_constructive_interference_size = 64;

}




namespace std
{


  struct destroying_delete_t
  {
    explicit destroying_delete_t() = default;
  };

  inline constexpr destroying_delete_t destroying_delete{};
}


#pragma GCC visibility pop
# 39 "/usr/include/c++/14.2.1/bits/exception_ptr.h" 2 3


# 1 "/usr/include/c++/14.2.1/bits/move.h" 1 3
# 37 "/usr/include/c++/14.2.1/bits/move.h" 3
# 1 "/usr/include/c++/14.2.1/type_traits" 1 3
# 32 "/usr/include/c++/14.2.1/type_traits" 3
       
# 33 "/usr/include/c++/14.2.1/type_traits" 3
# 63 "/usr/include/c++/14.2.1/type_traits" 3
# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 64 "/usr/include/c++/14.2.1/type_traits" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp>
    class reference_wrapper;
# 86 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      using value_type = _Tp;
      using type = integral_constant<_Tp, __v>;
      constexpr operator value_type() const noexcept { return value; }


      constexpr value_type operator()() const noexcept { return value; }

    };
# 106 "/usr/include/c++/14.2.1/type_traits" 3
  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;



  using true_type = __bool_constant<true>;


  using false_type = __bool_constant<false>;




  template<bool __v>
    using bool_constant = __bool_constant<__v>;






  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { using type = _Tp; };


  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;

  template<bool>
    struct __conditional
    {
      template<typename _Tp, typename>
 using type = _Tp;
    };

  template<>
    struct __conditional<false>
    {
      template<typename, typename _Up>
 using type = _Up;
    };


  template<bool _Cond, typename _If, typename _Else>
    using __conditional_t
      = typename __conditional<_Cond>::template type<_If, _Else>;


  template <typename _Type>
    struct __type_identity
    { using type = _Type; };

  template<typename _Tp>
    using __type_identity_t = typename __type_identity<_Tp>::type;

  namespace __detail
  {

    template<typename _Tp, typename...>
      using __first_t = _Tp;


    template<typename... _Bn>
      auto __or_fn(int) -> __first_t<false_type,
         __enable_if_t<!bool(_Bn::value)>...>;

    template<typename... _Bn>
      auto __or_fn(...) -> true_type;

    template<typename... _Bn>
      auto __and_fn(int) -> __first_t<true_type,
          __enable_if_t<bool(_Bn::value)>...>;

    template<typename... _Bn>
      auto __and_fn(...) -> false_type;
  }




  template<typename... _Bn>
    struct __or_
    : decltype(__detail::__or_fn<_Bn...>(0))
    { };

  template<typename... _Bn>
    struct __and_
    : decltype(__detail::__and_fn<_Bn...>(0))
    { };

  template<typename _Pp>
    struct __not_
    : __bool_constant<!bool(_Pp::value)>
    { };





  template<typename... _Bn>
    inline constexpr bool __or_v = __or_<_Bn...>::value;
  template<typename... _Bn>
    inline constexpr bool __and_v = __and_<_Bn...>::value;

  namespace __detail
  {
    template<typename , typename _B1, typename... _Bn>
      struct __disjunction_impl
      { using type = _B1; };

    template<typename _B1, typename _B2, typename... _Bn>
      struct __disjunction_impl<__enable_if_t<!bool(_B1::value)>, _B1, _B2, _Bn...>
      { using type = typename __disjunction_impl<void, _B2, _Bn...>::type; };

    template<typename , typename _B1, typename... _Bn>
      struct __conjunction_impl
      { using type = _B1; };

    template<typename _B1, typename _B2, typename... _Bn>
      struct __conjunction_impl<__enable_if_t<bool(_B1::value)>, _B1, _B2, _Bn...>
      { using type = typename __conjunction_impl<void, _B2, _Bn...>::type; };
  }


  template<typename... _Bn>
    struct conjunction
    : __detail::__conjunction_impl<void, _Bn...>::type
    { };

  template<>
    struct conjunction<>
    : true_type
    { };

  template<typename... _Bn>
    struct disjunction
    : __detail::__disjunction_impl<void, _Bn...>::type
    { };

  template<>
    struct disjunction<>
    : false_type
    { };

  template<typename _Pp>
    struct negation
    : __not_<_Pp>::type
    { };




  template<typename... _Bn>
    inline constexpr bool conjunction_v = conjunction<_Bn...>::value;

  template<typename... _Bn>
    inline constexpr bool disjunction_v = disjunction<_Bn...>::value;

  template<typename _Pp>
    inline constexpr bool negation_v = negation<_Pp>::value;





  template<typename>
    struct is_reference;
  template<typename>
    struct is_function;
  template<typename>
    struct is_void;
  template<typename>
    struct remove_cv;
  template<typename>
    struct is_const;


  template<typename>
    struct __is_array_unknown_bounds;




  template <typename _Tp, size_t = sizeof(_Tp)>
    constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>)
    { return {}; }

  template <typename _TypeIdentity,
      typename _NestedType = typename _TypeIdentity::type>
    constexpr typename __or_<
      is_reference<_NestedType>,
      is_function<_NestedType>,
      is_void<_NestedType>,
      __is_array_unknown_bounds<_NestedType>
    >::type __is_complete_or_unbounded(_TypeIdentity)
    { return {}; }


  template<typename _Tp>
    using __remove_cv_t = typename remove_cv<_Tp>::type;





  template<typename _Tp>
    struct is_void
    : public false_type { };

  template<>
    struct is_void<void>
    : public true_type { };

  template<>
    struct is_void<const void>
    : public true_type { };

  template<>
    struct is_void<volatile void>
    : public true_type { };

  template<>
    struct is_void<const volatile void>
    : public true_type { };


  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };




  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char8_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  __extension__
  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  __extension__
  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
# 460 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 513 "/usr/include/c++/14.2.1/type_traits" 3
  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };




  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type
    { };



  template<typename _Tp>
    struct is_array
    : public __bool_constant<__is_array(_Tp)>
    { };
# 545 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };



  template<typename _Tp>
    struct is_member_object_pointer
    : public __bool_constant<__is_member_object_pointer(_Tp)>
    { };
# 601 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct is_member_function_pointer
    : public __bool_constant<__is_member_function_pointer(_Tp)>
    { };
# 622 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct is_enum
    : public __bool_constant<__is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public __bool_constant<__is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public __bool_constant<__is_class(_Tp)>
    { };



  template<typename _Tp>
    struct is_function
    : public __bool_constant<__is_function(_Tp)>
    { };
# 661 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct is_null_pointer
    : public false_type { };

  template<>
    struct is_null_pointer<std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<const std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<volatile std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<const volatile std::nullptr_t>
    : public true_type { };



  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { } __attribute__ ((__deprecated__ ("use '" "std::is_null_pointer" "' instead")));






  template<typename _Tp>
    struct is_reference
    : public __bool_constant<__is_reference(_Tp)>
    { };
# 715 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };



  template<typename _Tp>
    struct is_object
    : public __bool_constant<__is_object(_Tp)>
    { };
# 741 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public __bool_constant<!is_fundamental<_Tp>::value> { };



  template<typename _Tp>
    struct is_member_pointer
    : public __bool_constant<__is_member_pointer(_Tp)>
    { };
# 779 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename, typename>
    struct is_same;


  template<typename _Tp, typename... _Types>
    using __is_one_of = __or_<is_same<_Tp, _Types>...>;


  __extension__
  template<typename _Tp>
    using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>,
   signed char, signed short, signed int, signed long,
   signed long long

   , signed __int128
# 804 "/usr/include/c++/14.2.1/type_traits" 3
   >;


  __extension__
  template<typename _Tp>
    using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>,
   unsigned char, unsigned short, unsigned int, unsigned long,
   unsigned long long

   , unsigned __int128
# 824 "/usr/include/c++/14.2.1/type_traits" 3
   >;


  template<typename _Tp>
    using __is_standard_integer
      = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;


  template<typename...> using __void_t = void;





  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public __bool_constant<__is_trivial(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copyable
    : public __bool_constant<__is_trivially_copyable(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_standard_layout
    : public __bool_constant<__is_standard_layout(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };






  template<typename _Tp>
    struct
    __attribute__ ((__deprecated__ ("use '" "is_standard_layout && is_trivial" "' instead")))
    is_pod
    : public __bool_constant<__is_pod(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct
    [[__deprecated__]]
    is_literal_type
    : public __bool_constant<__is_literal_type(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_empty
    : public __bool_constant<__is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public __bool_constant<__is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public __bool_constant<__is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public __bool_constant<__is_abstract(_Tp)>
    { };


  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public __bool_constant<_Tp(-1) < _Tp(0)>
    { };



  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type
    { };


  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);


  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename>
    struct remove_all_extents;


  template<typename _Tp>
    struct __is_array_known_bounds
    : public false_type
    { };

  template<typename _Tp, size_t _Size>
    struct __is_array_known_bounds<_Tp[_Size]>
    : public true_type
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public false_type
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds<_Tp[]>
    : public true_type
    { };
# 1006 "/usr/include/c++/14.2.1/type_traits" 3
  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };



  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };







  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static __bool_constant<noexcept(declval<_Tp&>().~_Tp())>
      __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };



  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_constructible_impl
      = __bool_constant<__is_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __is_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename = void>
    struct __add_lvalue_reference_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, __void_t<_Tp&>>
    { using type = _Tp&; };

  template<typename _Tp>
    using __add_lval_ref_t = typename __add_lvalue_reference_helper<_Tp>::type;



  template<typename _Tp>
    struct is_copy_constructible
    : public __is_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename = void>
    struct __add_rvalue_reference_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, __void_t<_Tp&&>>
    { using type = _Tp&&; };

  template<typename _Tp>
    using __add_rval_ref_t = typename __add_rvalue_reference_helper<_Tp>::type;



  template<typename _Tp>
    struct is_move_constructible
    : public __is_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_nothrow_constructible_impl
      = __bool_constant<__is_nothrow_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __is_nothrow_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __is_nothrow_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_assignable_impl = __bool_constant<__is_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_assignable
    : public __is_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_assignable_impl<__add_lval_ref_t<_Tp>,
      __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_assignable_impl<__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_nothrow_assignable_impl
      = __bool_constant<__is_nothrow_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __is_nothrow_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>,
       __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>,
       __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_trivially_constructible_impl
      = __bool_constant<__is_trivially_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __is_trivially_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public __is_trivially_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    constexpr bool __is_implicitly_default_constructible_v
      = requires (void(&__f)(_Tp)) { __f({}); };

  template<typename _Tp>
    struct __is_implicitly_default_constructible
    : __bool_constant<__is_implicitly_default_constructible_v<_Tp>>
    { };
# 1351 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_trivially_assignable_impl
      = __bool_constant<__is_trivially_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __is_trivially_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>,
         __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>,
         __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<__is_destructible_safe<_Tp>,
      __bool_constant<__has_trivial_destructor(_Tp)>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct has_virtual_destructor
    : public __bool_constant<__has_virtual_destructor(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint = 0>
    struct extent
    : public integral_constant<size_t, 0> { };

  template<typename _Tp, size_t _Size>
    struct extent<_Tp[_Size], 0>
    : public integral_constant<size_t, _Size> { };

  template<typename _Tp, unsigned _Uint, size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public extent<_Tp, _Uint - 1>::type { };

  template<typename _Tp>
    struct extent<_Tp[], 0>
    : public integral_constant<size_t, 0> { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public extent<_Tp, _Uint - 1>::type { };






  template<typename _Tp, typename _Up>
    struct is_same
    : public __bool_constant<__is_same(_Tp, _Up)>
    { };
# 1491 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Base, typename _Derived>
    struct is_base_of
    : public __bool_constant<__is_base_of(_Base, _Derived)>
    { };


  template<typename _From, typename _To>
    struct is_convertible
    : public __bool_constant<__is_convertible(_From, _To)>
    { };
# 1540 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _ToElementType, typename _FromElementType>
    using __is_array_convertible
      = is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;





  template<typename _From, typename _To>
    inline constexpr bool is_nothrow_convertible_v
      = __is_nothrow_convertible(_From, _To);


  template<typename _From, typename _To>
    struct is_nothrow_convertible
    : public bool_constant<is_nothrow_convertible_v<_From, _To>>
    { };
# 1603 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct remove_const
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { using type = _Tp; };


  template<typename _Tp>
    struct remove_volatile
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { using type = _Tp; };



  template<typename _Tp>
    struct remove_cv
    { using type = __remove_cv(_Tp); };
# 1644 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct add_const
    { using type = _Tp const; };


  template<typename _Tp>
    struct add_volatile
    { using type = _Tp volatile; };


  template<typename _Tp>
    struct add_cv
    { using type = _Tp const volatile; };



  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;






  template<typename _Tp>
    struct remove_reference
    { using type = __remove_reference(_Tp); };
# 1706 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct add_lvalue_reference
    { using type = __add_lval_ref_t<_Tp>; };


  template<typename _Tp>
    struct add_rvalue_reference
    { using type = __add_rval_ref_t<_Tp>; };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;







  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { using __type = _Unqualified; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { using __type = volatile _Unqualified; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { using __type = const _Unqualified; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { using __type = const volatile _Unqualified; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      using __match = __cv_selector<_Unqualified, _IsConst, _IsVol>;

    public:
      using __type = typename __match::__type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { using __type = _Tp; };

  template<>
    struct __make_unsigned<char>
    { using __type = unsigned char; };

  template<>
    struct __make_unsigned<signed char>
    { using __type = unsigned char; };

  template<>
    struct __make_unsigned<short>
    { using __type = unsigned short; };

  template<>
    struct __make_unsigned<int>
    { using __type = unsigned int; };

  template<>
    struct __make_unsigned<long>
    { using __type = unsigned long; };

  template<>
    struct __make_unsigned<long long>
    { using __type = unsigned long long; };


  __extension__
  template<>
    struct __make_unsigned<__int128>
    { using __type = unsigned __int128; };
# 1819 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = __is_enum(_Tp)>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      using __unsigned_type
 = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };

  class __make_unsigned_selector_base
  {
  protected:
    template<typename...> struct _List { };

    template<typename _Tp, typename... _Up>
      struct _List<_Tp, _Up...> : _List<_Up...>
      { static constexpr size_t __size = sizeof(_Tp); };

    template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
      struct __select;

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, true>
      { using __type = _Uint; };

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, false>
      : __select<_Sz, _List<_UInts...>>
      { };
  };


  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    : __make_unsigned_selector_base
    {

      using _UInts = _List<unsigned char, unsigned short, unsigned int,
      unsigned long, unsigned long long>;

      using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };





  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };


  template<>
    struct __make_unsigned<char8_t>
    {
      using __type
 = typename __make_unsigned_selector<char8_t, false, true>::__type;
    };


  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };






  template<typename _Tp>
    struct make_unsigned
    { using type = typename __make_unsigned_selector<_Tp>::__type; };


  template<> struct make_unsigned<bool>;
  template<> struct make_unsigned<bool const>;
  template<> struct make_unsigned<bool volatile>;
  template<> struct make_unsigned<bool const volatile>;




  template<typename _Tp>
    struct __make_signed
    { using __type = _Tp; };

  template<>
    struct __make_signed<char>
    { using __type = signed char; };

  template<>
    struct __make_signed<unsigned char>
    { using __type = signed char; };

  template<>
    struct __make_signed<unsigned short>
    { using __type = signed short; };

  template<>
    struct __make_signed<unsigned int>
    { using __type = signed int; };

  template<>
    struct __make_signed<unsigned long>
    { using __type = signed long; };

  template<>
    struct __make_signed<unsigned long long>
    { using __type = signed long long; };


  __extension__
  template<>
    struct __make_signed<unsigned __int128>
    { using __type = __int128; };
# 1979 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = __is_enum(_Tp)>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      using __signed_type
 = typename __make_signed<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };


  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      using __unsigned_type = typename __make_unsigned_selector<_Tp>::__type;

    public:
      using __type = typename __make_signed_selector<__unsigned_type>::__type;
    };





  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };


  template<>
    struct __make_signed<char8_t>
    {
      using __type
 = typename __make_signed_selector<char8_t, false, true>::__type;
    };


  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };






  template<typename _Tp>
    struct make_signed
    { using type = typename __make_signed_selector<_Tp>::__type; };


  template<> struct make_signed<bool>;
  template<> struct make_signed<bool const>;
  template<> struct make_signed<bool volatile>;
  template<> struct make_signed<bool const volatile>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { using type = _Tp; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { using type = _Tp; };


  template<typename _Tp>
    struct remove_all_extents
    { using type = _Tp; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { using type = typename remove_all_extents<_Tp>::type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { using type = typename remove_all_extents<_Tp>::type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;






  template<typename _Tp>
    struct remove_pointer
    { using type = __remove_pointer(_Tp); };
# 2124 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp, typename = void>
    struct __add_pointer_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, __void_t<_Tp*>>
    { using type = _Tp*; };


  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };

  template<typename _Tp>
    struct add_pointer<_Tp&>
    { using type = _Tp*; };

  template<typename _Tp>
    struct add_pointer<_Tp&&>
    { using type = _Tp*; };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2179 "/usr/include/c++/14.2.1/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct
   
    aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 2225 "/usr/include/c++/14.2.1/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct
   
    aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      using type = typename aligned_storage<_S_len, alignment_value>::type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;
#pragma GCC diagnostic pop





  template<typename _Up>
    struct __decay_selector
    : __conditional_t<is_const<const _Up>::value,
        remove_cv<_Up>,
        add_pointer<_Up>>
    { };

  template<typename _Up, size_t _Nm>
    struct __decay_selector<_Up[_Nm]>
    { using type = _Up*; };

  template<typename _Up>
    struct __decay_selector<_Up[]>
    { using type = _Up*; };




  template<typename _Tp>
    struct decay
    { using type = typename __decay_selector<_Tp>::type; };

  template<typename _Tp>
    struct decay<_Tp&>
    { using type = typename __decay_selector<_Tp>::type; };

  template<typename _Tp>
    struct decay<_Tp&&>
    { using type = typename __decay_selector<_Tp>::type; };




  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      using __type = _Tp;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      using __type = _Tp&;
    };


  template<typename _Tp>
    using __decay_t = typename decay<_Tp>::type;

  template<typename _Tp>
    using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;





  template<typename... _Cond>
    using _Require = __enable_if_t<__and_<_Cond...>::value>;


  template<typename _Tp>
    using __remove_cvref_t
     = typename remove_cv<typename remove_reference<_Tp>::type>::type;




  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { using type = _Iftrue; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { using type = _Iffalse; };


  template<typename... _Tp>
    struct common_type;
# 2340 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { using type = _Tp; };

  struct __failure_type
  { };

  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      using __cond_t
 = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());



    template<typename _Tp, typename _Up>
      static __success_type<__decay_t<__cond_t<_Tp, _Up>>>
      _S_test(int);




    template<typename _Tp, typename _Up>
      static __success_type<__remove_cvref_t<__cond_t<const _Tp&, const _Up&>>>
      _S_test_2(int);


    template<typename, typename>
      static __failure_type
      _S_test_2(...);

    template<typename _Tp, typename _Up>
      static decltype(_S_test_2<_Tp, _Up>(0))
      _S_test(...);
  };


  template<>
    struct common_type<>
    { };


  template<typename _Tp0>
    struct common_type<_Tp0>
    : public common_type<_Tp0, _Tp0>
    { };


  template<typename _Tp1, typename _Tp2,
    typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>
    struct __common_type_impl
    {


      using type = common_type<_Dp1, _Dp2>;
    };

  template<typename _Tp1, typename _Tp2>
    struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
    : private __do_common_type_impl
    {


      using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };


  template<typename _Tp1, typename _Tp2>
    struct common_type<_Tp1, _Tp2>
    : public __common_type_impl<_Tp1, _Tp2>::type
    { };

  template<typename...>
    struct __common_type_pack
    { };

  template<typename, typename, typename = void>
    struct __common_type_fold;


  template<typename _Tp1, typename _Tp2, typename... _Rp>
    struct common_type<_Tp1, _Tp2, _Rp...>
    : public __common_type_fold<common_type<_Tp1, _Tp2>,
    __common_type_pack<_Rp...>>
    { };




  template<typename _CTp, typename... _Rp>
    struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
         __void_t<typename _CTp::type>>
    : public common_type<typename _CTp::type, _Rp...>
    { };


  template<typename _CTp, typename _Rp>
    struct __common_type_fold<_CTp, _Rp, void>
    { };

  template<typename _Tp, bool = __is_enum(_Tp)>
    struct __underlying_type_impl
    {
      using type = __underlying_type(_Tp);
    };

  template<typename _Tp>
    struct __underlying_type_impl<_Tp, false>
    { };



  template<typename _Tp>
    struct underlying_type
    : public __underlying_type_impl<_Tp>
    { };


  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };






  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }


  template<typename _Signature>
    struct result_of;




  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg, _Args...>(0));
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg, _Args...>(0));
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg>(0));
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg>(0));
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      using _Argval = __remove_cvref_t<_Arg>;
      using _MemPtr = _Res _Class::*;
      using type = typename __conditional_t<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      using _Argval = typename remove_reference<_Arg>::type;
      using _MemPtr = _Res _Class::*;
      using type = typename __conditional_t<is_base_of<_Class, _Argval>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type;
    };






  template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      using type = __failure_type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      using type = decltype(_S_test<_Functor, _ArgTypes...>(0));
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };


  template<typename _Fn, typename... _Args>
    using __invoke_result_t = typename __invoke_result<_Fn, _Args...>::type;


  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { } __attribute__ ((__deprecated__ ("use '" "std::invoke_result" "' instead")));


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
#pragma GCC diagnostic pop


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;




  template<typename...> using void_t = void;
# 2727 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Def, template<typename...> class _Op, typename... _Args>
    struct __detected_or
    {
      using type = _Def;
      using __is_detected = false_type;
    };


  template<typename _Def, template<typename...> class _Op, typename... _Args>
    requires requires { typename _Op<_Args...>; }
    struct __detected_or<_Def, _Op, _Args...>
    {
      using type = _Op<_Args...>;
      using __is_detected = true_type;
    };
# 2767 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2786 "/usr/include/c++/14.2.1/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type
    { };


  template<typename _Tp>
    constexpr
    inline
    _Require<__not_<__is_tuple_like<_Tp>>,
      is_move_constructible<_Tp>,
      is_move_assignable<_Tp>>
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    constexpr
    inline
    __enable_if_t<__is_swappable<_Tp>::value>
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);


  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };






  template<typename _Tp>
    struct is_swappable
    : public __is_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    inline constexpr bool is_swappable_v =
      is_swappable<_Tp>::value;


  template<typename _Tp>
    inline constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;



  namespace __swappable_with_details {
    using std::swap;

    struct __do_is_swappable_with_impl
    {
      template<typename _Tp, typename _Up, typename
               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
               typename
               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
        static true_type __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_with_impl
    {
      template<typename _Tp, typename _Up>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
          &&
          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))
        > __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp, typename _Up>
    struct __is_swappable_with_impl
    : public __swappable_with_details::__do_is_swappable_with_impl
    {
      using type = decltype(__test<_Tp, _Up>(0));
    };


  template<typename _Tp>
    struct __is_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_swappable_impl
    {
      using type = decltype(__test<_Tp&>(0));
    };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
      using type = decltype(__test<_Tp, _Up>(0));
    };


  template<typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      using type = decltype(__test<_Tp&>(0));
    };



  template<typename _Tp, typename _Up>
    struct is_swappable_with
    : public __is_swappable_with_impl<_Tp, _Up>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "first template argument must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "second template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "first template argument must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "second template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp, typename _Up>
    inline constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;


  template<typename _Tp, typename _Up>
    inline constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;
# 3008 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Result, typename _Ret,
    bool = is_void<_Ret>::value, typename = void>
    struct __is_invocable_impl
    : false_type
    {
      using __nothrow_conv = false_type;
    };


  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                true,
          __void_t<typename _Result::type>>
    : true_type
    {
      using __nothrow_conv = true_type;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                false,
          __void_t<typename _Result::type>>
    {
    private:

      using _Res_t = typename _Result::type;



      static _Res_t _S_get() noexcept;


      template<typename _Tp>
 static void _S_conv(__type_identity_t<_Tp>) noexcept;


      template<typename _Tp,
        bool _Nothrow = noexcept(_S_conv<_Tp>(_S_get())),
        typename = decltype(_S_conv<_Tp>(_S_get())),

        bool _Dangle = __reference_converts_from_temporary(_Tp, _Res_t)



       >
 static __bool_constant<_Nothrow && !_Dangle>
 _S_test(int);

      template<typename _Tp, bool = false>
 static false_type
 _S_test(...);

    public:

      using type = decltype(_S_test<_Ret, true>(1));


      using __nothrow_conv = decltype(_S_test<_Ret>(1));
    };
#pragma GCC diagnostic pop

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  struct __nonesuchbase {};
  struct __nonesuch : private __nonesuchbase {
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
#pragma GCC diagnostic pop




  template<typename _Functor, typename... _ArgTypes>
    struct invoke_result
    : public __invoke_result<_Functor, _ArgTypes...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Functor>{}),
 "_Functor must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Fn, typename... _Args>
    using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;


  template<typename _Fn, typename... _ArgTypes>
    struct is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_invocable_r
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
 "_Ret must be a complete class or an unbounded array");
    };


  template<typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable
    : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>,
      __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };





  template<typename _Result, typename _Ret>
    using __is_nt_invocable_impl
      = typename __is_invocable_impl<_Result, _Ret>::__nothrow_conv;



  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable_r
    : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>,
             __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
 "_Ret must be a complete class or an unbounded array");
    };
# 3236 "/usr/include/c++/14.2.1/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_void_v = is_void<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_integral_v = is_integral<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;


template <typename _Tp>
  inline constexpr bool is_array_v = __is_array(_Tp);
# 3257 "/usr/include/c++/14.2.1/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_lvalue_reference_v = false;
template <typename _Tp>
  inline constexpr bool is_lvalue_reference_v<_Tp&> = true;
template <typename _Tp>
  inline constexpr bool is_rvalue_reference_v = false;
template <typename _Tp>
  inline constexpr bool is_rvalue_reference_v<_Tp&&> = true;


template <typename _Tp>
  inline constexpr bool is_member_object_pointer_v =
    __is_member_object_pointer(_Tp);







template <typename _Tp>
  inline constexpr bool is_member_function_pointer_v =
    __is_member_function_pointer(_Tp);






template <typename _Tp>
  inline constexpr bool is_enum_v = __is_enum(_Tp);
template <typename _Tp>
  inline constexpr bool is_union_v = __is_union(_Tp);
template <typename _Tp>
  inline constexpr bool is_class_v = __is_class(_Tp);



template <typename _Tp>
  inline constexpr bool is_reference_v = __is_reference(_Tp);
# 3308 "/usr/include/c++/14.2.1/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;


template <typename _Tp>
  inline constexpr bool is_object_v = __is_object(_Tp);





template <typename _Tp>
  inline constexpr bool is_scalar_v = is_scalar<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_compound_v = !is_fundamental_v<_Tp>;


template <typename _Tp>
  inline constexpr bool is_member_pointer_v = __is_member_pointer(_Tp);





template <typename _Tp>
  inline constexpr bool is_const_v = false;
template <typename _Tp>
  inline constexpr bool is_const_v<const _Tp> = true;


template <typename _Tp>
  inline constexpr bool is_function_v = __is_function(_Tp);
# 3351 "/usr/include/c++/14.2.1/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_volatile_v = false;
template <typename _Tp>
  inline constexpr bool is_volatile_v<volatile _Tp> = true;

template <typename _Tp>
  inline constexpr bool is_trivial_v = __is_trivial(_Tp);
template <typename _Tp>
  inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Tp);
template <typename _Tp>
  inline constexpr bool is_standard_layout_v = __is_standard_layout(_Tp);
template <typename _Tp>
  __attribute__ ((__deprecated__ ("use '" "is_standard_layout_v && is_trivial_v" "' instead")))
  inline constexpr bool is_pod_v = __is_pod(_Tp);
template <typename _Tp>
  [[__deprecated__]]
  inline constexpr bool is_literal_type_v = __is_literal_type(_Tp);
template <typename _Tp>
  inline constexpr bool is_empty_v = __is_empty(_Tp);
template <typename _Tp>
  inline constexpr bool is_polymorphic_v = __is_polymorphic(_Tp);
template <typename _Tp>
  inline constexpr bool is_abstract_v = __is_abstract(_Tp);
template <typename _Tp>
  inline constexpr bool is_final_v = __is_final(_Tp);

template <typename _Tp>
  inline constexpr bool is_signed_v = is_signed<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;

template <typename _Tp, typename... _Args>
  inline constexpr bool is_constructible_v = __is_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_default_constructible_v = __is_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_copy_constructible_v
    = __is_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_move_constructible_v
    = __is_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_assignable_v = __is_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_copy_assignable_v
    = __is_assignable(__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_move_assignable_v
    = __is_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);

template <typename _Tp>
  inline constexpr bool is_destructible_v = is_destructible<_Tp>::value;

template <typename _Tp, typename... _Args>
  inline constexpr bool is_trivially_constructible_v
    = __is_trivially_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_trivially_default_constructible_v
    = __is_trivially_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_trivially_copy_constructible_v
    = __is_trivially_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_trivially_move_constructible_v
    = __is_trivially_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_trivially_assignable_v
    = __is_trivially_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_trivially_copy_assignable_v
    = __is_trivially_assignable(__add_lval_ref_t<_Tp>,
    __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_trivially_move_assignable_v
    = __is_trivially_assignable(__add_lval_ref_t<_Tp>,
    __add_rval_ref_t<_Tp>);


template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v = false;

template <typename _Tp>
  requires (!is_reference_v<_Tp>) && requires (_Tp& __t) { __t.~_Tp(); }
  inline constexpr bool is_trivially_destructible_v<_Tp>
    = __has_trivial_destructor(_Tp);
template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v<_Tp&> = true;
template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v<_Tp&&> = true;
template <typename _Tp, size_t _Nm>
  inline constexpr bool is_trivially_destructible_v<_Tp[_Nm]>
    = is_trivially_destructible_v<_Tp>;






template <typename _Tp, typename... _Args>
  inline constexpr bool is_nothrow_constructible_v
    = __is_nothrow_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_nothrow_default_constructible_v
    = __is_nothrow_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_constructible_v
    = __is_nothrow_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_nothrow_move_constructible_v
    = __is_nothrow_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_nothrow_assignable_v
    = __is_nothrow_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_assignable_v
    = __is_nothrow_assignable(__add_lval_ref_t<_Tp>,
         __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_nothrow_move_assignable_v
    = __is_nothrow_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);

template <typename _Tp>
  inline constexpr bool is_nothrow_destructible_v =
    is_nothrow_destructible<_Tp>::value;

template <typename _Tp>
  inline constexpr bool has_virtual_destructor_v
    = __has_virtual_destructor(_Tp);

template <typename _Tp>
  inline constexpr size_t alignment_of_v = alignment_of<_Tp>::value;

template <typename _Tp>
  inline constexpr size_t rank_v = 0;
template <typename _Tp, size_t _Size>
  inline constexpr size_t rank_v<_Tp[_Size]> = 1 + rank_v<_Tp>;
template <typename _Tp>
  inline constexpr size_t rank_v<_Tp[]> = 1 + rank_v<_Tp>;

template <typename _Tp, unsigned _Idx = 0>
  inline constexpr size_t extent_v = 0;
template <typename _Tp, size_t _Size>
  inline constexpr size_t extent_v<_Tp[_Size], 0> = _Size;
template <typename _Tp, unsigned _Idx, size_t _Size>
  inline constexpr size_t extent_v<_Tp[_Size], _Idx> = extent_v<_Tp, _Idx - 1>;
template <typename _Tp>
  inline constexpr size_t extent_v<_Tp[], 0> = 0;
template <typename _Tp, unsigned _Idx>
  inline constexpr size_t extent_v<_Tp[], _Idx> = extent_v<_Tp, _Idx - 1>;


template <typename _Tp, typename _Up>
  inline constexpr bool is_same_v = __is_same(_Tp, _Up);






template <typename _Base, typename _Derived>
  inline constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

template <typename _From, typename _To>
  inline constexpr bool is_convertible_v = __is_convertible(_From, _To);




template<typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
template<typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_v
    = is_nothrow_invocable<_Fn, _Args...>::value;
template<typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_r_v
    = is_invocable_r<_Ret, _Fn, _Args...>::value;
template<typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_r_v
    = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;






  template<typename _Tp>
    struct has_unique_object_representations
    : bool_constant<__has_unique_object_representations(
      remove_cv_t<remove_all_extents_t<_Tp>>
      )>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    inline constexpr bool has_unique_object_representations_v
      = has_unique_object_representations<_Tp>::value;






  template<typename _Tp>
    struct is_aggregate
    : bool_constant<__is_aggregate(remove_cv_t<_Tp>)>
    { };






  template<typename _Tp>
    inline constexpr bool is_aggregate_v = __is_aggregate(remove_cv_t<_Tp>);
# 3581 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct remove_cvref
    { using type = __remove_cvref(_Tp); };
# 3598 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    using remove_cvref_t = typename remove_cvref<_Tp>::type;
# 3608 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct type_identity { using type = _Tp; };

  template<typename _Tp>
    using type_identity_t = typename type_identity<_Tp>::type;
# 3621 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct unwrap_reference { using type = _Tp; };

  template<typename _Tp>
    struct unwrap_reference<reference_wrapper<_Tp>> { using type = _Tp&; };

  template<typename _Tp>
    using unwrap_reference_t = typename unwrap_reference<_Tp>::type;






  template<typename _Tp>
    struct unwrap_ref_decay { using type = unwrap_reference_t<decay_t<_Tp>>; };

  template<typename _Tp>
    using unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;
# 3648 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    inline constexpr bool is_bounded_array_v = __is_bounded_array(_Tp);
# 3661 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    inline constexpr bool is_unbounded_array_v = false;

  template<typename _Tp>
    inline constexpr bool is_unbounded_array_v<_Tp[]> = true;



  template<typename _Tp>
    struct is_bounded_array
    : public bool_constant<is_bounded_array_v<_Tp>>
    { };



  template<typename _Tp>
    struct is_unbounded_array
    : public bool_constant<is_unbounded_array_v<_Tp>>
    { };





  template<typename _Tp, typename _Up>
    struct is_layout_compatible
    : bool_constant<__is_layout_compatible(_Tp, _Up)>
    { };



  template<typename _Tp, typename _Up>
    constexpr bool is_layout_compatible_v
      = __is_layout_compatible(_Tp, _Up);







  template<typename _S1, typename _S2, typename _M1, typename _M2>
    constexpr bool
    is_corresponding_member(_M1 _S1::*__m1, _M2 _S2::*__m2) noexcept
    { return __builtin_is_corresponding_member(__m1, __m2); }







  template<typename _Base, typename _Derived>
    struct is_pointer_interconvertible_base_of
    : bool_constant<__is_pointer_interconvertible_base_of(_Base, _Derived)>
    { };



  template<typename _Base, typename _Derived>
    constexpr bool is_pointer_interconvertible_base_of_v
      = __is_pointer_interconvertible_base_of(_Base, _Derived);
# 3732 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp, typename _Mem>
    constexpr bool
    is_pointer_interconvertible_with_class(_Mem _Tp::*__mp) noexcept
    { return __builtin_is_pointer_interconvertible_with_class(__mp); }
# 3816 "/usr/include/c++/14.2.1/type_traits" 3
  constexpr inline bool
  is_constant_evaluated() noexcept
  {



    return __builtin_is_constant_evaluated();

  }




  template<typename _From, typename _To>
    using __copy_cv = typename __match_cv_qualifiers<_From, _To>::__type;

  template<typename _Xp, typename _Yp>
    using __cond_res
      = decltype(false ? declval<_Xp(&)()>()() : declval<_Yp(&)()>()());

  template<typename _Ap, typename _Bp, typename = void>
    struct __common_ref_impl
    { };


  template<typename _Ap, typename _Bp>
    using __common_ref = typename __common_ref_impl<_Ap, _Bp>::type;


  template<typename _Xp, typename _Yp>
    using __condres_cvref
      = __cond_res<__copy_cv<_Xp, _Yp>&, __copy_cv<_Yp, _Xp>&>;


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&, _Yp&, __void_t<__condres_cvref<_Xp, _Yp>>>
    : enable_if<is_reference_v<__condres_cvref<_Xp, _Yp>>,
  __condres_cvref<_Xp, _Yp>>
    { };


  template<typename _Xp, typename _Yp>
    using __common_ref_C = remove_reference_t<__common_ref<_Xp&, _Yp&>>&&;


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&&, _Yp&&,
      _Require<is_convertible<_Xp&&, __common_ref_C<_Xp, _Yp>>,
        is_convertible<_Yp&&, __common_ref_C<_Xp, _Yp>>>>
    { using type = __common_ref_C<_Xp, _Yp>; };


  template<typename _Xp, typename _Yp>
    using __common_ref_D = __common_ref<const _Xp&, _Yp&>;


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&&, _Yp&,
      _Require<is_convertible<_Xp&&, __common_ref_D<_Xp, _Yp>>>>
    { using type = __common_ref_D<_Xp, _Yp>; };


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&, _Yp&&>
    : __common_ref_impl<_Yp&&, _Xp&>
    { };


  template<typename _Tp, typename _Up,
    template<typename> class _TQual, template<typename> class _UQual>
    struct basic_common_reference
    { };


  template<typename _Tp>
    struct __xref
    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>; };

  template<typename _Tp>
    struct __xref<_Tp&>
    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>&; };

  template<typename _Tp>
    struct __xref<_Tp&&>
    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>&&; };

  template<typename _Tp1, typename _Tp2>
    using __basic_common_ref
      = typename basic_common_reference<remove_cvref_t<_Tp1>,
     remove_cvref_t<_Tp2>,
     __xref<_Tp1>::template __type,
     __xref<_Tp2>::template __type>::type;


  template<typename... _Tp>
    struct common_reference;

  template<typename... _Tp>
    using common_reference_t = typename common_reference<_Tp...>::type;


  template<>
    struct common_reference<>
    { };


  template<typename _Tp0>
    struct common_reference<_Tp0>
    { using type = _Tp0; };


  template<typename _Tp1, typename _Tp2, int _Bullet = 1, typename = void>
    struct __common_reference_impl
    : __common_reference_impl<_Tp1, _Tp2, _Bullet + 1>
    { };


  template<typename _Tp1, typename _Tp2>
    struct common_reference<_Tp1, _Tp2>
    : __common_reference_impl<_Tp1, _Tp2>
    { };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&, _Tp2&, 1,
       void_t<__common_ref<_Tp1&, _Tp2&>>>
    { using type = __common_ref<_Tp1&, _Tp2&>; };

  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&&, _Tp2&&, 1,
       void_t<__common_ref<_Tp1&&, _Tp2&&>>>
    { using type = __common_ref<_Tp1&&, _Tp2&&>; };

  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&, _Tp2&&, 1,
       void_t<__common_ref<_Tp1&, _Tp2&&>>>
    { using type = __common_ref<_Tp1&, _Tp2&&>; };

  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&&, _Tp2&, 1,
       void_t<__common_ref<_Tp1&&, _Tp2&>>>
    { using type = __common_ref<_Tp1&&, _Tp2&>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 2,
       void_t<__basic_common_ref<_Tp1, _Tp2>>>
    { using type = __basic_common_ref<_Tp1, _Tp2>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 3,
       void_t<__cond_res<_Tp1, _Tp2>>>
    { using type = __cond_res<_Tp1, _Tp2>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 4,
       void_t<common_type_t<_Tp1, _Tp2>>>
    { using type = common_type_t<_Tp1, _Tp2>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 5, void>
    { };


  template<typename _Tp1, typename _Tp2, typename... _Rest>
    struct common_reference<_Tp1, _Tp2, _Rest...>
    : __common_type_fold<common_reference<_Tp1, _Tp2>,
    __common_type_pack<_Rest...>>
    { };


  template<typename _Tp1, typename _Tp2, typename... _Rest>
    struct __common_type_fold<common_reference<_Tp1, _Tp2>,
         __common_type_pack<_Rest...>,
         void_t<common_reference_t<_Tp1, _Tp2>>>
    : public common_reference<common_reference_t<_Tp1, _Tp2>, _Rest...>
    { };







}
# 38 "/usr/include/c++/14.2.1/bits/move.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }
# 67 "/usr/include/c++/14.2.1/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    [[__nodiscard__]]
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value,
   "std::forward must not be used to convert an rvalue to an lvalue");
      return static_cast<_Tp&&>(__t);
    }
# 124 "/usr/include/c++/14.2.1/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 144 "/usr/include/c++/14.2.1/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr
    __conditional_t<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 160 "/usr/include/c++/14.2.1/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    inline constexpr _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
    constexpr
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 204 "/usr/include/c++/14.2.1/bits/move.h" 3
  template<typename _Tp>
    constexpr
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type



    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value)

    {




      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    constexpr
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type



    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 42 "/usr/include/c++/14.2.1/bits/exception_ptr.h" 2 3
# 50 "/usr/include/c++/14.2.1/bits/exception_ptr.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{
  class type_info;






  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;
# 75 "/usr/include/c++/14.2.1/bits/exception_ptr.h" 3
  exception_ptr current_exception() noexcept;

  template<typename _Ex>
  exception_ptr make_exception_ptr(_Ex) noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;
# 97 "/usr/include/c++/14.2.1/bits/exception_ptr.h" 3
    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);
      template<typename _Ex>
      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(nullptr)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = nullptr; }
# 135 "/usr/include/c++/14.2.1/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 162 "/usr/include/c++/14.2.1/bits/exception_ptr.h" 3
      explicit operator bool() const noexcept
      { return _M_exception_object; }




      friend bool
      operator==(const exception_ptr&, const exception_ptr&) noexcept = default;
# 182 "/usr/include/c++/14.2.1/bits/exception_ptr.h" 3
      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

   
    inline
    exception_ptr::exception_ptr() noexcept
    : _M_exception_object(0)
    { }

   
    inline
    exception_ptr::exception_ptr(const exception_ptr& __other)
    noexcept
    : _M_exception_object(__other._M_exception_object)
    {
      if (_M_exception_object)
 _M_addref();
    }

   
    inline
    exception_ptr::~exception_ptr() noexcept
    {
      if (_M_exception_object)
 _M_release();
    }

   
    inline exception_ptr&
    exception_ptr::operator=(const exception_ptr& __other) noexcept
    {
      exception_ptr(__other).swap(*this);
      return *this;
    }

   
    inline void
    exception_ptr::swap(exception_ptr &__other) noexcept
    {
      void *__tmp = _M_exception_object;
      _M_exception_object = __other._M_exception_object;
      __other._M_exception_object = __tmp;
    }


    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }


    template<typename _Ex>
     
      inline void
      __dest_thunk(void* __x)
      { static_cast<_Ex*>(__x)->~_Ex(); }


  }

  using __exception_ptr::swap;



  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {

      using _Ex2 = typename decay<_Ex>::type;
      void* __e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
      (void) __cxxabiv1::__cxa_init_primary_exception(
   __e, const_cast<std::type_info*>(&typeid(_Ex)),
   __exception_ptr::__dest_thunk<_Ex2>);
      try
 {
   ::new (__e) _Ex2(__ex);
   return exception_ptr(__e);
 }
      catch(...)
 {
   __cxxabiv1::__cxa_free_exception(__e);
   return current_exception();
 }
# 277 "/usr/include/c++/14.2.1/bits/exception_ptr.h" 3
    }
# 291 "/usr/include/c++/14.2.1/bits/exception_ptr.h" 3
}

}
# 167 "/usr/include/c++/14.2.1/exception" 2 3
# 1 "/usr/include/c++/14.2.1/bits/nested_exception.h" 1 3
# 40 "/usr/include/c++/14.2.1/bits/nested_exception.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{
# 59 "/usr/include/c++/14.2.1/bits/nested_exception.h" 3
  class nested_exception
  {
    exception_ptr _M_ptr;

  public:

    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;


    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }


    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };



  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };
# 145 "/usr/include/c++/14.2.1/bits/nested_exception.h" 3
  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      using _Up = typename decay<_Tp>::type;
      using _CopyConstructible
 = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
      static_assert(_CopyConstructible::value,
   "throw_with_nested argument must be CopyConstructible");


      if constexpr (is_class_v<_Up>)
 if constexpr (!is_final_v<_Up>)
   if constexpr (!is_base_of_v<nested_exception, _Up>)
     throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
      throw std::forward<_Tp>(__t);





    }
# 203 "/usr/include/c++/14.2.1/bits/nested_exception.h" 3
  template<typename _Ex>



    inline void
    rethrow_if_nested(const _Ex& __ex)
    {
      const _Ex* __ptr = __builtin_addressof(__ex);
# 223 "/usr/include/c++/14.2.1/bits/nested_exception.h" 3
      if constexpr (!is_polymorphic_v<_Ex>)
 return;
      else if constexpr (is_base_of_v<nested_exception, _Ex>
    && !is_convertible_v<_Ex*, nested_exception*>)
 return;




      else if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))
 __ne_ptr->rethrow_nested();

    }


}

}
# 168 "/usr/include/c++/14.2.1/exception" 2 3
# 42 "/usr/include/c++/14.2.1/ios" 2 3
# 1 "/usr/include/c++/14.2.1/bits/char_traits.h" 1 3
# 37 "/usr/include/c++/14.2.1/bits/char_traits.h" 3
       
# 38 "/usr/include/c++/14.2.1/bits/char_traits.h" 3
# 46 "/usr/include/c++/14.2.1/bits/char_traits.h" 3
# 1 "/usr/include/c++/14.2.1/cwchar" 1 3
# 39 "/usr/include/c++/14.2.1/cwchar" 3
       
# 40 "/usr/include/c++/14.2.1/cwchar" 3
# 47 "/usr/include/c++/14.2.1/bits/char_traits.h" 2 3
# 56 "/usr/include/c++/14.2.1/bits/char_traits.h" 3
# 1 "/usr/include/c++/14.2.1/compare" 1 3
# 33 "/usr/include/c++/14.2.1/compare" 3
       
# 34 "/usr/include/c++/14.2.1/compare" 3


# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 37 "/usr/include/c++/14.2.1/compare" 2 3



# 1 "/usr/include/c++/14.2.1/concepts" 1 3
# 33 "/usr/include/c++/14.2.1/concepts" 3
       
# 34 "/usr/include/c++/14.2.1/concepts" 3


# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 37 "/usr/include/c++/14.2.1/concepts" 2 3
# 48 "/usr/include/c++/14.2.1/concepts" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __same_as = std::is_same_v<_Tp, _Up>;
  }


  template<typename _Tp, typename _Up>
    concept same_as
      = __detail::__same_as<_Tp, _Up> && __detail::__same_as<_Up, _Tp>;

  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __different_from
 = !same_as<remove_cvref_t<_Tp>, remove_cvref_t<_Up>>;
  }


  template<typename _Derived, typename _Base>
    concept derived_from = __is_base_of(_Base, _Derived)
      && is_convertible_v<const volatile _Derived*, const volatile _Base*>;


  template<typename _From, typename _To>
    concept convertible_to = is_convertible_v<_From, _To>
      && requires { static_cast<_To>(std::declval<_From>()); };


  template<typename _Tp, typename _Up>
    concept common_reference_with
      = same_as<common_reference_t<_Tp, _Up>, common_reference_t<_Up, _Tp>>
      && convertible_to<_Tp, common_reference_t<_Tp, _Up>>
      && convertible_to<_Up, common_reference_t<_Tp, _Up>>;


  template<typename _Tp, typename _Up>
    concept common_with
      = same_as<common_type_t<_Tp, _Up>, common_type_t<_Up, _Tp>>
      && requires {
 static_cast<common_type_t<_Tp, _Up>>(std::declval<_Tp>());
 static_cast<common_type_t<_Tp, _Up>>(std::declval<_Up>());
      }
      && common_reference_with<add_lvalue_reference_t<const _Tp>,
          add_lvalue_reference_t<const _Up>>
      && common_reference_with<add_lvalue_reference_t<common_type_t<_Tp, _Up>>,
          common_reference_t<
     add_lvalue_reference_t<const _Tp>,
     add_lvalue_reference_t<const _Up>>>;



  template<typename _Tp>
    concept integral = is_integral_v<_Tp>;

  template<typename _Tp>
    concept signed_integral = integral<_Tp> && is_signed_v<_Tp>;

  template<typename _Tp>
    concept unsigned_integral = integral<_Tp> && !signed_integral<_Tp>;

  template<typename _Tp>
    concept floating_point = is_floating_point_v<_Tp>;

  namespace __detail
  {
    template<typename _Tp>
      using __cref = const remove_reference_t<_Tp>&;

    template<typename _Tp>
      concept __class_or_enum
 = is_class_v<_Tp> || is_union_v<_Tp> || is_enum_v<_Tp>;

    template<typename _Tp>
      constexpr bool __destructible_impl = false;
    template<typename _Tp>
      requires requires(_Tp& __t) { { __t.~_Tp() } noexcept; }
      constexpr bool __destructible_impl<_Tp> = true;

    template<typename _Tp>
      constexpr bool __destructible = __destructible_impl<_Tp>;
    template<typename _Tp>
      constexpr bool __destructible<_Tp&> = true;
    template<typename _Tp>
      constexpr bool __destructible<_Tp&&> = true;
    template<typename _Tp, size_t _Nm>
      constexpr bool __destructible<_Tp[_Nm]> = __destructible<_Tp>;

  }


  template<typename _Lhs, typename _Rhs>
    concept assignable_from
      = is_lvalue_reference_v<_Lhs>
      && common_reference_with<__detail::__cref<_Lhs>, __detail::__cref<_Rhs>>
      && requires(_Lhs __lhs, _Rhs&& __rhs) {
 { __lhs = static_cast<_Rhs&&>(__rhs) } -> same_as<_Lhs>;
      };


  template<typename _Tp>
    concept destructible = __detail::__destructible<_Tp>;


  template<typename _Tp, typename... _Args>
    concept constructible_from
      = destructible<_Tp> && is_constructible_v<_Tp, _Args...>;


  template<typename _Tp>
    concept default_initializable = constructible_from<_Tp>
      && requires
      {
 _Tp{};
 (void) ::new _Tp;
      };


  template<typename _Tp>
    concept move_constructible
    = constructible_from<_Tp, _Tp> && convertible_to<_Tp, _Tp>;


  template<typename _Tp>
    concept copy_constructible
      = move_constructible<_Tp>
      && constructible_from<_Tp, _Tp&> && convertible_to<_Tp&, _Tp>
      && constructible_from<_Tp, const _Tp&> && convertible_to<const _Tp&, _Tp>
      && constructible_from<_Tp, const _Tp> && convertible_to<const _Tp, _Tp>;



  namespace ranges
  {

    namespace __swap
    {
      template<typename _Tp> void swap(_Tp&, _Tp&) = delete;

      template<typename _Tp, typename _Up>
 concept __adl_swap
   = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>
     || std::__detail::__class_or_enum<remove_reference_t<_Up>>)
   && requires(_Tp&& __t, _Up&& __u) {
     swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
   };

      struct _Swap
      {
      private:
 template<typename _Tp, typename _Up>
   static constexpr bool
   _S_noexcept()
   {
     if constexpr (__adl_swap<_Tp, _Up>)
       return noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()));
     else
       return is_nothrow_move_constructible_v<remove_reference_t<_Tp>>
     && is_nothrow_move_assignable_v<remove_reference_t<_Tp>>;
   }

      public:
 template<typename _Tp, typename _Up>
   requires __adl_swap<_Tp, _Up>
   || (same_as<_Tp, _Up> && is_lvalue_reference_v<_Tp>
       && move_constructible<remove_reference_t<_Tp>>
       && assignable_from<_Tp, remove_reference_t<_Tp>>)
   constexpr void
   operator()(_Tp&& __t, _Up&& __u) const
   noexcept(_S_noexcept<_Tp, _Up>())
   {
     if constexpr (__adl_swap<_Tp, _Up>)
       swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
     else
       {
  auto __tmp = static_cast<remove_reference_t<_Tp>&&>(__t);
  __t = static_cast<remove_reference_t<_Tp>&&>(__u);
  __u = static_cast<remove_reference_t<_Tp>&&>(__tmp);
       }
   }

 template<typename _Tp, typename _Up, size_t _Num>
   requires requires(const _Swap& __swap, _Tp& __e1, _Up& __e2) {
     __swap(__e1, __e2);
   }
   constexpr void
   operator()(_Tp (&__e1)[_Num], _Up (&__e2)[_Num]) const
   noexcept(noexcept(std::declval<const _Swap&>()(*__e1, *__e2)))
   {
     for (size_t __n = 0; __n < _Num; ++__n)
       (*this)(__e1[__n], __e2[__n]);
   }
      };
    }


    inline namespace _Cpo {
      inline constexpr __swap::_Swap swap{};
    }
  }

  template<typename _Tp>
    concept swappable
      = requires(_Tp& __a, _Tp& __b) { ranges::swap(__a, __b); };

  template<typename _Tp, typename _Up>
    concept swappable_with = common_reference_with<_Tp, _Up>
      && requires(_Tp&& __t, _Up&& __u) {
 ranges::swap(static_cast<_Tp&&>(__t), static_cast<_Tp&&>(__t));
 ranges::swap(static_cast<_Up&&>(__u), static_cast<_Up&&>(__u));
 ranges::swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
 ranges::swap(static_cast<_Up&&>(__u), static_cast<_Tp&&>(__t));
      };



  template<typename _Tp>
    concept movable = is_object_v<_Tp> && move_constructible<_Tp>
      && assignable_from<_Tp&, _Tp> && swappable<_Tp>;

  template<typename _Tp>
    concept copyable = copy_constructible<_Tp> && movable<_Tp>
      && assignable_from<_Tp&, _Tp&> && assignable_from<_Tp&, const _Tp&>
      && assignable_from<_Tp&, const _Tp>;

  template<typename _Tp>
    concept semiregular = copyable<_Tp> && default_initializable<_Tp>;




  namespace __detail
  {
    template<typename _Tp>
      concept __boolean_testable_impl = convertible_to<_Tp, bool>;

    template<typename _Tp>
      concept __boolean_testable
 = __boolean_testable_impl<_Tp>
   && requires(_Tp&& __t)
   { { !static_cast<_Tp&&>(__t) } -> __boolean_testable_impl; };
  }



  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __weakly_eq_cmp_with
 = requires(__detail::__cref<_Tp> __t, __detail::__cref<_Up> __u) {
   { __t == __u } -> __boolean_testable;
   { __t != __u } -> __boolean_testable;
   { __u == __t } -> __boolean_testable;
   { __u != __t } -> __boolean_testable;
 };
  }

  template<typename _Tp>
    concept equality_comparable = __detail::__weakly_eq_cmp_with<_Tp, _Tp>;

  template<typename _Tp, typename _Up>
    concept equality_comparable_with
      = equality_comparable<_Tp> && equality_comparable<_Up>
      && common_reference_with<__detail::__cref<_Tp>, __detail::__cref<_Up>>
      && equality_comparable<common_reference_t<__detail::__cref<_Tp>,
      __detail::__cref<_Up>>>
      && __detail::__weakly_eq_cmp_with<_Tp, _Up>;

  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __partially_ordered_with
 = requires(const remove_reference_t<_Tp>& __t,
     const remove_reference_t<_Up>& __u) {
   { __t < __u } -> __boolean_testable;
   { __t > __u } -> __boolean_testable;
   { __t <= __u } -> __boolean_testable;
   { __t >= __u } -> __boolean_testable;
   { __u < __t } -> __boolean_testable;
   { __u > __t } -> __boolean_testable;
   { __u <= __t } -> __boolean_testable;
   { __u >= __t } -> __boolean_testable;
 };
  }


  template<typename _Tp>
    concept totally_ordered
      = equality_comparable<_Tp>
      && __detail::__partially_ordered_with<_Tp, _Tp>;

  template<typename _Tp, typename _Up>
    concept totally_ordered_with
      = totally_ordered<_Tp> && totally_ordered<_Up>
      && equality_comparable_with<_Tp, _Up>
      && totally_ordered<common_reference_t<__detail::__cref<_Tp>,
         __detail::__cref<_Up>>>
      && __detail::__partially_ordered_with<_Tp, _Up>;

  template<typename _Tp>
    concept regular = semiregular<_Tp> && equality_comparable<_Tp>;




  template<typename _Fn, typename... _Args>
    concept invocable = is_invocable_v<_Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    concept regular_invocable = invocable<_Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    concept predicate = regular_invocable<_Fn, _Args...>
      && __detail::__boolean_testable<invoke_result_t<_Fn, _Args...>>;


  template<typename _Rel, typename _Tp, typename _Up>
    concept relation
      = predicate<_Rel, _Tp, _Tp> && predicate<_Rel, _Up, _Up>
      && predicate<_Rel, _Tp, _Up> && predicate<_Rel, _Up, _Tp>;


  template<typename _Rel, typename _Tp, typename _Up>
    concept equivalence_relation = relation<_Rel, _Tp, _Up>;


  template<typename _Rel, typename _Tp, typename _Up>
    concept strict_weak_order = relation<_Rel, _Tp, _Up>;


}
# 41 "/usr/include/c++/14.2.1/compare" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace __cmp_cat
  {
    using type = signed char;

    enum class _Ord : type { equivalent = 0, less = -1, greater = 1 };

    enum class _Ncmp : type { _Unordered = 2 };

    struct __unspec
    {
      consteval __unspec(__unspec*) noexcept { }
    };
  }

  class partial_ordering
  {

    __cmp_cat::type _M_value;

    constexpr explicit
    partial_ordering(__cmp_cat::_Ord __v) noexcept
    : _M_value(__cmp_cat::type(__v))
    { }

    constexpr explicit
    partial_ordering(__cmp_cat::_Ncmp __v) noexcept
    : _M_value(__cmp_cat::type(__v))
    { }

    friend class weak_ordering;
    friend class strong_ordering;

  public:

    static const partial_ordering less;
    static const partial_ordering equivalent;
    static const partial_ordering greater;
    static const partial_ordering unordered;


    [[nodiscard]]
    friend constexpr bool
    operator==(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 0; }

    [[nodiscard]]
    friend constexpr bool
    operator==(partial_ordering, partial_ordering) noexcept = default;

    [[nodiscard]]
    friend constexpr bool
    operator< (partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == -1; }

    [[nodiscard]]
    friend constexpr bool
    operator> (partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 1; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value <= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __cmp_cat::type(__v._M_value & 1) == __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator< (__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return __v._M_value == 1; }

    [[nodiscard]]
    friend constexpr bool
    operator> (__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return __v._M_value == -1; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return __cmp_cat::type(__v._M_value & 1) == __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return 0 >= __v._M_value; }

    [[nodiscard]]
    friend constexpr partial_ordering
    operator<=>(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v; }

    [[nodiscard]]
    friend constexpr partial_ordering
    operator<=>(__cmp_cat::__unspec, partial_ordering __v) noexcept
    {
      if (__v._M_value & 1)
 return partial_ordering(__cmp_cat::_Ord(-__v._M_value));
      else
 return __v;
    }
  };


  inline constexpr partial_ordering
  partial_ordering::less(__cmp_cat::_Ord::less);

  inline constexpr partial_ordering
  partial_ordering::equivalent(__cmp_cat::_Ord::equivalent);

  inline constexpr partial_ordering
  partial_ordering::greater(__cmp_cat::_Ord::greater);

  inline constexpr partial_ordering
  partial_ordering::unordered(__cmp_cat::_Ncmp::_Unordered);

  class weak_ordering
  {
    __cmp_cat::type _M_value;

    constexpr explicit
    weak_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(__cmp_cat::type(__v))
    { }

    friend class strong_ordering;

  public:

    static const weak_ordering less;
    static const weak_ordering equivalent;
    static const weak_ordering greater;

    [[nodiscard]]
    constexpr operator partial_ordering() const noexcept
    { return partial_ordering(__cmp_cat::_Ord(_M_value)); }


    [[nodiscard]]
    friend constexpr bool
    operator==(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 0; }

    [[nodiscard]]
    friend constexpr bool
    operator==(weak_ordering, weak_ordering) noexcept = default;

    [[nodiscard]]
    friend constexpr bool
    operator< (weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value < 0; }

    [[nodiscard]]
    friend constexpr bool
    operator> (weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value > 0; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value <= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value >= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator< (__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 < __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator> (__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 > __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 <= __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 >= __v._M_value; }

    [[nodiscard]]
    friend constexpr weak_ordering
    operator<=>(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v; }

    [[nodiscard]]
    friend constexpr weak_ordering
    operator<=>(__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return weak_ordering(__cmp_cat::_Ord(-__v._M_value)); }
  };


  inline constexpr weak_ordering
  weak_ordering::less(__cmp_cat::_Ord::less);

  inline constexpr weak_ordering
  weak_ordering::equivalent(__cmp_cat::_Ord::equivalent);

  inline constexpr weak_ordering
  weak_ordering::greater(__cmp_cat::_Ord::greater);

  class strong_ordering
  {
    __cmp_cat::type _M_value;

    constexpr explicit
    strong_ordering(__cmp_cat::_Ord __v) noexcept
    : _M_value(__cmp_cat::type(__v))
    { }

  public:

    static const strong_ordering less;
    static const strong_ordering equal;
    static const strong_ordering equivalent;
    static const strong_ordering greater;

    [[nodiscard]]
    constexpr operator partial_ordering() const noexcept
    { return partial_ordering(__cmp_cat::_Ord(_M_value)); }

    [[nodiscard]]
    constexpr operator weak_ordering() const noexcept
    { return weak_ordering(__cmp_cat::_Ord(_M_value)); }


    [[nodiscard]]
    friend constexpr bool
    operator==(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 0; }

    [[nodiscard]]
    friend constexpr bool
    operator==(strong_ordering, strong_ordering) noexcept = default;

    [[nodiscard]]
    friend constexpr bool
    operator< (strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value < 0; }

    [[nodiscard]]
    friend constexpr bool
    operator> (strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value > 0; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value <= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value >= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator< (__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 < __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator> (__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 > __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 <= __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 >= __v._M_value; }

    [[nodiscard]]
    friend constexpr strong_ordering
    operator<=>(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v; }

    [[nodiscard]]
    friend constexpr strong_ordering
    operator<=>(__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return strong_ordering(__cmp_cat::_Ord(-__v._M_value)); }
  };


  inline constexpr strong_ordering
  strong_ordering::less(__cmp_cat::_Ord::less);

  inline constexpr strong_ordering
  strong_ordering::equal(__cmp_cat::_Ord::equivalent);

  inline constexpr strong_ordering
  strong_ordering::equivalent(__cmp_cat::_Ord::equivalent);

  inline constexpr strong_ordering
  strong_ordering::greater(__cmp_cat::_Ord::greater);



  [[nodiscard]]
  constexpr bool
  is_eq(partial_ordering __cmp) noexcept
  { return __cmp == 0; }

  [[nodiscard]]
  constexpr bool
  is_neq(partial_ordering __cmp) noexcept
  { return __cmp != 0; }

  [[nodiscard]]
  constexpr bool
  is_lt (partial_ordering __cmp) noexcept
  { return __cmp < 0; }

  [[nodiscard]]
  constexpr bool
  is_lteq(partial_ordering __cmp) noexcept
  { return __cmp <= 0; }

  [[nodiscard]]
  constexpr bool
  is_gt (partial_ordering __cmp) noexcept
  { return __cmp > 0; }

  [[nodiscard]]
  constexpr bool
  is_gteq(partial_ordering __cmp) noexcept
  { return __cmp >= 0; }

  namespace __detail
  {
    template<typename _Tp>
      inline constexpr unsigned __cmp_cat_id = 1;
    template<>
      inline constexpr unsigned __cmp_cat_id<partial_ordering> = 2;
    template<>
      inline constexpr unsigned __cmp_cat_id<weak_ordering> = 4;
    template<>
      inline constexpr unsigned __cmp_cat_id<strong_ordering> = 8;

    template<typename... _Ts>
      constexpr auto __common_cmp_cat()
      {
 constexpr unsigned __cats = (__cmp_cat_id<_Ts> | ...);

 if constexpr (__cats & 1)
   return;


 else if constexpr (bool(__cats & __cmp_cat_id<partial_ordering>))
   return partial_ordering::equivalent;


 else if constexpr (bool(__cats & __cmp_cat_id<weak_ordering>))
   return weak_ordering::equivalent;

 else
   return strong_ordering::equivalent;
      }
  }


  template<typename... _Ts>
    struct common_comparison_category
    {
      using type = decltype(__detail::__common_cmp_cat<_Ts...>());
    };



  template<typename _Tp>
    struct common_comparison_category<_Tp>
    { using type = void; };

  template<>
    struct common_comparison_category<partial_ordering>
    { using type = partial_ordering; };

  template<>
    struct common_comparison_category<weak_ordering>
    { using type = weak_ordering; };

  template<>
    struct common_comparison_category<strong_ordering>
    { using type = strong_ordering; };

  template<>
    struct common_comparison_category<>
    { using type = strong_ordering; };

  template<typename... _Ts>
    using common_comparison_category_t
      = typename common_comparison_category<_Ts...>::type;



  namespace __detail
  {
    template<typename _Tp, typename _Cat>
      concept __compares_as
 = same_as<common_comparison_category_t<_Tp, _Cat>, _Cat>;
  }


  template<typename _Tp, typename _Cat = partial_ordering>
    concept three_way_comparable
      = __detail::__weakly_eq_cmp_with<_Tp, _Tp>
      && __detail::__partially_ordered_with<_Tp, _Tp>
      && requires(const remove_reference_t<_Tp>& __a,
    const remove_reference_t<_Tp>& __b)
      {
 { __a <=> __b } -> __detail::__compares_as<_Cat>;
      };

  template<typename _Tp, typename _Up, typename _Cat = partial_ordering>
    concept three_way_comparable_with
      = three_way_comparable<_Tp, _Cat>
      && three_way_comparable<_Up, _Cat>
      && common_reference_with<const remove_reference_t<_Tp>&,
          const remove_reference_t<_Up>&>
      && three_way_comparable<
   common_reference_t<const remove_reference_t<_Tp>&,
        const remove_reference_t<_Up>&>, _Cat>
      && __detail::__weakly_eq_cmp_with<_Tp, _Up>
      && __detail::__partially_ordered_with<_Tp, _Up>
      && requires(const remove_reference_t<_Tp>& __t,
    const remove_reference_t<_Up>& __u)
      {
 { __t <=> __u } -> __detail::__compares_as<_Cat>;
 { __u <=> __t } -> __detail::__compares_as<_Cat>;
      };

  namespace __detail
  {
    template<typename _Tp, typename _Up>
      using __cmp3way_res_t
 = decltype(std::declval<_Tp>() <=> std::declval<_Up>());






    template<typename _Tp, typename _Up>
      struct __cmp3way_res_impl
      { };

    template<typename _Tp, typename _Up>
      requires requires { typename __cmp3way_res_t<__cref<_Tp>, __cref<_Up>>; }
      struct __cmp3way_res_impl<_Tp, _Up>
      {
 using type = __cmp3way_res_t<__cref<_Tp>, __cref<_Up>>;
      };
  }


  template<typename _Tp, typename _Up = _Tp>
    struct compare_three_way_result
    : __detail::__cmp3way_res_impl<_Tp, _Up>
    { };


  template<typename _Tp, typename _Up = _Tp>
    using compare_three_way_result_t
      = typename __detail::__cmp3way_res_impl<_Tp, _Up>::type;

  namespace __detail
  {




    template<typename _Tp, typename _Up>
      concept __3way_builtin_ptr_cmp
 = requires(_Tp&& __t, _Up&& __u)
   { static_cast<_Tp&&>(__t) <=> static_cast<_Up&&>(__u); }
   && convertible_to<_Tp, const volatile void*>
   && convertible_to<_Up, const volatile void*>
   && ! requires(_Tp&& __t, _Up&& __u)
   { operator<=>(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u)); }
   && ! requires(_Tp&& __t, _Up&& __u)
   { static_cast<_Tp&&>(__t).operator<=>(static_cast<_Up&&>(__u)); };
  }





  struct compare_three_way
  {
    template<typename _Tp, typename _Up>
      requires three_way_comparable_with<_Tp, _Up>
      constexpr auto
      operator() [[nodiscard]] (_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() <=> std::declval<_Up>()))
      {
 if constexpr (__detail::__3way_builtin_ptr_cmp<_Tp, _Up>)
   {
     auto __pt = static_cast<const volatile void*>(__t);
     auto __pu = static_cast<const volatile void*>(__u);
     if (std::__is_constant_evaluated())
       return __pt <=> __pu;
     auto __it = reinterpret_cast<long unsigned int>(__pt);
     auto __iu = reinterpret_cast<long unsigned int>(__pu);
     return __it <=> __iu;
   }
 else
   return static_cast<_Tp&&>(__t) <=> static_cast<_Up&&>(__u);
      }

    using is_transparent = void;
  };



  namespace __compare
  {
    template<floating_point _Tp>
      constexpr weak_ordering
      __fp_weak_ordering(_Tp __e, _Tp __f)
      {


 auto __cat = [](_Tp __fp) -> int {
   const int __sign = __builtin_signbit(__fp) ? -1 : 1;
   if (__builtin_isnormal(__fp))
     return (__fp == 0 ? 1 : 3) * __sign;
   if (__builtin_isnan(__fp))
     return 5 * __sign;
   if (int __inf = __builtin_isinf_sign(__fp))
     return 4 * __inf;
   return 2 * __sign;
 };

 auto __po = __e <=> __f;
 if (is_lt(__po))
   return weak_ordering::less;
 else if (is_gt(__po))
   return weak_ordering::greater;
 else if (__po == partial_ordering::equivalent)
   return weak_ordering::equivalent;
 else
   {

     auto __isnan_sign = [](_Tp __fp) -> int {
       return __builtin_isnan(__fp)
  ? __builtin_signbit(__fp) ? -1 : 1
  : 0;
     };
     auto __ord = __isnan_sign(__e) <=> __isnan_sign(__f);
     if (is_eq(__ord))
       return weak_ordering::equivalent;
     else if (is_lt(__ord))
       return weak_ordering::less;
     else
       return weak_ordering::greater;
   }
      }

    void strong_order() = delete;

    template<typename _Tp, typename _Up>
      concept __adl_strong = requires(_Tp&& __t, _Up&& __u)
 {
   strong_ordering(strong_order(static_cast<_Tp&&>(__t),
           static_cast<_Up&&>(__u)));
 };

    void weak_order() = delete;

    template<typename _Tp, typename _Up>
      concept __adl_weak = requires(_Tp&& __t, _Up&& __u)
 {
   weak_ordering(weak_order(static_cast<_Tp&&>(__t),
       static_cast<_Up&&>(__u)));
 };

    void partial_order() = delete;

    template<typename _Tp, typename _Up>
      concept __adl_partial = requires(_Tp&& __t, _Up&& __u)
 {
   partial_ordering(partial_order(static_cast<_Tp&&>(__t),
      static_cast<_Up&&>(__u)));
 };

    template<typename _Ord, typename _Tp, typename _Up>
      concept __cmp3way = requires(_Tp&& __t, _Up&& __u, compare_three_way __c)
 {
   _Ord(__c(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u)));
 };

    template<typename _Tp, typename _Up>
      concept __strongly_ordered
 = __adl_strong<_Tp, _Up>
   || floating_point<remove_reference_t<_Tp>>
   || __cmp3way<strong_ordering, _Tp, _Up>;

    template<typename _Tp, typename _Up>
      concept __decayed_same_as = same_as<decay_t<_Tp>, decay_t<_Up>>;

    class _Strong_order
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return true;
   else if constexpr (__adl_strong<_Tp, _Up>)
     return noexcept(strong_ordering(strong_order(std::declval<_Tp>(),
        std::declval<_Up>())));
   else if constexpr (__cmp3way<strong_ordering, _Tp, _Up>)
     return noexcept(compare_three_way()(std::declval<_Tp>(),
      std::declval<_Up>()));
 }

      friend class _Weak_order;
      friend class _Strong_fallback;


      enum class _Fp_fmt
      {
 _Binary16, _Binary32, _Binary64, _Binary128,
 _X86_80bit,
 _M68k_80bit,
 _Dbldbl,
 _Bfloat16,
      };
# 699 "/usr/include/c++/14.2.1/compare" 3
      template<typename _Tp>
 static consteval _Fp_fmt
 _S_fp_fmt() noexcept
 {

   using enum _Fp_fmt;
# 719 "/usr/include/c++/14.2.1/compare" 3
   if constexpr (__is_same(_Tp, long double))
     return (-16381) == -16381 ? _X86_80bit : _M68k_80bit;


   if constexpr (__is_same(_Tp, __float80))
     return _X86_80bit;






   constexpr int __width = sizeof(_Tp) * 8;

   if constexpr (__width == 16)
     return _Binary16;
   else if constexpr (__width == 32)
     return _Binary32;
   else if constexpr (__width == 64)
     return _Binary64;
   else if constexpr (__width == 128)
     return _Binary128;
 }


      using int64_t = long int;
      using int32_t = int;
      using int16_t = short int;
      using uint64_t = long unsigned int;
      using uint16_t = short unsigned int;


      template<typename _Tp>
 struct _Int
 {

   uint64_t _M_lo;
   _Tp _M_hi;





   constexpr explicit
   _Int(_Tp __hi, uint64_t __lo) noexcept : _M_hi(__hi)
   { _M_lo = __lo; }

   constexpr explicit
   _Int(uint64_t __lo) noexcept : _M_hi(0)
   { _M_lo = __lo; }

   constexpr bool operator==(const _Int&) const = default;
# 781 "/usr/include/c++/14.2.1/compare" 3
   constexpr _Int&
   operator^=(const _Int& __rhs) noexcept
   {
     _M_hi ^= __rhs._M_hi;
     _M_lo ^= __rhs._M_lo;
     return *this;
   }

   constexpr strong_ordering
   operator<=>(const _Int& __rhs) const noexcept
   {
     strong_ordering __cmp = _M_hi <=> __rhs._M_hi;
     if (__cmp != strong_ordering::equal)
       return __cmp;
     return _M_lo <=> __rhs._M_lo;
   }
 };

      template<typename _Tp>
 static constexpr _Tp
 _S_compl(_Tp __t) noexcept
 {
   constexpr int __width = sizeof(_Tp) * 8;

   make_unsigned_t<_Tp> __sign = __t >> (__width - 1);


   return __t ^ (__sign >> 1);
 }


      template<typename _Tp>
 static constexpr _Int<_Tp>
 _S_compl(_Int<_Tp> __t) noexcept
 {
   constexpr int __width = sizeof(_Tp) * 8;
   make_unsigned_t<_Tp> __sign = __t._M_hi >> (__width - 1);
   __t._M_hi ^= (__sign >> 1 );
   uint64_t __sign64 = (_Tp)__sign;
   __t._M_lo ^= __sign64;
   return __t;
 }


      template<typename _Tp>
 constexpr static auto
 _S_fp_bits(_Tp __val) noexcept
 {
   if constexpr (sizeof(_Tp) == sizeof(int64_t))
     return __builtin_bit_cast(int64_t, __val);
   else if constexpr (sizeof(_Tp) == sizeof(int32_t))
     return __builtin_bit_cast(int32_t, __val);
   else if constexpr (sizeof(_Tp) == sizeof(int16_t))
     return __builtin_bit_cast(int16_t, __val);
   else
     {

       using enum _Fp_fmt;

       constexpr auto __fmt = _S_fp_fmt<_Tp>();
       if constexpr (__fmt == _X86_80bit || __fmt == _M68k_80bit)
  {
    if constexpr (sizeof(_Tp) == 3 * sizeof(int32_t))
      {
        auto __ival = __builtin_bit_cast(_Int<int32_t>, __val);
        return _Int<int16_t>(__ival._M_hi, __ival._M_lo);
      }
    else
      {
        auto __ival = __builtin_bit_cast(_Int<int64_t>, __val);
        return _Int<int16_t>(__ival._M_hi, __ival._M_lo);
      }
  }
       else if constexpr (sizeof(_Tp) == 2 * sizeof(int64_t))
  {

    return __builtin_bit_cast(__int128, __val);



  }
       else
  static_assert(sizeof(_Tp) == sizeof(int64_t),
         "unsupported floating-point type");
     }
 }

      template<typename _Tp>
 static constexpr strong_ordering
 _S_fp_cmp(_Tp __x, _Tp __y) noexcept
 {
# 885 "/usr/include/c++/14.2.1/compare" 3
   auto __ix = _S_fp_bits(__x);
   auto __iy = _S_fp_bits(__y);

   if (__ix == __iy)
     return strong_ordering::equal;


   using enum _Fp_fmt;

   constexpr auto __fmt = _S_fp_fmt<_Tp>();

   if constexpr (__fmt == _Dbldbl)
     {


       struct _Unpacked { double _M_hi; int64_t _M_lo; };
       auto __x2 = __builtin_bit_cast(_Unpacked, __x);
       auto __y2 = __builtin_bit_cast(_Unpacked, __y);


       auto __cmp = _S_fp_cmp(__x2._M_hi, __y2._M_hi);
       if (__cmp != strong_ordering::equal)
  return __cmp;



       if (__builtin_isnan(__x2._M_hi))
  return strong_ordering::equal;


       if (((__x2._M_lo | __y2._M_lo) & 0x7fffffffffffffffULL) == 0)
  return strong_ordering::equal;


       return _S_compl(__x2._M_lo) <=> _S_compl(__y2._M_lo);
     }
   else
     {
       if constexpr (__fmt == _M68k_80bit)
  {



    constexpr uint16_t __maxexp = 0x7fff;
    if ((__ix._M_hi & __maxexp) == __maxexp)
      __ix._M_lo |= 1ull << 63;
    if ((__iy._M_hi & __maxexp) == __maxexp)
      __iy._M_lo |= 1ull << 63;
  }
       else
  {
# 952 "/usr/include/c++/14.2.1/compare" 3
  }
       return _S_compl(__ix) <=> _S_compl(__iy);
     }
 }

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __strongly_ordered<_Tp, _Up>
 constexpr strong_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return _S_fp_cmp(__e, __f);
   else if constexpr (__adl_strong<_Tp, _Up>)
     return strong_ordering(strong_order(static_cast<_Tp&&>(__e),
      static_cast<_Up&&>(__f)));
   else if constexpr (__cmp3way<strong_ordering, _Tp, _Up>)
     return compare_three_way()(static_cast<_Tp&&>(__e),
           static_cast<_Up&&>(__f));
 }
    };

    template<typename _Tp, typename _Up>
      concept __weakly_ordered
 = floating_point<remove_reference_t<_Tp>>
   || __adl_weak<_Tp, _Up>
   || __cmp3way<weak_ordering, _Tp, _Up>
   || __strongly_ordered<_Tp, _Up>;

    class _Weak_order
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return true;
   else if constexpr (__adl_weak<_Tp, _Up>)
     return noexcept(weak_ordering(weak_order(std::declval<_Tp>(),
           std::declval<_Up>())));
   else if constexpr (__cmp3way<weak_ordering, _Tp, _Up>)
     return noexcept(compare_three_way()(std::declval<_Tp>(),
      std::declval<_Up>()));
   else if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order::_S_noexcept<_Tp, _Up>();
 }

      friend class _Partial_order;
      friend class _Weak_fallback;

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __weakly_ordered<_Tp, _Up>
 constexpr weak_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return __compare::__fp_weak_ordering(__e, __f);
   else if constexpr (__adl_weak<_Tp, _Up>)
     return weak_ordering(weak_order(static_cast<_Tp&&>(__e),
         static_cast<_Up&&>(__f)));
   else if constexpr (__cmp3way<weak_ordering, _Tp, _Up>)
     return compare_three_way()(static_cast<_Tp&&>(__e),
           static_cast<_Up&&>(__f));
   else if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order{}(static_cast<_Tp&&>(__e),
       static_cast<_Up&&>(__f));
 }
    };

    template<typename _Tp, typename _Up>
      concept __partially_ordered
 = __adl_partial<_Tp, _Up>
 || __cmp3way<partial_ordering, _Tp, _Up>
 || __weakly_ordered<_Tp, _Up>;

    class _Partial_order
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__adl_partial<_Tp, _Up>)
     return noexcept(partial_ordering(partial_order(std::declval<_Tp>(),
        std::declval<_Up>())));
   else if constexpr (__cmp3way<partial_ordering, _Tp, _Up>)
     return noexcept(compare_three_way()(std::declval<_Tp>(),
      std::declval<_Up>()));
   else if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order::_S_noexcept<_Tp, _Up>();
 }

      friend class _Partial_fallback;

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __partially_ordered<_Tp, _Up>
 constexpr partial_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__adl_partial<_Tp, _Up>)
     return partial_ordering(partial_order(static_cast<_Tp&&>(__e),
        static_cast<_Up&&>(__f)));
   else if constexpr (__cmp3way<partial_ordering, _Tp, _Up>)
     return compare_three_way()(static_cast<_Tp&&>(__e),
           static_cast<_Up&&>(__f));
   else if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order{}(static_cast<_Tp&&>(__e),
     static_cast<_Up&&>(__f));
 }
    };

    template<typename _Tp, typename _Up>
      concept __op_eq_lt = requires(_Tp&& __t, _Up&& __u)
 {
   { static_cast<_Tp&&>(__t) == static_cast<_Up&&>(__u) }
     -> convertible_to<bool>;
   { static_cast<_Tp&&>(__t) < static_cast<_Up&&>(__u) }
     -> convertible_to<bool>;
 };

    class _Strong_fallback
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order::_S_noexcept<_Tp, _Up>();
   else
     return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))
       && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
 }

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __strongly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>
 constexpr strong_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order{}(static_cast<_Tp&&>(__e),
       static_cast<_Up&&>(__f));
   else
     return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
       ? strong_ordering::equal
       : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
       ? strong_ordering::less
       : strong_ordering::greater;
 }
    };

    class _Weak_fallback
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order::_S_noexcept<_Tp, _Up>();
   else
     return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))
       && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
 }

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __weakly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>
 constexpr weak_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order{}(static_cast<_Tp&&>(__e),
     static_cast<_Up&&>(__f));
   else
     return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
       ? weak_ordering::equivalent
       : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
       ? weak_ordering::less
       : weak_ordering::greater;
 }
    };



    template<typename _Tp, typename _Up>
      concept __op_eq_lt_lt = __op_eq_lt<_Tp, _Up>
 && requires(_Tp&& __t, _Up&& __u)
 {
   { static_cast<_Up&&>(__u) < static_cast<_Tp&&>(__t) }
     -> convertible_to<bool>;
 };

    class _Partial_fallback
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__partially_ordered<_Tp, _Up>)
     return _Partial_order::_S_noexcept<_Tp, _Up>();
   else
     return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))
       && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
 }

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __partially_ordered<_Tp, _Up> || __op_eq_lt_lt<_Tp, _Up>
 constexpr partial_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__partially_ordered<_Tp, _Up>)
     return _Partial_order{}(static_cast<_Tp&&>(__e),
        static_cast<_Up&&>(__f));
   else
     return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
       ? partial_ordering::equivalent
       : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
       ? partial_ordering::less
       : static_cast<_Up&&>(__f) < static_cast<_Tp&&>(__e)
       ? partial_ordering::greater
       : partial_ordering::unordered;
 }
    };
  }



  inline namespace _Cpo
  {
    inline constexpr __compare::_Strong_order strong_order{};

    inline constexpr __compare::_Weak_order weak_order{};

    inline constexpr __compare::_Partial_order partial_order{};

    inline constexpr __compare::_Strong_fallback
      compare_strong_order_fallback{};

    inline constexpr __compare::_Weak_fallback
      compare_weak_order_fallback{};

    inline constexpr __compare::_Partial_fallback
      compare_partial_order_fallback{};
  }


  namespace __detail
  {

    inline constexpr struct _Synth3way
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept(const _Tp* __t = nullptr, const _Up* __u = nullptr)
 {
   if constexpr (three_way_comparable_with<_Tp, _Up>)
     return noexcept(*__t <=> *__u);
   else
     return noexcept(*__t < *__u) && noexcept(*__u < *__t);
 }

      template<typename _Tp, typename _Up>
 [[nodiscard]]
 constexpr auto
 operator()(const _Tp& __t, const _Up& __u) const
 noexcept(_S_noexcept<_Tp, _Up>())
 requires requires
 {
   { __t < __u } -> __boolean_testable;
   { __u < __t } -> __boolean_testable;
 }
 {
   if constexpr (three_way_comparable_with<_Tp, _Up>)
     return __t <=> __u;
   else
     {
       if (__t < __u)
  return weak_ordering::less;
       else if (__u < __t)
  return weak_ordering::greater;
       else
  return weak_ordering::equivalent;
     }
 }
    } __synth3way = {};


    template<typename _Tp, typename _Up = _Tp>
      using __synth3way_t
 = decltype(__detail::__synth3way(std::declval<_Tp&>(),
      std::declval<_Up&>()));
  }


}
# 57 "/usr/include/c++/14.2.1/bits/char_traits.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/stl_construct.h" 1 3
# 61 "/usr/include/c++/14.2.1/bits/stl_construct.h" 3
# 1 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 1 3
# 62 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
       
# 63 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
# 71 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
# 1 "/usr/include/c++/14.2.1/bits/iterator_concepts.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/iterator_concepts.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/iterator_concepts.h" 3



# 1 "/usr/include/c++/14.2.1/bits/ptr_traits.h" 1 3
# 39 "/usr/include/c++/14.2.1/bits/ptr_traits.h" 3
namespace __gnu_debug { struct _Safe_iterator_base; }


namespace std __attribute__ ((__visibility__ ("default")))
{




  class __undefined;



  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _SomeTemplate, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_SomeTemplate<_Tp, _Types...>>
    { using type = _Tp; };



  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _SomeTemplate, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_SomeTemplate<_Tp, _Types...>, _Up>
    { using type = _SomeTemplate<_Up, _Types...>; };


  template<typename _Ptr, typename = void>
    struct __ptr_traits_elem : __get_first_arg<_Ptr>
    { };



  template<typename _Ptr> requires requires { typename _Ptr::element_type; }
    struct __ptr_traits_elem<_Ptr, void>
    { using type = typename _Ptr::element_type; };






  template<typename _Ptr>
    using __ptr_traits_elem_t = typename __ptr_traits_elem<_Ptr>::type;




  template<typename _Ptr, typename _Elt, bool = is_void<_Elt>::value>
    struct __ptr_traits_ptr_to
    {
      using pointer = _Ptr;
      using element_type = _Elt;







      static pointer
      pointer_to(element_type& __r)

      requires requires {
 { pointer::pointer_to(__r) } -> convertible_to<pointer>;
      }

      { return pointer::pointer_to(__r); }
    };


  template<typename _Ptr, typename _Elt>
    struct __ptr_traits_ptr_to<_Ptr, _Elt, true>
    { };


  template<typename _Tp>
    struct __ptr_traits_ptr_to<_Tp*, _Tp, false>
    {
      using pointer = _Tp*;
      using element_type = _Tp;






      static constexpr pointer
      pointer_to(element_type& __r) noexcept
      { return std::addressof(__r); }
    };

  template<typename _Ptr, typename _Elt>
    struct __ptr_traits_impl : __ptr_traits_ptr_to<_Ptr, _Elt>
    {
    private:
      template<typename _Tp>
 using __diff_t = typename _Tp::difference_type;

      template<typename _Tp, typename _Up>
 using __rebind = __type_identity<typename _Tp::template rebind<_Up>>;

    public:

      using pointer = _Ptr;


      using element_type = _Elt;


      using difference_type = __detected_or_t<ptrdiff_t, __diff_t, _Ptr>;


      template<typename _Up>
 using rebind = typename __detected_or_t<__replace_first_arg<_Ptr, _Up>,
      __rebind, _Ptr, _Up>::type;
    };



  template<typename _Ptr>
    struct __ptr_traits_impl<_Ptr, __undefined>
    { };







  template<typename _Ptr>
    struct pointer_traits : __ptr_traits_impl<_Ptr, __ptr_traits_elem_t<_Ptr>>
    { };







  template<typename _Tp>
    struct pointer_traits<_Tp*> : __ptr_traits_ptr_to<_Tp*, _Tp>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up> using rebind = _Up*;
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template<typename _Tp>
    constexpr _Tp*
    __to_address(_Tp* __ptr) noexcept
    {
      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
      return __ptr;
    }







  template<typename _Ptr>
    constexpr auto
    __to_address(const _Ptr& __ptr) noexcept
    -> decltype(std::pointer_traits<_Ptr>::to_address(__ptr))
    { return std::pointer_traits<_Ptr>::to_address(__ptr); }

  template<typename _Ptr, typename... _None>
    constexpr auto
    __to_address(const _Ptr& __ptr, _None...) noexcept
    {
      if constexpr (is_base_of_v<__gnu_debug::_Safe_iterator_base, _Ptr>)
 return std::__to_address(__ptr.base().operator->());
      else
 return std::__to_address(__ptr.operator->());
    }







  template<typename _Tp>
    constexpr _Tp*
    to_address(_Tp* __ptr) noexcept
    { return std::__to_address(__ptr); }
# 251 "/usr/include/c++/14.2.1/bits/ptr_traits.h" 3
  template<typename _Ptr>
    constexpr auto
    to_address(const _Ptr& __ptr) noexcept
    { return std::__to_address(__ptr); }



}
# 38 "/usr/include/c++/14.2.1/bits/iterator_concepts.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/ranges_cmp.h" 1 3
# 37 "/usr/include/c++/14.2.1/bits/ranges_cmp.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __is_transparent;





  struct identity
  {
    template<typename _Tp>
      [[nodiscard]]
      constexpr _Tp&&
      operator()(_Tp&& __t) const noexcept
      { return std::forward<_Tp>(__t); }

    using is_transparent = __is_transparent;
  };


namespace ranges
{
  namespace __detail
  {



    template<typename _Tp, typename _Up>
      concept __less_builtin_ptr_cmp
 = requires (_Tp&& __t, _Up&& __u) { { __t < __u } -> same_as<bool>; }
   && convertible_to<_Tp, const volatile void*>
   && convertible_to<_Up, const volatile void*>
   && (! requires(_Tp&& __t, _Up&& __u)
       { operator<(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }
       && ! requires(_Tp&& __t, _Up&& __u)
       { std::forward<_Tp>(__t).operator<(std::forward<_Up>(__u)); });
  }







  struct equal_to
  {
    template<typename _Tp, typename _Up>
      requires equality_comparable_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() == std::declval<_Up>()))
      { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

    using is_transparent = __is_transparent;
  };


  struct not_equal_to
  {
    template<typename _Tp, typename _Up>
      requires equality_comparable_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Up>() == std::declval<_Tp>()))
      { return !equal_to{}(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }

    using is_transparent = __is_transparent;
  };


  struct less
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>()))
      {
 if constexpr (__detail::__less_builtin_ptr_cmp<_Tp, _Up>)
   {
     if (std::__is_constant_evaluated())
       return __t < __u;

     auto __x = reinterpret_cast<long unsigned int>(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)));
     auto __y = reinterpret_cast<long unsigned int>(
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
     return __x < __y;
   }
 else
   return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
      }

    using is_transparent = __is_transparent;
  };


  struct greater
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>()))
      { return less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t)); }

    using is_transparent = __is_transparent;
  };


  struct greater_equal
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>()))
      { return !less{}(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }

    using is_transparent = __is_transparent;
  };


  struct less_equal
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>()))
      { return !less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t)); }

    using is_transparent = __is_transparent;
  };

}


}
# 39 "/usr/include/c++/14.2.1/bits/iterator_concepts.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 58 "/usr/include/c++/14.2.1/bits/iterator_concepts.h" 3
  struct default_sentinel_t { };


  inline constexpr default_sentinel_t default_sentinel{};


  struct input_iterator_tag;
  struct output_iterator_tag;
  struct forward_iterator_tag;
  struct bidirectional_iterator_tag;
  struct random_access_iterator_tag;
  struct contiguous_iterator_tag;

  template<typename _Iterator>
    struct iterator_traits;

  template<typename _Tp> requires is_object_v<_Tp>
    struct iterator_traits<_Tp*>;

  template<typename _Iterator, typename>
    struct __iterator_traits;

  namespace __detail
  {
    template<typename _Tp>
      using __with_ref = _Tp&;

    template<typename _Tp>
      concept __can_reference = requires { typename __with_ref<_Tp>; };

    template<typename _Tp>
      concept __dereferenceable = requires(_Tp& __t)
 {
   { *__t } -> __can_reference;
 };
  }

  template<__detail::__dereferenceable _Tp>
    using iter_reference_t = decltype(*std::declval<_Tp&>());

  namespace ranges
  {

    namespace __imove
    {
      void iter_move() = delete;

      template<typename _Tp>
 concept __adl_imove
   = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>)
   && requires(_Tp&& __t) { iter_move(static_cast<_Tp&&>(__t)); };

      struct _IterMove
      {
      private:
 template<typename _Tp>
   struct __result
   { using type = iter_reference_t<_Tp>; };

 template<typename _Tp>
   requires __adl_imove<_Tp>
   struct __result<_Tp>
   { using type = decltype(iter_move(std::declval<_Tp>())); };

 template<typename _Tp>
   requires (!__adl_imove<_Tp>)
   && is_lvalue_reference_v<iter_reference_t<_Tp>>
   struct __result<_Tp>
   { using type = remove_reference_t<iter_reference_t<_Tp>>&&; };

 template<typename _Tp>
   static constexpr bool
   _S_noexcept()
   {
     if constexpr (__adl_imove<_Tp>)
       return noexcept(iter_move(std::declval<_Tp>()));
     else
       return noexcept(*std::declval<_Tp>());
   }

      public:

 template<std::__detail::__dereferenceable _Tp>
   using __type = typename __result<_Tp>::type;

 template<std::__detail::__dereferenceable _Tp>
   [[nodiscard]]
   constexpr __type<_Tp>
   operator()(_Tp&& __e) const
   noexcept(_S_noexcept<_Tp>())
   {
     if constexpr (__adl_imove<_Tp>)
       return iter_move(static_cast<_Tp&&>(__e));
     else if constexpr (is_lvalue_reference_v<iter_reference_t<_Tp>>)
       return static_cast<__type<_Tp>>(*__e);
     else
       return *__e;
   }
      };
    }


    inline namespace _Cpo {
      inline constexpr __imove::_IterMove iter_move{};
    }
  }

  template<__detail::__dereferenceable _Tp>
    requires __detail::__can_reference<ranges::__imove::_IterMove::__type<_Tp&>>
    using iter_rvalue_reference_t = ranges::__imove::_IterMove::__type<_Tp&>;

  template<typename> struct incrementable_traits { };

  template<typename _Tp> requires is_object_v<_Tp>
    struct incrementable_traits<_Tp*>
    { using difference_type = ptrdiff_t; };

  template<typename _Iter>
    struct incrementable_traits<const _Iter>
    : incrementable_traits<_Iter> { };

  template<typename _Tp> requires requires { typename _Tp::difference_type; }
    struct incrementable_traits<_Tp>
    { using difference_type = typename _Tp::difference_type; };

  template<typename _Tp>
    requires (!requires { typename _Tp::difference_type; }
       && requires(const _Tp& __a, const _Tp& __b)
       { { __a - __b } -> integral; })
    struct incrementable_traits<_Tp>
    {
      using difference_type
 = make_signed_t<decltype(std::declval<_Tp>() - std::declval<_Tp>())>;
    };
# 204 "/usr/include/c++/14.2.1/bits/iterator_concepts.h" 3
  namespace __detail
  {


    template<typename _Iter>
      concept __primary_traits_iter
 = __is_base_of(__iterator_traits<_Iter, void>, iterator_traits<_Iter>);

    template<typename _Iter, typename _Tp>
      struct __iter_traits_impl
      { using type = iterator_traits<_Iter>; };

    template<typename _Iter, typename _Tp>
      requires __primary_traits_iter<_Iter>
      struct __iter_traits_impl<_Iter, _Tp>
      { using type = _Tp; };


    template<typename _Iter, typename _Tp = _Iter>
      using __iter_traits = typename __iter_traits_impl<_Iter, _Tp>::type;

    template<typename _Tp>
      using __iter_diff_t = typename
 __iter_traits<_Tp, incrementable_traits<_Tp>>::difference_type;
  }

  template<typename _Tp>
    using iter_difference_t = __detail::__iter_diff_t<remove_cvref_t<_Tp>>;

  namespace __detail
  {
    template<typename> struct __cond_value_type { };

    template<typename _Tp> requires is_object_v<_Tp>
      struct __cond_value_type<_Tp>
      { using value_type = remove_cv_t<_Tp>; };

    template<typename _Tp>
      concept __has_member_value_type
 = requires { typename _Tp::value_type; };

    template<typename _Tp>
      concept __has_member_element_type
 = requires { typename _Tp::element_type; };

  }

  template<typename> struct indirectly_readable_traits { };

  template<typename _Tp>
    struct indirectly_readable_traits<_Tp*>
    : __detail::__cond_value_type<_Tp>
    { };

  template<typename _Iter> requires is_array_v<_Iter>
    struct indirectly_readable_traits<_Iter>
    { using value_type = remove_cv_t<remove_extent_t<_Iter>>; };

  template<typename _Iter>
    struct indirectly_readable_traits<const _Iter>
    : indirectly_readable_traits<_Iter>
    { };

  template<__detail::__has_member_value_type _Tp>
    struct indirectly_readable_traits<_Tp>
    : __detail::__cond_value_type<typename _Tp::value_type>
    { };

  template<__detail::__has_member_element_type _Tp>
    struct indirectly_readable_traits<_Tp>
    : __detail::__cond_value_type<typename _Tp::element_type>
    { };



  template<__detail::__has_member_value_type _Tp>
    requires __detail::__has_member_element_type<_Tp>
    && same_as<remove_cv_t<typename _Tp::element_type>,
        remove_cv_t<typename _Tp::value_type>>
    struct indirectly_readable_traits<_Tp>
    : __detail::__cond_value_type<typename _Tp::value_type>
    { };



  template<__detail::__has_member_value_type _Tp>
    requires __detail::__has_member_element_type<_Tp>
    struct indirectly_readable_traits<_Tp>
    { };

  namespace __detail
  {
    template<typename _Tp>
      using __iter_value_t = typename
 __iter_traits<_Tp, indirectly_readable_traits<_Tp>>::value_type;
  }

  template<typename _Tp>
    using iter_value_t = __detail::__iter_value_t<remove_cvref_t<_Tp>>;

  namespace __detail
  {


    template<typename _Iter>
      concept __cpp17_iterator = requires(_Iter __it)
 {
   { *__it } -> __can_reference;
   { ++__it } -> same_as<_Iter&>;
   { *__it++ } -> __can_reference;
 } && copyable<_Iter>;

    template<typename _Iter>
      concept __cpp17_input_iterator = __cpp17_iterator<_Iter>
 && equality_comparable<_Iter>
 && requires(_Iter __it)
 {
   typename incrementable_traits<_Iter>::difference_type;
   typename indirectly_readable_traits<_Iter>::value_type;
   typename common_reference_t<iter_reference_t<_Iter>&&,
     typename indirectly_readable_traits<_Iter>::value_type&>;
   typename common_reference_t<decltype(*__it++)&&,
     typename indirectly_readable_traits<_Iter>::value_type&>;
   requires signed_integral<
     typename incrementable_traits<_Iter>::difference_type>;
 };

    template<typename _Iter>
      concept __cpp17_fwd_iterator = __cpp17_input_iterator<_Iter>
 && constructible_from<_Iter>
 && is_lvalue_reference_v<iter_reference_t<_Iter>>
 && same_as<remove_cvref_t<iter_reference_t<_Iter>>,
     typename indirectly_readable_traits<_Iter>::value_type>
 && requires(_Iter __it)
 {
   { __it++ } -> convertible_to<const _Iter&>;
   { *__it++ } -> same_as<iter_reference_t<_Iter>>;
 };

    template<typename _Iter>
      concept __cpp17_bidi_iterator = __cpp17_fwd_iterator<_Iter>
 && requires(_Iter __it)
 {
   { --__it } -> same_as<_Iter&>;
   { __it-- } -> convertible_to<const _Iter&>;
   { *__it-- } -> same_as<iter_reference_t<_Iter>>;
 };

    template<typename _Iter>
      concept __cpp17_randacc_iterator = __cpp17_bidi_iterator<_Iter>
 && totally_ordered<_Iter>
 && requires(_Iter __it,
      typename incrementable_traits<_Iter>::difference_type __n)
 {
   { __it += __n } -> same_as<_Iter&>;
   { __it -= __n } -> same_as<_Iter&>;
   { __it + __n } -> same_as<_Iter>;
   { __n + __it } -> same_as<_Iter>;
   { __it - __n } -> same_as<_Iter>;
   { __it - __it } -> same_as<decltype(__n)>;
   { __it[__n] } -> convertible_to<iter_reference_t<_Iter>>;
 };

    template<typename _Iter>
      concept __iter_with_nested_types = requires {
 typename _Iter::iterator_category;
 typename _Iter::value_type;
 typename _Iter::difference_type;
 typename _Iter::reference;
      };

    template<typename _Iter>
      concept __iter_without_nested_types = !__iter_with_nested_types<_Iter>;

    template<typename _Iter>
      concept __iter_without_category
 = !requires { typename _Iter::iterator_category; };

  }

  template<typename _Iterator>
    requires __detail::__iter_with_nested_types<_Iterator>
    struct __iterator_traits<_Iterator, void>
    {
    private:
      template<typename _Iter>
 struct __ptr
 { using type = void; };

      template<typename _Iter> requires requires { typename _Iter::pointer; }
 struct __ptr<_Iter>
 { using type = typename _Iter::pointer; };

    public:
      using iterator_category = typename _Iterator::iterator_category;
      using value_type = typename _Iterator::value_type;
      using difference_type = typename _Iterator::difference_type;
      using pointer = typename __ptr<_Iterator>::type;
      using reference = typename _Iterator::reference;
    };

  template<typename _Iterator>
    requires __detail::__iter_without_nested_types<_Iterator>
       && __detail::__cpp17_input_iterator<_Iterator>
    struct __iterator_traits<_Iterator, void>
    {
    private:
      template<typename _Iter>
 struct __cat
 { using type = input_iterator_tag; };

      template<typename _Iter>
 requires requires { typename _Iter::iterator_category; }
 struct __cat<_Iter>
 { using type = typename _Iter::iterator_category; };

      template<typename _Iter>
 requires __detail::__iter_without_category<_Iter>
    && __detail::__cpp17_randacc_iterator<_Iter>
 struct __cat<_Iter>
 { using type = random_access_iterator_tag; };

      template<typename _Iter>
 requires __detail::__iter_without_category<_Iter>
    && __detail::__cpp17_bidi_iterator<_Iter>
 struct __cat<_Iter>
 { using type = bidirectional_iterator_tag; };

      template<typename _Iter>
 requires __detail::__iter_without_category<_Iter>
    && __detail::__cpp17_fwd_iterator<_Iter>
 struct __cat<_Iter>
 { using type = forward_iterator_tag; };

      template<typename _Iter>
 struct __ptr
 { using type = void; };

      template<typename _Iter> requires requires { typename _Iter::pointer; }
 struct __ptr<_Iter>
 { using type = typename _Iter::pointer; };

      template<typename _Iter>
 requires (!requires { typename _Iter::pointer; }
     && requires(_Iter& __it) { __it.operator->(); })
 struct __ptr<_Iter>
 { using type = decltype(std::declval<_Iter&>().operator->()); };

      template<typename _Iter>
 struct __ref
 { using type = iter_reference_t<_Iter>; };

      template<typename _Iter> requires requires { typename _Iter::reference; }
 struct __ref<_Iter>
 { using type = typename _Iter::reference; };

    public:
      using iterator_category = typename __cat<_Iterator>::type;
      using value_type
 = typename indirectly_readable_traits<_Iterator>::value_type;
      using difference_type
 = typename incrementable_traits<_Iterator>::difference_type;
      using pointer = typename __ptr<_Iterator>::type;
      using reference = typename __ref<_Iterator>::type;
    };

  template<typename _Iterator>
    requires __detail::__iter_without_nested_types<_Iterator>
       && __detail::__cpp17_iterator<_Iterator>
    struct __iterator_traits<_Iterator, void>
    {
    private:
      template<typename _Iter>
 struct __diff
 { using type = void; };

      template<typename _Iter>
 requires requires
 { typename incrementable_traits<_Iter>::difference_type; }
 struct __diff<_Iter>
 {
   using type = typename incrementable_traits<_Iter>::difference_type;
 };

    public:
      using iterator_category = output_iterator_tag;
      using value_type = void;
      using difference_type = typename __diff<_Iterator>::type;
      using pointer = void;
      using reference = void;
    };

  namespace __detail
  {
    template<typename _Iter>
      struct __iter_concept_impl;


    template<typename _Iter>
      requires requires { typename __iter_traits<_Iter>::iterator_concept; }
      struct __iter_concept_impl<_Iter>
      { using type = typename __iter_traits<_Iter>::iterator_concept; };


    template<typename _Iter>
      requires (!requires { typename __iter_traits<_Iter>::iterator_concept; }
   && requires { typename __iter_traits<_Iter>::iterator_category; })
      struct __iter_concept_impl<_Iter>
      { using type = typename __iter_traits<_Iter>::iterator_category; };


    template<typename _Iter>
      requires (!requires { typename __iter_traits<_Iter>::iterator_concept; }
   && !requires { typename __iter_traits<_Iter>::iterator_category; }
   && __primary_traits_iter<_Iter>)
      struct __iter_concept_impl<_Iter>
      { using type = random_access_iterator_tag; };


    template<typename _Iter>
      struct __iter_concept_impl
      { };


    template<typename _Iter>
      using __iter_concept = typename __iter_concept_impl<_Iter>::type;

  template<typename _In>
    concept __indirectly_readable_impl = requires
      {
 typename iter_value_t<_In>;
 typename iter_reference_t<_In>;
 typename iter_rvalue_reference_t<_In>;
 requires same_as<iter_reference_t<const _In>,
    iter_reference_t<_In>>;
 requires same_as<iter_rvalue_reference_t<const _In>,
    iter_rvalue_reference_t<_In>>;
      }
      && common_reference_with<iter_reference_t<_In>&&, iter_value_t<_In>&>
      && common_reference_with<iter_reference_t<_In>&&,
         iter_rvalue_reference_t<_In>&&>
      && common_reference_with<iter_rvalue_reference_t<_In>&&,
          const iter_value_t<_In>&>;

  }


  template<typename _In>
    concept indirectly_readable
      = __detail::__indirectly_readable_impl<remove_cvref_t<_In>>;

  template<indirectly_readable _Tp>
    using iter_common_reference_t
      = common_reference_t<iter_reference_t<_Tp>, iter_value_t<_Tp>&>;


  template<typename _Out, typename _Tp>
    concept indirectly_writable = requires(_Out&& __o, _Tp&& __t)
      {
 *__o = std::forward<_Tp>(__t);
 *std::forward<_Out>(__o) = std::forward<_Tp>(__t);
 const_cast<const iter_reference_t<_Out>&&>(*__o)
   = std::forward<_Tp>(__t);
 const_cast<const iter_reference_t<_Out>&&>(*std::forward<_Out>(__o))
   = std::forward<_Tp>(__t);
      };

  namespace ranges::__detail
  {
    class __max_diff_type;
    class __max_size_type;

    __extension__
    template<typename _Tp>
      concept __is_signed_int128

 = same_as<_Tp, __int128>;




    __extension__
    template<typename _Tp>
      concept __is_unsigned_int128

 = same_as<_Tp, unsigned __int128>;




    template<typename _Tp>
      concept __cv_bool = same_as<const volatile _Tp, const volatile bool>;

    template<typename _Tp>
      concept __integral_nonbool = integral<_Tp> && !__cv_bool<_Tp>;

    template<typename _Tp>
      concept __is_int128 = __is_signed_int128<_Tp> || __is_unsigned_int128<_Tp>;

    template<typename _Tp>
      concept __is_integer_like = __integral_nonbool<_Tp>
 || __is_int128<_Tp>
 || same_as<_Tp, __max_diff_type> || same_as<_Tp, __max_size_type>;

    template<typename _Tp>
      concept __is_signed_integer_like = signed_integral<_Tp>
 || __is_signed_int128<_Tp>
 || same_as<_Tp, __max_diff_type>;

  }

  namespace __detail { using ranges::__detail::__is_signed_integer_like; }


  template<typename _Iter>
    concept weakly_incrementable = movable<_Iter>
      && requires(_Iter __i)
      {
 typename iter_difference_t<_Iter>;
 requires __detail::__is_signed_integer_like<iter_difference_t<_Iter>>;
 { ++__i } -> same_as<_Iter&>;
 __i++;
      };

  template<typename _Iter>
    concept incrementable = regular<_Iter> && weakly_incrementable<_Iter>
      && requires(_Iter __i) { { __i++ } -> same_as<_Iter>; };

  template<typename _Iter>
    concept input_or_output_iterator
      = requires(_Iter __i) { { *__i } -> __detail::__can_reference; }
 && weakly_incrementable<_Iter>;

  template<typename _Sent, typename _Iter>
    concept sentinel_for = semiregular<_Sent>
      && input_or_output_iterator<_Iter>
      && __detail::__weakly_eq_cmp_with<_Sent, _Iter>;

  template<typename _Sent, typename _Iter>
    inline constexpr bool disable_sized_sentinel_for = false;

  template<typename _Sent, typename _Iter>
    concept sized_sentinel_for = sentinel_for<_Sent, _Iter>
    && !disable_sized_sentinel_for<remove_cv_t<_Sent>, remove_cv_t<_Iter>>
    && requires(const _Iter& __i, const _Sent& __s)
    {
      { __s - __i } -> same_as<iter_difference_t<_Iter>>;
      { __i - __s } -> same_as<iter_difference_t<_Iter>>;
    };

  template<typename _Iter>
    concept input_iterator = input_or_output_iterator<_Iter>
      && indirectly_readable<_Iter>
      && requires { typename __detail::__iter_concept<_Iter>; }
      && derived_from<__detail::__iter_concept<_Iter>, input_iterator_tag>;

  template<typename _Iter, typename _Tp>
    concept output_iterator = input_or_output_iterator<_Iter>
      && indirectly_writable<_Iter, _Tp>
      && requires(_Iter __i, _Tp&& __t) { *__i++ = std::forward<_Tp>(__t); };

  template<typename _Iter>
    concept forward_iterator = input_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>, forward_iterator_tag>
      && incrementable<_Iter> && sentinel_for<_Iter, _Iter>;

  template<typename _Iter>
    concept bidirectional_iterator = forward_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>,
        bidirectional_iterator_tag>
      && requires(_Iter __i)
      {
 { --__i } -> same_as<_Iter&>;
 { __i-- } -> same_as<_Iter>;
      };

  template<typename _Iter>
    concept random_access_iterator = bidirectional_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>,
        random_access_iterator_tag>
      && totally_ordered<_Iter> && sized_sentinel_for<_Iter, _Iter>
      && requires(_Iter __i, const _Iter __j,
    const iter_difference_t<_Iter> __n)
      {
 { __i += __n } -> same_as<_Iter&>;
 { __j + __n } -> same_as<_Iter>;
 { __n + __j } -> same_as<_Iter>;
 { __i -= __n } -> same_as<_Iter&>;
 { __j - __n } -> same_as<_Iter>;
 { __j[__n] } -> same_as<iter_reference_t<_Iter>>;
      };

  template<typename _Iter>
    concept contiguous_iterator = random_access_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>, contiguous_iterator_tag>
      && is_lvalue_reference_v<iter_reference_t<_Iter>>
      && same_as<iter_value_t<_Iter>, remove_cvref_t<iter_reference_t<_Iter>>>
      && requires(const _Iter& __i)
      {
 { std::to_address(__i) }
   -> same_as<add_pointer_t<iter_reference_t<_Iter>>>;
      };





  template<typename _Fn, typename _Iter>
    concept indirectly_unary_invocable = indirectly_readable<_Iter>
      && copy_constructible<_Fn> && invocable<_Fn&, iter_value_t<_Iter>&>
      && invocable<_Fn&, iter_reference_t<_Iter>>
      && invocable<_Fn&, iter_common_reference_t<_Iter>>
      && common_reference_with<invoke_result_t<_Fn&, iter_value_t<_Iter>&>,
          invoke_result_t<_Fn&, iter_reference_t<_Iter>>>;

  template<typename _Fn, typename _Iter>
    concept indirectly_regular_unary_invocable = indirectly_readable<_Iter>
      && copy_constructible<_Fn>
      && regular_invocable<_Fn&, iter_value_t<_Iter>&>
      && regular_invocable<_Fn&, iter_reference_t<_Iter>>
      && regular_invocable<_Fn&, iter_common_reference_t<_Iter>>
      && common_reference_with<invoke_result_t<_Fn&, iter_value_t<_Iter>&>,
          invoke_result_t<_Fn&, iter_reference_t<_Iter>>>;

  template<typename _Fn, typename _Iter>
    concept indirect_unary_predicate = indirectly_readable<_Iter>
      && copy_constructible<_Fn> && predicate<_Fn&, iter_value_t<_Iter>&>
      && predicate<_Fn&, iter_reference_t<_Iter>>
      && predicate<_Fn&, iter_common_reference_t<_Iter>>;

  template<typename _Fn, typename _I1, typename _I2>
    concept indirect_binary_predicate
      = indirectly_readable<_I1> && indirectly_readable<_I2>
      && copy_constructible<_Fn>
      && predicate<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
      && predicate<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
      && predicate<_Fn&, iter_reference_t<_I1>, iter_value_t<_I2>&>
      && predicate<_Fn&, iter_reference_t<_I1>, iter_reference_t<_I2>>
      && predicate<_Fn&, iter_common_reference_t<_I1>,
     iter_common_reference_t<_I2>>;

  template<typename _Fn, typename _I1, typename _I2 = _I1>
    concept indirect_equivalence_relation
      = indirectly_readable<_I1> && indirectly_readable<_I2>
      && copy_constructible<_Fn>
      && equivalence_relation<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
      && equivalence_relation<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
      && equivalence_relation<_Fn&, iter_reference_t<_I1>, iter_value_t<_I2>&>
      && equivalence_relation<_Fn&, iter_reference_t<_I1>,
         iter_reference_t<_I2>>
      && equivalence_relation<_Fn&, iter_common_reference_t<_I1>,
         iter_common_reference_t<_I2>>;

  template<typename _Fn, typename _I1, typename _I2 = _I1>
    concept indirect_strict_weak_order
      = indirectly_readable<_I1> && indirectly_readable<_I2>
      && copy_constructible<_Fn>
      && strict_weak_order<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
      && strict_weak_order<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
      && strict_weak_order<_Fn&, iter_reference_t<_I1>, iter_value_t<_I2>&>
      && strict_weak_order<_Fn&, iter_reference_t<_I1>, iter_reference_t<_I2>>
      && strict_weak_order<_Fn&, iter_common_reference_t<_I1>,
      iter_common_reference_t<_I2>>;

  template<typename _Fn, typename... _Is>
    requires (indirectly_readable<_Is> && ...)
      && invocable<_Fn, iter_reference_t<_Is>...>
    using indirect_result_t = invoke_result_t<_Fn, iter_reference_t<_Is>...>;

  namespace __detail
  {
    template<typename _Iter, typename _Proj>
      struct __projected
      {
 struct __type
 {
   using value_type = remove_cvref_t<indirect_result_t<_Proj&, _Iter>>;
   indirect_result_t<_Proj&, _Iter> operator*() const;
 };
      };

    template<weakly_incrementable _Iter, typename _Proj>
      struct __projected<_Iter, _Proj>
      {
 struct __type
 {
   using value_type = remove_cvref_t<indirect_result_t<_Proj&, _Iter>>;
   using difference_type = iter_difference_t<_Iter>;
   indirect_result_t<_Proj&, _Iter> operator*() const;
 };
      };
  }


  template<indirectly_readable _Iter,
    indirectly_regular_unary_invocable<_Iter> _Proj>
    using projected = typename __detail::__projected<_Iter, _Proj>::__type;





  template<typename _In, typename _Out>
    concept indirectly_movable = indirectly_readable<_In>
      && indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;

  template<typename _In, typename _Out>
    concept indirectly_movable_storable = indirectly_movable<_In, _Out>
      && indirectly_writable<_Out, iter_value_t<_In>>
      && movable<iter_value_t<_In>>
      && constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>>
      && assignable_from<iter_value_t<_In>&, iter_rvalue_reference_t<_In>>;


  template<typename _In, typename _Out>
    concept indirectly_copyable = indirectly_readable<_In>
      && indirectly_writable<_Out, iter_reference_t<_In>>;

  template<typename _In, typename _Out>
    concept indirectly_copyable_storable = indirectly_copyable<_In, _Out>
      && indirectly_writable<_Out, iter_value_t<_In>&>
      && indirectly_writable<_Out, const iter_value_t<_In>&>
      && indirectly_writable<_Out, iter_value_t<_In>&&>
      && indirectly_writable<_Out, const iter_value_t<_In>&&>
      && copyable<iter_value_t<_In>>
      && constructible_from<iter_value_t<_In>, iter_reference_t<_In>>
      && assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;

namespace ranges
{

  namespace __iswap
  {
    template<typename _It1, typename _It2>
      void iter_swap(_It1, _It2) = delete;

    template<typename _Tp, typename _Up>
      concept __adl_iswap
 = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>
   || std::__detail::__class_or_enum<remove_reference_t<_Up>>)
 && requires(_Tp&& __t, _Up&& __u) {
   iter_swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
 };

    template<typename _Xp, typename _Yp>
      constexpr iter_value_t<_Xp>
      __iter_exchange_move(_Xp&& __x, _Yp&& __y)
      noexcept(noexcept(iter_value_t<_Xp>(iter_move(__x)))
        && noexcept(*__x = iter_move(__y)))
      {
 iter_value_t<_Xp> __old_value(iter_move(__x));
 *__x = iter_move(__y);
 return __old_value;
      }

    struct _IterSwap
    {
    private:
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__adl_iswap<_Tp, _Up>)
     return noexcept(iter_swap(std::declval<_Tp>(),
          std::declval<_Up>()));
   else if constexpr (indirectly_readable<_Tp>
       && indirectly_readable<_Up>
       && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
     return noexcept(ranges::swap(*std::declval<_Tp>(),
      *std::declval<_Up>()));
   else
     return noexcept(*std::declval<_Tp>()
  = __iswap::__iter_exchange_move(std::declval<_Up>(),
          std::declval<_Tp>()));
 }

    public:
      template<typename _Tp, typename _Up>
 requires __adl_iswap<_Tp, _Up>
 || (indirectly_readable<remove_reference_t<_Tp>>
     && indirectly_readable<remove_reference_t<_Up>>
     && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
 || (indirectly_movable_storable<_Tp, _Up>
     && indirectly_movable_storable<_Up, _Tp>)
 constexpr void
 operator()(_Tp&& __e1, _Up&& __e2) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__adl_iswap<_Tp, _Up>)
     iter_swap(static_cast<_Tp&&>(__e1), static_cast<_Up&&>(__e2));
   else if constexpr (indirectly_readable<_Tp>
       && indirectly_readable<_Up>
       && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
     ranges::swap(*__e1, *__e2);
   else
     *__e1 = __iswap::__iter_exchange_move(__e2, __e1);
 }
    };
  }


  inline namespace _Cpo {
    inline constexpr __iswap::_IterSwap iter_swap{};
  }

}


  template<typename _I1, typename _I2 = _I1>
    concept indirectly_swappable
      = indirectly_readable<_I1> && indirectly_readable<_I2>
      && requires(const _I1 __i1, const _I2 __i2)
      {
 ranges::iter_swap(__i1, __i1);
 ranges::iter_swap(__i2, __i2);
 ranges::iter_swap(__i1, __i2);
 ranges::iter_swap(__i2, __i1);
      };


  template<typename _I1, typename _I2, typename _Rel, typename _P1 = identity,
    typename _P2 = identity>
    concept indirectly_comparable
      = indirect_binary_predicate<_Rel, projected<_I1, _P1>,
      projected<_I2, _P2>>;


  template<typename _Iter>
    concept permutable = forward_iterator<_Iter>
      && indirectly_movable_storable<_Iter, _Iter>
      && indirectly_swappable<_Iter, _Iter>;


  template<typename _I1, typename _I2, typename _Out,
    typename _Rel = ranges::less, typename _P1 = identity,
    typename _P2 = identity>
    concept mergeable = input_iterator<_I1> && input_iterator<_I2>
      && weakly_incrementable<_Out> && indirectly_copyable<_I1, _Out>
      && indirectly_copyable<_I2, _Out>
      && indirect_strict_weak_order<_Rel, projected<_I1, _P1>,
        projected<_I2, _P2>>;


  template<typename _Iter, typename _Rel = ranges::less,
    typename _Proj = identity>
    concept sortable = permutable<_Iter>
      && indirect_strict_weak_order<_Rel, projected<_Iter, _Proj>>;

  struct unreachable_sentinel_t
  {
    template<weakly_incrementable _It>
      friend constexpr bool
      operator==(unreachable_sentinel_t, const _It&) noexcept
      { return false; }
  };

  inline constexpr unreachable_sentinel_t unreachable_sentinel{};


  namespace ranges::__access
  {
    using std::__detail::__class_or_enum;

    struct _Decay_copy final
    {
      template<typename _Tp>
 constexpr decay_t<_Tp>
 operator()(_Tp&& __t) const
 noexcept(is_nothrow_convertible_v<_Tp, decay_t<_Tp>>)
 { return std::forward<_Tp>(__t); }
    } inline constexpr __decay_copy{};

    template<typename _Tp>
      concept __member_begin = requires(_Tp& __t)
 {
   { __decay_copy(__t.begin()) } -> input_or_output_iterator;
 };


    void begin() = delete;

    template<typename _Tp>
      concept __adl_begin = __class_or_enum<remove_reference_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(begin(__t)) } -> input_or_output_iterator;
 };



    template<typename _Tp>
      requires is_array_v<_Tp> || __member_begin<_Tp&> || __adl_begin<_Tp&>
      auto
      __begin(_Tp& __t)
      {
 if constexpr (is_array_v<_Tp>)
   return __t + 0;
 else if constexpr (__member_begin<_Tp&>)
   return __t.begin();
 else
   return begin(__t);
      }
  }

  namespace __detail
  {

    template<typename _Tp>
      using __range_iter_t
 = decltype(ranges::__access::__begin(std::declval<_Tp&>()));

  }



}
# 72 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 93 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };



  struct contiguous_iterator_tag : public random_access_iterator_tag { };
# 125 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct [[__deprecated__]] iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 149 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits;




  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };
# 176 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 194 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>

    requires is_object_v<_Tp>

    struct iterator_traits<_Tp*>
    {
      using iterator_concept = contiguous_iterator_tag;
      using iterator_category = random_access_iterator_tag;
      using value_type = remove_cv_t<_Tp>;
      using difference_type = ptrdiff_t;
      using pointer = _Tp*;
      using reference = _Tp&;
    };
# 235 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
  template<typename _Iter>
    __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }




  template<typename _Iter>
    using __iter_category_t
      = typename iterator_traits<_Iter>::iterator_category;

  template<typename _InIter>
    using _RequireInputIter =
      __enable_if_t<is_convertible<__iter_category_t<_InIter>,
       input_iterator_tag>::value>;

  template<typename _It,
    typename _Cat = __iter_category_t<_It>>
    struct __is_random_access_iter
      : is_base_of<random_access_iterator_tag, _Cat>
    {
      typedef is_base_of<random_access_iterator_tag, _Cat> _Base;
      enum { __value = _Base::value };
    };








}
# 62 "/usr/include/c++/14.2.1/bits/stl_construct.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/stl_iterator_base_funcs.h" 1 3
# 62 "/usr/include/c++/14.2.1/bits/stl_iterator_base_funcs.h" 3
       
# 63 "/usr/include/c++/14.2.1/bits/stl_iterator_base_funcs.h" 3

# 1 "/usr/include/c++/14.2.1/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/concept_check.h" 3
# 65 "/usr/include/c++/14.2.1/bits/stl_iterator_base_funcs.h" 2 3
# 1 "/usr/include/c++/14.2.1/debug/assertions.h" 1 3
# 66 "/usr/include/c++/14.2.1/bits/stl_iterator_base_funcs.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{




  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;


  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);




  template<typename _OutputIterator>
    void
    __distance(_OutputIterator, _OutputIterator, output_iterator_tag) = delete;
# 144 "/usr/include/c++/14.2.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    [[__nodiscard__]] __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n >= 0), false)) std::__glibcxx_assert_fail(); } while (false);
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline constexpr void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline constexpr void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      if (__builtin_constant_p(__n) && __n == 1)
 ++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
 --__i;
      else
 __i += __n;
    }



  template<typename _OutputIterator, typename _Distance>
    void
    __advance(_OutputIterator&, _Distance, output_iterator_tag) = delete;
# 217 "/usr/include/c++/14.2.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    __attribute__((__always_inline__))
    inline constexpr void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _InputIterator>
    [[__nodiscard__]] [[__gnu__::__always_inline__]]
    inline constexpr _InputIterator
    next(_InputIterator __x, typename
  iterator_traits<_InputIterator>::difference_type __n = 1)
    {

     
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    [[__nodiscard__]] [[__gnu__::__always_inline__]]
    inline constexpr _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 63 "/usr/include/c++/14.2.1/bits/stl_construct.h" 2 3
# 73 "/usr/include/c++/14.2.1/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template <typename _Tp>
    constexpr inline void
    destroy_at(_Tp* __location)
    {
      if constexpr (202002L > 201703L && is_array_v<_Tp>)
 {
   for (auto& __x : *__location)
     std::destroy_at(std::__addressof(__x));
 }
      else
 __location->~_Tp();
    }


  template<typename _Tp, typename... _Args>
    constexpr auto
    construct_at(_Tp* __location, _Args&&... __args)
    noexcept(noexcept(::new((void*)0) _Tp(std::declval<_Args>()...)))
    -> decltype(::new((void*)0) _Tp(std::declval<_Args>()...))
    { return ::new((void*)__location) _Tp(std::forward<_Args>(__args)...); }
# 106 "/usr/include/c++/14.2.1/bits/stl_construct.h" 3
  template<typename _Tp, typename... _Args>
    constexpr
    inline void
    _Construct(_Tp* __p, _Args&&... __args)
    {

      if (std::__is_constant_evaluated())
 {

   std::construct_at(__p, std::forward<_Args>(__args)...);
   return;
 }

      ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);
    }
# 132 "/usr/include/c++/14.2.1/bits/stl_construct.h" 3
  template<typename _T1>
    inline void
    _Construct_novalue(_T1* __p)
    { ::new((void*)__p) _T1; }

  template<typename _ForwardIterator>
    constexpr void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last);




  template<typename _Tp>
    constexpr inline void
    _Destroy(_Tp* __pointer)
    {

      std::destroy_at(__pointer);



    }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
 static constexpr void
 __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    constexpr inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");


      if (std::__is_constant_evaluated())
 return std::_Destroy_aux<false>::__destroy(__first, __last);

      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }

  template<bool>
    struct _Destroy_n_aux
    {
      template<typename _ForwardIterator, typename _Size>
 static constexpr _ForwardIterator
 __destroy_n(_ForwardIterator __first, _Size __count)
 {
   for (; __count > 0; (void)++__first, --__count)
     std::_Destroy(std::__addressof(*__first));
   return __first;
 }
    };

  template<>
    struct _Destroy_n_aux<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   std::advance(__first, __count);
   return __first;
 }
    };






  template<typename _ForwardIterator, typename _Size>
    constexpr inline _ForwardIterator
    _Destroy_n(_ForwardIterator __first, _Size __count)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");


      if (std::__is_constant_evaluated())
 return std::_Destroy_n_aux<false>::__destroy_n(__first, __count);

      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
 __destroy_n(__first, __count);
    }


  template <typename _ForwardIterator>
    constexpr inline void
    destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      std::_Destroy(__first, __last);
    }

  template <typename _ForwardIterator, typename _Size>
    constexpr inline _ForwardIterator
    destroy_n(_ForwardIterator __first, _Size __count)
    {
      return std::_Destroy_n(__first, __count);
    }



}
# 58 "/usr/include/c++/14.2.1/bits/char_traits.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


 
# 68 "/usr/include/c++/14.2.1/bits/char_traits.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstringop-overflow"
#pragma GCC diagnostic ignored "-Wstringop-overread"
#pragma GCC diagnostic ignored "-Warray-bounds"
# 83 "/usr/include/c++/14.2.1/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;

      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;

    };
# 110 "/usr/include/c++/14.2.1/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;

      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;


      using comparison_category = std::strong_ordering;


      static constexpr void
      assign(char_type& __c1, const char_type& __c2)
      {

 if (std::__is_constant_evaluated())
   std::construct_at(__builtin_addressof(__c1), __c2);
 else

 __c1 = __c2;
      }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static constexpr std::size_t
      length(const char_type* __s);

      static constexpr const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static constexpr char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static constexpr char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static constexpr char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }


      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }

    };

  template<typename _CharT>
    constexpr int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    constexpr std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    constexpr const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    constexpr
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      if (__n == 0)
 return __s1;

      if (std::__is_constant_evaluated())
 {

   if (__builtin_constant_p(__s2 < __s1)
  && __s1 > __s2 && __s1 < (__s2 + __n))
     {
       do
  {
    --__n;
    assign(__s1[__n], __s2[__n]);
  }
       while (__n > 0);
     }
   else
     copy(__s1, __s2, __n);
   return __s1;
 }

      __builtin_memmove(__s1, __s2, __n * sizeof(char_type));
      return __s1;
    }

  template<typename _CharT>
    constexpr
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      if (__n == 0)
 return __s1;

      if (std::__is_constant_evaluated())
 {
   for (std::size_t __i = 0; __i < __n; ++__i)
     std::construct_at(__s1 + __i, __s2[__i]);
   return __s1;
 }

      __builtin_memcpy(__s1, __s2, __n * sizeof(char_type));
      return __s1;
    }

  template<typename _CharT>
    constexpr
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      if (std::__is_constant_evaluated())
 {
   for (std::size_t __i = 0; __i < __n; ++__i)
     std::construct_at(__s + __i, __a);
   return __s;
 }


      if constexpr (sizeof(_CharT) == 1 && __is_trivial(_CharT))
 {
   if (__n)
     {
       unsigned char __c;
       __builtin_memcpy(&__c, __builtin_addressof(__a), 1);
       __builtin_memset(__s, __c, __n);
     }
 }
      else
 {
   for (std::size_t __i = 0; __i < __n; ++__i)
     __s[__i] = __a;
 }
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

# 322 "/usr/include/c++/14.2.1/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;

      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;


      using comparison_category = strong_ordering;


      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      {

 if (std::__is_constant_evaluated())
   std::construct_at(__builtin_addressof(__c1), __c2);
 else

 __c1 = __c2;
      }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;

 if (std::__is_constant_evaluated())
   {
     for (size_t __i = 0; __i < __n; ++__i)
       if (lt(__s1[__i], __s2[__i]))
  return -1;
       else if (lt(__s2[__i], __s1[__i]))
  return 1;
     return 0;
   }

 return __builtin_memcmp(__s1, __s2, __n);
      }

      static constexpr size_t
      length(const char_type* __s)
      {

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::length(__s);

 return __builtin_strlen(__s);
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);

 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static constexpr char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);

 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static constexpr char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);

 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static constexpr char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);

 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }


      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }

  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;

      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;


      using comparison_category = strong_ordering;


      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      {

 if (std::__is_constant_evaluated())
   std::construct_at(__builtin_addressof(__c1), __c2);
 else

 __c1 = __c2;
      }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);

 return wmemcmp(__s1, __s2, __n);
      }

      static constexpr size_t
      length(const char_type* __s)
      {

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::length(__s);

 return wcslen(__s);
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);

 return wmemchr(__s, __a, __n);
      }

      static constexpr char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);

 return wmemmove(__s1, __s2, __n);
      }

      static constexpr char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);

 return wmemcpy(__s1, __s2, __n);
      }

      static constexpr char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);

 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }


      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }

  };







  template<>
    struct char_traits<char8_t>
    {
      typedef char8_t char_type;
      typedef unsigned int int_type;

      typedef u8streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;


      using comparison_category = strong_ordering;


      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      {

 if (std::__is_constant_evaluated())
   std::construct_at(__builtin_addressof(__c1), __c2);
 else

 __c1 = __c2;
      }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);

 return __builtin_memcmp(__s1, __s2, __n);
      }

      static constexpr size_t
      length(const char_type* __s)
      {

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::length(__s);

 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);

 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static constexpr char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);

 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static constexpr char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);

 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static constexpr char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);

 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }


      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }

    };



}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;

      typedef short unsigned int int_type;




      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;


      using comparison_category = strong_ordering;


      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      {

 if (std::__is_constant_evaluated())
   std::construct_at(__builtin_addressof(__c1), __c2);
 else

 __c1 = __c2;
      }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static constexpr size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static constexpr char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);

 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static constexpr char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);

 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static constexpr char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }


      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return __c == eof() ? int_type(0xfffd) : int_type(__c); }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }





    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;

      typedef unsigned int int_type;




      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;


      using comparison_category = strong_ordering;


      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      {

 if (std::__is_constant_evaluated())
   std::construct_at(__builtin_addressof(__c1), __c2);
 else

 __c1 = __c2;
      }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static constexpr size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static constexpr char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);

 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static constexpr char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;

 if (std::__is_constant_evaluated())
   return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);

 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static constexpr char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }


      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }

    };


  namespace __detail
  {
    template<typename _ChTraits>
      constexpr auto
      __char_traits_cmp_cat(int __cmp) noexcept
      {
 if constexpr (requires { typename _ChTraits::comparison_category; })
   {
     using _Cat = typename _ChTraits::comparison_category;
     static_assert( !is_void_v<common_comparison_category_t<_Cat>> );
     return static_cast<_Cat>(__cmp <=> 0);
   }
 else
   return static_cast<weak_ordering>(__cmp <=> 0);
      }
  }


#pragma GCC diagnostic pop


}
# 43 "/usr/include/c++/14.2.1/ios" 2 3
# 1 "/usr/include/c++/14.2.1/bits/localefwd.h" 1 3
# 37 "/usr/include/c++/14.2.1/bits/localefwd.h" 3
       
# 38 "/usr/include/c++/14.2.1/bits/localefwd.h" 3


# 1 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++locale.h" 1 3
# 39 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++locale.h" 3
       
# 40 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++locale.h" 3

# 1 "/usr/include/c++/14.2.1/clocale" 1 3
# 39 "/usr/include/c++/14.2.1/clocale" 3
       
# 40 "/usr/include/c++/14.2.1/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) noexcept (true);


extern struct lconv *localeconv (void) noexcept (true);
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) noexcept (true);
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) noexcept (true);



extern void freelocale (locale_t __dataset) noexcept (true);






extern locale_t uselocale (locale_t __dataset) noexcept (true);







}
# 43 "/usr/include/c++/14.2.1/clocale" 2 3
# 51 "/usr/include/c++/14.2.1/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;
# 73 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++locale.h" 3
  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 93 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }







}
# 41 "/usr/include/c++/14.2.1/bits/localefwd.h" 2 3

# 1 "/usr/include/c++/14.2.1/cctype" 1 3
# 39 "/usr/include/c++/14.2.1/cctype" 3
       
# 40 "/usr/include/c++/14.2.1/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 26 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
# 27 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/types.h" 2 3 4
# 1 "/usr/include/bits/timesize.h" 1 3 4
# 19 "/usr/include/bits/timesize.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 20 "/usr/include/bits/timesize.h" 2 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 142 "/usr/include/bits/types.h" 2 3 4
# 1 "/usr/include/bits/time64.h" 1 3 4
# 143 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 27 "/usr/include/ctype.h" 2 3 4

extern "C" {
# 39 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 35 "/usr/include/bits/endian.h" 3 4
# 1 "/usr/include/bits/endianness.h" 1 3 4
# 36 "/usr/include/bits/endian.h" 2 3 4
# 40 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     noexcept (true) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     noexcept (true) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     noexcept (true) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) noexcept (true);
extern int isalpha (int) noexcept (true);
extern int iscntrl (int) noexcept (true);
extern int isdigit (int) noexcept (true);
extern int islower (int) noexcept (true);
extern int isgraph (int) noexcept (true);
extern int isprint (int) noexcept (true);
extern int ispunct (int) noexcept (true);
extern int isspace (int) noexcept (true);
extern int isupper (int) noexcept (true);
extern int isxdigit (int) noexcept (true);



extern int tolower (int __c) noexcept (true);


extern int toupper (int __c) noexcept (true);




extern int isblank (int) noexcept (true);




extern int isctype (int __c, int __mask) noexcept (true);






extern int isascii (int __c) noexcept (true);



extern int toascii (int __c) noexcept (true);



extern int _toupper (int) noexcept (true);
extern int _tolower (int) noexcept (true);
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) noexcept (true);
extern int isalpha_l (int, locale_t) noexcept (true);
extern int iscntrl_l (int, locale_t) noexcept (true);
extern int isdigit_l (int, locale_t) noexcept (true);
extern int islower_l (int, locale_t) noexcept (true);
extern int isgraph_l (int, locale_t) noexcept (true);
extern int isprint_l (int, locale_t) noexcept (true);
extern int ispunct_l (int, locale_t) noexcept (true);
extern int isspace_l (int, locale_t) noexcept (true);
extern int isupper_l (int, locale_t) noexcept (true);
extern int isxdigit_l (int, locale_t) noexcept (true);

extern int isblank_l (int, locale_t) noexcept (true);



extern int __tolower_l (int __c, locale_t __l) noexcept (true);
extern int tolower_l (int __c, locale_t __l) noexcept (true);


extern int __toupper_l (int __c, locale_t __l) noexcept (true);
extern int toupper_l (int __c, locale_t __l) noexcept (true);
# 327 "/usr/include/ctype.h" 3 4
}
# 43 "/usr/include/c++/14.2.1/cctype" 2 3
# 62 "/usr/include/c++/14.2.1/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "/usr/include/c++/14.2.1/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "/usr/include/c++/14.2.1/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  struct ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;


  template<> class codecvt<char16_t, char, mbstate_t>;
  template<> class codecvt<char32_t, char, mbstate_t>;

  template<> class codecvt<char16_t, char8_t, mbstate_t>;
  template<> class codecvt<char32_t, char8_t, mbstate_t>;


  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  struct messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}
# 44 "/usr/include/c++/14.2.1/ios" 2 3
# 1 "/usr/include/c++/14.2.1/bits/ios_base.h" 1 3
# 37 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
       
# 38 "/usr/include/c++/14.2.1/bits/ios_base.h" 3

# 1 "/usr/include/c++/14.2.1/ext/atomicity.h" 1 3
# 32 "/usr/include/c++/14.2.1/ext/atomicity.h" 3
       
# 33 "/usr/include/c++/14.2.1/ext/atomicity.h" 3


# 1 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/gthr.h" 1 3
# 30 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 157 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/gthr.h" 3
# 1 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/gthr-default.h" 1 3
# 35 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 22 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4

# 1 "/usr/include/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 32 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/bits/types/struct_timespec.h" 1 3 4
# 11 "/usr/include/bits/types/struct_timespec.h" 3 4
struct timespec
{



  __time_t tv_sec;




  __syscall_slong_t tv_nsec;
# 31 "/usr/include/bits/types/struct_timespec.h" 3 4
};
# 33 "/usr/include/sched.h" 2 3 4





typedef __pid_t pid_t;




# 1 "/usr/include/bits/sched.h" 1 3 4
# 80 "/usr/include/bits/sched.h" 3 4
# 1 "/usr/include/bits/types/struct_sched_param.h" 1 3 4
# 23 "/usr/include/bits/types/struct_sched_param.h" 3 4
struct sched_param
{
  int sched_priority;
};
# 81 "/usr/include/bits/sched.h" 2 3 4

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) noexcept (true);


extern int unshare (int __flags) noexcept (true);


extern int sched_getcpu (void) noexcept (true);


extern int getcpu (unsigned int *, unsigned int *) noexcept (true);


extern int setns (int __fd, int __nstype) noexcept (true);


}
# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 115 "/usr/include/bits/cpu-set.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
     noexcept (true);
extern cpu_set_t *__sched_cpualloc (size_t __count) noexcept (true) ;
extern void __sched_cpufree (cpu_set_t *__set) noexcept (true);

}
# 45 "/usr/include/sched.h" 2 3 4






extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     noexcept (true);


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) noexcept (true);


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) noexcept (true);


extern int sched_getscheduler (__pid_t __pid) noexcept (true);


extern int sched_yield (void) noexcept (true);


extern int sched_get_priority_max (int __algorithm) noexcept (true);


extern int sched_get_priority_min (int __algorithm) noexcept (true);



extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) noexcept (true);
# 130 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) noexcept (true);


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) noexcept (true);


}
# 23 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 73 "/usr/include/bits/time.h" 3 4
# 1 "/usr/include/bits/timex.h" 1 3 4
# 22 "/usr/include/bits/timex.h" 3 4
# 1 "/usr/include/bits/types/struct_timeval.h" 1 3 4







struct timeval
{




  __time_t tv_sec;
  __suseconds_t tv_usec;

};
# 23 "/usr/include/bits/timex.h" 2 3 4



struct timex
{
# 58 "/usr/include/bits/timex.h" 3 4
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;

};
# 74 "/usr/include/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) noexcept (true) __attribute__ ((__nonnull__ (2)));
# 90 "/usr/include/bits/time.h" 3 4
}
# 34 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 38 "/usr/include/time.h" 2 3 4

# 1 "/usr/include/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4






# 1 "/usr/include/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 47 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 48 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4
extern "C" {



extern clock_t clock (void) noexcept (true);



extern time_t time (time_t *__timer) noexcept (true);


extern double difftime (time_t __time1, time_t __time0);


extern time_t mktime (struct tm *__tp) noexcept (true);
# 99 "/usr/include/time.h" 3 4
extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp)
   noexcept (true) __attribute__ ((__nonnull__ (1, 3, 4)));




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     noexcept (true);






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) noexcept (true);



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) noexcept (true);






extern struct tm *gmtime (const time_t *__timer) noexcept (true);



extern struct tm *localtime (const time_t *__timer) noexcept (true);
# 154 "/usr/include/time.h" 3 4
extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) noexcept (true);



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) noexcept (true);
# 179 "/usr/include/time.h" 3 4
extern char *asctime (const struct tm *__tp) noexcept (true);



extern char *ctime (const time_t *__timer) noexcept (true);
# 197 "/usr/include/time.h" 3 4
extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) noexcept (true);



extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) noexcept (true);
# 217 "/usr/include/time.h" 3 4
extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) noexcept (true);



extern int daylight;
extern long int timezone;
# 246 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) noexcept (true);
# 263 "/usr/include/time.h" 3 4
extern time_t timelocal (struct tm *__tp) noexcept (true);







extern int dysize (int __year) noexcept (true) __attribute__ ((__const__));
# 281 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);


extern int clock_getres (clockid_t __clock_id, struct timespec *__res) noexcept (true);


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     noexcept (true) __attribute__ ((__nonnull__ (2)));
# 323 "/usr/include/time.h" 3 4
extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);
# 338 "/usr/include/time.h" 3 4
extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) noexcept (true);




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) noexcept (true);


extern int timer_delete (timer_t __timerid) noexcept (true);



extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) noexcept (true);


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     noexcept (true);
# 376 "/usr/include/time.h" 3 4
extern int timer_getoverrun (timer_t __timerid) noexcept (true);






extern int timespec_get (struct timespec *__ts, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 399 "/usr/include/time.h" 3 4
extern int timespec_getres (struct timespec *__ts, int __base)
     noexcept (true);
# 425 "/usr/include/time.h" 3 4
extern int getdate_err;
# 434 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 448 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 24 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 22 "/usr/include/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/bits/atomic_wide_counter.h" 3 4
typedef union
{
  __extension__ unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/bits/struct_rwlock.h" 3 4
};
# 90 "/usr/include/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 27 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 26 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 31 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/types/struct___jmp_buf_tag.h" 1 3 4
# 26 "/usr/include/bits/types/struct___jmp_buf_tag.h" 3 4
struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };
# 32 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/bits/pthread_stack_min-dynamic.h" 1 3 4
# 23 "/usr/include/bits/pthread_stack_min-dynamic.h" 3 4
extern "C" {
extern long int __sysconf (int __name) noexcept (true);
}
# 34 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 104 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 124 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 159 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 197 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) noexcept (true) __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) noexcept (true);
# 233 "/usr/include/pthread.h" 3 4
extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);
# 243 "/usr/include/pthread.h" 3 4
extern int pthread_clockjoin_np (pthread_t __th, void **__thread_return,
                                 clockid_t __clockid,
     const struct timespec *__abstime);
# 269 "/usr/include/pthread.h" 3 4
extern int pthread_detach (pthread_t __th) noexcept (true);



extern pthread_t pthread_self (void) noexcept (true) __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  noexcept (true) __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_setsigmask_np (pthread_attr_t *__attr,
           const __sigset_t *sigmask);




extern int pthread_attr_getsigmask_np (const pthread_attr_t *__attr,
           __sigset_t *sigmask);







extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     noexcept (true) __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     noexcept (true);




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) noexcept (true);


extern int pthread_setconcurrency (int __level) noexcept (true);



extern int pthread_yield (void) noexcept (true);

extern int pthread_yield (void) noexcept (true) __asm__ ("" "sched_yield")
  __attribute__ ((__deprecated__ ("pthread_yield is deprecated, use sched_yield instead")))
                                                      ;







extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     noexcept (true) __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 509 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 521 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




struct __cancel_jmp_buf_tag
{
  __jmp_buf __cancel_jmp_buf;
  int __mask_was_saved;
};

typedef struct
{
  struct __cancel_jmp_buf_tag __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 557 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 766 "/usr/include/pthread.h" 3 4
extern int __sigsetjmp_cancel (struct __cancel_jmp_buf_tag __env[1], int __savemask) noexcept (true) __asm__ ("" "__sigsetjmp")


                     __attribute__ ((__returns_twice__));
# 781 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
# 817 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_clocklock (pthread_mutex_t *__restrict __mutex,
        clockid_t __clockid,
        const struct timespec *__restrict
        __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 835 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_consistent_np (pthread_mutex_t *) noexcept (true) __asm__ ("" "pthread_mutex_consistent")
                                __attribute__ ((__nonnull__ (1)))
  __attribute__ ((__deprecated__ ("pthread_mutex_consistent_np is deprecated, use pthread_mutex_consistent")))
                                                                         ;
# 874 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_getrobust_np (pthread_mutexattr_t *, int *) noexcept (true) __asm__ ("" "pthread_mutexattr_getrobust")

                                   __attribute__ ((__nonnull__ (1)))
  __attribute__ ((__deprecated__ ("pthread_mutexattr_getrobust_np is deprecated, use pthread_mutexattr_getrobust")))
                                                                               ;






extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *, int) noexcept (true) __asm__ ("" "pthread_mutexattr_setrobust")

                                   __attribute__ ((__nonnull__ (1)))
  __attribute__ ((__deprecated__ ("pthread_mutexattr_setrobust_np is deprecated, use pthread_mutexattr_setrobust")))
                                                                               ;
# 967 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
# 1004 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_clockrdlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 1023 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
# 1051 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_clockwrlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 1071 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) noexcept (true) __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1145 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));
# 1171 "/usr/include/pthread.h" 3 4
extern int pthread_cond_clockwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __clockid_t __clock_id,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 4)));
# 1194 "/usr/include/pthread.h" 3 4
extern int pthread_condattr_init (pthread_condattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1230 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1297 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) noexcept (true);


extern void *pthread_getspecific (pthread_key_t __key) noexcept (true);


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer)
  noexcept (true) __attribute__ ((__access__ (__none__, 2)));




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     noexcept (true) __attribute__ ((__nonnull__ (2)));
# 1332 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) noexcept (true);
# 1346 "/usr/include/pthread.h" 3 4
}
# 36 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/gthr-default.h" 2 3
# 47 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;



typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 108 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/gthr-default.h" 3



































# 312 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  return 1;
}
# 672 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 821 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 863 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return pthread_cond_destroy (__cond);
}
# 158 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "/usr/include/c++/14.2.1/ext/atomicity.h" 2 3
# 1 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/atomic_word.h" 1 3
# 32 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/usr/include/c++/14.2.1/ext/atomicity.h" 2 3

# 1 "/usr/include/sys/single_threaded.h" 1 3 4
# 24 "/usr/include/sys/single_threaded.h" 3 4
extern "C" {




extern char __libc_single_threaded;

}
# 39 "/usr/include/c++/14.2.1/ext/atomicity.h" 2 3


namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  __attribute__((__always_inline__))
  inline bool
  __is_single_threaded() noexcept
  {



    return ::__libc_single_threaded;



  }






  inline _Atomic_word
  __attribute__((__always_inline__))
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  inline void
  __attribute__((__always_inline__))
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 80 "/usr/include/c++/14.2.1/ext/atomicity.h" 3
  inline _Atomic_word
  __attribute__((__always_inline__))
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  inline void
  __attribute__((__always_inline__))
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  inline _Atomic_word
  __attribute__ ((__always_inline__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
    if (__is_single_threaded())
      return __exchange_and_add_single(__mem, __val);
    else
      return __exchange_and_add(__mem, __val);
  }

  inline void
  __attribute__ ((__always_inline__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {
    if (__is_single_threaded())
      __atomic_add_single(__mem, __val);
    else
      __atomic_add(__mem, __val);
  }


}
# 40 "/usr/include/c++/14.2.1/bits/ios_base.h" 2 3

# 1 "/usr/include/c++/14.2.1/bits/locale_classes.h" 1 3
# 37 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
       
# 38 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3


# 1 "/usr/include/c++/14.2.1/string" 1 3
# 36 "/usr/include/c++/14.2.1/string" 3
       
# 37 "/usr/include/c++/14.2.1/string" 3






# 1 "/usr/include/c++/14.2.1/bits/allocator.h" 1 3
# 46 "/usr/include/c++/14.2.1/bits/allocator.h" 3
# 1 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++allocator.h" 1 3
# 33 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++allocator.h" 3
# 1 "/usr/include/c++/14.2.1/bits/new_allocator.h" 1 3
# 35 "/usr/include/c++/14.2.1/bits/new_allocator.h" 3
# 1 "/usr/include/c++/14.2.1/bits/functexcept.h" 1 3
# 42 "/usr/include/c++/14.2.1/bits/functexcept.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));

  void
  __throw_bad_array_new_length(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__,__cold__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__,__cold__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__,__cold__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__,__cold__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_ios_failure(const char*, int) __attribute__((__noreturn__,__cold__));


  void
  __throw_system_error(int) __attribute__((__noreturn__,__cold__));


  void
  __throw_future_error(int) __attribute__((__noreturn__,__cold__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__,__cold__));
# 140 "/usr/include/c++/14.2.1/bits/functexcept.h" 3

}
# 36 "/usr/include/c++/14.2.1/bits/new_allocator.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 62 "/usr/include/c++/14.2.1/bits/new_allocator.h" 3
  template<typename _Tp>
    class __new_allocator
    {
    public:
      typedef _Tp value_type;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
# 83 "/usr/include/c++/14.2.1/bits/new_allocator.h" 3
      typedef std::true_type propagate_on_container_move_assignment;


      __attribute__((__always_inline__))
      constexpr
      __new_allocator() noexcept { }

      __attribute__((__always_inline__))
      constexpr
      __new_allocator(const __new_allocator&) noexcept { }

      template<typename _Tp1>
 __attribute__((__always_inline__))
 constexpr
 __new_allocator(const __new_allocator<_Tp1>&) noexcept { }


      __new_allocator& operator=(const __new_allocator&) = default;
# 125 "/usr/include/c++/14.2.1/bits/new_allocator.h" 3
      [[__nodiscard__]] _Tp*
      allocate(size_type __n, const void* = static_cast<const void*>(0))
      {



 static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");


 if (__builtin_expect(__n > this->_M_max_size(), false))
   {


     if (__n > (std::size_t(-1) / sizeof(_Tp)))
       std::__throw_bad_array_new_length();
     std::__throw_bad_alloc();
   }


 if (alignof(_Tp) > 16)
   {
     std::align_val_t __al = std::align_val_t(alignof(_Tp));
     return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp),
          __al));
   }

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(_Tp* __p, size_type __n __attribute__ ((__unused__)))
      {







 if (alignof(_Tp) > 16)
   {
     ::operator delete((__p), (__n) * sizeof(_Tp),
         std::align_val_t(alignof(_Tp)));
     return;
   }

 ::operator delete((__p), (__n) * sizeof(_Tp));
      }
# 213 "/usr/include/c++/14.2.1/bits/new_allocator.h" 3
      template<typename _Up>
 friend __attribute__((__always_inline__)) constexpr bool
 operator==(const __new_allocator&, const __new_allocator<_Up>&)
 noexcept
 { return true; }
# 227 "/usr/include/c++/14.2.1/bits/new_allocator.h" 3
    private:
      __attribute__((__always_inline__))
      constexpr size_type
      _M_max_size() const noexcept
      {

 return std::size_t(0x7fffffffffffffffL) / sizeof(_Tp);



      }
    };


}
# 34 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++allocator.h" 2 3


namespace std
{
# 46 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __new_allocator<_Tp>;
}
# 47 "/usr/include/c++/14.2.1/bits/allocator.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 72 "/usr/include/c++/14.2.1/bits/allocator.h" 3
  template<>
    class allocator<void>
    {
    public:
      typedef void value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
# 93 "/usr/include/c++/14.2.1/bits/allocator.h" 3
      using propagate_on_container_move_assignment = true_type;

      using is_always_equal
 __attribute__ ((__deprecated__ ("use '" "std::allocator_traits::is_always_equal" "' instead")))
 = true_type;




      allocator() = default;
      ~allocator() = default;

      template<typename _Up>
 __attribute__((__always_inline__))
 constexpr
 allocator(const allocator<_Up>&) noexcept { }






    };
# 127 "/usr/include/c++/14.2.1/bits/allocator.h" 3
  template<typename _Tp>
    class allocator : public __allocator_base<_Tp>
    {
    public:
      typedef _Tp value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
# 150 "/usr/include/c++/14.2.1/bits/allocator.h" 3
      using propagate_on_container_move_assignment = true_type;

      using is_always_equal
 __attribute__ ((__deprecated__ ("use '" "std::allocator_traits::is_always_equal" "' instead")))
 = true_type;




      __attribute__((__always_inline__))
      constexpr
      allocator() noexcept { }

      __attribute__((__always_inline__))
      constexpr
      allocator(const allocator& __a) noexcept
      : __allocator_base<_Tp>(__a) { }



      allocator& operator=(const allocator&) = default;


      template<typename _Tp1>
 __attribute__((__always_inline__))
 constexpr
 allocator(const allocator<_Tp1>&) noexcept { }

      __attribute__((__always_inline__))

      constexpr

      ~allocator() noexcept { }


      [[nodiscard,__gnu__::__always_inline__]]
      constexpr _Tp*
      allocate(size_t __n)
      {
 if (std::__is_constant_evaluated())
   {
     if (__builtin_mul_overflow(__n, sizeof(_Tp), &__n))
       std::__throw_bad_array_new_length();
     return static_cast<_Tp*>(::operator new(__n));
   }

 return __allocator_base<_Tp>::allocate(__n, 0);
      }

      [[__gnu__::__always_inline__]]
      constexpr void
      deallocate(_Tp* __p, size_t __n)
      {
 if (std::__is_constant_evaluated())
   {
     ::operator delete(__p);
     return;
   }
 __allocator_base<_Tp>::deallocate(__p, __n);
      }


      friend __attribute__((__always_inline__)) constexpr
      bool
      operator==(const allocator&, const allocator&) noexcept
      { return true; }
# 225 "/usr/include/c++/14.2.1/bits/allocator.h" 3
    };






  template<typename _T1, typename _T2>
    __attribute__((__always_inline__))
    inline constexpr bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }
# 252 "/usr/include/c++/14.2.1/bits/allocator.h" 3
  template<typename _Tp>
    class allocator<const _Tp>
    {
    public:
      typedef _Tp value_type;
      allocator() { }
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      allocator() { }
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<const volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      allocator() { }
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };







  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






}
# 44 "/usr/include/c++/14.2.1/string" 2 3
# 1 "/usr/include/c++/14.2.1/bits/cpp_type_traits.h" 1 3
# 35 "/usr/include/c++/14.2.1/bits/cpp_type_traits.h" 3
       
# 36 "/usr/include/c++/14.2.1/bits/cpp_type_traits.h" 3
# 67 "/usr/include/c++/14.2.1/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char8_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 272 "/usr/include/c++/14.2.1/bits/cpp_type_traits.h" 3
__extension__ template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; __extension__ template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
# 289 "/usr/include/c++/14.2.1/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 366 "/usr/include/c++/14.2.1/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  enum class byte : unsigned char;

  template<>
    struct __is_byte<byte>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_byte<char8_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename> struct iterator_traits;


  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable
    {
      enum { __value = __is_trivially_copyable(_Tp) };
    };




  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable<volatile _Tp>
    {
      enum { __value = 0 };
    };


  template<typename _OutputIter, typename _InputIter>
    struct __memcpyable
    {
      enum { __value = 0 };
    };

  template<typename _Tp>
    struct __memcpyable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcpyable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };






  template<typename _Iter1, typename _Iter2>
    struct __memcmpable
    {
      enum { __value = 0 };
    };


  template<typename _Tp>
    struct __memcmpable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<const _Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };







  template<typename _Tp, bool _TreatAsBytes =



 __is_byte<_Tp>::__value

    >
    struct __is_memcmp_ordered
    {
      static const bool __value = _Tp(-1) > _Tp(1);
    };

  template<typename _Tp>
    struct __is_memcmp_ordered<_Tp, false>
    {
      static const bool __value = false;
    };


  template<typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)>
    struct __is_memcmp_ordered_with
    {
      static const bool __value = __is_memcmp_ordered<_Tp>::__value
 && __is_memcmp_ordered<_Up>::__value;
    };

  template<typename _Tp, typename _Up>
    struct __is_memcmp_ordered_with<_Tp, _Up, false>
    {
      static const bool __value = false;
    };
# 579 "/usr/include/c++/14.2.1/bits/cpp_type_traits.h" 3
  template<>
    struct __is_memcmp_ordered_with<std::byte, std::byte, true>
    { static constexpr bool __value = true; };

  template<typename _Tp, bool _SameSize>
    struct __is_memcmp_ordered_with<_Tp, std::byte, _SameSize>
    { static constexpr bool __value = false; };

  template<typename _Up, bool _SameSize>
    struct __is_memcmp_ordered_with<std::byte, _Up, _SameSize>
    { static constexpr bool __value = false; };





  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    constexpr
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 45 "/usr/include/c++/14.2.1/string" 2 3

# 1 "/usr/include/c++/14.2.1/bits/ostream_insert.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/ostream_insert.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/ostream_insert.h" 3


# 1 "/usr/include/c++/14.2.1/bits/cxxabi_forced.h" 1 3
# 34 "/usr/include/c++/14.2.1/bits/cxxabi_forced.h" 3
       
# 35 "/usr/include/c++/14.2.1/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/usr/include/c++/14.2.1/bits/ostream_insert.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);






}
# 47 "/usr/include/c++/14.2.1/string" 2 3

# 1 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 1 3
# 65 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
# 1 "/usr/include/c++/14.2.1/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/14.2.1/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/14.2.1/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    constexpr
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    constexpr
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  constexpr bool
  __is_null_pointer(std::nullptr_t)
  { return true; }




  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };
# 225 "/usr/include/c++/14.2.1/ext/type_traits.h" 3
  template<typename... _Tp>
    using __promoted_t = decltype((typename __promote<_Tp>::__type(0) + ...));



  template<typename _Tp, typename _Up>
    using __promote_2 = __promote<__promoted_t<_Tp, _Up>>;

  template<typename _Tp, typename _Up, typename _Vp>
    using __promote_3 = __promote<__promoted_t<_Tp, _Up, _Vp>>;

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
    using __promote_4 = __promote<__promoted_t<_Tp, _Up, _Vp, _Wp>>;
# 269 "/usr/include/c++/14.2.1/ext/type_traits.h" 3

}
}
# 66 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 2 3
# 85 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{








  namespace __detail
  {


    template<typename _Cat, typename _Limit, typename _Otherwise = _Cat>
      using __clamp_iter_cat
 = __conditional_t<derived_from<_Cat, _Limit>, _Limit, _Otherwise>;
  }



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 128 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
      template<typename _Iter>
 friend class reverse_iterator;




      template<typename _Iter>
 static constexpr bool __convertible = !is_same_v<_Iter, _Iterator>
     && convertible_to<const _Iter&, _Iterator>;


    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::pointer pointer;




      using iterator_concept
 = __conditional_t<random_access_iterator<_Iterator>,
     random_access_iterator_tag,
     bidirectional_iterator_tag>;
      using iterator_category
 = __detail::__clamp_iter_cat<typename __traits_type::iterator_category,
         random_access_iterator_tag>;
      using value_type = iter_value_t<_Iterator>;
      using difference_type = iter_difference_t<_Iterator>;
      using reference = iter_reference_t<_Iterator>;
# 178 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
      constexpr
      reverse_iterator()
      noexcept(noexcept(_Iterator()))
      : current()
      { }




      explicit constexpr
      reverse_iterator(iterator_type __x)
      noexcept(noexcept(_Iterator(__x)))
      : current(__x)
      { }




      constexpr
      reverse_iterator(const reverse_iterator& __x)
      noexcept(noexcept(_Iterator(__x.current)))
      : current(__x.current)
      { }


      reverse_iterator& operator=(const reverse_iterator&) = default;






      template<typename _Iter>

 requires __convertible<_Iter>

 constexpr
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 noexcept(noexcept(_Iterator(__x.current)))
 : current(__x.current)
 { }


      template<typename _Iter>

 requires __convertible<_Iter>
   && assignable_from<_Iterator&, const _Iter&>

 constexpr
 reverse_iterator&
 operator=(const reverse_iterator<_Iter>& __x)
 noexcept(noexcept(current = __x.current))
 {
   current = __x.current;
   return *this;
 }





      [[__nodiscard__]]
      constexpr iterator_type
      base() const
      noexcept(noexcept(_Iterator(current)))
      { return current; }
# 255 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
      [[__nodiscard__]]
      constexpr reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      [[__nodiscard__]]
      constexpr pointer
      operator->() const

      requires is_pointer_v<_Iterator>
 || requires(const _Iterator __i) { __i.operator->(); }

      {


 _Iterator __tmp = current;
 --__tmp;
 return _S_to_pointer(__tmp);
      }






      constexpr reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      constexpr reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      constexpr reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      constexpr reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      [[__nodiscard__]]
      constexpr reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      constexpr reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      [[__nodiscard__]]
      constexpr reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      constexpr reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      [[__nodiscard__]]
      constexpr reference
      operator[](difference_type __n) const
      { return *(*this + __n); }


      [[nodiscard]]
      friend constexpr iter_rvalue_reference_t<_Iterator>
      iter_move(const reverse_iterator& __i)
      noexcept(is_nothrow_copy_constructible_v<_Iterator>
        && noexcept(ranges::iter_move(--std::declval<_Iterator&>())))
      {
 auto __tmp = __i.base();
 return ranges::iter_move(--__tmp);
      }

      template<indirectly_swappable<_Iterator> _Iter2>
 friend constexpr void
 iter_swap(const reverse_iterator& __x,
    const reverse_iterator<_Iter2>& __y)
 noexcept(is_nothrow_copy_constructible_v<_Iterator>
   && is_nothrow_copy_constructible_v<_Iter2>
   && noexcept(ranges::iter_swap(--std::declval<_Iterator&>(),
            --std::declval<_Iter2&>())))
 {
   auto __xtmp = __x.base();
   auto __ytmp = __y.base();
   ranges::iter_swap(--__xtmp, --__ytmp);
 }


    private:
      template<typename _Tp>
 static constexpr _Tp*
 _S_to_pointer(_Tp* __p)
        { return __p; }

      template<typename _Tp>
 static constexpr pointer
 _S_to_pointer(_Tp __t)
        { return __t.operator->(); }
    };
# 524 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() != __y.base() } -> convertible_to<bool>; }
    { return __x.base() != __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() > __y.base() } -> convertible_to<bool>; }
    { return __x.base() > __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() >= __y.base() } -> convertible_to<bool>; }
    { return __x.base() >= __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() <= __y.base() } -> convertible_to<bool>; }
    { return __x.base() <= __y.base(); }

  template<typename _IteratorL,
    three_way_comparable_with<_IteratorL> _IteratorR>
    [[nodiscard]]
    constexpr compare_three_way_result_t<_IteratorL, _IteratorR>
    operator<=>(const reverse_iterator<_IteratorL>& __x,
  const reverse_iterator<_IteratorR>& __y)
    { return __y.base() <=> __x.base(); }




  template<typename _Iterator>
    [[nodiscard]]
    constexpr bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }
    { return __x.base() == __y.base(); }

  template<three_way_comparable _Iterator>
    [[nodiscard]]
    constexpr compare_three_way_result_t<_Iterator, _Iterator>
    operator<=>(const reverse_iterator<_Iterator>& __x,
  const reverse_iterator<_Iterator>& __y)
    { return __y.base() <=> __x.base(); }
# 615 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }





  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }


  template<typename _Iterator1, typename _Iterator2>
    requires (!sized_sentinel_for<_Iterator1, _Iterator2>)
    inline constexpr bool
    disable_sized_sentinel_for<reverse_iterator<_Iterator1>,
          reverse_iterator<_Iterator2>> = true;



  template<typename _Iterator>
    constexpr
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
    constexpr
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 688 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;

      using difference_type = ptrdiff_t;



      explicit constexpr
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 726 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
      constexpr
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      constexpr
      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      [[__nodiscard__]] constexpr
      back_insert_iterator&
      operator*()
      { return *this; }


      constexpr
      back_insert_iterator&
      operator++()
      { return *this; }


      constexpr
      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 773 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    [[__nodiscard__]] constexpr
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 789 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;

      using difference_type = ptrdiff_t;



      explicit constexpr
      front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 827 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
      constexpr
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      constexpr
      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      [[__nodiscard__]] constexpr
      front_insert_iterator&
      operator*()
      { return *this; }


      constexpr
      front_insert_iterator&
      operator++()
      { return *this; }


      constexpr
      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 874 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    [[__nodiscard__]] constexpr
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 894 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {

      using _Iter = std::__detail::__range_iter_t<_Container>;



    protected:
      _Container* container;
      _Iter iter;

    public:

      typedef _Container container_type;


      using difference_type = ptrdiff_t;






      constexpr
      insert_iterator(_Container& __x, _Iter __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 955 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
      constexpr
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      constexpr
      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      [[__nodiscard__]] constexpr
      insert_iterator&
      operator*()
      { return *this; }


      constexpr
      insert_iterator&
      operator++()
      { return *this; }


      constexpr
      insert_iterator&
      operator++(int)
      { return *this; }
    };

#pragma GCC diagnostic pop
# 1008 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    [[nodiscard]]
    constexpr insert_iterator<_Container>
    inserter(_Container& __x, std::__detail::__range_iter_t<_Container> __i)
    { return insert_iterator<_Container>(__x, __i); }
# 1023 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3

}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 1037 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef std::iterator_traits<_Iterator> __traits_type;


      template<typename _Iter>
 using __convertible_from
   = std::__enable_if_t<std::is_convertible<_Iter, _Iterator>::value>;


    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;


      using iterator_concept = std::__detail::__iter_concept<_Iterator>;


      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit constexpr
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }



      template<typename _Iter, typename = __convertible_from<_Iter>>
 constexpr
 __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 noexcept
# 1085 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
        : _M_current(__i.base()) { }


      constexpr
      reference
      operator*() const noexcept
      { return *_M_current; }

      constexpr
      pointer
      operator->() const noexcept
      { return _M_current; }

      constexpr
      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      constexpr
      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      constexpr
      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      constexpr
      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      constexpr
      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      constexpr
      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      constexpr
      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      constexpr
      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      constexpr
      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      constexpr
      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 1166 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[nodiscard]]
    constexpr bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept(noexcept(__lhs.base() == __rhs.base()))
    requires requires {
      { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>;
    }
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[nodiscard]]
    constexpr std::__detail::__synth3way_t<_IteratorR, _IteratorL>
    operator<=>(const __normal_iterator<_IteratorL, _Container>& __lhs,
  const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
    { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }

  template<typename _Iterator, typename _Container>
    [[nodiscard]]
    constexpr bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept(noexcept(__lhs.base() == __rhs.base()))
    requires requires {
      { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>;
    }
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[nodiscard]]
    constexpr std::__detail::__synth3way_t<_Iterator>
    operator<=>(const __normal_iterator<_Iterator, _Container>& __lhs,
  const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
    { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
# 1307 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>


    [[__nodiscard__]] constexpr
    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]] constexpr
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]] constexpr
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    constexpr
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it.base(); }
# 1371 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<semiregular _Sent>
    class move_sentinel
    {
    public:
      constexpr
      move_sentinel()
      noexcept(is_nothrow_default_constructible_v<_Sent>)
      : _M_last() { }

      constexpr explicit
      move_sentinel(_Sent __s)
      noexcept(is_nothrow_move_constructible_v<_Sent>)
      : _M_last(std::move(__s)) { }

      template<typename _S2> requires convertible_to<const _S2&, _Sent>
 constexpr
 move_sentinel(const move_sentinel<_S2>& __s)
 noexcept(is_nothrow_constructible_v<_Sent, const _S2&>)
 : _M_last(__s.base())
 { }

      template<typename _S2> requires assignable_from<_Sent&, const _S2&>
 constexpr move_sentinel&
 operator=(const move_sentinel<_S2>& __s)
 noexcept(is_nothrow_assignable_v<_Sent, const _S2&>)
 {
   _M_last = __s.base();
   return *this;
 }

      [[nodiscard]]
      constexpr _Sent
      base() const
      noexcept(is_nothrow_copy_constructible_v<_Sent>)
      { return _M_last; }

    private:
      _Sent _M_last;
    };


  namespace __detail
  {

    template<typename _Iterator>
      struct __move_iter_cat
      { };

    template<typename _Iterator>
      requires requires { typename __iter_category_t<_Iterator>; }
      struct __move_iter_cat<_Iterator>
      {
 using iterator_category
   = __clamp_iter_cat<__iter_category_t<_Iterator>,
        random_access_iterator_tag>;
      };

  }
# 1439 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator

      : public __detail::__move_iter_cat<_Iterator>

    {
      _Iterator _M_current;

      using __traits_type = iterator_traits<_Iterator>;




      template<typename _Iter2>
 friend class move_iterator;




      template<typename _Iter2>
 static constexpr bool __convertible = !is_same_v<_Iter2, _Iterator>
     && convertible_to<const _Iter2&, _Iterator>;



      static auto
      _S_iter_concept()
      {
 if constexpr (random_access_iterator<_Iterator>)
   return random_access_iterator_tag{};
 else if constexpr (bidirectional_iterator<_Iterator>)
   return bidirectional_iterator_tag{};
 else if constexpr (forward_iterator<_Iterator>)
   return forward_iterator_tag{};
 else
   return input_iterator_tag{};
      }


    public:
      using iterator_type = _Iterator;


      using iterator_concept = decltype(_S_iter_concept());


      using value_type = iter_value_t<_Iterator>;
      using difference_type = iter_difference_t<_Iterator>;
      using pointer = _Iterator;
      using reference = iter_rvalue_reference_t<_Iterator>;
# 1503 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
      constexpr
      move_iterator()
      : _M_current() { }

      explicit constexpr
      move_iterator(iterator_type __i)
      : _M_current(std::move(__i)) { }

      template<typename _Iter>

 requires __convertible<_Iter>

 constexpr
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i._M_current) { }

      template<typename _Iter>

 requires __convertible<_Iter>
   && assignable_from<_Iterator&, const _Iter&>

 constexpr
 move_iterator& operator=(const move_iterator<_Iter>& __i)
 {
   _M_current = __i._M_current;
   return *this;
 }







      [[nodiscard]]
      constexpr const iterator_type&
      base() const & noexcept
      { return _M_current; }

      [[nodiscard]]
      constexpr iterator_type
      base() &&
      { return std::move(_M_current); }


      [[__nodiscard__]]
      constexpr reference
      operator*() const

      { return ranges::iter_move(_M_current); }




      [[__nodiscard__]]
      constexpr pointer
      operator->() const
      { return _M_current; }

      constexpr move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      constexpr move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }


      constexpr void
      operator++(int) requires (!forward_iterator<_Iterator>)
      { ++_M_current; }


      constexpr move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      constexpr move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      [[__nodiscard__]]
      constexpr move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      constexpr move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      [[__nodiscard__]]
      constexpr move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      constexpr move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      [[__nodiscard__]]
      constexpr reference
      operator[](difference_type __n) const

      { return ranges::iter_move(_M_current + __n); }





      template<sentinel_for<_Iterator> _Sent>
 [[nodiscard]]
 friend constexpr bool
 operator==(const move_iterator& __x, const move_sentinel<_Sent>& __y)
 { return __x.base() == __y.base(); }

      template<sized_sentinel_for<_Iterator> _Sent>
 [[nodiscard]]
 friend constexpr iter_difference_t<_Iterator>
 operator-(const move_sentinel<_Sent>& __x, const move_iterator& __y)
 { return __x.base() - __y.base(); }

      template<sized_sentinel_for<_Iterator> _Sent>
 [[nodiscard]]
 friend constexpr iter_difference_t<_Iterator>
 operator-(const move_iterator& __x, const move_sentinel<_Sent>& __y)
 { return __x.base() - __y.base(); }

      [[nodiscard]]
      friend constexpr iter_rvalue_reference_t<_Iterator>
      iter_move(const move_iterator& __i)
      noexcept(noexcept(ranges::iter_move(__i._M_current)))
      { return ranges::iter_move(__i._M_current); }

      template<indirectly_swappable<_Iterator> _Iter2>
 friend constexpr void
 iter_swap(const move_iterator& __x, const move_iterator<_Iter2>& __y)
 noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
 { return ranges::iter_swap(__x._M_current, __y._M_current); }

    };

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)

    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }

    { return __x.base() == __y.base(); }


  template<typename _IteratorL,
    three_way_comparable_with<_IteratorL> _IteratorR>
    [[__nodiscard__]]
    constexpr compare_three_way_result_t<_IteratorL, _IteratorR>
    operator<=>(const move_iterator<_IteratorL>& __x,
  const move_iterator<_IteratorR>& __y)
    { return __x.base() <=> __y.base(); }
# 1691 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)

    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }

    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)

    requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; }

    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)

    requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; }

    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)

    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }

    { return !(__x < __y); }




  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }


  template<three_way_comparable _Iterator>
    [[__nodiscard__]]
    constexpr compare_three_way_result_t<_Iterator>
    operator<=>(const move_iterator<_Iterator>& __x,
  const move_iterator<_Iterator>& __y)
    { return __x.base() <=> __y.base(); }
# 1786 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(std::move(__i)); }

  template<typename _Iterator, typename _ReturnType
    = __conditional_t<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
  _Iterator, move_iterator<_Iterator>>>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = __conditional_t<__move_if_noexcept_cond<_Tp>::value,
        const _Tp*, move_iterator<_Tp*>>>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }




  template<typename _Iterator1, typename _Iterator2>
    requires (!sized_sentinel_for<_Iterator1, _Iterator2>)
    inline constexpr bool
    disable_sized_sentinel_for<move_iterator<_Iterator1>,
          move_iterator<_Iterator2>> = true;



  namespace __detail
  {
    template<typename _It>
      concept __common_iter_has_arrow = indirectly_readable<const _It>
 && (requires(const _It& __it) { __it.operator->(); }
     || is_reference_v<iter_reference_t<_It>>
     || constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);

    template<typename _It>
      concept __common_iter_use_postfix_proxy
 = (!requires (_It& __i) { { *__i++ } -> __can_reference; })
   && constructible_from<iter_value_t<_It>, iter_reference_t<_It>>
   && move_constructible<iter_value_t<_It>>;
  }


  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    requires (!same_as<_It, _Sent>) && copyable<_It>
  class common_iterator
  {
    template<typename _Tp, typename _Up>
      static constexpr bool
      _S_noexcept1()
      {
 if constexpr (is_trivially_default_constructible_v<_Tp>)
   return is_nothrow_assignable_v<_Tp&, _Up>;
 else
   return is_nothrow_constructible_v<_Tp, _Up>;
      }

    template<typename _It2, typename _Sent2>
      static constexpr bool
      _S_noexcept()
      { return _S_noexcept1<_It, _It2>() && _S_noexcept1<_Sent, _Sent2>(); }

    class __arrow_proxy
    {
      iter_value_t<_It> _M_keep;

      constexpr
      __arrow_proxy(iter_reference_t<_It>&& __x)
      : _M_keep(std::move(__x)) { }

      friend class common_iterator;

    public:
      constexpr const iter_value_t<_It>*
      operator->() const noexcept
      { return std::__addressof(_M_keep); }
    };

    class __postfix_proxy
    {
      iter_value_t<_It> _M_keep;

      constexpr
      __postfix_proxy(iter_reference_t<_It>&& __x)
      : _M_keep(std::forward<iter_reference_t<_It>>(__x)) { }

      friend class common_iterator;

    public:
      constexpr const iter_value_t<_It>&
      operator*() const noexcept
      { return _M_keep; }
    };

  public:
    constexpr
    common_iterator()
    noexcept(is_nothrow_default_constructible_v<_It>)
    requires default_initializable<_It>
    : _M_it(), _M_index(0)
    { }

    constexpr
    common_iterator(_It __i)
    noexcept(is_nothrow_move_constructible_v<_It>)
    : _M_it(std::move(__i)), _M_index(0)
    { }

    constexpr
    common_iterator(_Sent __s)
    noexcept(is_nothrow_move_constructible_v<_Sent>)
    : _M_sent(std::move(__s)), _M_index(1)
    { }

    template<typename _It2, typename _Sent2>
      requires convertible_to<const _It2&, _It>
 && convertible_to<const _Sent2&, _Sent>
      constexpr
      common_iterator(const common_iterator<_It2, _Sent2>& __x)
      noexcept(_S_noexcept<const _It2&, const _Sent2&>())
      : _M_valueless(), _M_index(__x._M_index)
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
 if (_M_index == 0)
   {
     if constexpr (is_trivially_default_constructible_v<_It>)
       _M_it = std::move(__x._M_it);
     else
       std::construct_at(std::__addressof(_M_it), __x._M_it);
   }
 else if (_M_index == 1)
   {
     if constexpr (is_trivially_default_constructible_v<_Sent>)
       _M_sent = std::move(__x._M_sent);
     else
       std::construct_at(std::__addressof(_M_sent), __x._M_sent);
   }
      }

    common_iterator(const common_iterator&) = default;

    constexpr
    common_iterator(const common_iterator& __x)
    noexcept(_S_noexcept<const _It&, const _Sent&>())
    requires (!is_trivially_copyable_v<_It> || !is_trivially_copyable_v<_Sent>)
    : _M_valueless(), _M_index(__x._M_index)
    {
      if (_M_index == 0)
 {
   if constexpr (is_trivially_default_constructible_v<_It>)
     _M_it = __x._M_it;
   else
     std::construct_at(std::__addressof(_M_it), __x._M_it);
 }
      else if (_M_index == 1)
 {
   if constexpr (is_trivially_default_constructible_v<_Sent>)
     _M_sent = __x._M_sent;
   else
     std::construct_at(std::__addressof(_M_sent), __x._M_sent);
 }
    }

    common_iterator(common_iterator&&) = default;

    constexpr
    common_iterator(common_iterator&& __x)
    noexcept(_S_noexcept<_It, _Sent>())
    requires (!is_trivially_copyable_v<_It> || !is_trivially_copyable_v<_Sent>)
    : _M_valueless(), _M_index(__x._M_index)
    {
      if (_M_index == 0)
 {
   if constexpr (is_trivially_default_constructible_v<_It>)
     _M_it = std::move(__x._M_it);
   else
     std::construct_at(std::__addressof(_M_it), std::move(__x._M_it));
 }
      else if (_M_index == 1)
 {
   if constexpr (is_trivially_default_constructible_v<_Sent>)
     _M_sent = std::move(__x._M_sent);
   else
     std::construct_at(std::__addressof(_M_sent),
         std::move(__x._M_sent));
 }
    }

    constexpr common_iterator&
    operator=(const common_iterator&) = default;

    constexpr common_iterator&
    operator=(const common_iterator& __x)
    noexcept(is_nothrow_copy_assignable_v<_It>
      && is_nothrow_copy_assignable_v<_Sent>
      && is_nothrow_copy_constructible_v<_It>
      && is_nothrow_copy_constructible_v<_Sent>)
    requires (!is_trivially_copy_assignable_v<_It>
  || !is_trivially_copy_assignable_v<_Sent>)
    {
      _M_assign(__x);
      return *this;
    }

    constexpr common_iterator&
    operator=(common_iterator&&) = default;

    constexpr common_iterator&
    operator=(common_iterator&& __x)
    noexcept(is_nothrow_move_assignable_v<_It>
      && is_nothrow_move_assignable_v<_Sent>
      && is_nothrow_move_constructible_v<_It>
      && is_nothrow_move_constructible_v<_Sent>)
    requires (!is_trivially_move_assignable_v<_It>
  || !is_trivially_move_assignable_v<_Sent>)
    {
      _M_assign(std::move(__x));
      return *this;
    }

    template<typename _It2, typename _Sent2>
      requires convertible_to<const _It2&, _It>
 && convertible_to<const _Sent2&, _Sent>
 && assignable_from<_It&, const _It2&>
 && assignable_from<_Sent&, const _Sent2&>
      constexpr common_iterator&
      operator=(const common_iterator<_It2, _Sent2>& __x)
      noexcept(is_nothrow_constructible_v<_It, const _It2&>
        && is_nothrow_constructible_v<_Sent, const _Sent2&>
        && is_nothrow_assignable_v<_It&, const _It2&>
        && is_nothrow_assignable_v<_Sent&, const _Sent2&>)
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
 _M_assign(__x);
 return *this;
      }


    ~common_iterator() = default;

    constexpr
    ~common_iterator()
      requires (!is_trivially_destructible_v<_It>
    || !is_trivially_destructible_v<_Sent>)




    {
      if (_M_index == 0)
 _M_it.~_It();
      else if (_M_index == 1)
 _M_sent.~_Sent();
    }

    [[nodiscard]]
    constexpr decltype(auto)
    operator*()
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      return *_M_it;
    }

    [[nodiscard]]
    constexpr decltype(auto)
    operator*() const requires __detail::__dereferenceable<const _It>
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      return *_M_it;
    }

    [[nodiscard]]
    constexpr auto
    operator->() const requires __detail::__common_iter_has_arrow<_It>
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      if constexpr (is_pointer_v<_It> || requires { _M_it.operator->(); })
 return _M_it;
      else if constexpr (is_reference_v<iter_reference_t<_It>>)
 {
   auto&& __tmp = *_M_it;
   return std::__addressof(__tmp);
 }
      else
 return __arrow_proxy{*_M_it};
    }

    constexpr common_iterator&
    operator++()
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      ++_M_it;
      return *this;
    }

    constexpr decltype(auto)
    operator++(int)
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      if constexpr (forward_iterator<_It>)
 {
   common_iterator __tmp = *this;
   ++*this;
   return __tmp;
 }
      else if constexpr (!__detail::__common_iter_use_postfix_proxy<_It>)
 return _M_it++;
      else
 {
   __postfix_proxy __p(**this);
   ++*this;
   return __p;
 }
    }

    template<typename _It2, sentinel_for<_It> _Sent2>
      requires sentinel_for<_Sent, _It2>
      friend constexpr bool
      operator== [[nodiscard]] (const common_iterator& __x,
    const common_iterator<_It2, _Sent2>& __y)
      {
 switch(__x._M_index << 2 | __y._M_index)
   {
   case 0b0000:
   case 0b0101:
     return true;
   case 0b0001:
     return __x._M_it == __y._M_sent;
   case 0b0100:
     return __x._M_sent == __y._M_it;
   default:
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__y._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     __builtin_unreachable();
   }
      }

    template<typename _It2, sentinel_for<_It> _Sent2>
      requires sentinel_for<_Sent, _It2> && equality_comparable_with<_It, _It2>
      friend constexpr bool
      operator== [[nodiscard]] (const common_iterator& __x,
    const common_iterator<_It2, _Sent2>& __y)
      {
 switch(__x._M_index << 2 | __y._M_index)
   {
   case 0b0101:
     return true;
   case 0b0000:
     return __x._M_it == __y._M_it;
   case 0b0001:
     return __x._M_it == __y._M_sent;
   case 0b0100:
     return __x._M_sent == __y._M_it;
   default:
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__y._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     __builtin_unreachable();
   }
      }

    template<sized_sentinel_for<_It> _It2, sized_sentinel_for<_It> _Sent2>
      requires sized_sentinel_for<_Sent, _It2>
      friend constexpr iter_difference_t<_It2>
      operator- [[nodiscard]] (const common_iterator& __x,
          const common_iterator<_It2, _Sent2>& __y)
      {
 switch(__x._M_index << 2 | __y._M_index)
   {
   case 0b0101:
     return 0;
   case 0b0000:
     return __x._M_it - __y._M_it;
   case 0b0001:
     return __x._M_it - __y._M_sent;
   case 0b0100:
     return __x._M_sent - __y._M_it;
   default:
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__y._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     __builtin_unreachable();
   }
      }

    [[nodiscard]]
    friend constexpr iter_rvalue_reference_t<_It>
    iter_move(const common_iterator& __i)
    noexcept(noexcept(ranges::iter_move(std::declval<const _It&>())))
    requires input_iterator<_It>
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__i._M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      return ranges::iter_move(__i._M_it);
    }

    template<indirectly_swappable<_It> _It2, typename _Sent2>
      friend constexpr void
      iter_swap(const common_iterator& __x,
  const common_iterator<_It2, _Sent2>& __y)
      noexcept(noexcept(ranges::iter_swap(std::declval<const _It&>(),
       std::declval<const _It2&>())))
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__y._M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return ranges::iter_swap(__x._M_it, __y._M_it);
      }

  private:
    template<input_or_output_iterator _It2, sentinel_for<_It2> _Sent2>
      requires (!same_as<_It2, _Sent2>) && copyable<_It2>
      friend class common_iterator;

    constexpr bool
    _M_has_value() const noexcept { return _M_index != _S_valueless; }

    template<typename _CIt>
      constexpr void
      _M_assign(_CIt&& __x)
      {
 if (_M_index == __x._M_index)
   {
     if (_M_index == 0)
       _M_it = std::forward<_CIt>(__x)._M_it;
     else if (_M_index == 1)
       _M_sent = std::forward<_CIt>(__x)._M_sent;
   }
 else
   {
     if (_M_index == 0)
       _M_it.~_It();
     else if (_M_index == 1)
       _M_sent.~_Sent();
     _M_index = _S_valueless;

     if (__x._M_index == 0)
       std::construct_at(std::__addressof(_M_it),
    std::forward<_CIt>(__x)._M_it);
     else if (__x._M_index == 1)
       std::construct_at(std::__addressof(_M_sent),
    std::forward<_CIt>(__x)._M_sent);
     _M_index = __x._M_index;
   }
      }

    union
    {
      _It _M_it;
      _Sent _M_sent;
      unsigned char _M_valueless;
    };
    unsigned char _M_index;

    static constexpr unsigned char _S_valueless{2};
  };

  template<typename _It, typename _Sent>
    struct incrementable_traits<common_iterator<_It, _Sent>>
    {
      using difference_type = iter_difference_t<_It>;
    };

  template<input_iterator _It, typename _Sent>
    struct iterator_traits<common_iterator<_It, _Sent>>
    {
    private:
      template<typename _Iter>
 struct __ptr
 {
   using type = void;
 };

      template<typename _Iter>
 requires __detail::__common_iter_has_arrow<_Iter>
 struct __ptr<_Iter>
 {
   using _CIter = common_iterator<_Iter, _Sent>;
   using type = decltype(std::declval<const _CIter&>().operator->());
 };

      static auto
      _S_iter_cat()
      {
 if constexpr (requires { requires derived_from<__iter_category_t<_It>,
             forward_iterator_tag>; })
   return forward_iterator_tag{};
 else
   return input_iterator_tag{};
      }

    public:
      using iterator_concept = __conditional_t<forward_iterator<_It>,
            forward_iterator_tag,
            input_iterator_tag>;
      using iterator_category = decltype(_S_iter_cat());
      using value_type = iter_value_t<_It>;
      using difference_type = iter_difference_t<_It>;
      using pointer = typename __ptr<_It>::type;
      using reference = iter_reference_t<_It>;
    };



  namespace __detail
  {
    template<typename _It>
      struct __counted_iter_value_type
      { };

    template<indirectly_readable _It>
      struct __counted_iter_value_type<_It>
      { using value_type = iter_value_t<_It>; };

    template<typename _It>
      struct __counted_iter_concept
      { };

    template<typename _It>
      requires requires { typename _It::iterator_concept; }
      struct __counted_iter_concept<_It>
      { using iterator_concept = typename _It::iterator_concept; };

    template<typename _It>
      struct __counted_iter_cat
      { };

    template<typename _It>
      requires requires { typename _It::iterator_category; }
      struct __counted_iter_cat<_It>
      { using iterator_category = typename _It::iterator_category; };
  }


  template<input_or_output_iterator _It>
    class counted_iterator
      : public __detail::__counted_iter_value_type<_It>,
 public __detail::__counted_iter_concept<_It>,
 public __detail::__counted_iter_cat<_It>
    {
    public:
      using iterator_type = _It;

      using difference_type = iter_difference_t<_It>;



      constexpr counted_iterator() requires default_initializable<_It> = default;

      constexpr
      counted_iterator(_It __i, iter_difference_t<_It> __n)
      : _M_current(std::move(__i)), _M_length(__n)
      { do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n >= 0), false)) std::__glibcxx_assert_fail(); } while (false); }

      template<typename _It2>
 requires convertible_to<const _It2&, _It>
 constexpr
 counted_iterator(const counted_iterator<_It2>& __x)
 : _M_current(__x._M_current), _M_length(__x._M_length)
 { }

      template<typename _It2>
 requires assignable_from<_It&, const _It2&>
 constexpr counted_iterator&
 operator=(const counted_iterator<_It2>& __x)
 {
   _M_current = __x._M_current;
   _M_length = __x._M_length;
   return *this;
 }

      [[nodiscard]]
      constexpr const _It&
      base() const & noexcept
      { return _M_current; }

      [[nodiscard]]
      constexpr _It
      base() &&
      noexcept(is_nothrow_move_constructible_v<_It>)
      { return std::move(_M_current); }

      [[nodiscard]]
      constexpr iter_difference_t<_It>
      count() const noexcept { return _M_length; }

      [[nodiscard]]
      constexpr decltype(auto)
      operator*()
      noexcept(noexcept(*_M_current))
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return *_M_current;
      }

      [[nodiscard]]
      constexpr decltype(auto)
      operator*() const
      noexcept(noexcept(*_M_current))
      requires __detail::__dereferenceable<const _It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return *_M_current;
      }

      [[nodiscard]]
      constexpr auto
      operator->() const noexcept
      requires contiguous_iterator<_It>
      { return std::to_address(_M_current); }

      constexpr counted_iterator&
      operator++()
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 ++_M_current;
 --_M_length;
 return *this;
      }

      constexpr decltype(auto)
      operator++(int)
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 --_M_length;
 try
   {
     return _M_current++;
   } catch(...) {
     ++_M_length;
     throw;
   }
      }

      constexpr counted_iterator
      operator++(int) requires forward_iterator<_It>
      {
 auto __tmp = *this;
 ++*this;
 return __tmp;
      }

      constexpr counted_iterator&
      operator--() requires bidirectional_iterator<_It>
      {
 --_M_current;
 ++_M_length;
 return *this;
      }

      constexpr counted_iterator
      operator--(int) requires bidirectional_iterator<_It>
      {
 auto __tmp = *this;
 --*this;
 return __tmp;
      }

      [[nodiscard]]
      constexpr counted_iterator
      operator+(iter_difference_t<_It> __n) const
 requires random_access_iterator<_It>
      { return counted_iterator(_M_current + __n, _M_length - __n); }

      [[nodiscard]]
      friend constexpr counted_iterator
      operator+(iter_difference_t<_It> __n, const counted_iterator& __x)
      requires random_access_iterator<_It>
      { return __x + __n; }

      constexpr counted_iterator&
      operator+=(iter_difference_t<_It> __n)
      requires random_access_iterator<_It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n <= _M_length), false)) std::__glibcxx_assert_fail(); } while (false);
 _M_current += __n;
 _M_length -= __n;
 return *this;
      }

      [[nodiscard]]
      constexpr counted_iterator
      operator-(iter_difference_t<_It> __n) const
      requires random_access_iterator<_It>
      { return counted_iterator(_M_current - __n, _M_length + __n); }

      template<common_with<_It> _It2>
 [[nodiscard]]
 friend constexpr iter_difference_t<_It2>
 operator-(const counted_iterator& __x,
    const counted_iterator<_It2>& __y)
 { return __y._M_length - __x._M_length; }

      [[nodiscard]]
      friend constexpr iter_difference_t<_It>
      operator-(const counted_iterator& __x, default_sentinel_t)
      { return -__x._M_length; }

      [[nodiscard]]
      friend constexpr iter_difference_t<_It>
      operator-(default_sentinel_t, const counted_iterator& __y)
      { return __y._M_length; }

      constexpr counted_iterator&
      operator-=(iter_difference_t<_It> __n)
      requires random_access_iterator<_It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(-__n <= _M_length), false)) std::__glibcxx_assert_fail(); } while (false);
 _M_current -= __n;
 _M_length += __n;
 return *this;
      }

      [[nodiscard]]
      constexpr decltype(auto)
      operator[](iter_difference_t<_It> __n) const
      noexcept(noexcept(_M_current[__n]))
      requires random_access_iterator<_It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n < _M_length), false)) std::__glibcxx_assert_fail(); } while (false);
 return _M_current[__n];
      }

      template<common_with<_It> _It2>
 [[nodiscard]]
 friend constexpr bool
 operator==(const counted_iterator& __x,
     const counted_iterator<_It2>& __y)
 { return __x._M_length == __y._M_length; }

      [[nodiscard]]
      friend constexpr bool
      operator==(const counted_iterator& __x, default_sentinel_t)
      { return __x._M_length == 0; }

      template<common_with<_It> _It2>
 [[nodiscard]]
 friend constexpr strong_ordering
 operator<=>(const counted_iterator& __x,
      const counted_iterator<_It2>& __y)
 { return __y._M_length <=> __x._M_length; }

      [[nodiscard]]
      friend constexpr iter_rvalue_reference_t<_It>
      iter_move(const counted_iterator& __i)
      noexcept(noexcept(ranges::iter_move(__i._M_current)))
      requires input_iterator<_It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__i._M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return ranges::iter_move(__i._M_current);
      }

      template<indirectly_swappable<_It> _It2>
 friend constexpr void
 iter_swap(const counted_iterator& __x,
    const counted_iterator<_It2>& __y)
 noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
 {
   do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_length > 0 && __y._M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
   ranges::iter_swap(__x._M_current, __y._M_current);
 }

    private:
      template<input_or_output_iterator _It2> friend class counted_iterator;

      _It _M_current = _It();
      iter_difference_t<_It> _M_length = 0;
    };

  template<input_iterator _It>
    requires same_as<__detail::__iter_traits<_It>, iterator_traits<_It>>
    struct iterator_traits<counted_iterator<_It>> : iterator_traits<_It>
    {
      using pointer = __conditional_t<contiguous_iterator<_It>,
          add_pointer_t<iter_reference_t<_It>>,
          void>;
    };
# 2960 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    constexpr
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    constexpr
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }
# 2992 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _InputIterator>
    using __iter_key_t = remove_const_t<



      typename iterator_traits<_InputIterator>::value_type::first_type>;


  template<typename _InputIterator>
    using __iter_val_t



      = typename iterator_traits<_InputIterator>::value_type::second_type;


  template<typename _T1, typename _T2>
    struct pair;

  template<typename _InputIterator>
    using __iter_to_alloc_t
      = pair<const __iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>>;



}
# 49 "/usr/include/c++/14.2.1/string" 2 3
# 1 "/usr/include/c++/14.2.1/bits/stl_function.h" 1 3
# 63 "/usr/include/c++/14.2.1/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 116 "/usr/include/c++/14.2.1/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    } __attribute__ ((__deprecated__));





  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    } __attribute__ ((__deprecated__));
# 157 "/usr/include/c++/14.2.1/bits/stl_function.h" 3
  struct __is_transparent;

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {

      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
#pragma GCC diagnostic pop


  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct negate<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(-std::forward<_Tp>(__t)))
 -> decltype(-std::forward<_Tp>(__t))
 { return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 346 "/usr/include/c++/14.2.1/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };


  template<typename _Tp>
    struct greater<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {

 if (std::__is_constant_evaluated())
   return __x > __y;

 return (long unsigned int)__x > (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {

 if (std::__is_constant_evaluated())
   return __x < __y;

 return (long unsigned int)__x < (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {

 if (std::__is_constant_evaluated())
   return __x >= __y;

 return (long unsigned int)__x >= (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {

 if (std::__is_constant_evaluated())
   return __x <= __y;

 return (long unsigned int)__x <= (long unsigned int)__y;
      }
    };
#pragma GCC diagnostic pop



  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return greater<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return greater<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return less<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return less<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return greater_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return greater_equal<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator>=(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return less_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return less_equal<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator<=(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };
# 778 "/usr/include/c++/14.2.1/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
#pragma GCC diagnostic pop



  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(!std::forward<_Tp>(__t)))
 -> decltype(!std::forward<_Tp>(__t))
 { return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };




  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"



  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };
#pragma GCC diagnostic pop


  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(~std::forward<_Tp>(__t)))
 -> decltype(~std::forward<_Tp>(__t))
 { return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 1020 "/usr/include/c++/14.2.1/bits/stl_function.h" 3
  template<typename _Predicate>
    class [[__deprecated__]] unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    __attribute__ ((__deprecated__ ("use '" "std::not_fn" "' instead")))
    constexpr
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class [[__deprecated__]] binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    __attribute__ ((__deprecated__ ("use '" "std::not_fn" "' instead")))
    constexpr
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 1101 "/usr/include/c++/14.2.1/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    } __attribute__ ((__deprecated__));


  template<typename _Arg, typename _Result>
    __attribute__ ((__deprecated__ ("use '" "std::function" "' instead")))
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    } __attribute__ ((__deprecated__));


  template<typename _Arg1, typename _Arg2, typename _Result>
    __attribute__ ((__deprecated__ ("use '" "std::function" "' instead")))
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp, _Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };


  template<typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> { };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 1228 "/usr/include/c++/14.2.1/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    } __attribute__ ((__deprecated__));



  template<typename _Ret, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
#pragma GCC diagnostic pop




  template<typename _Func, typename _SfinaeType, typename = __void_t<>>
    struct __has_is_transparent
    { };

  template<typename _Func, typename _SfinaeType>
    struct __has_is_transparent<_Func, _SfinaeType,
    __void_t<typename _Func::is_transparent>>
    { typedef void type; };

  template<typename _Func, typename _SfinaeType>
    using __has_is_transparent_t
      = typename __has_is_transparent<_Func, _SfinaeType>::type;



}


# 1 "/usr/include/c++/14.2.1/backward/binders.h" 1 3
# 60 "/usr/include/c++/14.2.1/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std __attribute__ ((__visibility__ ("default")))
{

# 107 "/usr/include/c++/14.2.1/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__ ("use '" "std::bind" "' instead")));


  template<typename _Operation, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::bind" "' instead")))
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__ ("use '" "std::bind" "' instead")));


  template<typename _Operation, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::bind" "' instead")))
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1436 "/usr/include/c++/14.2.1/bits/stl_function.h" 2 3
# 50 "/usr/include/c++/14.2.1/string" 2 3
# 1 "/usr/include/c++/14.2.1/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/14.2.1/ext/numeric_traits.h" 3
       
# 33 "/usr/include/c++/14.2.1/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 50 "/usr/include/c++/14.2.1/ext/numeric_traits.h" 3
  template<typename _Tp>
    struct __is_integer_nonstrict
    : public std::__is_integer<_Tp>
    {
      using std::__is_integer<_Tp>::__value;


      enum { __width = __value ? sizeof(_Tp) * 8 : 0 };
    };

  template<typename _Value>
    struct __numeric_traits_integer
    {

      static_assert(__is_integer_nonstrict<_Value>::__value,
      "invalid specialization");




      static const bool __is_signed = (_Value)(-1) < 0;
      static const int __digits
 = __is_integer_nonstrict<_Value>::__width - __is_signed;


      static const _Value __max = __is_signed
 ? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)
 : ~(_Value)0;
      static const _Value __min = __is_signed ? -__max - 1 : (_Value)0;
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 137 "/usr/include/c++/14.2.1/ext/numeric_traits.h" 3
  template<typename _Tp>
    using __int_traits = __numeric_traits_integer<_Tp>;
# 157 "/usr/include/c++/14.2.1/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;






  template<typename _Value>
    struct __numeric_traits
    : public __numeric_traits_integer<_Value>
    { };

  template<>
    struct __numeric_traits<float>
    : public __numeric_traits_floating<float>
    { };

  template<>
    struct __numeric_traits<double>
    : public __numeric_traits_floating<double>
    { };

  template<>
    struct __numeric_traits<long double>
    : public __numeric_traits_floating<long double>
    { };
# 238 "/usr/include/c++/14.2.1/ext/numeric_traits.h" 3

}
# 51 "/usr/include/c++/14.2.1/string" 2 3
# 1 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 1 3
# 64 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/14.2.1/bits/stl_pair.h" 1 3
# 62 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
# 1 "/usr/include/c++/14.2.1/bits/utility.h" 1 3
# 36 "/usr/include/c++/14.2.1/bits/utility.h" 3
       
# 37 "/usr/include/c++/14.2.1/bits/utility.h" 3






namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };


  template<typename _Tp>
    inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;



  template<size_t __i, typename _Tp>
    struct tuple_element;


  template<size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      using type = const __tuple_element_t<__i, _Tp>;
    };

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      using type = volatile __tuple_element_t<__i, _Tp>;
    };

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      using type = const volatile __tuple_element_t<__i, _Tp>;
    };





  template<typename _Tp, typename... _Types>
    constexpr size_t
    __find_uniq_type_in_pack()
    {
      constexpr size_t __sz = sizeof...(_Types);
      constexpr bool __found[__sz] = { __is_same(_Tp, _Types) ... };
      size_t __n = __sz;
      for (size_t __i = 0; __i < __sz; ++__i)
 {
   if (__found[__i])
     {
       if (__n < __sz)
  return __sz;
       __n = __i;
     }
 }
      return __n;
    }
# 134 "/usr/include/c++/14.2.1/bits/utility.h" 3
  template<size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;




  template<size_t... _Indexes> struct _Index_tuple { };


  template<size_t _Num>
    struct _Build_index_tuple
    {
# 154 "/usr/include/c++/14.2.1/bits/utility.h" 3
      using __type = _Index_tuple<__integer_pack(_Num)...>;

    };




  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {

      static_assert(is_integral_v<_Tp>);

      typedef _Tp value_type;
      static constexpr size_t size() noexcept { return sizeof...(_Idx); }
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence



      = integer_sequence<_Tp, __integer_pack(_Num)...>;



  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;




  struct in_place_t {
    explicit in_place_t() = default;
  };

  inline constexpr in_place_t in_place{};

  template<typename _Tp> struct in_place_type_t
  {
    explicit in_place_type_t() = default;
  };

  template<typename _Tp>
    inline constexpr in_place_type_t<_Tp> in_place_type{};

  template<size_t _Idx> struct in_place_index_t
  {
    explicit in_place_index_t() = default;
  };

  template<size_t _Idx>
    inline constexpr in_place_index_t<_Idx> in_place_index{};

  template<typename>
    inline constexpr bool __is_in_place_type_v = false;

  template<typename _Tp>
    inline constexpr bool __is_in_place_type_v<in_place_type_t<_Tp>> = true;

  template<typename _Tp>
    using __is_in_place_type = bool_constant<__is_in_place_type_v<_Tp>>;

  template<typename>
    inline constexpr bool __is_in_place_index_v = false;

  template<size_t _Nm>
    inline constexpr bool __is_in_place_index_v<in_place_index_t<_Nm>> = true;




  template<size_t _Np, typename... _Types>
    struct _Nth_type
    { using type = __type_pack_element<_Np, _Types...>; };
# 276 "/usr/include/c++/14.2.1/bits/utility.h" 3
  namespace ranges::__detail
  {
    template<typename _Range>
      inline constexpr bool __is_subrange = false;
  }



}
# 63 "/usr/include/c++/14.2.1/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 79 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  inline constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();




  template<typename _T1, typename _T2>
    struct pair;

  template<typename...>
    class tuple;





  template<typename _Tp, size_t _Nm>
    struct array;

  template<size_t...>
    struct _Index_tuple;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(pair<_Tp1, _Tp2>& __in) noexcept;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(pair<_Tp1, _Tp2>&& __in) noexcept;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(const pair<_Tp1, _Tp2>& __in) noexcept;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(const pair<_Tp1, _Tp2>&& __in) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
    get(const tuple<_Elements...>&& __t) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>&) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&&) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>&) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr const _Tp&&
    get(const array<_Tp, _Nm>&&) noexcept;
# 260 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  template<typename _U1, typename _U2> class __pair_base
  {







  };
# 283 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    : public __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;


      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;

      template<typename... _Args1, typename... _Args2>
 constexpr
 pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);


      constexpr void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
        __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }
# 331 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
    private:
      template<typename... _Args1, size_t... _Indexes1,
        typename... _Args2, size_t... _Indexes2>
 constexpr
 pair(tuple<_Args1...>&, tuple<_Args2...>&,
      _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
    public:





      constexpr
      explicit(__not_<__and_<__is_implicitly_default_constructible<_T1>,
        __is_implicitly_default_constructible<_T2>>>())
      pair()
      requires is_default_constructible_v<_T1>
        && is_default_constructible_v<_T2>
      : first(), second()
      { }

    private:


      template<typename _U1, typename _U2>
 static constexpr bool
 _S_constructible()
 {
   if constexpr (is_constructible_v<_T1, _U1>)
     return is_constructible_v<_T2, _U2>;
   return false;
 }

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_nothrow_constructible()
 {
   if constexpr (is_nothrow_constructible_v<_T1, _U1>)
     return is_nothrow_constructible_v<_T2, _U2>;
   return false;
 }

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_convertible()
 {
   if constexpr (is_convertible_v<_U1, _T1>)
     return is_convertible_v<_U2, _T2>;
   return false;
 }


      template<typename _U1, typename _U2>
 static constexpr bool
 _S_dangles()
 {

   if constexpr (__reference_constructs_from_temporary(_T1, _U1&&))
     return true;
   else
     return __reference_constructs_from_temporary(_T2, _U2&&);



 }
# 424 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
    public:


      constexpr explicit(!_S_convertible<const _T1&, const _T2&>())
      pair(const _T1& __x, const _T2& __y)
      noexcept(_S_nothrow_constructible<const _T1&, const _T2&>())
      requires (_S_constructible<const _T1&, const _T2&>())
      : first(__x), second(__y)
      { }





      template<typename _U1, typename _U2>

 requires (_S_constructible<_U1, _U2>()) && (!_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<_U1, _U2>())
 pair(_U1&& __x, _U2&& __y)
 noexcept(_S_nothrow_constructible<_U1, _U2>())
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))
 { }




      template<typename _U1, typename _U2>

 requires (_S_constructible<_U1, _U2>()) && (_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<_U1, _U2>())
 pair(_U1&&, _U2&&) = delete;


      template<typename _U1, typename _U2>
 requires (_S_constructible<const _U1&, const _U2&>())
   && (!_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<const _U1&, const _U2&>())
 pair(const pair<_U1, _U2>& __p)
 noexcept(_S_nothrow_constructible<const _U1&, const _U2&>())
 : first(__p.first), second(__p.second)
 { }

      template<typename _U1, typename _U2>
 requires (_S_constructible<const _U1&, const _U2&>())
       && (_S_dangles<const _U1&, const _U2&>())
 constexpr explicit(!_S_convertible<const _U1&, const _U2&>())
 pair(const pair<_U1, _U2>&) = delete;


      template<typename _U1, typename _U2>
 requires (_S_constructible<_U1, _U2>()) && (!_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<_U1, _U2>())
 pair(pair<_U1, _U2>&& __p)
 noexcept(_S_nothrow_constructible<_U1, _U2>())
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second))
 { }

      template<typename _U1, typename _U2>
 requires (_S_constructible<_U1, _U2>()) && (_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<_U1, _U2>())
 pair(pair<_U1, _U2>&&) = delete;
# 537 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  private:

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_assignable()
 {
   if constexpr (is_assignable_v<_T1&, _U1>)
     return is_assignable_v<_T2&, _U2>;
   return false;
 }

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_const_assignable()
 {
   if constexpr (is_assignable_v<const _T1&, _U1>)
     return is_assignable_v<const _T2&, _U2>;
   return false;
 }

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_nothrow_assignable()
 {
   if constexpr (is_nothrow_assignable_v<_T1&, _U1>)
     return is_nothrow_assignable_v<_T2&, _U2>;
   return false;
 }
# 585 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  public:

      pair& operator=(const pair&) = delete;


      constexpr pair&
      operator=(const pair& __p)
      noexcept(_S_nothrow_assignable<const _T1&, const _T2&>())
      requires (_S_assignable<const _T1&, const _T2&>())
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }


      constexpr pair&
      operator=(pair&& __p)
      noexcept(_S_nothrow_assignable<_T1, _T2>())
      requires (_S_assignable<_T1, _T2>())
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }


      template<typename _U1, typename _U2>
 constexpr pair&
 operator=(const pair<_U1, _U2>& __p)
 noexcept(_S_nothrow_assignable<const _U1&, const _U2&>())
 requires (_S_assignable<const _U1&, const _U2&>())
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }


      template<typename _U1, typename _U2>
 constexpr pair&
 operator=(pair<_U1, _U2>&& __p)
 noexcept(_S_nothrow_assignable<_U1, _U2>())
 requires (_S_assignable<_U1, _U2>())
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }
# 995 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
    };




  template<typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;







  template<typename _T1, typename _T2, typename _U1, typename _U2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }
# 1020 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2, typename _U1, typename _U2>
    constexpr common_comparison_category_t<__detail::__synth3way_t<_T1, _U1>,
        __detail::__synth3way_t<_T2, _U2>>
    operator<=>(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y)
    {
      if (auto __c = __detail::__synth3way(__x.first, __y.first); __c != 0)
 return __c;
      return __detail::__synth3way(__x.second, __y.second);
    }
# 1080 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr inline


    typename enable_if<__and_<__is_swappable<_T1>,
                              __is_swappable<_T2>>::value>::type



    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 1103 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    typename enable_if<!__and_<__is_swappable<_T1>,
          __is_swappable<_T2>>::value>::type
    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
# 1129 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 1152 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type
    { };



  template<class _Tp1, class _Tp2>
    struct tuple_size<pair<_Tp1, _Tp2>>
    : public integral_constant<size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };



  template<size_t __i, typename... _Types>
    struct tuple_element<__i, tuple<_Types...>>;


  template<typename _Tp1, typename _Tp2>
    inline constexpr size_t tuple_size_v<pair<_Tp1, _Tp2>> = 2;

  template<typename _Tp1, typename _Tp2>
    inline constexpr size_t tuple_size_v<const pair<_Tp1, _Tp2>> = 2;

  template<typename _Tp>
    inline constexpr bool __is_pair = false;

  template<typename _Tp, typename _Up>
    inline constexpr bool __is_pair<pair<_Tp, _Up>> = true;



  template<size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp1&
 __get(pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp1&&
 __move_get(pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp1&
 __const_get(const pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp1&&
 __const_move_get(const pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<const _Tp1>(__pair.first); }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp2&
 __get(pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp2&&
 __move_get(pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp2&
 __const_get(const pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp2&&
 __const_move_get(const pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<const _Tp2>(__pair.second); }
    };






  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(const pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(const pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }



  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }
# 1332 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3

}
# 65 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 2 3




# 1 "/usr/include/c++/14.2.1/debug/debug.h" 1 3
# 48 "/usr/include/c++/14.2.1/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;

  template<typename _Ite, typename _Seq, typename _Cat>
    struct _Safe_iterator;
}
# 70 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/14.2.1/bits/predefined_ops.h" 1 3
# 35 "/usr/include/c++/14.2.1/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




    constexpr
    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
      constexpr
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

  constexpr
  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  constexpr
  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




    constexpr
    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
      constexpr
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

  constexpr
  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  constexpr
  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

  constexpr
  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      constexpr
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

  constexpr
  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  constexpr
  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      constexpr
      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      constexpr
      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      constexpr
      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>
 constexpr
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    constexpr
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      constexpr
      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      constexpr
      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      constexpr
      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>
 constexpr
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    constexpr
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    constexpr
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      constexpr
      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    constexpr
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

      constexpr
      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>
 constexpr
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
    constexpr
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      constexpr
      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    constexpr
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      constexpr
      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    constexpr
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

      constexpr
      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>
 constexpr
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
    constexpr
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      constexpr
      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    constexpr
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 2 3




# 1 "/usr/include/c++/14.2.1/bit" 1 3
# 32 "/usr/include/c++/14.2.1/bit" 3
       
# 33 "/usr/include/c++/14.2.1/bit" 3
# 61 "/usr/include/c++/14.2.1/bit" 3
# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 62 "/usr/include/c++/14.2.1/bit" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 85 "/usr/include/c++/14.2.1/bit" 3
  template<typename _To, typename _From>
    [[nodiscard]]
    constexpr _To
    bit_cast(const _From& __from) noexcept

    requires (sizeof(_To) == sizeof(_From))
      && is_trivially_copyable_v<_To> && is_trivially_copyable_v<_From>

    {
      return __builtin_bit_cast(_To, __from);
    }
# 155 "/usr/include/c++/14.2.1/bit" 3
  template<typename _Tp>
    constexpr _Tp
    __rotl(_Tp __x, int __s) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if constexpr ((_Nd & (_Nd - 1)) == 0)
 {


   constexpr unsigned __uNd = _Nd;
   const unsigned __r = __s;
   return (__x << (__r % __uNd)) | (__x >> ((-__r) % __uNd));
 }
      const int __r = __s % _Nd;
      if (__r == 0)
 return __x;
      else if (__r > 0)
 return (__x << __r) | (__x >> ((_Nd - __r) % _Nd));
      else
 return (__x >> -__r) | (__x << ((_Nd + __r) % _Nd));
    }

  template<typename _Tp>
    constexpr _Tp
    __rotr(_Tp __x, int __s) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if constexpr ((_Nd & (_Nd - 1)) == 0)
 {


   constexpr unsigned __uNd = _Nd;
   const unsigned __r = __s;
   return (__x >> (__r % __uNd)) | (__x << ((-__r) % __uNd));
 }
      const int __r = __s % _Nd;
      if (__r == 0)
 return __x;
      else if (__r > 0)
 return (__x >> __r) | (__x << ((_Nd - __r) % _Nd));
      else
 return (__x << -__r) | (__x >> ((_Nd + __r) % _Nd));
    }

  template<typename _Tp>
    constexpr int
    __countl_zero(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      if (__x == 0)
        return _Nd;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 {
   constexpr int __diff = _Nd_u - _Nd;
   return __builtin_clz(__x) - __diff;
 }
      else if constexpr (_Nd <= _Nd_ul)
 {
   constexpr int __diff = _Nd_ul - _Nd;
   return __builtin_clzl(__x) - __diff;
 }
      else if constexpr (_Nd <= _Nd_ull)
 {
   constexpr int __diff = _Nd_ull - _Nd;
   return __builtin_clzll(__x) - __diff;
 }
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   unsigned long long __high = __x >> _Nd_ull;
   if (__high != 0)
     {
       constexpr int __diff = (2 * _Nd_ull) - _Nd;
       return __builtin_clzll(__high) - __diff;
     }
   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   return (_Nd - _Nd_ull) + __builtin_clzll(__low);
 }
    }

  template<typename _Tp>
    constexpr int
    __countl_one(_Tp __x) noexcept
    {
      return std::__countl_zero<_Tp>((_Tp)~__x);
    }

  template<typename _Tp>
    constexpr int
    __countr_zero(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      if (__x == 0)
        return _Nd;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 return __builtin_ctz(__x);
      else if constexpr (_Nd <= _Nd_ul)
 return __builtin_ctzl(__x);
      else if constexpr (_Nd <= _Nd_ull)
 return __builtin_ctzll(__x);
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   if (__low != 0)
     return __builtin_ctzll(__low);
   unsigned long long __high = __x >> _Nd_ull;
   return __builtin_ctzll(__high) + _Nd_ull;
 }
    }

  template<typename _Tp>
    constexpr int
    __countr_one(_Tp __x) noexcept
    {
      return std::__countr_zero((_Tp)~__x);
    }

  template<typename _Tp>
    constexpr int
    __popcount(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 return __builtin_popcount(__x);
      else if constexpr (_Nd <= _Nd_ul)
 return __builtin_popcountl(__x);
      else if constexpr (_Nd <= _Nd_ull)
 return __builtin_popcountll(__x);
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   unsigned long long __high = __x >> _Nd_ull;
   return __builtin_popcountll(__low) + __builtin_popcountll(__high);
 }
    }

  template<typename _Tp>
    constexpr bool
    __has_single_bit(_Tp __x) noexcept
    { return std::__popcount(__x) == 1; }

  template<typename _Tp>
    constexpr _Tp
    __bit_ceil(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;
      if (__x == 0 || __x == 1)
        return 1;
      auto __shift_exponent = _Nd - std::__countl_zero((_Tp)(__x - 1u));




      if (!std::__is_constant_evaluated())
 {
   do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__shift_exponent != __int_traits<_Tp>::__digits), false)) std::__glibcxx_assert_fail(); } while (false);
 }

      using __promoted_type = decltype(__x << 1);
      if constexpr (!is_same<__promoted_type, _Tp>::value)
 {





   const int __extra_exp = sizeof(__promoted_type) / sizeof(_Tp) / 2;
   __shift_exponent |= (__shift_exponent & _Nd) << __extra_exp;
 }
      return (_Tp)1u << __shift_exponent;
    }

  template<typename _Tp>
    constexpr _Tp
    __bit_floor(_Tp __x) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if (__x == 0)
        return 0;
      return (_Tp)1u << (_Nd - std::__countl_zero((_Tp)(__x >> 1)));
    }

  template<typename _Tp>
    constexpr int
    __bit_width(_Tp __x) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      return _Nd - std::__countl_zero(__x);
    }






  template<typename _Tp>
    concept __unsigned_integer = __is_unsigned_integer<_Tp>::value;





  template<__unsigned_integer _Tp>
    [[nodiscard]] constexpr _Tp
    rotl(_Tp __x, int __s) noexcept
    { return std::__rotl(__x, __s); }


  template<__unsigned_integer _Tp>
    [[nodiscard]] constexpr _Tp
    rotr(_Tp __x, int __s) noexcept
    { return std::__rotr(__x, __s); }




  template<__unsigned_integer _Tp>
    constexpr int
    countl_zero(_Tp __x) noexcept
    { return std::__countl_zero(__x); }


  template<__unsigned_integer _Tp>
    constexpr int
    countl_one(_Tp __x) noexcept
    { return std::__countl_one(__x); }


  template<__unsigned_integer _Tp>
    constexpr int
    countr_zero(_Tp __x) noexcept
    { return std::__countr_zero(__x); }


  template<__unsigned_integer _Tp>
    constexpr int
    countr_one(_Tp __x) noexcept
    { return std::__countr_one(__x); }


  template<__unsigned_integer _Tp>
    constexpr int
    popcount(_Tp __x) noexcept
    { return std::__popcount(__x); }






  template<__unsigned_integer _Tp>
    constexpr bool
    has_single_bit(_Tp __x) noexcept
    { return std::__has_single_bit(__x); }


  template<__unsigned_integer _Tp>
    constexpr _Tp
    bit_ceil(_Tp __x) noexcept
    { return std::__bit_ceil(__x); }


  template<__unsigned_integer _Tp>
    constexpr _Tp
    bit_floor(_Tp __x) noexcept
    { return std::__bit_floor(__x); }




  template<__unsigned_integer _Tp>
    constexpr int
    bit_width(_Tp __x) noexcept
    { return std::__bit_width(__x); }
# 472 "/usr/include/c++/14.2.1/bit" 3
  enum class endian
  {
    little = 1234,
    big = 4321,
    native = 1234
  };





}
# 77 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{






  template<typename _Tp, typename _Up>
    constexpr
    inline int
    __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
    {

      static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");


      if (std::is_constant_evaluated())
 {
   for(; __num > 0; ++__first1, ++__first2, --__num)
     if (*__first1 != *__first2)
       return *__first1 < *__first2 ? -1 : 1;
   return 0;
 }
      else

 return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
    }
# 152 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 185 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 201 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 230 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 254 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 278 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 300 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    constexpr
    inline _Iterator
    __niter_base(_Iterator __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it; }
# 332 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _Ite, typename _Seq>
    constexpr
    decltype(std::__niter_base(std::declval<_Ite>()))
    __niter_base(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq,
   std::random_access_iterator_tag>&)
    noexcept(std::is_nothrow_copy_constructible<_Ite>::value);





  template<typename _From, typename _To>
    constexpr
    inline _From
    __niter_wrap(_From __from, _To __res)
    { return __from + (std::__niter_base(__res) - std::__niter_base(__from)); }


  template<typename _Iterator>
    constexpr
    inline _Iterator
    __niter_wrap(const _Iterator&, _Iterator __res)
    { return __res; }







  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }

      template<typename _Tp, typename _Up>
 static void
 __assign_one(_Tp* __to, _Up* __from)
 { *__to = *__from; }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }

      template<typename _Tp, typename _Up>
 static void
 __assign_one(_Tp* __to, _Up* __from)
 { *__to = std::move(*__from); }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp, typename _Up>
 constexpr
 static _Up*
 __copy_m(_Tp* __first, _Tp* __last, _Up* __result)
 {
   const ptrdiff_t _Num = __last - __first;
   if (__builtin_expect(_Num > 1, true))
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   else if (_Num == 1)
     std::__copy_move<_IsMove, false, random_access_iterator_tag>::
       __assign_one(__result, __first);
   return __result + _Num;
 }
    };



  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator;

  struct _Bit_iterator;






  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
    __copy_move_a2(
 istreambuf_iterator<_CharT, char_traits<_CharT> >,
 istreambuf_iterator<_CharT, char_traits<_CharT> >,
 std::_Deque_iterator<_CharT, _CharT&, _CharT*>);


  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::iterator_category _Category;

      if (std::is_constant_evaluated())
 return std::__copy_move<_IsMove, false, _Category>::
   __copy_m(__first, __last, __result);

      return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
         _Category>::__copy_m(__first, __last, __result);
    }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_a1(_II __first, _II __last, _OI __result)
    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    constexpr
    _OI
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    constexpr
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_a(_II, _II,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    constexpr
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    constexpr
    _OutputIterator
    __copy_n_a(_InputIterator __first, _Size __n, _OutputIterator __result,
        bool)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }


  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value, _CharT*>::__type
    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >,
        _Size, _CharT*, bool);

  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >, _Size,
        std::_Deque_iterator<_CharT, _CharT&, _CharT*>,
        bool);
# 639 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    constexpr
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<__is_move_iterator<_II>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 672 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    constexpr
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<true>(std::__miter_base(__first),
          std::__miter_base(__last), __result);
    }






  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp, typename _Up>
 constexpr
 static _Up*
 __copy_move_b(_Tp* __first, _Tp* __last, _Up* __result)
 {
   const ptrdiff_t _Num = __last - __first;
   if (__builtin_expect(_Num > 1, true))
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   else if (_Num == 1)
     std::__copy_move<_IsMove, false, random_access_iterator_tag>::
       __assign_one(__result - 1, __first);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::iterator_category _Category;

      if (std::is_constant_evaluated())
 return std::__copy_move_backward<_IsMove, false, _Category>::
   __copy_move_b(__first, __last, __result);

      return std::__copy_move_backward<_IsMove,
           __memcpyable<_BI2, _BI1>::__value,
           _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)
    { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_backward_a1(
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_backward_a1(_II, _II,
       std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_backward_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_backward_a1<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    constexpr
    _OI
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    constexpr
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_backward_a(_II, _II,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    constexpr
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
# 875 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     

      ;

      return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 910 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     

      ;

      return std::__copy_move_backward_a<true>(std::__miter_base(__first),
            std::__miter_base(__last),
            __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;

      if (std::is_constant_evaluated())
 {
   for (; __first != __last; ++__first)
     *__first = __tmp;
   return;
 }

      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }

  template<typename _Ite, typename _Cont, typename _Tp>
    constexpr
    inline void
    __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
       ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
       const _Tp& __value)
    { std::__fill_a1(__first.base(), __last.base(), __value); }

  template<typename _Tp, typename _VTp>
    void
    __fill_a1(const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const _VTp&);

  constexpr
  void
  __fill_a1(std::_Bit_iterator, std::_Bit_iterator,
     const bool&);

  template<typename _FIte, typename _Tp>
    constexpr
    inline void
    __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
    { std::__fill_a1(__first, __last, __value); }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
    constexpr
    void
    __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const _Tp&);
# 1019 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(__first, __last, __value);
    }


  inline constexpr int
  __size_to_integer(int __n) { return __n; }
  inline constexpr unsigned
  __size_to_integer(unsigned __n) { return __n; }
  inline constexpr long
  __size_to_integer(long __n) { return __n; }
  inline constexpr unsigned long
  __size_to_integer(unsigned long __n) { return __n; }
  inline constexpr long long
  __size_to_integer(long long __n) { return __n; }
  inline constexpr unsigned long long
  __size_to_integer(unsigned long long __n) { return __n; }


  __extension__ inline constexpr __int128
  __size_to_integer(__int128 __n) { return __n; }
  __extension__ inline constexpr unsigned __int128
  __size_to_integer(unsigned __int128 __n) { return __n; }
# 1071 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  inline constexpr long long
  __size_to_integer(float __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(double __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(long double __n) { return (long long)__n; }

  __extension__ inline constexpr long long
  __size_to_integer(__float128 __n) { return (long long)__n; }


  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Size,
    typename _Tp>
    constexpr
    ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,
        _Size __n, const _Tp& __value,
        std::input_iterator_tag);

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::output_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::input_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::random_access_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      if (__n <= 0)
 return __first;

      ;

      std::__fill_a(__first, __first + __n, __value);
      return __first + __n;
    }
# 1172 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    constexpr
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
          std::__iterator_category(__first));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
 constexpr
 static bool
 equal(_II1 __first1, _II1 __last1, _II2 __first2)
 {
   for (; __first1 != __last1; ++__first1, (void) ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
 constexpr
 static bool
 equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
 {
   if (const size_t __len = (__last1 - __first1))
     return !std::__memcmp(__first1, __first2, __len);
   return true;
 }
    };

  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   _II);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(_II, _II,
  std::_Deque_iterator<_Tp, _Ref, _Ptr>);

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
        && __memcmpable<_II1, _II2>::__value);
      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      return std::__equal_aux1(std::__niter_base(__first1),
          std::__niter_base(__last1),
          std::__niter_base(__first2));
    }

  template<typename _II1, typename _Seq1, typename _Cat1, typename _II2>
    constexpr
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  _II2);

  template<typename _II1, typename _II2, typename _Seq2, typename _Cat2>
    constexpr
    bool
    __equal_aux(_II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename _II1, typename _Seq1, typename _Cat1,
    typename _II2, typename _Seq2, typename _Cat2>
    constexpr
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
 constexpr
 static _II1
 __newlast1(_II1, _II1 __last1, _II2, _II2)
 { return __last1; }

      template<typename _II>
 constexpr
 static bool
 __cnd2(_II __first, _II __last)
 { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
 constexpr
 static _RAI1
 __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
 {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
 static constexpr bool
 __cnd2(_RAI, _RAI)
 { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    constexpr
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
 constexpr
 static bool
 __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   using __gnu_cxx::__ops::__iter_less_iter;
   return std::__lexicographical_compare_impl(__first1, __last1,
           __first2, __last2,
           __iter_less_iter());
 }

      template<typename _II1, typename _II2>
 constexpr
 static int
 __3way(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   while (__first1 != __last1)
     {
       if (__first2 == __last2)
  return +1;
       if (*__first1 < *__first2)
  return -1;
       if (*__first2 < *__first1)
  return +1;
       ++__first1;
       ++__first2;
     }
   return int(__first2 == __last2) - 1;
 }
    };

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
 constexpr
 static bool
 __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 { return __3way(__first1, __last1, __first2, __last2) < 0; }

      template<typename _Tp, typename _Up>
 constexpr
 static ptrdiff_t
 __3way(const _Tp* __first1, const _Tp* __last1,
        const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = std::__memcmp(__first1, __first2, __len))
       return __result;
   return ptrdiff_t(__len1 - __len2);
 }
    };

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __lexicographical_compare_aux1(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value




  && !is_volatile_v<remove_reference_t<iter_reference_t<_II1>>>
  && !is_volatile_v<remove_reference_t<iter_reference_t<_II2>>>

  );

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2>
    bool
    __lexicographical_compare_aux1(
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 _Tp2*, _Tp2*);

  template<typename _Tp1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __lexicographical_compare_aux1(_Tp1*, _Tp1*,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __lexicographical_compare_aux1(
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      return std::__lexicographical_compare_aux1(std::__niter_base(__first1),
       std::__niter_base(__last1),
       std::__niter_base(__first2),
       std::__niter_base(__last2));
    }

  template<typename _Iter1, typename _Seq1, typename _Cat1,
    typename _II2>
    constexpr
    bool
    __lexicographical_compare_aux(
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  _II2, _II2);

  template<typename _II1,
    typename _Iter2, typename _Seq2, typename _Cat2>
    constexpr
    bool
    __lexicographical_compare_aux(
  _II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);

  template<typename _Iter1, typename _Seq1, typename _Cat1,
    typename _Iter2, typename _Seq2, typename _Cat2>
    constexpr
    bool
    __lexicographical_compare_aux(
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    constexpr
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 1524 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    [[__nodiscard__]] constexpr
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  template<typename _Tp>
    inline constexpr _Tp
    __lg(_Tp __n)
    {

      return std::__bit_width(make_unsigned_t<_Tp>(__n)) - 1;
# 1557 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
    }


# 1573 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    [[__nodiscard__]] constexpr
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(__first1, __last1, __first2);
    }
# 1604 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    [[__nodiscard__]] constexpr
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }



  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }


  template<typename _II1, typename _II2, typename _BinaryPredicate>
    constexpr
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
      _BinaryPredicate __binary_pred)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1691 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    [[__nodiscard__]] constexpr
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2);
    }
# 1724 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    [[__nodiscard__]] constexpr
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2,
          __binary_pred);
    }
# 1756 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    [[__nodiscard__]] constexpr
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(__first1, __last1,
      __first2, __last2);
    }
# 1791 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    [[__nodiscard__]] constexpr
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }





  template<typename _Iter1, typename _Iter2>
    concept __memcmp_ordered_with
      = (__is_memcmp_ordered_with<iter_value_t<_Iter1>,
      iter_value_t<_Iter2>>::__value)
   && contiguous_iterator<_Iter1> && contiguous_iterator<_Iter2>;



  template<typename _Tp>
    constexpr auto
    __min_cmp(_Tp __x, _Tp __y)
    {
      struct _Res {
 _Tp _M_min;
 decltype(__x <=> __y) _M_cmp;
      };
      auto __c = __x <=> __y;
      if (__c > 0)
 return _Res{__y, __c};
      return _Res{__x, __c};
    }
# 1845 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _Comp>
    [[nodiscard]] constexpr auto
    lexicographical_compare_three_way(_InputIter1 __first1,
          _InputIter1 __last1,
          _InputIter2 __first2,
          _InputIter2 __last2,
          _Comp __comp)
    -> decltype(__comp(*__first1, *__first2))
    {

     
     
      ;
      ;

      using _Cat = decltype(__comp(*__first1, *__first2));
      static_assert(same_as<common_comparison_category_t<_Cat>, _Cat>);

      if (!std::__is_constant_evaluated())
 if constexpr (same_as<_Comp, __detail::_Synth3way>
        || same_as<_Comp, compare_three_way>)
   if constexpr (__memcmp_ordered_with<_InputIter1, _InputIter2>)
     {
       const auto [__len, __lencmp] = std::
  __min_cmp(__last1 - __first1, __last2 - __first2);
       if (__len)
  {
    const auto __blen = __len * sizeof(*__first1);
    const auto __c
      = __builtin_memcmp(&*__first1, &*__first2, __blen) <=> 0;
    if (__c != 0)
      return __c;
  }
       return __lencmp;
     }

      while (__first1 != __last1)
 {
   if (__first2 == __last2)
     return strong_ordering::greater;
   if (auto __cmp = __comp(*__first1, *__first2); __cmp != 0)
     return __cmp;
   ++__first1;
   ++__first2;
 }
      return (__first2 == __last2) <=> true;
    }

  template<typename _InputIter1, typename _InputIter2>
    constexpr auto
    lexicographical_compare_three_way(_InputIter1 __first1,
          _InputIter1 __last1,
          _InputIter2 __first2,
          _InputIter2 __last2)
    {
      return std::
 lexicographical_compare_three_way(__first1, __last1, __first2, __last2,
       compare_three_way{});
    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    constexpr
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1934 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    [[__nodiscard__]] constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1968 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    [[__nodiscard__]] constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    constexpr
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 2016 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    [[__nodiscard__]] constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 2052 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    [[__nodiscard__]] constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }





  template<typename _InputIterator, typename _Predicate>
    constexpr
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    constexpr
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;

 case 2:
   if (__pred(__first))
     return __first;
   ++__first;

 case 1:
   if (__pred(__first))
     return __first;
   ++__first;

 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
    constexpr
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Predicate>
    constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }

  template<typename _ForwardIterator, typename _Predicate>
    constexpr
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   _ForwardIterator2 __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 2276 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }



# 2318 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }



}
# 52 "/usr/include/c++/14.2.1/string" 2 3
# 1 "/usr/include/c++/14.2.1/bits/refwrap.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/refwrap.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/refwrap.h" 3




# 1 "/usr/include/c++/14.2.1/bits/invoke.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/invoke.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/invoke.h" 3
# 42 "/usr/include/c++/14.2.1/bits/invoke.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 53 "/usr/include/c++/14.2.1/bits/invoke.h" 3
  template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
    constexpr _Up&&
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    constexpr typename __invoke_result<_Callable, _Args...>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }



  template<typename _Res, typename _Callable, typename... _Args>
    constexpr enable_if_t<is_invocable_r_v<_Res, _Callable, _Args...>, _Res>
    __invoke_r(_Callable&& __fn, _Args&&... __args)
    noexcept(is_nothrow_invocable_r_v<_Res, _Callable, _Args...>)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      if constexpr (is_void_v<_Res>)
 std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
      else
 return std::__invoke_impl<__type>(__tag{},
       std::forward<_Callable>(__fn),
       std::forward<_Args>(__args)...);
    }
# 155 "/usr/include/c++/14.2.1/bits/invoke.h" 3

}
# 39 "/usr/include/c++/14.2.1/bits/refwrap.h" 2 3






namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/include/c++/14.2.1/bits/refwrap.h" 3
  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };

#pragma GCC diagnostic pop

  template<typename _Signature>
    struct _Mem_fn_traits;

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Mem_fn_traits_base
    {
      using __result_type = _Res;
      using __maybe_type
 = _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;
      using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
    };
# 107 "/usr/include/c++/14.2.1/bits/refwrap.h" 3
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };


template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) & noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) & noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const & noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const & noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile & noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile & noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile & noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile & noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) && noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) && noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const && noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const && noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile && noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile && noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile && noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile && noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };






  template<typename _Functor, typename = __void_t<>>
    struct _Maybe_get_result_type
    { };

  template<typename _Functor>
    struct _Maybe_get_result_type<_Functor,
      __void_t<typename _Functor::result_type>>
    { typedef typename _Functor::result_type result_type; };





  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<_Functor>
    { };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...) noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct
    _Weak_result_type_impl<_Res(*)(_ArgTypes......) noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Functor,
    bool = is_member_function_pointer<_Functor>::value>
    struct _Weak_result_type_memfun
    : _Weak_result_type_impl<_Functor>
    { };


  template<typename _MemFunPtr>
    struct _Weak_result_type_memfun<_MemFunPtr, true>
    {
      using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
    };


  template<typename _Func, typename _Class>
    struct _Weak_result_type_memfun<_Func _Class::*, false>
    { };





  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_memfun<typename remove_cv<_Functor>::type>
    { };
# 306 "/usr/include/c++/14.2.1/bits/refwrap.h" 3
  template<typename _Tp>
    class reference_wrapper





    {
      _Tp* _M_data;

      constexpr
      static _Tp* _S_fun(_Tp& __r) noexcept { return std::__addressof(__r); }

      static void _S_fun(_Tp&&) = delete;

      template<typename _Up, typename _Up2 = __remove_cvref_t<_Up>>
 using __not_same
   = typename enable_if<!is_same<reference_wrapper, _Up2>::value>::type;

    public:
      typedef _Tp type;




      template<typename _Up, typename = __not_same<_Up>, typename
  = decltype(reference_wrapper::_S_fun(std::declval<_Up>()))>
 constexpr
 reference_wrapper(_Up&& __uref)
 noexcept(noexcept(reference_wrapper::_S_fun(std::declval<_Up>())))
 : _M_data(reference_wrapper::_S_fun(std::forward<_Up>(__uref)))
 { }

      reference_wrapper(const reference_wrapper&) = default;

      reference_wrapper&
      operator=(const reference_wrapper&) = default;

      constexpr
      operator _Tp&() const noexcept
      { return this->get(); }

      constexpr
      _Tp&
      get() const noexcept
      { return *_M_data; }

      template<typename... _Args>
 constexpr
 typename __invoke_result<_Tp&, _Args...>::type
 operator()(_Args&&... __args) const
 noexcept(__is_nothrow_invocable<_Tp&, _Args...>::value)
 {

   if constexpr (is_object_v<type>)
     static_assert(sizeof(type), "type must be complete");

   return std::__invoke(get(), std::forward<_Args>(__args)...);
 }
# 412 "/usr/include/c++/14.2.1/bits/refwrap.h" 3
    };


  template<typename _Tp>
    reference_wrapper(_Tp&) -> reference_wrapper<_Tp>;





  template<typename _Tp>
    constexpr
    inline reference_wrapper<_Tp>
    ref(_Tp& __t) noexcept
    { return reference_wrapper<_Tp>(__t); }


  template<typename _Tp>
    constexpr
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t) noexcept
    { return reference_wrapper<const _Tp>(__t); }

  template<typename _Tp>
    void ref(const _Tp&&) = delete;

  template<typename _Tp>
    void cref(const _Tp&&) = delete;


  template<typename _Tp>
    constexpr
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t) noexcept
    { return __t; }


  template<typename _Tp>
    constexpr
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t) noexcept
    { return { __t.get() }; }




}
# 53 "/usr/include/c++/14.2.1/string" 2 3
# 1 "/usr/include/c++/14.2.1/bits/range_access.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/range_access.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/range_access.h" 3


# 1 "/usr/include/c++/14.2.1/initializer_list" 1 3
# 33 "/usr/include/c++/14.2.1/initializer_list" 3
       
# 34 "/usr/include/c++/14.2.1/initializer_list" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };







  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }







  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}
# 37 "/usr/include/c++/14.2.1/bits/range_access.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm]) noexcept
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm]) noexcept
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&) noexcept;
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&) noexcept;
  template<typename _Tp> _Tp* end(valarray<_Tp>&) noexcept;
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&) noexcept;






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Tp, size_t _Nm>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm]) noexcept
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<typename _Tp, size_t _Nm>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm]) noexcept
    { return reverse_iterator<_Tp*>(__arr); }






  template<typename _Tp>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il) noexcept
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<typename _Tp>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il) noexcept
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }
# 259 "/usr/include/c++/14.2.1/bits/range_access.h" 3
  template <typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    size(const _Container& __cont) noexcept(noexcept(__cont.size()))
    -> decltype(__cont.size())
    { return __cont.size(); }




  template <typename _Tp, size_t _Nm>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr size_t
    size(const _Tp (&)[_Nm]) noexcept
    { return _Nm; }





  template <typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    empty(const _Container& __cont) noexcept(noexcept(__cont.empty()))
    -> decltype(__cont.empty())
    { return __cont.empty(); }




  template <typename _Tp, size_t _Nm>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr bool
    empty(const _Tp (&)[_Nm]) noexcept
    { return false; }





  template <typename _Tp>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr bool
    empty(initializer_list<_Tp> __il) noexcept
    { return __il.size() == 0;}





  template <typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    data(_Container& __cont) noexcept(noexcept(__cont.data()))
    -> decltype(__cont.data())
    { return __cont.data(); }





  template <typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    data(const _Container& __cont) noexcept(noexcept(__cont.data()))
    -> decltype(__cont.data())
    { return __cont.data(); }





  template <typename _Tp, size_t _Nm>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr _Tp*
    data(_Tp (&__array)[_Nm]) noexcept
    { return __array; }





  template <typename _Tp>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr const _Tp*
    data(initializer_list<_Tp> __il) noexcept
    { return __il.begin(); }



  template<typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    ssize(const _Container& __cont)
    noexcept(noexcept(__cont.size()))
    -> common_type_t<ptrdiff_t, make_signed_t<decltype(__cont.size())>>
    {
      using type = make_signed_t<decltype(__cont.size())>;
      return static_cast<common_type_t<ptrdiff_t, type>>(__cont.size());
    }

  template<typename _Tp, ptrdiff_t _Num>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr ptrdiff_t
    ssize(const _Tp (&)[_Num]) noexcept
    { return _Num; }


}
# 54 "/usr/include/c++/14.2.1/string" 2 3
# 1 "/usr/include/c++/14.2.1/bits/basic_string.h" 1 3
# 37 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
       
# 38 "/usr/include/c++/14.2.1/bits/basic_string.h" 3

# 1 "/usr/include/c++/14.2.1/ext/alloc_traits.h" 1 3
# 32 "/usr/include/c++/14.2.1/ext/alloc_traits.h" 3
       
# 33 "/usr/include/c++/14.2.1/ext/alloc_traits.h" 3

# 1 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 1 3
# 46 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  struct __allocator_traits_base
  {
    template<typename _Tp, typename _Up, typename = void>
      struct __rebind : __replace_first_arg<_Tp, _Up>
      {
 static_assert(is_same<
   typename __replace_first_arg<_Tp, typename _Tp::value_type>::type,
   _Tp>::value,
   "allocator_traits<A>::rebind_alloc<A::value_type> must be A");
      };

    template<typename _Tp, typename _Up>
      struct __rebind<_Tp, _Up,
        __void_t<typename _Tp::template rebind<_Up>::other>>
      {
 using type = typename _Tp::template rebind<_Up>::other;

 static_assert(is_same<
   typename _Tp::template rebind<typename _Tp::value_type>::other,
   _Tp>::value,
   "allocator_traits<A>::rebind_alloc<A::value_type> must be A");
      };

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = __type_identity<typename _Tp::is_always_equal>;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind
      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
# 105 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;

    private:

      template<template<typename> class _Func, typename _Tp, typename = void>
 struct _Ptr
 {
   using type = typename pointer_traits<pointer>::template rebind<_Tp>;
 };

      template<template<typename> class _Func, typename _Tp>
 struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
 {
   using type = _Func<_Alloc>;
 };


      template<typename _A2, typename _PtrT, typename = void>
 struct _Diff
 { using type = typename pointer_traits<_PtrT>::difference_type; };

      template<typename _A2, typename _PtrT>
 struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
 { using type = typename _A2::difference_type; };


      template<typename _A2, typename _DiffT, typename = void>
 struct _Size : make_unsigned<_DiffT> { };

      template<typename _A2, typename _DiffT>
 struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
 { using type = typename _A2::size_type; };

    public:






      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;







      using void_pointer = typename _Ptr<__v_pointer, void>::type;







      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;







      using difference_type = typename _Diff<_Alloc, pointer>::type;







      using size_type = typename _Size<_Alloc, difference_type>::type;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = typename __detected_or_t<is_empty<_Alloc>, __equal, _Alloc>::type;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 static constexpr auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static constexpr pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static constexpr _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static constexpr
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value)
 {



   std::construct_at(__p, std::forward<_Args>(__args)...);

 }

      template<typename _Alloc2, typename _Tp>
 static constexpr auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 noexcept(noexcept(__a.destroy(__p)))
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static constexpr void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 noexcept(std::is_nothrow_destructible<_Tp>::value)
 { std::_Destroy(__p); }

      template<typename _Alloc2>
 static constexpr auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static constexpr size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static constexpr auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static constexpr _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 332 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      [[__nodiscard__]] static constexpr pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 347 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      [[__nodiscard__]] static constexpr pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 359 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      static constexpr void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 374 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static constexpr auto
 construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(_S_construct(__a, __p,
           std::forward<_Args>(__args)...)))
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 390 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      template<typename _Tp>
 static constexpr void
 destroy(_Alloc& __a, _Tp* __p)
 noexcept(noexcept(_S_destroy(__a, __p, 0)))
 { _S_destroy(__a, __p, 0); }
# 404 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      static constexpr size_type
      max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 416 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      static constexpr _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };



  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;


      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 475 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      [[__nodiscard__,__gnu__::__always_inline__]]
      static constexpr pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 490 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      [[__nodiscard__,__gnu__::__always_inline__]]
      static constexpr pointer
      allocate(allocator_type& __a, size_type __n,
        [[maybe_unused]] const_void_pointer __hint)
      {



 return __a.allocate(__n);

      }
# 510 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      [[__gnu__::__always_inline__]]
      static constexpr void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 526 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 [[__gnu__::__always_inline__]]
 static constexpr void
 construct(allocator_type& __a __attribute__((__unused__)), _Up* __p,
    _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 {



   std::construct_at(__p, std::forward<_Args>(__args)...);

 }
# 547 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      template<typename _Up>
 [[__gnu__::__always_inline__]]
 static constexpr void
 destroy(allocator_type& __a __attribute__((__unused__)), _Up* __p)
 noexcept(is_nothrow_destructible<_Up>::value)
 {



   std::destroy_at(__p);

 }






      [[__gnu__::__always_inline__]]
      static constexpr size_type
      max_size(const allocator_type& __a __attribute__((__unused__))) noexcept
      {



 return size_t(-1) / sizeof(value_type);

      }






      [[__gnu__::__always_inline__]]
      static constexpr allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<>
    struct allocator_traits<allocator<void>>
    {

      using allocator_type = allocator<void>;


      using value_type = void;


      using pointer = void*;


      using const_pointer = const void*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;


      static void*
      allocate(allocator_type&, size_type, const void* = nullptr) = delete;


      static void
      deallocate(allocator_type&, void*, size_type) = delete;
# 652 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 [[__gnu__::__always_inline__]]
 static constexpr void
 construct(allocator_type&, _Up* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 { std::_Construct(__p, std::forward<_Args>(__args)...); }
# 666 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      template<typename _Up>
 [[__gnu__::__always_inline__]]
 static constexpr void
 destroy(allocator_type&, _Up* __p)
 noexcept(is_nothrow_destructible<_Up>::value)
 { std::_Destroy(__p); }


      static size_type
      max_size(const allocator_type&) = delete;






      [[__gnu__::__always_inline__]]
      static constexpr allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };
# 704 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
  template<typename _Alloc>
    [[__gnu__::__always_inline__]]
    constexpr inline void
    __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      using __traits = allocator_traits<_Alloc>;
      using __pocca =
 typename __traits::propagate_on_container_copy_assignment::type;

      if constexpr (__pocca::value)
 __one = __two;



    }

  template<typename _Alloc>
    [[__gnu__::__always_inline__]]
    constexpr _Alloc
    __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }
# 741 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
  template<typename _Alloc>
    [[__gnu__::__always_inline__]]
    constexpr inline void
    __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      using __traits = allocator_traits<_Alloc>;
      using __pocma
 = typename __traits::propagate_on_container_move_assignment::type;

      if constexpr (__pocma::value)
 __one = std::move(__two);



    }
# 772 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
  template<typename _Alloc>
    [[__gnu__::__always_inline__]]
    constexpr inline void
    __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      using __traits = allocator_traits<_Alloc>;
      using __pocs = typename __traits::propagate_on_container_swap::type;

      if constexpr (__pocs::value)
 {
   using std::swap;
   swap(__one, __two);
 }



    }

  template<typename _Alloc, typename _Tp,
    typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,
    typename = void>
    struct __is_alloc_insertable_impl
    : false_type
    { };

  template<typename _Alloc, typename _Tp, typename _ValueT>
    struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT,
      __void_t<decltype(allocator_traits<_Alloc>::construct(
     std::declval<_Alloc&>(), std::declval<_ValueT*>(),
     std::declval<_Tp>()))>>
    : true_type
    { };




  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_alloc_insertable_impl<_Alloc,
     typename _Alloc::value_type const&>::type
    { };



  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };





  template<typename _Alloc>
    struct __is_move_insertable
    : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type
    { };



  template<typename _Tp>
    struct __is_move_insertable<allocator<_Tp>>
    : is_move_constructible<_Tp>
    { };



  template<typename _Alloc, typename = void>
    struct __is_allocator : false_type { };

  template<typename _Alloc>
    struct __is_allocator<_Alloc,
      __void_t<typename _Alloc::value_type,
        decltype(std::declval<_Alloc&>().allocate(size_t{}))>>
    : true_type { };

  template<typename _Alloc>
    using _RequireAllocator
      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;

  template<typename _Alloc>
    using _RequireNotAllocator
      = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;


  template<typename _Alloc>
    concept __allocator_like = requires (_Alloc& __a) {
      typename _Alloc::value_type;
      __a.deallocate(__a.allocate(1u), 1u);
    };







  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      constexpr
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };
# 922 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
  template<typename _ForwardIterator, typename _Allocator>
    constexpr
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)



 allocator_traits<_Allocator>::destroy(__alloc,
           std::__addressof(*__first));

    }


  template<typename _ForwardIterator, typename _Tp>
    __attribute__((__always_inline__)) constexpr
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      std::_Destroy(__first, __last);
    }




}
# 35 "/usr/include/c++/14.2.1/ext/alloc_traits.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{






template<typename _Alloc, typename = typename _Alloc::value_type>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      [[__gnu__::__always_inline__]]
      static constexpr
      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p),
           std::forward<_Args>(__args)...)))
      {
 _Base_type::construct(__a, std::__to_address(__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      [[__gnu__::__always_inline__]]
      static constexpr
      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
      destroy(_Alloc& __a, _Ptr __p)
      noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p))))
      { _Base_type::destroy(__a, std::__to_address(__p)); }

    [[__gnu__::__always_inline__]]
    static constexpr _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    [[__gnu__::__always_inline__]]
    static constexpr void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    [[__gnu__::__always_inline__]]
    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    [[__gnu__::__always_inline__]]
    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    [[__gnu__::__always_inline__]]
    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    [[__gnu__::__always_inline__]]
    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    __attribute__((__always_inline__))
    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 180 "/usr/include/c++/14.2.1/ext/alloc_traits.h" 3
  };


}
# 40 "/usr/include/c++/14.2.1/bits/basic_string.h" 2 3







# 1 "/usr/include/c++/14.2.1/string_view" 1 3
# 36 "/usr/include/c++/14.2.1/string_view" 3
       
# 37 "/usr/include/c++/14.2.1/string_view" 3







# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 45 "/usr/include/c++/14.2.1/string_view" 2 3





# 1 "/usr/include/c++/14.2.1/bits/functional_hash.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/functional_hash.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/functional_hash.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 50 "/usr/include/c++/14.2.1/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type [[__deprecated__]];
      typedef _Arg argument_type [[__deprecated__]];
    };


  template<typename _Tp>
    struct hash;

  template<typename _Tp, typename = void>
    struct __poison_hash
    {
      static constexpr bool __enable_hash_call = false;
    private:

      __poison_hash(__poison_hash&&);
      ~__poison_hash();
    };

  template<typename _Tp>
    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>
    {
      static constexpr bool __enable_hash_call = true;
    };


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 125 "/usr/include/c++/14.2.1/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };



  template<> struct hash<char8_t> : public __hash_base<size_t, char8_t> { size_t operator()(char8_t __val) const noexcept { return static_cast<size_t>(__val); } };



  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };


  __extension__
  template<> struct hash<__int128> : public __hash_base<size_t, __int128> { size_t operator()(__int128 __val) const noexcept { return static_cast<size_t>(__val); } };
  __extension__
  template<> struct hash<__int128 unsigned> : public __hash_base<size_t, __int128 unsigned> { size_t operator()(__int128 unsigned __val) const noexcept { return static_cast<size_t>(__val); } };
# 201 "/usr/include/c++/14.2.1/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };


  template<>
    struct hash<nullptr_t> : public __hash_base<size_t, nullptr_t>
    {
      size_t
      operator()(nullptr_t) const noexcept
      { return 0; }
    };
# 294 "/usr/include/c++/14.2.1/bits/functional_hash.h" 3
  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 51 "/usr/include/c++/14.2.1/string_view" 2 3





# 1 "/usr/include/c++/14.2.1/bits/ranges_base.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3





# 1 "/usr/include/c++/14.2.1/bits/max_size_type.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/max_size_type.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/max_size_type.h" 3



# 1 "/usr/include/c++/14.2.1/numbers" 1 3
# 32 "/usr/include/c++/14.2.1/numbers" 3
       
# 33 "/usr/include/c++/14.2.1/numbers" 3


# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 36 "/usr/include/c++/14.2.1/numbers" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{








namespace numbers
{


  template<typename _Tp>
    using _Enable_if_floating = enable_if_t<is_floating_point_v<_Tp>, _Tp>;



  template<typename _Tp>
    inline constexpr _Tp e_v
      = _Enable_if_floating<_Tp>(2.718281828459045235360287471352662498L);


  template<typename _Tp>
    inline constexpr _Tp log2e_v
      = _Enable_if_floating<_Tp>(1.442695040888963407359924681001892137L);


  template<typename _Tp>
    inline constexpr _Tp log10e_v
      = _Enable_if_floating<_Tp>(0.434294481903251827651128918916605082L);


  template<typename _Tp>
    inline constexpr _Tp pi_v
      = _Enable_if_floating<_Tp>(3.141592653589793238462643383279502884L);


  template<typename _Tp>
    inline constexpr _Tp inv_pi_v
      = _Enable_if_floating<_Tp>(0.318309886183790671537767526745028724L);


  template<typename _Tp>
    inline constexpr _Tp inv_sqrtpi_v
      = _Enable_if_floating<_Tp>(0.564189583547756286948079451560772586L);


  template<typename _Tp>
    inline constexpr _Tp ln2_v
      = _Enable_if_floating<_Tp>(0.693147180559945309417232121458176568L);


  template<typename _Tp>
    inline constexpr _Tp ln10_v
      = _Enable_if_floating<_Tp>(2.302585092994045684017991454684364208L);


  template<typename _Tp>
    inline constexpr _Tp sqrt2_v
      = _Enable_if_floating<_Tp>(1.414213562373095048801688724209698079L);


  template<typename _Tp>
    inline constexpr _Tp sqrt3_v
      = _Enable_if_floating<_Tp>(1.732050807568877293527446341505872367L);


  template<typename _Tp>
    inline constexpr _Tp inv_sqrt3_v
      = _Enable_if_floating<_Tp>(0.577350269189625764509148780501957456L);


  template<typename _Tp>
    inline constexpr _Tp egamma_v
      = _Enable_if_floating<_Tp>(0.577215664901532860606512090082402431L);


  template<typename _Tp>
    inline constexpr _Tp phi_v
      = _Enable_if_floating<_Tp>(1.618033988749894848204586834365638118L);

  inline constexpr double e = e_v<double>;
  inline constexpr double log2e = log2e_v<double>;
  inline constexpr double log10e = log10e_v<double>;
  inline constexpr double pi = pi_v<double>;
  inline constexpr double inv_pi = inv_pi_v<double>;
  inline constexpr double inv_sqrtpi = inv_sqrtpi_v<double>;
  inline constexpr double ln2 = ln2_v<double>;
  inline constexpr double ln10 = ln10_v<double>;
  inline constexpr double sqrt2 = sqrt2_v<double>;
  inline constexpr double sqrt3 = sqrt3_v<double>;
  inline constexpr double inv_sqrt3 = inv_sqrt3_v<double>;
  inline constexpr double egamma = egamma_v<double>;
  inline constexpr double phi = phi_v<double>;
# 225 "/usr/include/c++/14.2.1/numbers" 3
template<> inline constexpr __float128 e_v<__float128> = 2.718281828459045235360287471352662498Q; template<> inline constexpr __float128 log2e_v<__float128> = 1.442695040888963407359924681001892137Q; template<> inline constexpr __float128 log10e_v<__float128> = 0.434294481903251827651128918916605082Q; template<> inline constexpr __float128 pi_v<__float128> = 3.141592653589793238462643383279502884Q; template<> inline constexpr __float128 inv_pi_v<__float128> = 0.318309886183790671537767526745028724Q; template<> inline constexpr __float128 inv_sqrtpi_v<__float128> = 0.564189583547756286948079451560772586Q; template<> inline constexpr __float128 ln2_v<__float128> = 0.693147180559945309417232121458176568Q; template<> inline constexpr __float128 ln10_v<__float128> = 2.302585092994045684017991454684364208Q; template<> inline constexpr __float128 sqrt2_v<__float128> = 1.414213562373095048801688724209698079Q; template<> inline constexpr __float128 sqrt3_v<__float128> = 1.732050807568877293527446341505872367Q; template<> inline constexpr __float128 inv_sqrt3_v<__float128> = 0.577350269189625764509148780501957456Q; template<> inline constexpr __float128 egamma_v<__float128> = 0.577215664901532860606512090082402431Q; template<> inline constexpr __float128 phi_v<__float128> = 1.618033988749894848204586834365638118Q;




}


}
# 38 "/usr/include/c++/14.2.1/bits/max_size_type.h" 2 3
# 48 "/usr/include/c++/14.2.1/bits/max_size_type.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


template<typename _Tp>
  struct numeric_limits;

namespace ranges
{
  namespace __detail
  {
    class __max_size_type
    {
    public:
      __max_size_type() = default;

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 constexpr
 __max_size_type(_Tp __i) noexcept
   : _M_val(__i), _M_msb(__i < 0)
 { }

      constexpr explicit
      __max_size_type(const __max_diff_type& __d) noexcept;

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 constexpr explicit
 operator _Tp() const noexcept
 { return _M_val; }

      constexpr explicit
      operator bool() const noexcept
      { return _M_val != 0 || _M_msb != 0; }

      constexpr __max_size_type
      operator+() const noexcept
      { return *this; }

      constexpr __max_size_type
      operator~() const noexcept
      { return __max_size_type{~_M_val, !_M_msb}; }

      constexpr __max_size_type
      operator-() const noexcept
      { return operator~() + 1; }

      constexpr __max_size_type&
      operator++() noexcept
      { return *this += 1; }

      constexpr __max_size_type
      operator++(int) noexcept
      {
 auto __tmp = *this;
 ++*this;
 return __tmp;
      }

      constexpr __max_size_type&
      operator--() noexcept
      { return *this -= 1; }

      constexpr __max_size_type
      operator--(int) noexcept
      {
 auto __tmp = *this;
 --*this;
 return __tmp;
      }

      constexpr __max_size_type&
      operator+=(const __max_size_type& __r) noexcept
      {
 const auto __sum = _M_val + __r._M_val;
 const bool __overflow = (__sum < _M_val);
 _M_msb = _M_msb ^ __r._M_msb ^ __overflow;
 _M_val = __sum;
 return *this;
      }

      constexpr __max_size_type&
      operator-=(const __max_size_type& __r) noexcept
      { return *this += -__r; }

      constexpr __max_size_type&
      operator*=(__max_size_type __r) noexcept
      {
 constexpr __max_size_type __threshold
   = __rep(1) << (_S_rep_bits / 2 - 1);
 if (_M_val < __threshold && __r < __threshold)


   _M_val = _M_val * __r._M_val;
 else
   {



     const bool __lsb = _M_val & 1;
     const bool __rlsb = __r._M_val & 1;
     *this >>= 1;
     __r >>= 1;
     _M_val = (2 * _M_val * __r._M_val
        + _M_val * __rlsb + __r._M_val * __lsb);
     *this <<= 1;
     *this += __rlsb * __lsb;
   }

 return *this;
      }

      constexpr __max_size_type&
      operator/=(const __max_size_type& __r) noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__r != 0), false)) std::__glibcxx_assert_fail(); } while (false);

 if (!_M_msb && !__r._M_msb) [[likely]]
   _M_val /= __r._M_val;
 else if (_M_msb && __r._M_msb)
   {
     _M_val = (_M_val >= __r._M_val);
     _M_msb = 0;
   }
 else if (!_M_msb && __r._M_msb)
   _M_val = 0;
 else if (_M_msb && !__r._M_msb)
   {




     const auto __orig = *this;
     *this >>= 1;
     _M_val /= __r._M_val;
     *this <<= 1;
     if (__orig - *this * __r >= __r)
       ++_M_val;
   }
 return *this;
      }

      constexpr __max_size_type&
      operator%=(const __max_size_type& __r) noexcept
      {
 if (!_M_msb && !__r._M_msb) [[likely]]
   _M_val %= __r._M_val;
 else
   *this -= (*this / __r) * __r;
 return *this;
      }

      constexpr __max_size_type&
      operator<<=(const __max_size_type& __r) noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__r <= _S_rep_bits), false)) std::__glibcxx_assert_fail(); } while (false);
 if (__r != 0)
   {
     _M_msb = (_M_val >> (_S_rep_bits - __r._M_val)) & 1;

     if (__r._M_val == _S_rep_bits) [[unlikely]]
       _M_val = 0;
     else
       _M_val <<= __r._M_val;
   }
 return *this;
      }

      constexpr __max_size_type&
      operator>>=(const __max_size_type& __r) noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__r <= _S_rep_bits), false)) std::__glibcxx_assert_fail(); } while (false);
 if (__r != 0)
   {
     if (__r._M_val == _S_rep_bits) [[unlikely]]
       _M_val = 0;
     else
       _M_val >>= __r._M_val;

     if (_M_msb) [[unlikely]]
       {
  _M_val |= __rep(1) << (_S_rep_bits - __r._M_val);
  _M_msb = 0;
       }
   }
 return *this;
      }

      constexpr __max_size_type&
      operator&=(const __max_size_type& __r) noexcept
      {
 _M_val &= __r._M_val;
 _M_msb &= __r._M_msb;
 return *this;
      }

      constexpr __max_size_type&
      operator|=(const __max_size_type& __r) noexcept
      {
 _M_val |= __r._M_val;
 _M_msb |= __r._M_msb;
 return *this;
      }

      constexpr __max_size_type&
      operator^=(const __max_size_type& __r) noexcept
      {
 _M_val ^= __r._M_val;
 _M_msb ^= __r._M_msb;
 return *this;
      }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator+=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a + __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator-=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a - __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator*=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a * __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator/=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a / __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator%=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a % __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator&=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a & __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator|=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a | __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator^=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a ^ __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator<<=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a << __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator>>=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a >> __b)); }

      friend constexpr __max_size_type
      operator+(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l += __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator-(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l -= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator*(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l *= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator/(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l /= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator%(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l %= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator<<(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l <<= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator>>(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l >>= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator&(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l &= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator|(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l |= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator^(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l ^= __r;
 return __l;
      }

      friend constexpr bool
      operator==(const __max_size_type& __l, const __max_size_type& __r) noexcept
      { return __l._M_val == __r._M_val && __l._M_msb == __r._M_msb; }


      friend constexpr strong_ordering
      operator<=>(const __max_size_type& __l, const __max_size_type& __r) noexcept
      {
 if (__l._M_msb ^ __r._M_msb)
   return __l._M_msb ? strong_ordering::greater : strong_ordering::less;
 else
   return __l._M_val <=> __r._M_val;
      }
# 420 "/usr/include/c++/14.2.1/bits/max_size_type.h" 3
      __extension__
      using __rep = unsigned __int128;



      static constexpr size_t _S_rep_bits = sizeof(__rep) * 8;
    private:
      __rep _M_val = 0;
      unsigned _M_msb:1 = 0;

      constexpr explicit
      __max_size_type(__rep __val, int __msb) noexcept
 : _M_val(__val), _M_msb(__msb)
      { }

      friend __max_diff_type;
      friend std::numeric_limits<__max_size_type>;
      friend std::numeric_limits<__max_diff_type>;
    };

    class __max_diff_type
    {
    public:
      __max_diff_type() = default;

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 constexpr
 __max_diff_type(_Tp __i) noexcept
   : _M_rep(__i)
 { }

      constexpr explicit
      __max_diff_type(const __max_size_type& __d) noexcept
 : _M_rep(__d)
      { }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 constexpr explicit
 operator _Tp() const noexcept
 { return static_cast<_Tp>(_M_rep); }

      constexpr explicit
      operator bool() const noexcept
      { return _M_rep != 0; }

      constexpr __max_diff_type
      operator+() const noexcept
      { return *this; }

      constexpr __max_diff_type
      operator-() const noexcept
      { return __max_diff_type(-_M_rep); }

      constexpr __max_diff_type
      operator~() const noexcept
      { return __max_diff_type(~_M_rep); }

      constexpr __max_diff_type&
      operator++() noexcept
      { return *this += 1; }

      constexpr __max_diff_type
      operator++(int) noexcept
      {
 auto __tmp = *this;
 ++*this;
 return __tmp;
      }

      constexpr __max_diff_type&
      operator--() noexcept
      { return *this -= 1; }

      constexpr __max_diff_type
      operator--(int) noexcept
      {
 auto __tmp = *this;
 --*this;
 return __tmp;
      }

      constexpr __max_diff_type&
      operator+=(const __max_diff_type& __r) noexcept
      {
 _M_rep += __r._M_rep;
 return *this;
      }

      constexpr __max_diff_type&
      operator-=(const __max_diff_type& __r) noexcept
      {
 _M_rep -= __r._M_rep;
 return *this;
      }

      constexpr __max_diff_type&
      operator*=(const __max_diff_type& __r) noexcept
      {
 _M_rep *= __r._M_rep;
 return *this;
      }

      constexpr __max_diff_type&
      operator/=(const __max_diff_type& __r) noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__r != 0), false)) std::__glibcxx_assert_fail(); } while (false);
 const bool __neg = *this < 0;
 const bool __rneg = __r < 0;
 if (!__neg && !__rneg)
   _M_rep = _M_rep / __r._M_rep;
 else if (__neg && __rneg)
   _M_rep = -_M_rep / -__r._M_rep;
 else if (__neg && !__rneg)
   _M_rep = -(-_M_rep / __r._M_rep);
 else
   _M_rep = -(_M_rep / -__r._M_rep);
 return *this ;
      }

      constexpr __max_diff_type&
      operator%=(const __max_diff_type& __r) noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__r != 0), false)) std::__glibcxx_assert_fail(); } while (false);
 if (*this >= 0 && __r > 0)
   _M_rep %= __r._M_rep;
 else
   *this -= (*this / __r) * __r;
 return *this;
      }

      constexpr __max_diff_type&
      operator<<=(const __max_diff_type& __r) noexcept
      {
 _M_rep.operator<<=(__r._M_rep);
 return *this;
      }

      constexpr __max_diff_type&
      operator>>=(const __max_diff_type& __r) noexcept
      {

 const auto __msb = _M_rep._M_msb;
 _M_rep >>= __r._M_rep;
 if (__msb)
   _M_rep |= ~(__max_size_type(-1) >> __r._M_rep);
 return *this;
      }

      constexpr __max_diff_type&
      operator&=(const __max_diff_type& __r) noexcept
      {
 _M_rep &= __r._M_rep;
 return *this;
      }

      constexpr __max_diff_type&
      operator|=(const __max_diff_type& __r) noexcept
      {
 _M_rep |= __r._M_rep;
 return *this;
      }

      constexpr __max_diff_type&
      operator^=(const __max_diff_type& __r) noexcept
      {
 _M_rep ^= __r._M_rep;
 return *this;
      }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator+=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a + __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator-=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a - __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator*=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a * __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator/=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a / __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator%=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a % __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator&=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a & __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator|=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a | __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator^=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a ^ __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator<<=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a << __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator>>=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a >> __b)); }

      friend constexpr __max_diff_type
      operator+(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l += __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator-(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l -= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator*(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l *= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator/(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l /= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator%(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l %= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator<<(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l <<= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator>>(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l >>= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator&(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l &= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator|(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l |= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator^(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l ^= __r;
 return __l;
      }

      friend constexpr bool
      operator==(const __max_diff_type& __l, const __max_diff_type& __r) noexcept
      { return __l._M_rep == __r._M_rep; }


      constexpr strong_ordering
      operator<=>(const __max_diff_type& __r) const noexcept
      {
 const auto __lsign = _M_rep._M_msb;
 const auto __rsign = __r._M_rep._M_msb;
 if (__lsign ^ __rsign)
   return __lsign ? strong_ordering::less : strong_ordering::greater;
 else
   return _M_rep <=> __r._M_rep;
      }
# 753 "/usr/include/c++/14.2.1/bits/max_size_type.h" 3
    private:
      __max_size_type _M_rep = 0;

      friend class __max_size_type;
    };

    constexpr
    __max_size_type::__max_size_type(const __max_diff_type& __d) noexcept
      : __max_size_type(__d._M_rep)
    { }

  }
}

  template<>
    struct numeric_limits<ranges::__detail::__max_size_type>
    {
      using _Sp = ranges::__detail::__max_size_type;
      static constexpr bool is_specialized = true;
      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int digits
 = __gnu_cxx::__int_traits<_Sp::__rep>::__digits + 1;
      static constexpr int digits10
 = static_cast<int>(digits * numbers::ln2 / numbers::ln10);

      static constexpr _Sp
      min() noexcept
      { return 0; }

      static constexpr _Sp
      max() noexcept
      { return _Sp(static_cast<_Sp::__rep>(-1), 1); }

      static constexpr _Sp
      lowest() noexcept
      { return min(); }
    };

  template<>
    struct numeric_limits<ranges::__detail::__max_diff_type>
    {
      using _Dp = ranges::__detail::__max_diff_type;
      using _Sp = ranges::__detail::__max_size_type;
      static constexpr bool is_specialized = true;
      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int digits = numeric_limits<_Sp>::digits - 1;
      static constexpr int digits10
 = static_cast<int>(digits * numbers::ln2 / numbers::ln10);

      static constexpr _Dp
      min() noexcept
      { return _Dp(_Sp(0, 1)); }

      static constexpr _Dp
      max() noexcept
      { return _Dp(_Sp(static_cast<_Sp::__rep>(-1), 0)); }

      static constexpr _Dp
      lowest() noexcept
      { return min(); }
    };


}
# 40 "/usr/include/c++/14.2.1/bits/ranges_base.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 41 "/usr/include/c++/14.2.1/bits/ranges_base.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

namespace ranges
{
  template<typename>
    inline constexpr bool disable_sized_range = false;

  template<typename _Tp>
    inline constexpr bool enable_borrowed_range = false;

  namespace __detail
  {
    constexpr __max_size_type
    __to_unsigned_like(__max_size_type __t) noexcept
    { return __t; }

    constexpr __max_size_type
    __to_unsigned_like(__max_diff_type __t) noexcept
    { return __max_size_type(__t); }

    template<integral _Tp>
      constexpr auto
      __to_unsigned_like(_Tp __t) noexcept
      { return static_cast<make_unsigned_t<_Tp>>(__t); }
# 79 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
    template<typename _Tp>
      using __make_unsigned_like_t
 = decltype(__detail::__to_unsigned_like(std::declval<_Tp>()));


    template<typename _Tp>
      concept __maybe_borrowed_range
 = is_lvalue_reference_v<_Tp>
   || enable_borrowed_range<remove_cvref_t<_Tp>>;

  }


  namespace __access
  {
    using std::ranges::__detail::__maybe_borrowed_range;
    using std::__detail::__range_iter_t;

    struct _Begin
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (is_array_v<remove_reference_t<_Tp>>)
     return true;
   else if constexpr (__member_begin<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().begin()));
   else
     return noexcept(__decay_copy(begin(std::declval<_Tp&>())));
 }

    public:
      template<__maybe_borrowed_range _Tp>
 requires is_array_v<remove_reference_t<_Tp>> || __member_begin<_Tp>
   || __adl_begin<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (is_array_v<remove_reference_t<_Tp>>)
     {
       static_assert(is_lvalue_reference_v<_Tp>);
       return __t + 0;
     }
   else if constexpr (__member_begin<_Tp>)
     return __t.begin();
   else
     return begin(__t);
 }
    };

    template<typename _Tp>
      concept __member_end = requires(_Tp& __t)
 {
   { __decay_copy(__t.end()) } -> sentinel_for<__range_iter_t<_Tp>>;
 };


    void end() = delete;

    template<typename _Tp>
      concept __adl_end = __class_or_enum<remove_reference_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(end(__t)) } -> sentinel_for<__range_iter_t<_Tp>>;
 };

    struct _End
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)
     return true;
   else if constexpr (__member_end<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().end()));
   else
     return noexcept(__decay_copy(end(std::declval<_Tp&>())));
 }

    public:
      template<__maybe_borrowed_range _Tp>
 requires is_bounded_array_v<remove_reference_t<_Tp>>
   || __member_end<_Tp> || __adl_end<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)
     {
       static_assert(is_lvalue_reference_v<_Tp>);
       return __t + extent_v<remove_reference_t<_Tp>>;
     }
   else if constexpr (__member_end<_Tp>)
     return __t.end();
   else
     return end(__t);
 }
    };

    template<typename _Tp>
      concept __member_rbegin = requires(_Tp& __t)
 {
   { __decay_copy(__t.rbegin()) } -> input_or_output_iterator;
 };

    void rbegin() = delete;

    template<typename _Tp>
      concept __adl_rbegin = __class_or_enum<remove_reference_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(rbegin(__t)) } -> input_or_output_iterator;
 };

    template<typename _Tp>
      concept __reversable = requires(_Tp& __t)
 {
   { _Begin{}(__t) } -> bidirectional_iterator;
   { _End{}(__t) } -> same_as<decltype(_Begin{}(__t))>;
 };

    struct _RBegin
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__member_rbegin<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().rbegin()));
   else if constexpr (__adl_rbegin<_Tp>)
     return noexcept(__decay_copy(rbegin(std::declval<_Tp&>())));
   else
     {
       if constexpr (noexcept(_End{}(std::declval<_Tp&>())))
  {
    using _It = decltype(_End{}(std::declval<_Tp&>()));

    return is_nothrow_copy_constructible_v<_It>;
  }
       else
  return false;
     }
 }

    public:
      template<__maybe_borrowed_range _Tp>
 requires __member_rbegin<_Tp> || __adl_rbegin<_Tp> || __reversable<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const
 noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (__member_rbegin<_Tp>)
     return __t.rbegin();
   else if constexpr (__adl_rbegin<_Tp>)
     return rbegin(__t);
   else
     return std::make_reverse_iterator(_End{}(__t));
 }
    };

    template<typename _Tp>
      concept __member_rend = requires(_Tp& __t)
 {
   { __decay_copy(__t.rend()) }
     -> sentinel_for<decltype(_RBegin{}(std::forward<_Tp>(__t)))>;
 };

    void rend() = delete;

    template<typename _Tp>
      concept __adl_rend = __class_or_enum<remove_reference_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(rend(__t)) }
     -> sentinel_for<decltype(_RBegin{}(std::forward<_Tp>(__t)))>;
 };

    struct _REnd
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__member_rend<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().rend()));
   else if constexpr (__adl_rend<_Tp>)
     return noexcept(__decay_copy(rend(std::declval<_Tp&>())));
   else
     {
       if constexpr (noexcept(_Begin{}(std::declval<_Tp&>())))
  {
    using _It = decltype(_Begin{}(std::declval<_Tp&>()));

    return is_nothrow_copy_constructible_v<_It>;
  }
       else
  return false;
     }
 }

    public:
      template<__maybe_borrowed_range _Tp>
 requires __member_rend<_Tp> || __adl_rend<_Tp> || __reversable<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const
 noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (__member_rend<_Tp>)
     return __t.rend();
   else if constexpr (__adl_rend<_Tp>)
     return rend(__t);
   else
     return std::make_reverse_iterator(_Begin{}(__t));
 }
    };

    template<typename _Tp>
      concept __member_size = !disable_sized_range<remove_cvref_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(__t.size()) } -> __detail::__is_integer_like;
 };

    void size() = delete;

    template<typename _Tp>
      concept __adl_size = __class_or_enum<remove_reference_t<_Tp>>
 && !disable_sized_range<remove_cvref_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(size(__t)) } -> __detail::__is_integer_like;
 };

    template<typename _Tp>
      concept __sentinel_size = requires(_Tp& __t)
 {
   requires (!is_unbounded_array_v<remove_reference_t<_Tp>>);

   { _Begin{}(__t) } -> forward_iterator;

   { _End{}(__t) } -> sized_sentinel_for<decltype(_Begin{}(__t))>;

   __detail::__to_unsigned_like(_End{}(__t) - _Begin{}(__t));
 };

    struct _Size
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)
     return true;
   else if constexpr (__member_size<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().size()));
   else if constexpr (__adl_size<_Tp>)
     return noexcept(__decay_copy(size(std::declval<_Tp&>())));
   else if constexpr (__sentinel_size<_Tp>)
     return noexcept(_End{}(std::declval<_Tp&>())
       - _Begin{}(std::declval<_Tp&>()));
 }

    public:
      template<typename _Tp>
 requires is_bounded_array_v<remove_reference_t<_Tp>>
   || __member_size<_Tp> || __adl_size<_Tp> || __sentinel_size<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)
     return extent_v<remove_reference_t<_Tp>>;
   else if constexpr (__member_size<_Tp>)
     return __t.size();
   else if constexpr (__adl_size<_Tp>)
     return size(__t);
   else if constexpr (__sentinel_size<_Tp>)
     return __detail::__to_unsigned_like(_End{}(__t) - _Begin{}(__t));
 }
    };

    struct _SSize
    {


      template<typename _Tp>
 requires requires (_Tp& __t) { _Size{}(__t); }
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const noexcept(noexcept(_Size{}(__t)))
 {
   auto __size = _Size{}(__t);
   using __size_type = decltype(__size);

   if constexpr (integral<__size_type>)
     {
       using __gnu_cxx::__int_traits;
       if constexpr (__int_traits<__size_type>::__digits
       < __int_traits<ptrdiff_t>::__digits)
  return static_cast<ptrdiff_t>(__size);
       else
  return static_cast<make_signed_t<__size_type>>(__size);
     }





   else
     return __detail::__max_diff_type(__size);
 }
    };

    template<typename _Tp>
      concept __member_empty = requires(_Tp& __t) { bool(__t.empty()); };

    template<typename _Tp>
      concept __size0_empty = requires(_Tp& __t) { _Size{}(__t) == 0; };

    template<typename _Tp>
      concept __eq_iter_empty = requires(_Tp& __t)
 {
   requires (!is_unbounded_array_v<remove_reference_t<_Tp>>);

   { _Begin{}(__t) } -> forward_iterator;

   bool(_Begin{}(__t) == _End{}(__t));
 };

    struct _Empty
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__member_empty<_Tp>)
     return noexcept(bool(std::declval<_Tp&>().empty()));
   else if constexpr (__size0_empty<_Tp>)
     return noexcept(_Size{}(std::declval<_Tp&>()) == 0);
   else
     return noexcept(bool(_Begin{}(std::declval<_Tp&>())
  == _End{}(std::declval<_Tp&>())));
 }

    public:
      template<typename _Tp>
 requires __member_empty<_Tp> || __size0_empty<_Tp>
   || __eq_iter_empty<_Tp>
 constexpr bool
 operator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (__member_empty<_Tp>)
     return bool(__t.empty());
   else if constexpr (__size0_empty<_Tp>)
     return _Size{}(__t) == 0;
   else
     return bool(_Begin{}(__t) == _End{}(__t));
 }
    };

    template<typename _Tp>
      concept __pointer_to_object = is_pointer_v<_Tp>
        && is_object_v<remove_pointer_t<_Tp>>;

    template<typename _Tp>
      concept __member_data = requires(_Tp& __t)
 {
   { __decay_copy(__t.data()) } -> __pointer_to_object;
 };

    template<typename _Tp>
      concept __begin_data = contiguous_iterator<__range_iter_t<_Tp>>;

    struct _Data
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__member_data<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().data()));
   else
     return noexcept(_Begin{}(std::declval<_Tp&>()));
 }

    public:
      template<__maybe_borrowed_range _Tp>
 requires __member_data<_Tp> || __begin_data<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp>())
 {
   if constexpr (__member_data<_Tp>)
     return __t.data();
   else
     return std::to_address(_Begin{}(__t));
 }
    };

  }

  inline namespace _Cpo
  {
    inline constexpr ranges::__access::_Begin begin{};
    inline constexpr ranges::__access::_End end{};
    inline constexpr ranges::__access::_RBegin rbegin{};
    inline constexpr ranges::__access::_REnd rend{};
    inline constexpr ranges::__access::_Size size{};
    inline constexpr ranges::__access::_SSize ssize{};
    inline constexpr ranges::__access::_Empty empty{};
    inline constexpr ranges::__access::_Data data{};
  }


  template<typename _Tp>
    concept range = requires(_Tp& __t)
      {
 ranges::begin(__t);
 ranges::end(__t);
      };


  template<typename _Tp>
    concept borrowed_range
      = range<_Tp> && __detail::__maybe_borrowed_range<_Tp>;

  template<typename _Tp>
    using iterator_t = std::__detail::__range_iter_t<_Tp>;

  template<range _Range>
    using sentinel_t = decltype(ranges::end(std::declval<_Range&>()));
# 527 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
  template<range _Range>
    using range_difference_t = iter_difference_t<iterator_t<_Range>>;

  template<range _Range>
    using range_value_t = iter_value_t<iterator_t<_Range>>;

  template<range _Range>
    using range_reference_t = iter_reference_t<iterator_t<_Range>>;

  template<range _Range>
    using range_rvalue_reference_t
      = iter_rvalue_reference_t<iterator_t<_Range>>;


  template<typename _Tp>
    concept sized_range = range<_Tp>
      && requires(_Tp& __t) { ranges::size(__t); };

  template<sized_range _Range>
    using range_size_t = decltype(ranges::size(std::declval<_Range&>()));

  template<typename _Derived>
    requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
    class view_interface;

  namespace __detail
  {
    template<typename _Tp, typename _Up>
      requires (!same_as<_Tp, view_interface<_Up>>)
      void __is_derived_from_view_interface_fn(const _Tp&,
            const view_interface<_Up>&);



    template<typename _Tp>
      concept __is_derived_from_view_interface
 = requires (_Tp __t) { __is_derived_from_view_interface_fn(__t, __t); };
  }


  struct view_base { };


  template<typename _Tp>
    inline constexpr bool enable_view = derived_from<_Tp, view_base>
      || __detail::__is_derived_from_view_interface<_Tp>;


  template<typename _Tp>
    concept view
      = range<_Tp> && movable<_Tp> && enable_view<_Tp>;




  template<typename _Range, typename _Tp>
    concept output_range
      = range<_Range> && output_iterator<iterator_t<_Range>, _Tp>;


  template<typename _Tp>
    concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;


  template<typename _Tp>
    concept forward_range
      = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;


  template<typename _Tp>
    concept bidirectional_range
      = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;


  template<typename _Tp>
    concept random_access_range
      = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;


  template<typename _Tp>
    concept contiguous_range
      = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>>
      && requires(_Tp& __t)
      {
 { ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>;
      };


  template<typename _Tp>
    concept common_range
      = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;







  namespace __access
  {
# 639 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
    template<typename _To, typename _Tp>
      constexpr decltype(auto)
      __as_const(_Tp& __t) noexcept
      {
 static_assert(std::is_same_v<_To&, _Tp&>);

 if constexpr (is_lvalue_reference_v<_To>)
   return const_cast<const _Tp&>(__t);
 else
   return static_cast<const _Tp&&>(__t);
      }


    struct _CBegin
    {
# 668 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
      template<typename _Tp>
 [[nodiscard]]
 constexpr auto
 operator()(_Tp&& __e) const
 noexcept(noexcept(_Begin{}(__access::__as_const<_Tp>(__e))))
 requires requires { _Begin{}(__access::__as_const<_Tp>(__e)); }
 {
   return _Begin{}(__access::__as_const<_Tp>(__e));
 }

    };

    struct _CEnd final
    {
# 696 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
      template<typename _Tp>
 [[nodiscard]]
 constexpr auto
 operator()(_Tp&& __e) const
 noexcept(noexcept(_End{}(__access::__as_const<_Tp>(__e))))
 requires requires { _End{}(__access::__as_const<_Tp>(__e)); }
 {
   return _End{}(__access::__as_const<_Tp>(__e));
 }

    };

    struct _CRBegin
    {
# 724 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
      template<typename _Tp>
 [[nodiscard]]
 constexpr auto
 operator()(_Tp&& __e) const
 noexcept(noexcept(_RBegin{}(__access::__as_const<_Tp>(__e))))
 requires requires { _RBegin{}(__access::__as_const<_Tp>(__e)); }
 {
   return _RBegin{}(__access::__as_const<_Tp>(__e));
 }

    };

    struct _CREnd
    {
# 752 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
      template<typename _Tp>
 [[nodiscard]]
 constexpr auto
 operator()(_Tp&& __e) const
 noexcept(noexcept(_REnd{}(__access::__as_const<_Tp>(__e))))
 requires requires { _REnd{}(__access::__as_const<_Tp>(__e)); }
 {
   return _REnd{}(__access::__as_const<_Tp>(__e));
 }

    };

    struct _CData
    {
# 775 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
      template<typename _Tp>
 [[nodiscard]]
 constexpr auto
 operator()(_Tp&& __e) const
 noexcept(noexcept(_Data{}(__access::__as_const<_Tp>(__e))))
 requires requires { _Data{}(__access::__as_const<_Tp>(__e)); }
 {
   return _Data{}(__access::__as_const<_Tp>(__e));
 }

    };
  }

  inline namespace _Cpo
  {
    inline constexpr ranges::__access::_CBegin cbegin{};
    inline constexpr ranges::__access::_CEnd cend{};
    inline constexpr ranges::__access::_CRBegin crbegin{};
    inline constexpr ranges::__access::_CREnd crend{};
    inline constexpr ranges::__access::_CData cdata{};
  }

  namespace __detail
  {
    template<typename _Tp>
      inline constexpr bool __is_initializer_list = false;

    template<typename _Tp>
      inline constexpr bool __is_initializer_list<initializer_list<_Tp>> = true;
  }


  template<typename _Tp>
    concept viewable_range = range<_Tp>
      && ((view<remove_cvref_t<_Tp>> && constructible_from<remove_cvref_t<_Tp>, _Tp>)
   || (!view<remove_cvref_t<_Tp>>
       && (is_lvalue_reference_v<_Tp>
    || (movable<remove_reference_t<_Tp>>
        && !__detail::__is_initializer_list<remove_cvref_t<_Tp>>))));



  struct __advance_fn final
  {
    template<input_or_output_iterator _It>
      constexpr void
      operator()(_It& __it, iter_difference_t<_It> __n) const
      {
 if constexpr (random_access_iterator<_It>)
   __it += __n;
 else if constexpr (bidirectional_iterator<_It>)
   {
     if (__n > 0)
       {
  do
    {
      ++__it;
    }
  while (--__n);
       }
     else if (__n < 0)
       {
  do
    {
      --__it;
    }
  while (++__n);
       }
   }
 else
   {

     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n >= 0), false)) std::__glibcxx_assert_fail(); } while (false);
     while (__n-- > 0)
       ++__it;
   }
      }

    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
      constexpr void
      operator()(_It& __it, _Sent __bound) const
      {
 if constexpr (assignable_from<_It&, _Sent>)
   __it = std::move(__bound);
 else if constexpr (sized_sentinel_for<_Sent, _It>)
   (*this)(__it, __bound - __it);
 else
   {
     while (__it != __bound)
       ++__it;
   }
      }

    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
      constexpr iter_difference_t<_It>
      operator()(_It& __it, iter_difference_t<_It> __n, _Sent __bound) const
      {
 if constexpr (sized_sentinel_for<_Sent, _It>)
   {
     const auto __diff = __bound - __it;

     if (__diff == 0)
       return __n;
     else if (__diff > 0 ? __n >= __diff : __n <= __diff)
       {
  (*this)(__it, __bound);
  return __n - __diff;
       }
     else if (__n != 0) [[likely]]
       {

  do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool((__n < 0) == (__diff < 0)), false)) std::__glibcxx_assert_fail(); } while (false);

  (*this)(__it, __n);
  return 0;
       }
     else
       return 0;
   }
 else if (__it == __bound || __n == 0)
   return __n;
 else if (__n > 0)
   {
     iter_difference_t<_It> __m = 0;
     do
       {
  ++__it;
  ++__m;
       }
     while (__m != __n && __it != __bound);
     return __n - __m;
   }
 else if constexpr (bidirectional_iterator<_It> && same_as<_It, _Sent>)
   {
     iter_difference_t<_It> __m = 0;
     do
       {
  --__it;
  --__m;
       }
     while (__m != __n && __it != __bound);
     return __n - __m;
   }
 else
   {

     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n >= 0), false)) std::__glibcxx_assert_fail(); } while (false);
     return __n;
   }
      }

    void operator&() const = delete;
  };

  inline constexpr __advance_fn advance{};

  struct __distance_fn final
  {
    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
      requires (!sized_sentinel_for<_Sent, _It>)
      constexpr iter_difference_t<_It>
      operator()[[nodiscard]](_It __first, _Sent __last) const
      {
 iter_difference_t<_It> __n = 0;
 while (__first != __last)
   {
     ++__first;
     ++__n;
   }
 return __n;
      }

    template<input_or_output_iterator _It, sized_sentinel_for<_It> _Sent>
      [[nodiscard]]
      constexpr iter_difference_t<_It>
      operator()(const _It& __first, const _Sent& __last) const
      {
 return __last - __first;
      }

    template<range _Range>
      [[nodiscard]]
      constexpr range_difference_t<_Range>
      operator()(_Range&& __r) const
      {
 if constexpr (sized_range<_Range>)
   return static_cast<range_difference_t<_Range>>(ranges::size(__r));
 else
   return (*this)(ranges::begin(__r), ranges::end(__r));
      }

    void operator&() const = delete;
  };

  inline constexpr __distance_fn distance{};

  struct __next_fn final
  {
    template<input_or_output_iterator _It>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x) const
      {
 ++__x;
 return __x;
      }

    template<input_or_output_iterator _It>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x, iter_difference_t<_It> __n) const
      {
 ranges::advance(__x, __n);
 return __x;
      }

    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x, _Sent __bound) const
      {
 ranges::advance(__x, __bound);
 return __x;
      }

    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x, iter_difference_t<_It> __n, _Sent __bound) const
      {
 ranges::advance(__x, __n, __bound);
 return __x;
      }

    void operator&() const = delete;
  };

  inline constexpr __next_fn next{};

  struct __prev_fn final
  {
    template<bidirectional_iterator _It>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x) const
      {
 --__x;
 return __x;
      }

    template<bidirectional_iterator _It>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x, iter_difference_t<_It> __n) const
      {
 ranges::advance(__x, -__n);
 return __x;
      }

    template<bidirectional_iterator _It>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x, iter_difference_t<_It> __n, _It __bound) const
      {
 ranges::advance(__x, -__n, __bound);
 return __x;
      }

    void operator&() const = delete;
  };

  inline constexpr __prev_fn prev{};


  struct dangling
  {
    constexpr dangling() noexcept = default;
    template<typename... _Args>
      constexpr dangling(_Args&&...) noexcept { }
  };

  template<range _Range>
    using borrowed_iterator_t = __conditional_t<borrowed_range<_Range>,
      iterator_t<_Range>,
      dangling>;
}







}
# 57 "/usr/include/c++/14.2.1/string_view" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{



  constexpr size_t
  __sv_check(size_t __size, size_t __pos, const char* __s)
  {
    if (__pos > __size)
      __throw_out_of_range_fmt(("%s: __pos (which is %zu) > __size " "(which is %zu)")
                        , __s, __pos, __size);
    return __pos;
  }



  constexpr size_t
  __sv_limit(size_t __size, size_t __pos, size_t __off) noexcept
  {
   const bool __testoff = __off < __size - __pos;
   return __testoff ? __off : __size - __pos;
  }
# 105 "/usr/include/c++/14.2.1/string_view" 3
  template<typename _CharT, typename _Traits = std::char_traits<_CharT>>
    class basic_string_view
    {
      static_assert(!is_array_v<_CharT>);
      static_assert(is_trivial_v<_CharT> && is_standard_layout_v<_CharT>);
      static_assert(is_same_v<_CharT, typename _Traits::char_type>);

    public:


      using traits_type = _Traits;
      using value_type = _CharT;
      using pointer = value_type*;
      using const_pointer = const value_type*;
      using reference = value_type&;
      using const_reference = const value_type&;
      using const_iterator = const value_type*;
      using iterator = const_iterator;
      using const_reverse_iterator = std::reverse_iterator<const_iterator>;
      using reverse_iterator = const_reverse_iterator;
      using size_type = size_t;
      using difference_type = ptrdiff_t;
      static constexpr size_type npos = size_type(-1);



      constexpr
      basic_string_view() noexcept
      : _M_len{0}, _M_str{nullptr}
      { }

      constexpr basic_string_view(const basic_string_view&) noexcept = default;

      [[__gnu__::__nonnull__]]
      constexpr
      basic_string_view(const _CharT* __str) noexcept
      : _M_len{traits_type::length(__str)},
 _M_str{__str}
      { }

      constexpr
      basic_string_view(const _CharT* __str, size_type __len) noexcept
      : _M_len{__len}, _M_str{__str}
      { }


      template<contiguous_iterator _It, sized_sentinel_for<_It> _End>
 requires same_as<iter_value_t<_It>, _CharT>
   && (!convertible_to<_End, size_type>)
 constexpr
 basic_string_view(_It __first, _End __last)
 noexcept(noexcept(__last - __first))
 : _M_len(__last - __first), _M_str(std::to_address(__first))
 { }
# 180 "/usr/include/c++/14.2.1/string_view" 3
      constexpr basic_string_view&
      operator=(const basic_string_view&) noexcept = default;



      [[nodiscard]]
      constexpr const_iterator
      begin() const noexcept
      { return this->_M_str; }

      [[nodiscard]]
      constexpr const_iterator
      end() const noexcept
      { return this->_M_str + this->_M_len; }

      [[nodiscard]]
      constexpr const_iterator
      cbegin() const noexcept
      { return this->_M_str; }

      [[nodiscard]]
      constexpr const_iterator
      cend() const noexcept
      { return this->_M_str + this->_M_len; }

      [[nodiscard]]
      constexpr const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }

      [[nodiscard]]
      constexpr const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }

      [[nodiscard]]
      constexpr const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }

      [[nodiscard]]
      constexpr const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }



      [[nodiscard]]
      constexpr size_type
      size() const noexcept
      { return this->_M_len; }

      [[nodiscard]]
      constexpr size_type
      length() const noexcept
      { return _M_len; }

      [[nodiscard]]
      constexpr size_type
      max_size() const noexcept
      {
 return (npos - sizeof(size_type) - sizeof(void*))
  / sizeof(value_type) / 4;
      }

      [[nodiscard]]
      constexpr bool
      empty() const noexcept
      { return this->_M_len == 0; }



      [[nodiscard]]
      constexpr const_reference
      operator[](size_type __pos) const noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__pos < this->_M_len), false)) std::__glibcxx_assert_fail(); } while (false);
 return *(this->_M_str + __pos);
      }

      [[nodiscard]]
      constexpr const_reference
      at(size_type __pos) const
      {
 if (__pos >= _M_len)
   __throw_out_of_range_fmt(("basic_string_view::at: __pos " "(which is %zu) >= this->size() " "(which is %zu)")

                            , __pos, this->size());
 return *(this->_M_str + __pos);
      }

      [[nodiscard]]
      constexpr const_reference
      front() const noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(this->_M_len > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return *this->_M_str;
      }

      [[nodiscard]]
      constexpr const_reference
      back() const noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(this->_M_len > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return *(this->_M_str + this->_M_len - 1);
      }

      [[nodiscard]]
      constexpr const_pointer
      data() const noexcept
      { return this->_M_str; }



      constexpr void
      remove_prefix(size_type __n) noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(this->_M_len >= __n), false)) std::__glibcxx_assert_fail(); } while (false);
 this->_M_str += __n;
 this->_M_len -= __n;
      }

      constexpr void
      remove_suffix(size_type __n) noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(this->_M_len >= __n), false)) std::__glibcxx_assert_fail(); } while (false);
 this->_M_len -= __n;
      }

      constexpr void
      swap(basic_string_view& __sv) noexcept
      {
 auto __tmp = *this;
 *this = __sv;
 __sv = __tmp;
      }



      constexpr
      size_type
      copy(_CharT* __str, size_type __n, size_type __pos = 0) const
      {
 ;
 __pos = std::__sv_check(size(), __pos, "basic_string_view::copy");
 const size_type __rlen = std::min<size_t>(__n, _M_len - __pos);


 traits_type::copy(__str, data() + __pos, __rlen);
 return __rlen;
      }

      [[nodiscard]]
      constexpr basic_string_view
      substr(size_type __pos = 0, size_type __n = npos) const noexcept(false)
      {
 __pos = std::__sv_check(size(), __pos, "basic_string_view::substr");
 const size_type __rlen = std::min<size_t>(__n, _M_len - __pos);
 return basic_string_view{_M_str + __pos, __rlen};
      }

      [[nodiscard]]
      constexpr int
      compare(basic_string_view __str) const noexcept
      {
 const size_type __rlen = std::min(this->_M_len, __str._M_len);
 int __ret = traits_type::compare(this->_M_str, __str._M_str, __rlen);
 if (__ret == 0)
   __ret = _S_compare(this->_M_len, __str._M_len);
 return __ret;
      }

      [[nodiscard]]
      constexpr int
      compare(size_type __pos1, size_type __n1, basic_string_view __str) const
      { return this->substr(__pos1, __n1).compare(__str); }

      [[nodiscard]]
      constexpr int
      compare(size_type __pos1, size_type __n1,
       basic_string_view __str, size_type __pos2, size_type __n2) const
      {
 return this->substr(__pos1, __n1).compare(__str.substr(__pos2, __n2));
      }

      [[nodiscard, __gnu__::__nonnull__]]
      constexpr int
      compare(const _CharT* __str) const noexcept
      { return this->compare(basic_string_view{__str}); }

      [[nodiscard, __gnu__::__nonnull__]]
      constexpr int
      compare(size_type __pos1, size_type __n1, const _CharT* __str) const
      { return this->substr(__pos1, __n1).compare(basic_string_view{__str}); }

      [[nodiscard]]
      constexpr int
      compare(size_type __pos1, size_type __n1,
       const _CharT* __str, size_type __n2) const noexcept(false)
      {
 return this->substr(__pos1, __n1)
     .compare(basic_string_view(__str, __n2));
      }


      [[nodiscard]]
      constexpr bool
      starts_with(basic_string_view __x) const noexcept
      { return this->substr(0, __x.size()) == __x; }

      [[nodiscard]]
      constexpr bool
      starts_with(_CharT __x) const noexcept
      { return !this->empty() && traits_type::eq(this->front(), __x); }

      [[nodiscard, __gnu__::__nonnull__]]
      constexpr bool
      starts_with(const _CharT* __x) const noexcept
      { return this->starts_with(basic_string_view(__x)); }

      [[nodiscard]]
      constexpr bool
      ends_with(basic_string_view __x) const noexcept
      {
 const auto __len = this->size();
 const auto __xlen = __x.size();
 return __len >= __xlen
   && traits_type::compare(end() - __xlen, __x.data(), __xlen) == 0;
      }

      [[nodiscard]]
      constexpr bool
      ends_with(_CharT __x) const noexcept
      { return !this->empty() && traits_type::eq(this->back(), __x); }

      [[nodiscard, __gnu__::__nonnull__]]
      constexpr bool
      ends_with(const _CharT* __x) const noexcept
      { return this->ends_with(basic_string_view(__x)); }
# 445 "/usr/include/c++/14.2.1/string_view" 3
      [[nodiscard]]
      constexpr size_type
      find(basic_string_view __str, size_type __pos = 0) const noexcept
      { return this->find(__str._M_str, __pos, __str._M_len); }

      [[nodiscard]]
      constexpr size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;

      [[nodiscard]]
      constexpr size_type
      find(const _CharT* __str, size_type __pos, size_type __n) const noexcept;

      [[nodiscard, __gnu__::__nonnull__]]
      constexpr size_type
      find(const _CharT* __str, size_type __pos = 0) const noexcept
      { return this->find(__str, __pos, traits_type::length(__str)); }

      [[nodiscard]]
      constexpr size_type
      rfind(basic_string_view __str, size_type __pos = npos) const noexcept
      { return this->rfind(__str._M_str, __pos, __str._M_len); }

      [[nodiscard]]
      constexpr size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;

      [[nodiscard]]
      constexpr size_type
      rfind(const _CharT* __str, size_type __pos, size_type __n) const noexcept;

      [[nodiscard, __gnu__::__nonnull__]]
      constexpr size_type
      rfind(const _CharT* __str, size_type __pos = npos) const noexcept
      { return this->rfind(__str, __pos, traits_type::length(__str)); }

      [[nodiscard]]
      constexpr size_type
      find_first_of(basic_string_view __str, size_type __pos = 0) const noexcept
      { return this->find_first_of(__str._M_str, __pos, __str._M_len); }

      [[nodiscard]]
      constexpr size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }

      [[nodiscard]]
      constexpr size_type
      find_first_of(const _CharT* __str, size_type __pos,
      size_type __n) const noexcept;

      [[nodiscard, __gnu__::__nonnull__]]
      constexpr size_type
      find_first_of(const _CharT* __str, size_type __pos = 0) const noexcept
      { return this->find_first_of(__str, __pos, traits_type::length(__str)); }

      [[nodiscard]]
      constexpr size_type
      find_last_of(basic_string_view __str,
     size_type __pos = npos) const noexcept
      { return this->find_last_of(__str._M_str, __pos, __str._M_len); }

      [[nodiscard]]
      constexpr size_type
      find_last_of(_CharT __c, size_type __pos=npos) const noexcept
      { return this->rfind(__c, __pos); }

      [[nodiscard]]
      constexpr size_type
      find_last_of(const _CharT* __str, size_type __pos,
     size_type __n) const noexcept;

      [[nodiscard, __gnu__::__nonnull__]]
      constexpr size_type
      find_last_of(const _CharT* __str, size_type __pos = npos) const noexcept
      { return this->find_last_of(__str, __pos, traits_type::length(__str)); }

      [[nodiscard]]
      constexpr size_type
      find_first_not_of(basic_string_view __str,
   size_type __pos = 0) const noexcept
      { return this->find_first_not_of(__str._M_str, __pos, __str._M_len); }

      [[nodiscard]]
      constexpr size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const noexcept;

      [[nodiscard]]
      constexpr size_type
      find_first_not_of(const _CharT* __str,
   size_type __pos, size_type __n) const noexcept;

      [[nodiscard, __gnu__::__nonnull__]]
      constexpr size_type
      find_first_not_of(const _CharT* __str, size_type __pos = 0) const noexcept
      {
 return this->find_first_not_of(__str, __pos,
           traits_type::length(__str));
      }

      [[nodiscard]]
      constexpr size_type
      find_last_not_of(basic_string_view __str,
         size_type __pos = npos) const noexcept
      { return this->find_last_not_of(__str._M_str, __pos, __str._M_len); }

      [[nodiscard]]
      constexpr size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const noexcept;

      [[nodiscard]]
      constexpr size_type
      find_last_not_of(const _CharT* __str,
         size_type __pos, size_type __n) const noexcept;

      [[nodiscard, __gnu__::__nonnull__]]
      constexpr size_type
      find_last_not_of(const _CharT* __str,
         size_type __pos = npos) const noexcept
      {
 return this->find_last_not_of(__str, __pos,
          traits_type::length(__str));
      }

    private:

      static constexpr int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 using __limits = __gnu_cxx::__int_traits<int>;
 const difference_type __diff = __n1 - __n2;
 if (__diff > __limits::__max)
   return __limits::__max;
 if (__diff < __limits::__min)
   return __limits::__min;
 return static_cast<int>(__diff);
      }

      size_t _M_len;
      const _CharT* _M_str;
    };


  template<contiguous_iterator _It, sized_sentinel_for<_It> _End>
    basic_string_view(_It, _End) -> basic_string_view<iter_value_t<_It>>;
# 606 "/usr/include/c++/14.2.1/string_view" 3
  template<typename _CharT, typename _Traits>
    [[nodiscard]]
    constexpr bool
    operator==(basic_string_view<_CharT, _Traits> __x,
        type_identity_t<basic_string_view<_CharT, _Traits>> __y)
    noexcept
    { return __x.size() == __y.size() && __x.compare(__y) == 0; }

  template<typename _CharT, typename _Traits>
    [[nodiscard]]
    constexpr auto
    operator<=>(basic_string_view<_CharT, _Traits> __x,
  __type_identity_t<basic_string_view<_CharT, _Traits>> __y)
    noexcept
    -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))
    { return __detail::__char_traits_cmp_cat<_Traits>(__x.compare(__y)); }
# 758 "/usr/include/c++/14.2.1/string_view" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        basic_string_view<_CharT,_Traits> __str)
    { return __ostream_insert(__os, __str.data(), __str.size()); }




  using string_view = basic_string_view<char>;
  using wstring_view = basic_string_view<wchar_t>;

  using u8string_view = basic_string_view<char8_t>;

  using u16string_view = basic_string_view<char16_t>;
  using u32string_view = basic_string_view<char32_t>;



  template<typename _Tp>
    struct hash;

  template<>
    struct hash<string_view>
    : public __hash_base<size_t, string_view>
    {
      [[nodiscard]]
      size_t
      operator()(const string_view& __str) const noexcept
      { return std::_Hash_impl::hash(__str.data(), __str.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string_view>> : std::false_type
    { };

  template<>
    struct hash<wstring_view>
    : public __hash_base<size_t, wstring_view>
    {
      [[nodiscard]]
      size_t
      operator()(const wstring_view& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring_view>> : std::false_type
    { };


  template<>
    struct hash<u8string_view>
    : public __hash_base<size_t, u8string_view>
    {
      [[nodiscard]]
      size_t
      operator()(const u8string_view& __str) const noexcept
      { return std::_Hash_impl::hash(__str.data(), __str.length()); }
    };

  template<>
    struct __is_fast_hash<hash<u8string_view>> : std::false_type
    { };


  template<>
    struct hash<u16string_view>
    : public __hash_base<size_t, u16string_view>
    {
      [[nodiscard]]
      size_t
      operator()(const u16string_view& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string_view>> : std::false_type
    { };

  template<>
    struct hash<u32string_view>
    : public __hash_base<size_t, u32string_view>
    {
      [[nodiscard]]
      size_t
      operator()(const u32string_view& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string_view>> : std::false_type
    { };

  inline namespace literals
  {
  inline namespace string_view_literals
  {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wliteral-suffix"
    inline constexpr basic_string_view<char>
    operator""sv(const char* __str, size_t __len) noexcept
    { return basic_string_view<char>{__str, __len}; }

    inline constexpr basic_string_view<wchar_t>
    operator""sv(const wchar_t* __str, size_t __len) noexcept
    { return basic_string_view<wchar_t>{__str, __len}; }


    inline constexpr basic_string_view<char8_t>
    operator""sv(const char8_t* __str, size_t __len) noexcept
    { return basic_string_view<char8_t>{__str, __len}; }


    inline constexpr basic_string_view<char16_t>
    operator""sv(const char16_t* __str, size_t __len) noexcept
    { return basic_string_view<char16_t>{__str, __len}; }

    inline constexpr basic_string_view<char32_t>
    operator""sv(const char32_t* __str, size_t __len) noexcept
    { return basic_string_view<char32_t>{__str, __len}; }

#pragma GCC diagnostic pop
  }
  }


  namespace ranges
  {

    template<typename _CharT, typename _Traits>
      inline constexpr bool
 enable_borrowed_range<basic_string_view<_CharT, _Traits>> = true;


    template<typename _CharT, typename _Traits>
      inline constexpr bool
 enable_view<basic_string_view<_CharT, _Traits>> = true;
  }


}

# 1 "/usr/include/c++/14.2.1/bits/string_view.tcc" 1 3
# 37 "/usr/include/c++/14.2.1/bits/string_view.tcc" 3
       
# 38 "/usr/include/c++/14.2.1/bits/string_view.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find(const _CharT* __str, size_type __pos, size_type __n) const noexcept
    {
      ;

      if (__n == 0)
 return __pos <= _M_len ? __pos : npos;
      if (__pos >= _M_len)
 return npos;

      const _CharT __elem0 = __str[0];
      const _CharT* __first = _M_str + __pos;
      const _CharT* const __last = _M_str + _M_len;
      size_type __len = _M_len - __pos;

      while (__len >= __n)
 {

   __first = traits_type::find(__first, __len - __n + 1, __elem0);
   if (!__first)
     return npos;



   if (traits_type::compare(__first, __str, __n) == 0)
     return __first - _M_str;
   __len = __last - ++__first;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      if (__pos < this->_M_len)
 {
   const size_type __n = this->_M_len - __pos;
   const _CharT* __p = traits_type::find(this->_M_str + __pos, __n, __c);
   if (__p)
     __ret = __p - this->_M_str;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    rfind(const _CharT* __str, size_type __pos, size_type __n) const noexcept
    {
      ;

      if (__n <= this->_M_len)
 {
   __pos = std::min(size_type(this->_M_len - __n), __pos);
   do
     {
       if (traits_type::compare(this->_M_str + __pos, __str, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->_M_len;
      if (__size > 0)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(this->_M_str[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_first_of(const _CharT* __str, size_type __pos,
    size_type __n) const noexcept
    {
      ;
      for (; __n && __pos < this->_M_len; ++__pos)
 {
   const _CharT* __p = traits_type::find(__str, __n,
      this->_M_str[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_last_of(const _CharT* __str, size_type __pos,
   size_type __n) const noexcept
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__str, __n, this->_M_str[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_first_not_of(const _CharT* __str, size_type __pos,
        size_type __n) const noexcept
    {
      ;
      for (; __pos < this->_M_len; ++__pos)
 if (!traits_type::find(__str, __n, this->_M_str[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->_M_len; ++__pos)
 if (!traits_type::eq(this->_M_str[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_last_not_of(const _CharT* __str, size_type __pos,
       size_type __n) const noexcept
    {
      ;
      size_type __size = this->_M_len;
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__str, __n, this->_M_str[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->_M_len;
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(this->_M_str[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }


}
# 905 "/usr/include/c++/14.2.1/string_view" 2 3
# 48 "/usr/include/c++/14.2.1/bits/basic_string.h" 2 3






# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 55 "/usr/include/c++/14.2.1/bits/basic_string.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {
# 85 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {

      static_assert(is_same_v<_CharT, typename _Traits::char_type>);
      static_assert(is_same_v<_CharT, typename _Alloc::value_type>);
      using _Char_alloc_type = _Alloc;





      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    protected:




      typedef const_iterator __const_iterator;


    private:
      static constexpr pointer
      _S_allocate(_Char_alloc_type& __a, size_type __n)
      {
 pointer __p = _Alloc_traits::allocate(__a, __n);



 if constexpr (!is_same_v<_Traits, char_traits<_CharT>>)
   if (std::__is_constant_evaluated())

     for (size_type __i = 0; __i < __n; ++__i)
       std::construct_at(__builtin_addressof(__p[__i]));

 return __p;
      }



      typedef basic_string_view<_CharT, _Traits> __sv_type;

      template<typename _Tp, typename _Res>
 using _If_sv = enable_if_t<
   __and_<is_convertible<const _Tp&, __sv_type>,
   __not_<is_convertible<const _Tp*, const basic_string*>>,
   __not_<is_convertible<const _Tp&, const _CharT*>>>::value,
   _Res>;


      constexpr
      static __sv_type
      _S_to_string_view(__sv_type __svt) noexcept
      { return __svt; }





      struct __sv_wrapper
      {
 constexpr explicit
 __sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) { }

 __sv_type _M_sv;
      };







      constexpr
      explicit
      basic_string(__sv_wrapper __svw, const _Alloc& __a)
      : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }



      struct _Alloc_hider : allocator_type
      {




 constexpr
 _Alloc_hider(pointer __dat, const _Alloc& __a)
 : allocator_type(__a), _M_p(__dat) { }

 constexpr
 _Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
 : allocator_type(std::move(__a)), _M_p(__dat) { }


 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      constexpr
      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      constexpr
      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      constexpr
      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      constexpr
      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      constexpr
      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      constexpr
      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      constexpr
      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      constexpr
      bool
      _M_is_local() const
      {
 if (_M_data() == _M_local_data())
   {
     if (_M_string_length > _S_local_capacity)
       __builtin_unreachable();
     return true;
   }
 return false;
      }


      constexpr
      pointer
      _M_create(size_type&, size_type);

      constexpr
      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      constexpr
      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }
# 321 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _InIterator>
 constexpr
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
 constexpr
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      constexpr
      void
      _M_construct(size_type __req, _CharT __c);

      constexpr
      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      constexpr
      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }


      __attribute__((__always_inline__))
      constexpr
      void
      _M_init_local_buf() noexcept
      {

 if (std::is_constant_evaluated())
   for (size_type __i = 0; __i <= _S_local_capacity; ++__i)
     _M_local_buf[__i] = _CharT();

      }

      __attribute__((__always_inline__))
      constexpr
      pointer
      _M_use_local_data() noexcept
      {

 _M_init_local_buf();

 return _M_local_data();
      }

    private:
# 389 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)")
                                         ,
       __s, __pos, this->size());
 return __pos;
      }

      constexpr
      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      constexpr
      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      constexpr
      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      constexpr
      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      constexpr
      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
 constexpr
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, (void)++__p)
     traits_type::assign(*__p, *__k1);
 }

      constexpr
      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      constexpr
      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      constexpr
      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      constexpr
      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      constexpr
      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      constexpr
      void
      _M_assign(const basic_string&);

      constexpr
      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      constexpr
      void
      _M_erase(size_type __pos, size_type __n);

    public:







      constexpr
      basic_string()
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
      : _M_dataplus(_M_local_data())
      {
 _M_init_local_buf();
 _M_set_length(0);
      }




      constexpr
      explicit
      basic_string(const _Alloc& __a) noexcept
      : _M_dataplus(_M_local_data(), __a)
      {
 _M_init_local_buf();
 _M_set_length(0);
      }





      constexpr
      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(),
      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
      {
 _M_construct(__str._M_data(), __str._M_data() + __str.length(),
       std::forward_iterator_tag());
      }
# 568 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string(const basic_string& __str, size_type __pos,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, npos),
       std::forward_iterator_tag());
      }







      constexpr
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n),
       std::forward_iterator_tag());
      }
# 603 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n),
       std::forward_iterator_tag());
      }
# 623 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      {

 if (__s == 0 && __n > 0)
   std::__throw_logic_error(("basic_string: " "construction from null is not valid")
                                                 );
 _M_construct(__s, __s + __n, std::forward_iterator_tag());
      }
# 643 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename = _RequireAllocator<_Alloc>>

      constexpr
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      {

 if (__s == 0)
   std::__throw_logic_error(("basic_string: " "construction from null is not valid")
                                                 );
 const _CharT* __end = __s + traits_type::length(__s);
 _M_construct(__s, __end, forward_iterator_tag());
      }
# 666 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename = _RequireAllocator<_Alloc>>

      constexpr
      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
# 681 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     _M_init_local_buf();
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         __str.length() + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_use_local_data());
 __str._M_set_length(0);
      }






      constexpr
      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end(), std::forward_iterator_tag()); }

      constexpr
      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end(), std::forward_iterator_tag()); }

      constexpr
      basic_string(basic_string&& __str, const _Alloc& __a)
      noexcept(_Alloc_traits::_S_always_equal())
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str._M_is_local())
   {
     _M_init_local_buf();
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         __str.length() + 1);
     _M_length(__str.length());
     __str._M_set_length(0);
   }
 else if (_Alloc_traits::_S_always_equal()
     || __str.get_allocator() == __a)
   {
     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     __str._M_data(__str._M_use_local_data());
     __str._M_set_length(0);
   }
 else
   _M_construct(__str.begin(), __str.end(), std::forward_iterator_tag());
      }
# 759 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



 constexpr
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a), _M_string_length(0)
 {

   _M_construct(__beg, __end, std::__iterator_category(__beg));




 }
# 785 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp,
        typename = enable_if_t<is_convertible_v<const _Tp&, __sv_type>>>
 constexpr
 basic_string(const _Tp& __t, size_type __pos, size_type __n,
       const _Alloc& __a = _Alloc())
 : basic_string(_S_to_string_view(__t).substr(__pos, __n), __a) { }






      template<typename _Tp, typename = _If_sv<_Tp, void>>
 constexpr
 explicit
 basic_string(const _Tp& __t, const _Alloc& __a = _Alloc())
 : basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }





      constexpr
      ~basic_string()
      { _M_dispose(); }





      constexpr
      basic_string&
      operator=(const basic_string& __str)
      {
 return this->assign(__str);
      }





      constexpr
      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 838 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 856 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      operator=(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {
 const bool __equal_allocs = _Alloc_traits::_S_always_equal()
   || _M_get_allocator() == __str._M_get_allocator();
 if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
     && !__equal_allocs)
   {

     _M_destroy(_M_allocated_capacity);
     _M_data(_M_local_data());
     _M_set_length(0);
   }

 std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

 if (__str._M_is_local())
   {



     if (__builtin_expect(std::__addressof(__str) != this, true))
       {
  if (__str.size())
    this->_S_copy(_M_data(), __str._M_data(), __str.size());
  _M_set_length(__str.size());
       }
   }
 else if (_Alloc_traits::_S_propagate_on_move_assign() || __equal_allocs)
   {

     pointer __data = nullptr;
     size_type __capacity;
     if (!_M_is_local())
       {
  if (__equal_allocs)
    {

      __data = _M_data();
      __capacity = _M_allocated_capacity;
    }
  else
    _M_destroy(_M_allocated_capacity);
       }

     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     if (__data)
       {
  __str._M_data(__data);
  __str._M_capacity(__capacity);
       }
     else
       __str._M_data(__str._M_use_local_data());
   }
 else
   assign(__str);
 __str.clear();
 return *this;
      }





      constexpr
      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }







     template<typename _Tp>
       constexpr
       _If_sv<_Tp, basic_string&>
       operator=(const _Tp& __svt)
       { return this->assign(__svt); }





      constexpr
      operator __sv_type() const noexcept
      { return __sv_type(data(), size()); }







      [[__nodiscard__]] constexpr
      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      [[__nodiscard__]] constexpr
      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      [[__nodiscard__]] constexpr
      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      [[__nodiscard__]] constexpr
      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      [[__nodiscard__]] constexpr
      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      [[__nodiscard__]] constexpr
      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      [[__nodiscard__]] constexpr
      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      [[__nodiscard__]] constexpr
      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      [[__nodiscard__]] constexpr
      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      [[__nodiscard__]] constexpr
      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      [[__nodiscard__]] constexpr
      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      [[__nodiscard__]] constexpr
      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      [[__nodiscard__]] constexpr
      size_type
      size() const noexcept
      { return _M_string_length; }



      [[__nodiscard__]] constexpr
      size_type
      length() const noexcept
      { return _M_string_length; }


      [[__nodiscard__]] constexpr
      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
# 1102 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      void
      resize(size_type __n, _CharT __c);
# 1116 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

      constexpr
      void
      shrink_to_fit() noexcept
      { reserve(); }
#pragma GCC diagnostic pop
# 1169 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Operation>
 constexpr void
 __resize_and_overwrite(size_type __n, _Operation __op);






      [[__nodiscard__]] constexpr
      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
# 1203 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      void
      reserve(size_type __res_arg);





      [[deprecated("use shrink_to_fit() instead")]]

      constexpr
      void
      reserve();




      constexpr
      void
      clear() noexcept
      { _M_set_length(0); }





      [[__nodiscard__]] constexpr
      bool
      empty() const noexcept
      { return this->size() == 0; }
# 1245 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      const_reference
      operator[] (size_type __pos) const noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__pos <= size()), false)) std::__glibcxx_assert_fail(); } while (false);
 return _M_data()[__pos];
      }
# 1263 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      reference
      operator[](size_type __pos)
      {


 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__pos <= size()), false)) std::__glibcxx_assert_fail(); } while (false);

 ;
 return _M_data()[__pos];
      }
# 1285 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }
# 1307 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }






      [[__nodiscard__]] constexpr
      reference
      front() noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return operator[](0);
      }





      [[__nodiscard__]] constexpr
      const_reference
      front() const noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return operator[](0);
      }





      [[__nodiscard__]] constexpr
      reference
      back() noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return operator[](this->size() - 1);
      }





      [[__nodiscard__]] constexpr
      const_reference
      back() const noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return operator[](this->size() - 1);
      }
# 1375 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      constexpr
      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      constexpr
      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      constexpr
      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1421 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp>
 constexpr
 _If_sv<_Tp, basic_string&>
 operator+=(const _Tp& __svt)
 { return this->append(__svt); }







      constexpr
      basic_string&
      append(const basic_string& __str)
      { return this->append(__str._M_data(), __str.size()); }
# 1451 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return this->append(__str._M_data()
       + __str._M_check(__pos, "basic_string::append"),
       __str._M_limit(__pos, __n)); }







      constexpr
      basic_string&
      append(const _CharT* __s, size_type __n)
      {
 ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      constexpr
      basic_string&
      append(const _CharT* __s)
      {
 ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
# 1496 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      constexpr
      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1522 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 constexpr



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }







      template<typename _Tp>
 constexpr
        _If_sv<_Tp, basic_string&>
        append(const _Tp& __svt)
        {
          __sv_type __sv = __svt;
          return this->append(__sv.data(), __sv.size());
        }
# 1554 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp>
 constexpr
        _If_sv<_Tp, basic_string&>
 append(const _Tp& __svt, size_type __pos, size_type __n = npos)
 {
   __sv_type __sv = __svt;
   return _M_append(__sv.data()
       + std::__sv_check(__sv.size(), __pos, "basic_string::append"),
       std::__sv_limit(__sv.size(), __pos, __n));
 }






      constexpr
      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      constexpr
      basic_string&
      assign(const basic_string& __str)
      {

 if (_Alloc_traits::_S_propagate_on_copy_assign())
   {
     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
  && _M_get_allocator() != __str._M_get_allocator())
       {


  if (__str.size() <= _S_local_capacity)
    {
      _M_destroy(_M_allocated_capacity);
      _M_data(_M_use_local_data());
      _M_set_length(0);
    }
  else
    {
      const auto __len = __str.size();
      auto __alloc = __str._M_get_allocator();

      auto __ptr = _S_allocate(__alloc, __len + 1);
      _M_destroy(_M_allocated_capacity);
      _M_data(__ptr);
      _M_capacity(__len);
      _M_set_length(__len);
    }
       }
     std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
   }

 this->_M_assign(__str);
 return *this;
      }
# 1632 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      assign(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {


 return *this = std::move(__str);
      }
# 1656 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
# 1673 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
# 1690 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
# 1708 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1722 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wc++17-extensions"
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 constexpr
 basic_string&
 assign(_InputIterator __first, _InputIterator __last)
 {

   if constexpr (contiguous_iterator<_InputIterator>
     && is_same_v<iter_value_t<_InputIterator>, _CharT>)




     {
       ;
       return _M_replace(size_type(0), size(),
    std::__to_address(__first), __last - __first);
     }
   else
     return *this = basic_string(__first, __last, get_allocator());
 }
#pragma GCC diagnostic pop
# 1759 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      assign(initializer_list<_CharT> __l)
      {


 const size_type __n = __l.size();
 if (__n > capacity())
   *this = basic_string(__l.begin(), __l.end(), get_allocator());
 else
   {
     if (__n)
       _S_copy(_M_data(), __l.begin(), __n);
     _M_set_length(__n);
   }
 return *this;
      }
# 1784 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp>
 constexpr
 _If_sv<_Tp, basic_string&>
 assign(const _Tp& __svt)
 {
   __sv_type __sv = __svt;
   return this->assign(__sv.data(), __sv.size());
 }
# 1800 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp>
 constexpr
 _If_sv<_Tp, basic_string&>
 assign(const _Tp& __svt, size_type __pos, size_type __n = npos)
 {
   __sv_type __sv = __svt;
   return _M_replace(size_type(0), this->size(),
       __sv.data()
       + std::__sv_check(__sv.size(), __pos, "basic_string::assign"),
       std::__sv_limit(__sv.size(), __pos, __n));
 }
# 1829 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
# 1872 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 constexpr
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
   ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
# 1909 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      iterator
      insert(const_iterator __p, initializer_list<_CharT> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }
# 1937 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
# 1961 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n = npos)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
# 1985 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
# 2005 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
# 2030 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 2049 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
# 2066 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp>
 constexpr
 _If_sv<_Tp, basic_string&>
 insert(size_type __pos, const _Tp& __svt)
 {
   __sv_type __sv = __svt;
   return this->insert(__pos, __sv.data(), __sv.size());
 }
# 2083 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp>
 constexpr
 _If_sv<_Tp, basic_string&>
 insert(size_type __pos1, const _Tp& __svt,
        size_type __pos2, size_type __n = npos)
 {
   __sv_type __sv = __svt;
   return this->replace(__pos1, size_type(0),
       __sv.data()
       + std::__sv_check(__sv.size(), __pos2, "basic_string::insert"),
       std::__sv_limit(__sv.size(), __pos2, __n));
 }
# 2112 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_check(__pos, "basic_string::erase");
 if (__n == npos)
   this->_M_set_length(__pos);
 else if (__n != 0)
   this->_M_erase(__pos, _M_limit(__pos, __n));
 return *this;
      }
# 2132 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
# 2152 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 if (__last == end())
   this->_M_set_length(__pos);
 else
   this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      constexpr
      void
      pop_back() noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 _M_erase(size() - 1, 1);
      }
# 2198 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 2221 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 2247 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
 ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
# 2273 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 2298 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 2317 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 2338 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
# 2361 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 2383 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
# 2409 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 constexpr
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                        ;
   ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
# 2442 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      constexpr
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      constexpr
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      constexpr
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 2505 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }
# 2519 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp>
 constexpr
 _If_sv<_Tp, basic_string&>
 replace(size_type __pos, size_type __n, const _Tp& __svt)
 {
   __sv_type __sv = __svt;
   return this->replace(__pos, __n, __sv.data(), __sv.size());
 }
# 2537 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp>
 constexpr
 _If_sv<_Tp, basic_string&>
 replace(size_type __pos1, size_type __n1, const _Tp& __svt,
  size_type __pos2, size_type __n2 = npos)
 {
   __sv_type __sv = __svt;
   return this->replace(__pos1, __n1,
       __sv.data()
       + std::__sv_check(__sv.size(), __pos2, "basic_string::replace"),
       std::__sv_limit(__sv.size(), __pos2, __n2));
 }
# 2559 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp>
 constexpr
 _If_sv<_Tp, basic_string&>
 replace(const_iterator __i1, const_iterator __i2, const _Tp& __svt)
 {
   __sv_type __sv = __svt;
   return this->replace(__i1 - begin(), __i2 - __i1, __sv);
 }


    private:
      template<class _Integer>
 constexpr
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 constexpr
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      constexpr
      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      __attribute__((__noinline__, __noclone__, __cold__)) void
      _M_replace_cold(pointer __p, size_type __len1, const _CharT* __s,
        const size_type __len2, const size_type __how_much);

      constexpr
      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      constexpr
      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
# 2616 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 2627 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      constexpr
      void
      swap(basic_string& __s) noexcept;
# 2638 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }
# 2651 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      const _CharT*
      data() const noexcept
      { return _M_data(); }
# 2663 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      _CharT*
      data() noexcept
      { return _M_data(); }





      [[__nodiscard__]] constexpr
      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
# 2689 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2704 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 2717 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp>
 [[__nodiscard__]] constexpr
 _If_sv<_Tp, size_type>
 find(const _Tp& __svt, size_type __pos = 0) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find(__sv.data(), __pos, __sv.size());
 }
# 2738 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find(const _CharT* __s, size_type __pos = 0) const noexcept
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 2756 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 2770 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 2783 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp>
 [[__nodiscard__]] constexpr
 _If_sv<_Tp, size_type>
 rfind(const _Tp& __svt, size_type __pos = npos) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->rfind(__sv.data(), __pos, __sv.size());
 }
# 2806 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2821 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 2839 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 2854 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 2868 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp>
 [[__nodiscard__]] constexpr
 _If_sv<_Tp, size_type>
 find_first_of(const _Tp& __svt, size_type __pos = 0) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find_first_of(__sv.data(), __pos, __sv.size());
 }
# 2891 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2906 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2927 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2943 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2957 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp>
 [[__nodiscard__]] constexpr
 _If_sv<_Tp, size_type>
 find_last_of(const _Tp& __svt, size_type __pos = npos) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find_last_of(__sv.data(), __pos, __sv.size());
 }
# 2980 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2995 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 3016 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 3031 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 3045 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp>
 [[__nodiscard__]] constexpr
 _If_sv<_Tp, size_type>
 find_first_not_of(const _Tp& __svt, size_type __pos = 0) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find_first_not_of(__sv.data(), __pos, __sv.size());
 }
# 3068 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const noexcept;
# 3083 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 3102 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
      noexcept;
# 3118 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 3132 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp>
 [[__nodiscard__]] constexpr
 _If_sv<_Tp, size_type>
 find_last_not_of(const _Tp& __svt, size_type __pos = npos) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find_last_not_of(__sv.data(), __pos, __sv.size());
 }
# 3155 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const noexcept;
# 3170 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 3189 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
      noexcept;
# 3206 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 3226 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }







      template<typename _Tp>
 [[__nodiscard__]] constexpr
 _If_sv<_Tp, int>
 compare(const _Tp& __svt) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   const size_type __size = this->size();
   const size_type __osize = __sv.size();
   const size_type __len = std::min(__size, __osize);

   int __r = traits_type::compare(_M_data(), __sv.data(), __len);
   if (!__r)
     __r = _S_compare(__size, __osize);
   return __r;
 }
# 3271 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp>
 [[__nodiscard__]] constexpr
 _If_sv<_Tp, int>
 compare(size_type __pos, size_type __n, const _Tp& __svt) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return __sv_type(*this).substr(__pos, __n).compare(__sv);
 }
# 3291 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename _Tp>
 [[__nodiscard__]] constexpr
 _If_sv<_Tp, int>
 compare(size_type __pos1, size_type __n1, const _Tp& __svt,
  size_type __pos2, size_type __n2 = npos) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return __sv_type(*this)
     .substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
 }
# 3323 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const
      {
 _M_check(__pos, "basic_string::compare");
 __n = _M_limit(__pos, __n);
 const size_type __osize = __str.size();
 const size_type __len = std::min(__n, __osize);
 int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
 if (!__r)
   __r = _S_compare(__n, __osize);
 return __r;
      }
# 3360 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos) const
      {
 _M_check(__pos1, "basic_string::compare");
 __str._M_check(__pos2, "basic_string::compare");
 __n1 = _M_limit(__pos1, __n1);
 __n2 = __str._M_limit(__pos2, __n2);
 const size_type __len = std::min(__n1, __n2);
 int __r = traits_type::compare(_M_data() + __pos1,
           __str.data() + __pos2, __len);
 if (!__r)
   __r = _S_compare(__n1, __n2);
 return __r;
      }
# 3391 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      int
      compare(const _CharT* __s) const noexcept
      {
 ;
 const size_type __size = this->size();
 const size_type __osize = traits_type::length(__s);
 const size_type __len = std::min(__size, __osize);
 int __r = traits_type::compare(_M_data(), __s, __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 3426 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const
      {
 ;
 _M_check(__pos, "basic_string::compare");
 __n1 = _M_limit(__pos, __n1);
 const size_type __osize = traits_type::length(__s);
 const size_type __len = std::min(__n1, __osize);
 int __r = traits_type::compare(_M_data() + __pos, __s, __len);
 if (!__r)
   __r = _S_compare(__n1, __osize);
 return __r;
      }
# 3465 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      [[__nodiscard__]] constexpr
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const
      {
 ;
 _M_check(__pos, "basic_string::compare");
 __n1 = _M_limit(__pos, __n1);
 const size_type __len = std::min(__n1, __n2);
 int __r = traits_type::compare(_M_data() + __pos, __s, __len);
 if (!__r)
   __r = _S_compare(__n1, __n2);
 return __r;
      }


      [[nodiscard]]
      constexpr bool
      starts_with(basic_string_view<_CharT, _Traits> __x) const noexcept
      { return __sv_type(this->data(), this->size()).starts_with(__x); }

      [[nodiscard]]
      constexpr bool
      starts_with(_CharT __x) const noexcept
      { return __sv_type(this->data(), this->size()).starts_with(__x); }

      [[nodiscard, __gnu__::__nonnull__]]
      constexpr bool
      starts_with(const _CharT* __x) const noexcept
      { return __sv_type(this->data(), this->size()).starts_with(__x); }

      [[nodiscard]]
      constexpr bool
      ends_with(basic_string_view<_CharT, _Traits> __x) const noexcept
      { return __sv_type(this->data(), this->size()).ends_with(__x); }

      [[nodiscard]]
      constexpr bool
      ends_with(_CharT __x) const noexcept
      { return __sv_type(this->data(), this->size()).ends_with(__x); }

      [[nodiscard, __gnu__::__nonnull__]]
      constexpr bool
      ends_with(const _CharT* __x) const noexcept
      { return __sv_type(this->data(), this->size()).ends_with(__x); }
# 3530 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
      template<typename, typename, typename> friend class basic_stringbuf;
    };
}

}


namespace std __attribute__ ((__visibility__ ("default")))
{



namespace __cxx11 {
  template<typename _InputIterator, typename _CharT
      = typename iterator_traits<_InputIterator>::value_type,
    typename _Allocator = allocator<_CharT>,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator())
      -> basic_string<_CharT, char_traits<_CharT>, _Allocator>;



  template<typename _CharT, typename _Traits,
    typename _Allocator = allocator<_CharT>,
    typename = _RequireAllocator<_Allocator>>
    basic_string(basic_string_view<_CharT, _Traits>, const _Allocator& = _Allocator())
      -> basic_string<_CharT, _Traits, _Allocator>;

  template<typename _CharT, typename _Traits,
    typename _Allocator = allocator<_CharT>,
    typename = _RequireAllocator<_Allocator>>
    basic_string(basic_string_view<_CharT, _Traits>,
   typename basic_string<_CharT, _Traits, _Allocator>::size_type,
   typename basic_string<_CharT, _Traits, _Allocator>::size_type,
   const _Allocator& = _Allocator())
      -> basic_string<_CharT, _Traits, _Allocator>;
}


  template<typename _Str>
    constexpr
    inline _Str
    __str_concat(typename _Str::value_type const* __lhs,
   typename _Str::size_type __lhs_len,
   typename _Str::value_type const* __rhs,
   typename _Str::size_type __rhs_len,
   typename _Str::allocator_type const& __a)
    {
      typedef typename _Str::allocator_type allocator_type;
      typedef __gnu_cxx::__alloc_traits<allocator_type> _Alloc_traits;
      _Str __str(_Alloc_traits::_S_select_on_copy(__a));
      __str.reserve(__lhs_len + __rhs_len);
      __str.append(__lhs, __lhs_len);
      __str.append(__rhs, __rhs_len);
      return __str;
    }
# 3595 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    [[__nodiscard__]] constexpr
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> _Str;
      return std::__str_concat<_Str>(__lhs.c_str(), __lhs.size(),
         __rhs.c_str(), __rhs.size(),
         __lhs.get_allocator());
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    [[__nodiscard__]] constexpr
    inline basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> _Str;
      return std::__str_concat<_Str>(__lhs, _Traits::length(__lhs),
         __rhs.c_str(), __rhs.size(),
         __rhs.get_allocator());
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    [[__nodiscard__]] constexpr
    inline basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> _Str;
      return std::__str_concat<_Str>(__builtin_addressof(__lhs), 1,
         __rhs.c_str(), __rhs.size(),
         __rhs.get_allocator());
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    [[__nodiscard__]] constexpr
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> _Str;
      return std::__str_concat<_Str>(__lhs.c_str(), __lhs.size(),
         __rhs, _Traits::length(__rhs),
         __lhs.get_allocator());
    }






  template<typename _CharT, typename _Traits, typename _Alloc>
    [[__nodiscard__]] constexpr
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> _Str;
      return std::__str_concat<_Str>(__lhs.c_str(), __lhs.size(),
         __builtin_addressof(__rhs), 1,
         __lhs.get_allocator());
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    [[__nodiscard__]] constexpr
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    [[__nodiscard__]] constexpr
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {

      using _Alloc_traits = allocator_traits<_Alloc>;
      bool __use_rhs = false;
      if constexpr (typename _Alloc_traits::is_always_equal{})
 __use_rhs = true;
      else if (__lhs.get_allocator() == __rhs.get_allocator())
 __use_rhs = true;
      if (__use_rhs)

 {
   const auto __size = __lhs.size() + __rhs.size();
   if (__size > __lhs.capacity() && __size <= __rhs.capacity())
     return std::move(__rhs.insert(0, __lhs));
 }
      return std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    [[__nodiscard__]] [[__nodiscard__]] constexpr
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    [[__nodiscard__]] constexpr
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    [[__nodiscard__]] constexpr
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    [[__nodiscard__]] constexpr
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 3752 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    [[__nodiscard__]] constexpr
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    {
      return __lhs.size() == __rhs.size()
        && !_Traits::compare(__lhs.data(), __rhs.data(), __lhs.size());
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    [[__nodiscard__]] constexpr
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    {
      return __lhs.size() == _Traits::length(__rhs)
        && !_Traits::compare(__lhs.data(), __rhs, __lhs.size());
    }
# 3787 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    [[nodiscard]]
    constexpr auto
    operator<=>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
  const basic_string<_CharT, _Traits, _Alloc>& __rhs) noexcept
    -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))
    { return __detail::__char_traits_cmp_cat<_Traits>(__lhs.compare(__rhs)); }
# 3802 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    [[nodiscard]]
    constexpr auto
    operator<=>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
  const _CharT* __rhs) noexcept
    -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))
    { return __detail::__char_traits_cmp_cat<_Traits>(__lhs.compare(__rhs)); }
# 4036 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }
# 4057 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 4075 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 4098 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 4115 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}



# 1 "/usr/include/c++/14.2.1/ext/string_conversions.h" 1 3
# 32 "/usr/include/c++/14.2.1/ext/string_conversions.h" 3
       
# 33 "/usr/include/c++/14.2.1/ext/string_conversions.h" 3
# 43 "/usr/include/c++/14.2.1/ext/string_conversions.h" 3
# 1 "/usr/include/c++/14.2.1/cstdlib" 1 3
# 39 "/usr/include/c++/14.2.1/cstdlib" 3
       
# 40 "/usr/include/c++/14.2.1/cstdlib" 3
# 79 "/usr/include/c++/14.2.1/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 26 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {





# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 59 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 98 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) noexcept (true) ;



extern double atof (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) noexcept (true) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 141 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 177 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));






extern long int strtol (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtol")


     __attribute__ ((__nonnull__ (1)));
extern unsigned long int strtoul (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoul")



     __attribute__ ((__nonnull__ (1)));

__extension__
extern long long int strtoq (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoll")


     __attribute__ ((__nonnull__ (1)));
__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoull")



     __attribute__ ((__nonnull__ (1)));

__extension__
extern long long int strtoll (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoll")


     __attribute__ ((__nonnull__ (1)));
__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoull")



     __attribute__ ((__nonnull__ (1)));
# 278 "/usr/include/stdlib.h" 3 4
extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 298 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 340 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));





extern long int strtol_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_strtol_l")



     __attribute__ ((__nonnull__ (1, 4)));
extern unsigned long int strtoul_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_strtoul_l")




     __attribute__ ((__nonnull__ (1, 4)));
__extension__
extern long long int strtoll_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_strtoll_l")




     __attribute__ ((__nonnull__ (1, 4)));
__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_strtoull_l")




     __attribute__ ((__nonnull__ (1, 4)));
# 415 "/usr/include/stdlib.h" 3 4
extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 436 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 505 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) noexcept (true) ;


extern long int a64l (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 27 "/usr/include/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;
# 103 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 134 "/usr/include/sys/types.h" 3 4
typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 145 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 33 "/usr/include/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/select.h" 1 3 4
# 30 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/types/sigset_t.h" 1 3 4






typedef __sigset_t sigset_t;
# 34 "/usr/include/sys/select.h" 2 3 4
# 49 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/sys/select.h" 3 4
extern "C" {
# 102 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 127 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 153 "/usr/include/sys/select.h" 3 4
}
# 180 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
# 230 "/usr/include/sys/types.h" 3 4
}
# 515 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) noexcept (true);


extern void srandom (unsigned int __seed) noexcept (true);





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) noexcept (true) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) noexcept (true);

extern void srand (unsigned int __seed) noexcept (true);



extern int rand_r (unsigned int *__seed) noexcept (true);







extern double drand48 (void) noexcept (true);
extern double erand48 (unsigned short int __xsubi[3]) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) noexcept (true);
extern long int nrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) noexcept (true);
extern long int jrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) noexcept (true);
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) noexcept (true) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern __uint32_t arc4random (void)
     noexcept (true) ;


extern void arc4random_buf (void *__buf, size_t __size)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern __uint32_t arc4random_uniform (__uint32_t __upper_bound)
     noexcept (true) ;




extern void *malloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));


extern void free (void *__ptr) noexcept (true);







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)))
    __attribute__ ((__malloc__ (__builtin_free, 1)));


extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__malloc__ (reallocarray, 1)));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) noexcept (true);





}
# 707 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__alloc_align__ (1)))
     __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) noexcept (true) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) noexcept (true) __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     noexcept (true) __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 749 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void _Exit (int __status) noexcept (true) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) noexcept (true);
# 814 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1)));
# 827 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 837 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 849 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 859 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 870 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 881 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 891 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 901 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 913 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 923 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__malloc__))
     __attribute__ ((__malloc__ (__builtin_free, 1))) ;
# 940 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) noexcept (true) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) noexcept (true) __attribute__ ((__const__)) ;
extern long int labs (long int __x) noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     noexcept (true) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
# 1012 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) noexcept (true);


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) noexcept (true);


extern int wctomb (char *__s, wchar_t __wchar) noexcept (true);



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) noexcept (true)
    __attribute__ ((__access__ (__read_only__, 2)));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     noexcept (true)
  __attribute__ ((__access__ (__write_only__, 1, 3)))
  __attribute__ ((__access__ (__read_only__, 2)));






extern int rpmatch (const char *__response) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 1099 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) noexcept (true);



extern int unlockpt (int __fd) noexcept (true);




extern char *ptsname (int __fd) noexcept (true) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1155 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/stdlib-float.h" 1 3 4
# 1156 "/usr/include/stdlib.h" 2 3 4
# 1167 "/usr/include/stdlib.h" 3 4
}
# 80 "/usr/include/c++/14.2.1/cstdlib" 2 3

# 1 "/usr/include/c++/14.2.1/bits/std_abs.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/std_abs.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/std_abs.h" 3
# 46 "/usr/include/c++/14.2.1/bits/std_abs.h" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
# 70 "/usr/include/c++/14.2.1/bits/std_abs.h" 3
  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }



  __extension__ inline constexpr __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 135 "/usr/include/c++/14.2.1/bits/std_abs.h" 3
  __extension__ inline constexpr
  __float128
  abs(__float128 __x)
  {



    return __builtin_fabsf128(__x);




  }



}
}
# 82 "/usr/include/c++/14.2.1/cstdlib" 2 3
# 125 "/usr/include/c++/14.2.1/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;

  using ::aligned_alloc;

  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) noexcept { return ldiv(__i, __j); }




}
# 199 "/usr/include/c++/14.2.1/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 231 "/usr/include/c++/14.2.1/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
# 275 "/usr/include/c++/14.2.1/cstdlib" 3
}
# 44 "/usr/include/c++/14.2.1/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/14.2.1/cwchar" 1 3
# 39 "/usr/include/c++/14.2.1/cwchar" 3
       
# 40 "/usr/include/c++/14.2.1/cwchar" 3
# 45 "/usr/include/c++/14.2.1/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/14.2.1/cstdio" 1 3
# 39 "/usr/include/c++/14.2.1/cstdio" 3
       
# 40 "/usr/include/c++/14.2.1/cstdio" 3


# 1 "/usr/include/stdio.h" 1 3 4
# 28 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 29 "/usr/include/stdio.h" 2 3 4

extern "C" {



# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 35 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stdarg.h" 1 3 4
# 38 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/bits/types/__fpos_t.h" 1 3 4
# 10 "/usr/include/bits/types/__fpos_t.h" 3 4
typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 42 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  struct _IO_FILE **_prevchain;
  int _mode;

  char _unused2[15 * sizeof (int) - 5 * sizeof (void *)];
};
# 45 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 48 "/usr/include/stdio.h" 2 3 4
# 85 "/usr/include/stdio.h" 3 4
typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 129 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 130 "/usr/include/stdio.h" 2 3 4
# 149 "/usr/include/stdio.h" 3 4
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) noexcept (true);

extern int rename (const char *__old, const char *__new) noexcept (true);



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) noexcept (true);
# 176 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) noexcept (true);






extern int fclose (FILE *__stream) __attribute__ ((__nonnull__ (1)));
# 194 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;
# 206 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void)
   __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;



extern char *tmpnam (char[20]) noexcept (true) ;




extern char *tmpnam_r (char __s[20]) noexcept (true) ;
# 228 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
   noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (__builtin_free, 1)));






extern int fflush (FILE *__stream);
# 245 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 255 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 264 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) __attribute__ ((__nonnull__ (3)));
# 289 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) __attribute__ ((__nonnull__ (3)));




extern FILE *fdopen (int __fd, const char *__modes) noexcept (true)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) noexcept (true)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) noexcept (true)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;





extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) noexcept (true)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1)));





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) noexcept (true)
  __attribute__ ((__nonnull__ (1)));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void setlinebuf (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...) __attribute__ ((__nonnull__ (1)));




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) noexcept (true);





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nonnull__ (1)));




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) noexcept (true);



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) __attribute__ ((__nonnull__ (1)));




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) noexcept (true);
# 442 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc23_fscanf")

                                __attribute__ ((__nonnull__ (1)));
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc23_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) noexcept (true) __asm__ ("" "__isoc23_sscanf")

                      ;
# 490 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__nonnull__ (1)));





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__scanf__, 2, 0)));






extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc23_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__nonnull__ (1)));
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc23_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept (true) __asm__ ("" "__isoc23_vsscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 575 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream) __attribute__ ((__nonnull__ (1)));
extern int getc (FILE *__stream) __attribute__ ((__nonnull__ (1)));





extern int getchar (void);






extern int getc_unlocked (FILE *__stream) __attribute__ ((__nonnull__ (1)));
extern int getchar_unlocked (void);
# 600 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream) __attribute__ ((__nonnull__ (1)));
# 611 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));
extern int putc (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));





extern int putchar (int __c);
# 627 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));







extern int putc_unlocked (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream) __attribute__ ((__nonnull__ (1)));


extern int putw (int __w, FILE *__stream) __attribute__ ((__nonnull__ (2)));







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__access__ (__write_only__, 1, 2))) __attribute__ ((__nonnull__ (3)));
# 677 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream)
    __attribute__ ((__access__ (__write_only__, 1, 2))) __attribute__ ((__nonnull__ (3)));
# 689 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) __attribute__ ((__nonnull__ (4)));
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) __attribute__ ((__nonnull__ (4)));


extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) __attribute__ ((__nonnull__ (3)));







extern int fputs (const char *__restrict __s, FILE *__restrict __stream)
  __attribute__ ((__nonnull__ (2)));





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream)
  __attribute__ ((__nonnull__ (4)));




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s) __attribute__ ((__nonnull__ (4)));
# 745 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream) __attribute__ ((__nonnull__ (2)));
# 756 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream)
  __attribute__ ((__nonnull__ (4)));
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream)
  __attribute__ ((__nonnull__ (4)));







extern int fseek (FILE *__stream, long int __off, int __whence)
  __attribute__ ((__nonnull__ (1)));




extern long int ftell (FILE *__stream) __attribute__ ((__nonnull__ (1)));




extern void rewind (FILE *__stream) __attribute__ ((__nonnull__ (1)));
# 793 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence)
  __attribute__ ((__nonnull__ (1)));




extern __off_t ftello (FILE *__stream) __attribute__ ((__nonnull__ (1)));
# 819 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos)
  __attribute__ ((__nonnull__ (1)));




extern int fsetpos (FILE *__stream, const fpos_t *__pos) __attribute__ ((__nonnull__ (1)));
# 841 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence)
  __attribute__ ((__nonnull__ (1)));
extern __off64_t ftello64 (FILE *__stream) __attribute__ ((__nonnull__ (1)));
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos)
  __attribute__ ((__nonnull__ (1)));
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos) __attribute__ ((__nonnull__ (1)));



extern void clearerr (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));

extern int feof (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));

extern int ferror (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern void clearerr_unlocked (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));
extern int feof_unlocked (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));
extern int ferror_unlocked (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));







extern void perror (const char *__s) __attribute__ ((__cold__));




extern int fileno (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int fileno_unlocked (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));
# 887 "/usr/include/stdio.h" 3 4
extern int pclose (FILE *__stream) __attribute__ ((__nonnull__ (1)));





extern FILE *popen (const char *__command, const char *__modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (pclose, 1))) ;






extern char *ctermid (char *__s) noexcept (true)
  __attribute__ ((__access__ (__write_only__, 1)));





extern char *cuserid (char *__s)
  __attribute__ ((__access__ (__write_only__, 1)));




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int ftrylockfile (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void funlockfile (FILE *__stream) noexcept (true) __attribute__ ((__nonnull__ (1)));
# 949 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 973 "/usr/include/stdio.h" 3 4
}
# 43 "/usr/include/c++/14.2.1/cstdio" 2 3
# 96 "/usr/include/c++/14.2.1/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;




  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 157 "/usr/include/c++/14.2.1/cstdio" 3
namespace __gnu_cxx
{
# 175 "/usr/include/c++/14.2.1/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 46 "/usr/include/c++/14.2.1/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/14.2.1/cerrno" 1 3
# 39 "/usr/include/c++/14.2.1/cerrno" 3
       
# 40 "/usr/include/c++/14.2.1/cerrno" 3


# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/bits/errno.h" 1 3 4
# 26 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4





extern "C" {


extern int *__errno_location (void) noexcept (true) __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;

# 1 "/usr/include/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4



}
# 43 "/usr/include/c++/14.2.1/cerrno" 2 3
# 47 "/usr/include/c++/14.2.1/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;

      struct _Save_errno {
 _Save_errno() : _M_errno((*__errno_location ())) { (*__errno_location ()) = 0; }
 ~_Save_errno() { if ((*__errno_location ()) == 0) (*__errno_location ()) = _M_errno; }
 int _M_errno;
      } const __save_errno;

      struct _Range_chk {
   static bool
   _S_chk(_TRet, std::false_type) { return false; }

   static bool
   _S_chk(_TRet __val, std::true_type)
   {
     return __val < _TRet(__numeric_traits<int>::__min)
       || __val > _TRet(__numeric_traits<int>::__max);
   }
      };

      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
   || _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>{}))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 4155 "/usr/include/c++/14.2.1/bits/basic_string.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/charconv.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/charconv.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/charconv.h" 3






namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __detail
{


  template<typename _Tp>
    constexpr bool __integer_to_chars_is_unsigned
      = ! __gnu_cxx::__int_traits<_Tp>::__is_signed;



  template<typename _Tp>
    constexpr unsigned
    __to_chars_len(_Tp __value, int __base = 10) noexcept
    {

      static_assert(__integer_to_chars_is_unsigned<_Tp>, "implementation bug");


      unsigned __n = 1;
      const unsigned __b2 = __base * __base;
      const unsigned __b3 = __b2 * __base;
      const unsigned long __b4 = __b3 * __base;
      for (;;)
 {
   if (__value < (unsigned)__base) return __n;
   if (__value < __b2) return __n + 1;
   if (__value < __b3) return __n + 2;
   if (__value < __b4) return __n + 3;
   __value /= __b4;
   __n += 4;
 }
    }




  template<typename _Tp>
    void
    __to_chars_10_impl(char* __first, unsigned __len, _Tp __val) noexcept
    {

      static_assert(__integer_to_chars_is_unsigned<_Tp>, "implementation bug");


      constexpr char __digits[201] =
 "0001020304050607080910111213141516171819"
 "2021222324252627282930313233343536373839"
 "4041424344454647484950515253545556575859"
 "6061626364656667686970717273747576777879"
 "8081828384858687888990919293949596979899";
      unsigned __pos = __len - 1;
      while (__val >= 100)
 {
   auto const __num = (__val % 100) * 2;
   __val /= 100;
   __first[__pos] = __digits[__num + 1];
   __first[__pos - 1] = __digits[__num];
   __pos -= 2;
 }
      if (__val >= 10)
 {
   auto const __num = __val * 2;
   __first[1] = __digits[__num + 1];
   __first[0] = __digits[__num];
 }
      else
 __first[0] = '0' + __val;
    }

}

}
# 4156 "/usr/include/c++/14.2.1/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {


  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }


  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }
# 4198 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }



  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }
# 4226 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }
# 4238 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
  [[__nodiscard__]]
  inline string
  to_string(int __val)

  noexcept

  {
    const bool __neg = __val < 0;
    const unsigned __uval = __neg ? (unsigned)~__val + 1u : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str;
    __str.__resize_and_overwrite(__neg + __len, [=](char* __p, size_t __n) {
      __p[0] = '-';
      __detail::__to_chars_10_impl(__p + (int)__neg, __len, __uval);
      return __n;
    });
    return __str;
  }

  [[__nodiscard__]]
  inline string
  to_string(unsigned __val)

  noexcept

  {
    const auto __len = __detail::__to_chars_len(__val);
    string __str;
    __str.__resize_and_overwrite(__len, [__val](char* __p, size_t __n) {
      __detail::__to_chars_10_impl(__p, __n, __val);
      return __n;
    });
    return __str;
  }

  [[__nodiscard__]]
  inline string
  to_string(long __val)



  {
    const bool __neg = __val < 0;
    const unsigned long __uval = __neg ? (unsigned long)~__val + 1ul : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str;
    __str.__resize_and_overwrite(__neg + __len, [=](char* __p, size_t __n) {
      __p[0] = '-';
      __detail::__to_chars_10_impl(__p + (int)__neg, __len, __uval);
      return __n;
    });
    return __str;
  }

  [[__nodiscard__]]
  inline string
  to_string(unsigned long __val)



  {
    const auto __len = __detail::__to_chars_len(__val);
    string __str;
    __str.__resize_and_overwrite(__len, [__val](char* __p, size_t __n) {
      __detail::__to_chars_10_impl(__p, __n, __val);
      return __n;
    });
    return __str;
  }

  [[__nodiscard__]]
  inline string
  to_string(long long __val)
  {
    const bool __neg = __val < 0;
    const unsigned long long __uval
      = __neg ? (unsigned long long)~__val + 1ull : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str;
    __str.__resize_and_overwrite(__neg + __len, [=](char* __p, size_t __n) {
      __p[0] = '-';
      __detail::__to_chars_10_impl(__p + (int)__neg, __len, __uval);
      return __n;
    });
    return __str;
  }

  [[__nodiscard__]]
  inline string
  to_string(unsigned long long __val)
  {
    const auto __len = __detail::__to_chars_len(__val);
    string __str;
    __str.__resize_and_overwrite(__len, [__val](char* __p, size_t __n) {
      __detail::__to_chars_10_impl(__p, __n, __val);
      return __n;
    });
    return __str;
  }
# 4399 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
  [[__nodiscard__]]
  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  [[__nodiscard__]]
  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  [[__nodiscard__]]
  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }



  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wc++17-extensions"
  constexpr
  inline void
  __to_wstring_numeric(const char* __s, int __len, wchar_t* __wout)
  {


    if constexpr (wchar_t('0') == L'0' && wchar_t('-') == L'-'
      && wchar_t('.') == L'.' && wchar_t('e') == L'e')
      {
 for (int __i = 0; __i < __len; ++__i)
   __wout[__i] = (wchar_t) __s[__i];
      }
    else
      {
 wchar_t __wc[256];
 for (int __i = '0'; __i <= '9'; ++__i)
   __wc[__i] = L'0' + __i;
 __wc['.'] = L'.';
 __wc['+'] = L'+';
 __wc['-'] = L'-';
 __wc['a'] = L'a';
 __wc['b'] = L'b';
 __wc['c'] = L'c';
 __wc['d'] = L'd';
 __wc['e'] = L'e';
 __wc['f'] = L'f';
 __wc['n'] = L'n';
 __wc['p'] = L'p';
 __wc['x'] = L'x';
 __wc['A'] = L'A';
 __wc['B'] = L'B';
 __wc['C'] = L'C';
 __wc['D'] = L'D';
 __wc['E'] = L'E';
 __wc['F'] = L'F';
 __wc['N'] = L'N';
 __wc['P'] = L'P';
 __wc['X'] = L'X';

 for (int __i = 0; __i < __len; ++__i)
   __wout[__i] = __wc[(int)__s[__i]];
      }
  }


  constexpr

  inline wstring

  __to_wstring_numeric(string_view __s)



  {
    if constexpr (wchar_t('0') == L'0' && wchar_t('-') == L'-'
      && wchar_t('.') == L'.' && wchar_t('e') == L'e')
      return wstring(__s.data(), __s.data() + __s.size());
    else
      {
 wstring __ws;
 auto __f = __s.data();
 __ws.__resize_and_overwrite(__s.size(),
        [__f] (wchar_t* __to, int __n) {
          std::__to_wstring_numeric(__f, __n, __to);
          return __n;
        });
 return __ws;
      }
  }
#pragma GCC diagnostic pop

  [[__nodiscard__]]
  inline wstring
  to_wstring(int __val)
  { return std::__to_wstring_numeric(std::to_string(__val)); }

  [[__nodiscard__]]
  inline wstring
  to_wstring(unsigned __val)
  { return std::__to_wstring_numeric(std::to_string(__val)); }

  [[__nodiscard__]]
  inline wstring
  to_wstring(long __val)
  { return std::__to_wstring_numeric(std::to_string(__val)); }

  [[__nodiscard__]]
  inline wstring
  to_wstring(unsigned long __val)
  { return std::__to_wstring_numeric(std::to_string(__val)); }

  [[__nodiscard__]]
  inline wstring
  to_wstring(long long __val)
  { return std::__to_wstring_numeric(std::to_string(__val)); }

  [[__nodiscard__]]
  inline wstring
  to_wstring(unsigned long long __val)
  { return std::__to_wstring_numeric(std::to_string(__val)); }


  [[__nodiscard__]]
  inline wstring
  to_wstring(float __val)
  { return std::__to_wstring_numeric(std::to_string(__val)); }

  [[__nodiscard__]]
  inline wstring
  to_wstring(double __val)
  { return std::__to_wstring_numeric(std::to_string(__val)); }

  [[__nodiscard__]]
  inline wstring
  to_wstring(long double __val)
  { return std::__to_wstring_numeric(std::to_string(__val)); }



}

}







namespace std __attribute__ ((__visibility__ ("default")))
{





  template<typename _CharT, typename _Alloc,
    typename _StrT = basic_string<_CharT, char_traits<_CharT>, _Alloc>>
    struct __str_hash_base
    : public __hash_base<size_t, _StrT>
    {
      [[__nodiscard__]]
      size_t
      operator()(const _StrT& __s) const noexcept
      { return _Hash_impl::hash(__s.data(), __s.length() * sizeof(_CharT)); }
    };



  template<typename _Alloc>
    struct hash<basic_string<char, char_traits<char>, _Alloc>>
    : public __str_hash_base<char, _Alloc>
    { };


  template<typename _Alloc>
    struct hash<basic_string<wchar_t, char_traits<wchar_t>, _Alloc>>
    : public __str_hash_base<wchar_t, _Alloc>
    { };

  template<typename _Alloc>
    struct __is_fast_hash<hash<basic_string<wchar_t, char_traits<wchar_t>,
         _Alloc>>>
    : std::false_type
    { };




  template<typename _Alloc>
    struct hash<basic_string<char8_t, char_traits<char8_t>, _Alloc>>
    : public __str_hash_base<char8_t, _Alloc>
    { };



  template<typename _Alloc>
    struct hash<basic_string<char16_t, char_traits<char16_t>, _Alloc>>
    : public __str_hash_base<char16_t, _Alloc>
    { };


  template<typename _Alloc>
    struct hash<basic_string<char32_t, char_traits<char32_t>, _Alloc>>
    : public __str_hash_base<char32_t, _Alloc>
    { };



  template<> struct __is_fast_hash<hash<string>> : std::false_type { };
  template<> struct __is_fast_hash<hash<wstring>> : std::false_type { };
  template<> struct __is_fast_hash<hash<u16string>> : std::false_type { };
  template<> struct __is_fast_hash<hash<u32string>> : std::false_type { };

  template<> struct __is_fast_hash<hash<u8string>> : std::false_type { };
# 4678 "/usr/include/c++/14.2.1/bits/basic_string.h" 3
  inline namespace literals
  {
  inline namespace string_literals
  {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wliteral-suffix"







    __attribute ((__abi_tag__ ("cxx11"))) constexpr
    inline basic_string<char>
    operator""s(const char* __str, size_t __len)
    { return basic_string<char>{__str, __len}; }

    __attribute ((__abi_tag__ ("cxx11"))) constexpr
    inline basic_string<wchar_t>
    operator""s(const wchar_t* __str, size_t __len)
    { return basic_string<wchar_t>{__str, __len}; }


    __attribute ((__abi_tag__ ("cxx11"))) constexpr
    inline basic_string<char8_t>
    operator""s(const char8_t* __str, size_t __len)
    { return basic_string<char8_t>{__str, __len}; }


    __attribute ((__abi_tag__ ("cxx11"))) constexpr
    inline basic_string<char16_t>
    operator""s(const char16_t* __str, size_t __len)
    { return basic_string<char16_t>{__str, __len}; }

    __attribute ((__abi_tag__ ("cxx11"))) constexpr
    inline basic_string<char32_t>
    operator""s(const char32_t* __str, size_t __len)
    { return basic_string<char32_t>{__str, __len}; }


#pragma GCC diagnostic pop
  }
  }



  namespace __detail::__variant
  {
    template<typename> struct _Never_valueless_alt;



    template<typename _Tp, typename _Traits, typename _Alloc>
      struct _Never_valueless_alt<std::basic_string<_Tp, _Traits, _Alloc>>
      : __and_<
 is_nothrow_move_constructible<std::basic_string<_Tp, _Traits, _Alloc>>,
 is_nothrow_move_assignable<std::basic_string<_Tp, _Traits, _Alloc>>
 >::type
      { };
  }



}
# 55 "/usr/include/c++/14.2.1/string" 2 3
# 1 "/usr/include/c++/14.2.1/bits/basic_string.tcc" 1 3
# 42 "/usr/include/c++/14.2.1/bits/basic_string.tcc" 3
       
# 43 "/usr/include/c++/14.2.1/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == std::__addressof(__s))
 return;

      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      __s.length() + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      length() + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      __s.length() + 1);
       }
     else if (__s.length())
       {
  _M_init_local_buf();
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      __s.length() + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  __s._M_init_local_buf();
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      length() + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     __s._M_init_local_buf();
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         length() + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       _M_init_local_buf();
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    __s.length() + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _S_allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      constexpr
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 _M_init_local_buf();

 while (__beg != __end && __len < __capacity)
   {
     _M_local_buf[__len++] = *__beg;
     ++__beg;
   }

 struct _Guard
 {
   constexpr
   explicit _Guard(basic_string* __s) : _M_guarded(__s) { }

   constexpr
   ~_Guard() { if (_M_guarded) _M_guarded->_M_dispose(); }

   basic_string* _M_guarded;
 } __guard(this);

 while (__beg != __end)
   {
     if (__len == __capacity)
       {

  __capacity = __len + 1;
  pointer __another = _M_create(__capacity, __len);
  this->_S_copy(__another, _M_data(), __len);
  _M_dispose();
  _M_data(__another);
  _M_capacity(__capacity);
       }
     traits_type::assign(_M_data()[__len++], *__beg);
     ++__beg;
   }

 __guard._M_guarded = 0;

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      constexpr
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {
 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }
 else
   _M_init_local_buf();


 struct _Guard
 {
   constexpr
   explicit _Guard(basic_string* __s) : _M_guarded(__s) { }

   constexpr
   ~_Guard() { if (_M_guarded) _M_guarded->_M_dispose(); }

   basic_string* _M_guarded;
 } __guard(this);

 this->_S_copy_chars(_M_data(), __beg, __end);

 __guard._M_guarded = 0;

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }
      else
 _M_init_local_buf();

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != std::__addressof(__str))
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      const size_type __capacity = capacity();




      if (__res <= __capacity)
 return;

      pointer __tmp = _M_create(__res, __capacity);
      this->_S_copy(__tmp, _M_data(), length() + 1);
      _M_dispose();
      _M_data(__tmp);
      _M_capacity(__res);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve()
    {
      if (_M_is_local())
 return;

      const size_type __length = length();
      const size_type __capacity = _M_allocated_capacity;

      if (__length <= size_type(_S_local_capacity))
 {
   _M_init_local_buf();
   this->_S_copy(_M_local_buf, _M_data(), __length + 1);
   _M_destroy(__capacity);
   _M_data(_M_local_data());
 }

      else if (__length < __capacity)
 try
   {
     pointer __tmp = _S_allocate(_M_get_allocator(), __length + 1);
     this->_S_copy(__tmp, _M_data(), __length + 1);
     _M_dispose();
     _M_data(__tmp);
     _M_capacity(__length);
   }
 catch (const __cxxabiv1::__forced_unwind&)
   { throw; }
 catch (...)
   { }

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      constexpr
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {


 const basic_string __s(__k1, __k2, this->get_allocator());
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    __attribute__((__noinline__, __noclone__, __cold__)) void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_cold(pointer __p, size_type __len1, const _CharT* __s,
      const size_type __len2, const size_type __how_much)
    {

      if (__len2 && __len2 <= __len1)
 this->_S_move(__p, __s, __len2);
      if (__how_much && __len1 != __len2)
 this->_S_move(__p + __len2, __p + __len1, __how_much);
      if (__len2 > __len1)
 {
   if (__s + __len2 <= __p + __len1)
     this->_S_move(__p, __s, __len2);
   else if (__s >= __p + __len1)
     {


       const size_type __poff = (__s - __p) + (__len2 - __len1);
       this->_S_copy(__p, __p + __poff, __len2);
     }
   else
     {
       const size_type __nleft = (__p + __len1) - __s;
       this->_S_move(__p, __s, __nleft);
       this->_S_copy(__p + __nleft, __p + __len2, __len2 - __nleft);
     }
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;

   if (std::is_constant_evaluated())
     {
       auto __newp = _S_allocate(_M_get_allocator(), __new_size);
       _S_copy(__newp, this->_M_data(), __pos);
       _S_copy(__newp + __pos, __s, __len2);
       _S_copy(__newp + __pos + __len2, __p + __len1, __how_much);
       _S_copy(this->_M_data(), __newp, __new_size);
       this->_M_get_allocator().deallocate(__newp, __new_size);
     }
   else

   if (__builtin_expect(_M_disjunct(__s), true))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     _M_replace_cold(__p, __len1, __s, __len2, __how_much);
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
# 580 "/usr/include/c++/14.2.1/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
  template<typename _Operation>
    constexpr void
    basic_string<_CharT, _Traits, _Alloc>::



    __resize_and_overwrite(const size_type __n, _Operation __op)

    {
      reserve(__n);
      _CharT* const __p = _M_data();

      if (std::__is_constant_evaluated() && __n > size())
 traits_type::assign(__p + size(), __n - size(), _CharT());

      struct _Terminator {
 constexpr ~_Terminator() { _M_this->_M_set_length(_M_r); }
 basic_string* _M_this;
 size_type _M_r;
      };
      _Terminator __term{this, 0};
      auto __r = std::move(__op)(__p + 0, __n + 0);

      static_assert(ranges::__detail::__is_integer_like<decltype(__r)>);




      ;
      __term._M_r = size_type(__r);
      if (__term._M_r > __n)
 __builtin_unreachable();
    }
# 623 "/usr/include/c++/14.2.1/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;
      if (__pos >= __size)
 return npos;

      const _CharT __elem0 = __s[0];
      const _CharT* const __data = data();
      const _CharT* __first = __data + __pos;
      const _CharT* const __last = __data + __size;
      size_type __len = __size - __pos;

      while (__len >= __n)
 {

   __first = traits_type::find(__first, __len - __n + 1, __elem0);
   if (!__first)
     return npos;



   if (traits_type::compare(__first, __s, __n) == 0)
     return __first - __data;
   __len = __last - ++__first;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    constexpr
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }




  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (__extracted < __n && _Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
# 985 "/usr/include/c++/14.2.1/bits/basic_string.tcc" 3
  extern template void
    basic_string<char>::_M_replace_cold(char *, size_type, const char*,
     const size_type, const size_type);


  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);
# 1011 "/usr/include/c++/14.2.1/bits/basic_string.tcc" 3
  extern template void
    basic_string<wchar_t>::_M_replace_cold(wchar_t*, size_type, const wchar_t*,
        const size_type, const size_type);


  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 56 "/usr/include/c++/14.2.1/string" 2 3
# 65 "/usr/include/c++/14.2.1/string" 3
# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 66 "/usr/include/c++/14.2.1/string" 2 3


# 1 "/usr/include/c++/14.2.1/bits/memory_resource.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3




# 1 "/usr/include/c++/14.2.1/cstddef" 1 3
# 42 "/usr/include/c++/14.2.1/cstddef" 3
       
# 43 "/usr/include/c++/14.2.1/cstddef" 3







# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 51 "/usr/include/c++/14.2.1/cstddef" 2 3


# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 54 "/usr/include/c++/14.2.1/cstddef" 2 3

extern "C++"
{

namespace std
{

  using ::max_align_t;
}



namespace std
{


  enum class byte : unsigned char {};

  template<typename _IntegerType> struct __byte_operand { };
  template<> struct __byte_operand<bool> { using __type = byte; };
  template<> struct __byte_operand<char> { using __type = byte; };
  template<> struct __byte_operand<signed char> { using __type = byte; };
  template<> struct __byte_operand<unsigned char> { using __type = byte; };
  template<> struct __byte_operand<wchar_t> { using __type = byte; };

  template<> struct __byte_operand<char8_t> { using __type = byte; };

  template<> struct __byte_operand<char16_t> { using __type = byte; };
  template<> struct __byte_operand<char32_t> { using __type = byte; };
  template<> struct __byte_operand<short> { using __type = byte; };
  template<> struct __byte_operand<unsigned short> { using __type = byte; };
  template<> struct __byte_operand<int> { using __type = byte; };
  template<> struct __byte_operand<unsigned int> { using __type = byte; };
  template<> struct __byte_operand<long> { using __type = byte; };
  template<> struct __byte_operand<unsigned long> { using __type = byte; };
  template<> struct __byte_operand<long long> { using __type = byte; };
  template<> struct __byte_operand<unsigned long long> { using __type = byte; };

  template<> struct __byte_operand<__int128>
  { using __type = byte; };
  template<> struct __byte_operand<unsigned __int128>
  { using __type = byte; };
# 109 "/usr/include/c++/14.2.1/cstddef" 3
  template<typename _IntegerType>
    struct __byte_operand<const _IntegerType>
    : __byte_operand<_IntegerType> { };
  template<typename _IntegerType>
    struct __byte_operand<volatile _IntegerType>
    : __byte_operand<_IntegerType> { };
  template<typename _IntegerType>
    struct __byte_operand<const volatile _IntegerType>
    : __byte_operand<_IntegerType> { };

  template<typename _IntegerType>
    using __byte_op_t = typename __byte_operand<_IntegerType>::__type;

  template<typename _IntegerType>
    [[__gnu__::__always_inline__]]
    constexpr __byte_op_t<_IntegerType>
    operator<<(byte __b, _IntegerType __shift) noexcept
    { return (byte)(unsigned char)((unsigned)__b << __shift); }

  template<typename _IntegerType>
    [[__gnu__::__always_inline__]]
    constexpr __byte_op_t<_IntegerType>
    operator>>(byte __b, _IntegerType __shift) noexcept
    { return (byte)(unsigned char)((unsigned)__b >> __shift); }

  [[__gnu__::__always_inline__]]
  constexpr byte
  operator|(byte __l, byte __r) noexcept
  { return (byte)(unsigned char)((unsigned)__l | (unsigned)__r); }

  [[__gnu__::__always_inline__]]
  constexpr byte
  operator&(byte __l, byte __r) noexcept
  { return (byte)(unsigned char)((unsigned)__l & (unsigned)__r); }

  [[__gnu__::__always_inline__]]
  constexpr byte
  operator^(byte __l, byte __r) noexcept
  { return (byte)(unsigned char)((unsigned)__l ^ (unsigned)__r); }

  [[__gnu__::__always_inline__]]
  constexpr byte
  operator~(byte __b) noexcept
  { return (byte)(unsigned char)~(unsigned)__b; }

  template<typename _IntegerType>
    [[__gnu__::__always_inline__]]
    constexpr __byte_op_t<_IntegerType>&
    operator<<=(byte& __b, _IntegerType __shift) noexcept
    { return __b = __b << __shift; }

  template<typename _IntegerType>
    [[__gnu__::__always_inline__]]
    constexpr __byte_op_t<_IntegerType>&
    operator>>=(byte& __b, _IntegerType __shift) noexcept
    { return __b = __b >> __shift; }

  [[__gnu__::__always_inline__]]
  constexpr byte&
  operator|=(byte& __l, byte __r) noexcept
  { return __l = __l | __r; }

  [[__gnu__::__always_inline__]]
  constexpr byte&
  operator&=(byte& __l, byte __r) noexcept
  { return __l = __l & __r; }

  [[__gnu__::__always_inline__]]
  constexpr byte&
  operator^=(byte& __l, byte __r) noexcept
  { return __l = __l ^ __r; }

  template<typename _IntegerType>
    [[nodiscard,__gnu__::__always_inline__]]
    constexpr _IntegerType
    to_integer(__byte_op_t<_IntegerType> __b) noexcept
    { return _IntegerType(__b); }


}

}
# 39 "/usr/include/c++/14.2.1/bits/memory_resource.h" 2 3

# 1 "/usr/include/c++/14.2.1/bits/uses_allocator.h" 1 3
# 40 "/usr/include/c++/14.2.1/bits/uses_allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  struct __erased_type { };




  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_convertible<_Alloc, _Tp>, is_same<_Tp, __erased_type>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

  inline constexpr allocator_arg_t allocator_arg =
    allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void constexpr operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : __conditional_t<
        is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>
    {


      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>,
   is_constructible<_Tp, _Args..., const _Alloc&>>::value,
   "construction with an allocator must be possible"
   " if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void
    __use_alloc(const _Alloc&&) = delete;


  template <typename _Tp, typename _Alloc>
    inline constexpr bool uses_allocator_v =
      uses_allocator<_Tp, _Alloc>::value;


  template<template<typename...> class _Predicate,
    typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_predicate
    : __conditional_t<uses_allocator<_Tp, _Alloc>::value,
      __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>,
     _Predicate<_Tp, _Args..., _Alloc>>,
      _Predicate<_Tp, _Args...>> { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...>
    { };


  template<typename _Tp, typename _Alloc, typename... _Args>
    inline constexpr bool __is_uses_allocator_constructible_v =
      __is_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_nothrow_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_nothrow_constructible,
        _Tp, _Alloc, _Args...>
    { };



  template<typename _Tp, typename _Alloc, typename... _Args>
    inline constexpr bool
    __is_nothrow_uses_allocator_constructible_v =
      __is_nothrow_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc0, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)...); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    {
      ::new ((void*)__ptr) _Tp(allocator_arg, *__a._M_a,
          std::forward<_Args>(__args)...);
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,
        _Args&&... __args)
    {
      std::__uses_allocator_construct_impl(
   std::__use_alloc<_Tp, _Alloc, _Args...>(__a), __ptr,
   std::forward<_Args>(__args)...);
    }



}
# 41 "/usr/include/c++/14.2.1/bits/memory_resource.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/uses_allocator_args.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/uses_allocator_args.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/uses_allocator_args.h" 3

# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 36 "/usr/include/c++/14.2.1/bits/uses_allocator_args.h" 2 3



# 1 "/usr/include/c++/14.2.1/tuple" 1 3
# 32 "/usr/include/c++/14.2.1/tuple" 3
       
# 33 "/usr/include/c++/14.2.1/tuple" 3
# 44 "/usr/include/c++/14.2.1/tuple" 3
# 1 "/usr/include/c++/14.2.1/bits/ranges_util.h" 1 3
# 39 "/usr/include/c++/14.2.1/bits/ranges_util.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

namespace ranges
{


  namespace __detail
  {
    template<typename _Range>
      concept __simple_view = view<_Range> && range<const _Range>
 && same_as<iterator_t<_Range>, iterator_t<const _Range>>
 && same_as<sentinel_t<_Range>, sentinel_t<const _Range>>;

    template<typename _It>
      concept __has_arrow = input_iterator<_It>
 && (is_pointer_v<_It> || requires(_It __it) { __it.operator->(); });

    using std::__detail::__different_from;
  }


  template<typename _Derived>
    requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
    class view_interface
    {
    private:
      constexpr _Derived& _M_derived() noexcept
      {
 static_assert(derived_from<_Derived, view_interface<_Derived>>);
 static_assert(view<_Derived>);
 return static_cast<_Derived&>(*this);
      }

      constexpr const _Derived& _M_derived() const noexcept
      {
 static_assert(derived_from<_Derived, view_interface<_Derived>>);
 static_assert(view<_Derived>);
 return static_cast<const _Derived&>(*this);
      }

      static constexpr bool
      _S_bool(bool) noexcept;

      template<typename _Tp>
 static constexpr bool
 _S_empty(_Tp& __t)
 noexcept(noexcept(_S_bool(ranges::begin(__t) == ranges::end(__t))))
 { return ranges::begin(__t) == ranges::end(__t); }

      template<typename _Tp>
 static constexpr auto
 _S_size(_Tp& __t)
 noexcept(noexcept(ranges::end(__t) - ranges::begin(__t)))
 { return ranges::end(__t) - ranges::begin(__t); }

    public:
      constexpr bool
      empty()
      noexcept(noexcept(_S_empty(_M_derived())))
      requires forward_range<_Derived> && (!sized_range<_Derived>)
      { return _S_empty(_M_derived()); }

      constexpr bool
      empty()
      noexcept(noexcept(ranges::size(_M_derived()) == 0))
      requires sized_range<_Derived>
      { return ranges::size(_M_derived()) == 0; }

      constexpr bool
      empty() const
      noexcept(noexcept(_S_empty(_M_derived())))
      requires forward_range<const _Derived> && (!sized_range<const _Derived>)
      { return _S_empty(_M_derived()); }

      constexpr bool
      empty() const
      noexcept(noexcept(ranges::size(_M_derived()) == 0))
      requires sized_range<const _Derived>
      { return ranges::size(_M_derived()) == 0; }

      constexpr explicit
      operator bool() noexcept(noexcept(ranges::empty(_M_derived())))
      requires requires { ranges::empty(_M_derived()); }
      { return !ranges::empty(_M_derived()); }

      constexpr explicit
      operator bool() const noexcept(noexcept(ranges::empty(_M_derived())))
      requires requires { ranges::empty(_M_derived()); }
      { return !ranges::empty(_M_derived()); }

      constexpr auto
      data() noexcept(noexcept(ranges::begin(_M_derived())))
      requires contiguous_iterator<iterator_t<_Derived>>
      { return std::to_address(ranges::begin(_M_derived())); }

      constexpr auto
      data() const noexcept(noexcept(ranges::begin(_M_derived())))
      requires range<const _Derived>
 && contiguous_iterator<iterator_t<const _Derived>>
      { return std::to_address(ranges::begin(_M_derived())); }

      constexpr auto
      size() noexcept(noexcept(_S_size(_M_derived())))
      requires forward_range<_Derived>
 && sized_sentinel_for<sentinel_t<_Derived>, iterator_t<_Derived>>
      { return _S_size(_M_derived()); }

      constexpr auto
      size() const noexcept(noexcept(_S_size(_M_derived())))
      requires forward_range<const _Derived>
 && sized_sentinel_for<sentinel_t<const _Derived>,
         iterator_t<const _Derived>>
      { return _S_size(_M_derived()); }

      constexpr decltype(auto)
      front() requires forward_range<_Derived>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return *ranges::begin(_M_derived());
      }

      constexpr decltype(auto)
      front() const requires forward_range<const _Derived>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return *ranges::begin(_M_derived());
      }

      constexpr decltype(auto)
      back()
      requires bidirectional_range<_Derived> && common_range<_Derived>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return *ranges::prev(ranges::end(_M_derived()));
      }

      constexpr decltype(auto)
      back() const
      requires bidirectional_range<const _Derived>
 && common_range<const _Derived>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return *ranges::prev(ranges::end(_M_derived()));
      }

      template<random_access_range _Range = _Derived>
 constexpr decltype(auto)
 operator[](range_difference_t<_Range> __n)
 { return ranges::begin(_M_derived())[__n]; }

      template<random_access_range _Range = const _Derived>
 constexpr decltype(auto)
 operator[](range_difference_t<_Range> __n) const
 { return ranges::begin(_M_derived())[__n]; }
# 212 "/usr/include/c++/14.2.1/bits/ranges_util.h" 3
    };

  namespace __detail
  {
    template<typename _From, typename _To>
      concept __uses_nonqualification_pointer_conversion
 = is_pointer_v<_From> && is_pointer_v<_To>
   && !convertible_to<remove_pointer_t<_From>(*)[],
        remove_pointer_t<_To>(*)[]>;

    template<typename _From, typename _To>
      concept __convertible_to_non_slicing = convertible_to<_From, _To>
 && !__uses_nonqualification_pointer_conversion<decay_t<_From>,
             decay_t<_To>>;





    template<typename _Tp>
      concept __pair_like
 = !is_reference_v<_Tp> && requires(_Tp __t)
 {
   typename tuple_size<_Tp>::type;
   requires derived_from<tuple_size<_Tp>, integral_constant<size_t, 2>>;
   typename tuple_element_t<0, remove_const_t<_Tp>>;
   typename tuple_element_t<1, remove_const_t<_Tp>>;
   { get<0>(__t) } -> convertible_to<const tuple_element_t<0, _Tp>&>;
   { get<1>(__t) } -> convertible_to<const tuple_element_t<1, _Tp>&>;
 };


    template<typename _Tp, typename _Up, typename _Vp>
      concept __pair_like_convertible_from
 = !range<_Tp> && !is_reference_v<_Vp> && __pair_like<_Tp>
 && constructible_from<_Tp, _Up, _Vp>
 && __convertible_to_non_slicing<_Up, tuple_element_t<0, _Tp>>
 && convertible_to<_Vp, tuple_element_t<1, _Tp>>;

  }

  namespace views { struct _Drop; }

  enum class subrange_kind : bool { unsized, sized };


  template<input_or_output_iterator _It, sentinel_for<_It> _Sent = _It,
    subrange_kind _Kind = sized_sentinel_for<_Sent, _It>
      ? subrange_kind::sized : subrange_kind::unsized>
    requires (_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _It>)
    class subrange : public view_interface<subrange<_It, _Sent, _Kind>>
    {
    private:
      static constexpr bool _S_store_size
 = _Kind == subrange_kind::sized && !sized_sentinel_for<_Sent, _It>;

      friend struct views::_Drop;

      _It _M_begin = _It();
      [[no_unique_address]] _Sent _M_end = _Sent();

      using __size_type
 = __detail::__make_unsigned_like_t<iter_difference_t<_It>>;

      template<typename _Tp, bool = _S_store_size>
 struct _Size
 {
   [[__gnu__::__always_inline__]]
   constexpr _Size(_Tp = {}) { }
 };

      template<typename _Tp>
 struct _Size<_Tp, true>
 {
   [[__gnu__::__always_inline__]]
   constexpr _Size(_Tp __s = {}) : _M_size(__s) { }

   _Tp _M_size;
 };

      [[no_unique_address]] _Size<__size_type> _M_size = {};

    public:
      subrange() requires default_initializable<_It> = default;

      constexpr
      subrange(__detail::__convertible_to_non_slicing<_It> auto __i, _Sent __s)
      noexcept(is_nothrow_constructible_v<_It, decltype(__i)>
        && is_nothrow_constructible_v<_Sent, _Sent&>)
 requires (!_S_store_size)
      : _M_begin(std::move(__i)), _M_end(__s)
      { }

      constexpr
      subrange(__detail::__convertible_to_non_slicing<_It> auto __i, _Sent __s,
        __size_type __n)
      noexcept(is_nothrow_constructible_v<_It, decltype(__i)>
        && is_nothrow_constructible_v<_Sent, _Sent&>)
 requires (_Kind == subrange_kind::sized)
      : _M_begin(std::move(__i)), _M_end(__s), _M_size(__n)
      { }

      template<__detail::__different_from<subrange> _Rng>
 requires borrowed_range<_Rng>
   && __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It>
   && convertible_to<sentinel_t<_Rng>, _Sent>
 constexpr
 subrange(_Rng&& __r)
 noexcept(noexcept(subrange(__r, ranges::size(__r))))
 requires _S_store_size && sized_range<_Rng>
 : subrange(__r, ranges::size(__r))
 { }

      template<__detail::__different_from<subrange> _Rng>
 requires borrowed_range<_Rng>
   && __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It>
   && convertible_to<sentinel_t<_Rng>, _Sent>
 constexpr
 subrange(_Rng&& __r)
 noexcept(noexcept(subrange(ranges::begin(__r), ranges::end(__r))))
 requires (!_S_store_size)
 : subrange(ranges::begin(__r), ranges::end(__r))
 { }

      template<borrowed_range _Rng>
 requires __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It>
   && convertible_to<sentinel_t<_Rng>, _Sent>
 constexpr
 subrange(_Rng&& __r, __size_type __n)
 noexcept(noexcept(subrange(ranges::begin(__r), ranges::end(__r), __n)))
 requires (_Kind == subrange_kind::sized)
 : subrange{ranges::begin(__r), ranges::end(__r), __n}
 { }

      template<__detail::__different_from<subrange> _PairLike>
 requires __detail::__pair_like_convertible_from<_PairLike, const _It&,
       const _Sent&>
 constexpr
 operator _PairLike() const
 { return _PairLike(_M_begin, _M_end); }

      constexpr _It
      begin() const requires copyable<_It>
      { return _M_begin; }

      [[nodiscard]] constexpr _It
      begin() requires (!copyable<_It>)
      { return std::move(_M_begin); }

      constexpr _Sent end() const { return _M_end; }

      constexpr bool empty() const { return _M_begin == _M_end; }

      constexpr __size_type
      size() const requires (_Kind == subrange_kind::sized)
      {
 if constexpr (_S_store_size)
   return _M_size._M_size;
 else
   return __detail::__to_unsigned_like(_M_end - _M_begin);
      }

      [[nodiscard]] constexpr subrange
      next(iter_difference_t<_It> __n = 1) const &
 requires forward_iterator<_It>
      {
 auto __tmp = *this;
 __tmp.advance(__n);
 return __tmp;
      }

      [[nodiscard]] constexpr subrange
      next(iter_difference_t<_It> __n = 1) &&
      {
 advance(__n);
 return std::move(*this);
      }

      [[nodiscard]] constexpr subrange
      prev(iter_difference_t<_It> __n = 1) const
 requires bidirectional_iterator<_It>
      {
 auto __tmp = *this;
 __tmp.advance(-__n);
 return __tmp;
      }

      constexpr subrange&
      advance(iter_difference_t<_It> __n)
      {


 if constexpr (bidirectional_iterator<_It>)
   if (__n < 0)
     {
       ranges::advance(_M_begin, __n);
       if constexpr (_S_store_size)
  _M_size._M_size += __detail::__to_unsigned_like(-__n);
       return *this;
     }

 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n >= 0), false)) std::__glibcxx_assert_fail(); } while (false);
 auto __d = __n - ranges::advance(_M_begin, __n, _M_end);
 if constexpr (_S_store_size)
   _M_size._M_size -= __detail::__to_unsigned_like(__d);
 return *this;
      }
    };

  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    subrange(_It, _Sent) -> subrange<_It, _Sent>;

  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    subrange(_It, _Sent,
      __detail::__make_unsigned_like_t<iter_difference_t<_It>>)
      -> subrange<_It, _Sent, subrange_kind::sized>;

  template<borrowed_range _Rng>
    subrange(_Rng&&)
      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,
   (sized_range<_Rng>
    || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>)
   ? subrange_kind::sized : subrange_kind::unsized>;

  template<borrowed_range _Rng>
    subrange(_Rng&&,
      __detail::__make_unsigned_like_t<range_difference_t<_Rng>>)
      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;

  template<size_t _Num, class _It, class _Sent, subrange_kind _Kind>
    requires (_Num < 2)
    constexpr auto
    get(const subrange<_It, _Sent, _Kind>& __r)
    {
      if constexpr (_Num == 0)
 return __r.begin();
      else
 return __r.end();
    }

  template<size_t _Num, class _It, class _Sent, subrange_kind _Kind>
    requires (_Num < 2)
    constexpr auto
    get(subrange<_It, _Sent, _Kind>&& __r)
    {
      if constexpr (_Num == 0)
 return __r.begin();
      else
 return __r.end();
    }

  template<typename _It, typename _Sent, subrange_kind _Kind>
    inline constexpr bool
      enable_borrowed_range<subrange<_It, _Sent, _Kind>> = true;

  template<range _Range>
    using borrowed_subrange_t = __conditional_t<borrowed_range<_Range>,
      subrange<iterator_t<_Range>>,
      dangling>;


  template<typename _Iter, typename _Sent, subrange_kind _Kind>
    inline constexpr bool __detail::__is_subrange<subrange<_Iter, _Sent, _Kind>> = true;
}
# 485 "/usr/include/c++/14.2.1/bits/ranges_util.h" 3
namespace ranges
{
  struct __find_fn
  {
    template<input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,
      typename _Proj = identity>
      requires indirect_binary_predicate<ranges::equal_to,
      projected<_Iter, _Proj>, const _Tp*>
      constexpr _Iter
      operator()(_Iter __first, _Sent __last,
   const _Tp& __value, _Proj __proj = {}) const
      {
 while (__first != __last
     && !(std::__invoke(__proj, *__first) == __value))
   ++__first;
 return __first;
      }

    template<input_range _Range, typename _Tp, typename _Proj = identity>
      requires indirect_binary_predicate<ranges::equal_to,
      projected<iterator_t<_Range>, _Proj>,
      const _Tp*>
      constexpr borrowed_iterator_t<_Range>
      operator()(_Range&& __r, const _Tp& __value, _Proj __proj = {}) const
      {
 return (*this)(ranges::begin(__r), ranges::end(__r),
         __value, std::move(__proj));
      }
  };

  inline constexpr __find_fn find{};

  struct __find_if_fn
  {
    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
      typename _Proj = identity,
      indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
      constexpr _Iter
      operator()(_Iter __first, _Sent __last,
   _Pred __pred, _Proj __proj = {}) const
      {
 while (__first != __last
     && !(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
   ++__first;
 return __first;
      }

    template<input_range _Range, typename _Proj = identity,
      indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
        _Pred>
      constexpr borrowed_iterator_t<_Range>
      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
      {
 return (*this)(ranges::begin(__r), ranges::end(__r),
         std::move(__pred), std::move(__proj));
      }
  };

  inline constexpr __find_if_fn find_if{};

  struct __find_if_not_fn
  {
    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
      typename _Proj = identity,
      indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
      constexpr _Iter
      operator()(_Iter __first, _Sent __last,
   _Pred __pred, _Proj __proj = {}) const
      {
 while (__first != __last
     && (bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
   ++__first;
 return __first;
      }

    template<input_range _Range, typename _Proj = identity,
      indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
        _Pred>
      constexpr borrowed_iterator_t<_Range>
      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
      {
 return (*this)(ranges::begin(__r), ranges::end(__r),
         std::move(__pred), std::move(__proj));
      }
  };

  inline constexpr __find_if_not_fn find_if_not{};

  template<typename _Iter1, typename _Iter2>
    struct in_in_result
    {
      [[no_unique_address]] _Iter1 in1;
      [[no_unique_address]] _Iter2 in2;

      template<typename _IIter1, typename _IIter2>
 requires convertible_to<const _Iter1&, _IIter1>
   && convertible_to<const _Iter2&, _IIter2>
 constexpr
 operator in_in_result<_IIter1, _IIter2>() const &
 { return {in1, in2}; }

      template<typename _IIter1, typename _IIter2>
 requires convertible_to<_Iter1, _IIter1>
   && convertible_to<_Iter2, _IIter2>
 constexpr
 operator in_in_result<_IIter1, _IIter2>() &&
 { return {std::move(in1), std::move(in2)}; }
    };

  template<typename _Iter1, typename _Iter2>
    using mismatch_result = in_in_result<_Iter1, _Iter2>;

  struct __mismatch_fn
  {
    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
      input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
      typename _Pred = ranges::equal_to,
      typename _Proj1 = identity, typename _Proj2 = identity>
      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
      constexpr mismatch_result<_Iter1, _Iter2>
      operator()(_Iter1 __first1, _Sent1 __last1,
   _Iter2 __first2, _Sent2 __last2, _Pred __pred = {},
   _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
      {
 while (__first1 != __last1 && __first2 != __last2
        && (bool)std::__invoke(__pred,
          std::__invoke(__proj1, *__first1),
          std::__invoke(__proj2, *__first2)))
 {
   ++__first1;
   ++__first2;
 }
 return { std::move(__first1), std::move(__first2) };
      }

    template<input_range _Range1, input_range _Range2,
      typename _Pred = ranges::equal_to,
      typename _Proj1 = identity, typename _Proj2 = identity>
      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
         _Pred, _Proj1, _Proj2>
      constexpr mismatch_result<iterator_t<_Range1>, iterator_t<_Range2>>
      operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},
   _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
      {
 return (*this)(ranges::begin(__r1), ranges::end(__r1),
         ranges::begin(__r2), ranges::end(__r2),
         std::move(__pred),
         std::move(__proj1), std::move(__proj2));
      }
  };

  inline constexpr __mismatch_fn mismatch{};

  struct __search_fn
  {
    template<forward_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
      forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
      typename _Pred = ranges::equal_to,
      typename _Proj1 = identity, typename _Proj2 = identity>
      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
      constexpr subrange<_Iter1>
      operator()(_Iter1 __first1, _Sent1 __last1,
   _Iter2 __first2, _Sent2 __last2, _Pred __pred = {},
   _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
      {
 if (__first1 == __last1 || __first2 == __last2)
   return {__first1, __first1};

 for (;;)
   {
     for (;;)
       {
  if (__first1 == __last1)
    return {__first1, __first1};
  if (std::__invoke(__pred,
      std::__invoke(__proj1, *__first1),
      std::__invoke(__proj2, *__first2)))
    break;
  ++__first1;
       }
     auto __cur1 = __first1;
     auto __cur2 = __first2;
     for (;;)
       {
  if (++__cur2 == __last2)
    return {__first1, ++__cur1};
  if (++__cur1 == __last1)
    return {__cur1, __cur1};
  if (!(bool)std::__invoke(__pred,
      std::__invoke(__proj1, *__cur1),
      std::__invoke(__proj2, *__cur2)))
    {
      ++__first1;
      break;
    }
       }
   }
      }

    template<forward_range _Range1, forward_range _Range2,
      typename _Pred = ranges::equal_to,
      typename _Proj1 = identity, typename _Proj2 = identity>
      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
         _Pred, _Proj1, _Proj2>
      constexpr borrowed_subrange_t<_Range1>
      operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},
   _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
      {
 return (*this)(ranges::begin(__r1), ranges::end(__r1),
         ranges::begin(__r2), ranges::end(__r2),
         std::move(__pred),
         std::move(__proj1), std::move(__proj2));
      }
  };

  inline constexpr __search_fn search{};

  struct __min_fn
  {
    template<typename _Tp, typename _Proj = identity,
      indirect_strict_weak_order<projected<const _Tp*, _Proj>>
        _Comp = ranges::less>
      constexpr const _Tp&
      operator()(const _Tp& __a, const _Tp& __b,
   _Comp __comp = {}, _Proj __proj = {}) const
      {
 if (std::__invoke(__comp,
     std::__invoke(__proj, __b),
     std::__invoke(__proj, __a)))
   return __b;
 else
   return __a;
      }

    template<input_range _Range, typename _Proj = identity,
      indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
        _Comp = ranges::less>
      requires indirectly_copyable_storable<iterator_t<_Range>,
         range_value_t<_Range>*>
      constexpr range_value_t<_Range>
      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
      {
 auto __first = ranges::begin(__r);
 auto __last = ranges::end(__r);
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__first != __last), false)) std::__glibcxx_assert_fail(); } while (false);
 auto __result = *__first;
 while (++__first != __last)
   {
     auto __tmp = *__first;
     if (std::__invoke(__comp,
         std::__invoke(__proj, __tmp),
         std::__invoke(__proj, __result)))
       __result = std::move(__tmp);
   }
 return __result;
      }

    template<copyable _Tp, typename _Proj = identity,
      indirect_strict_weak_order<projected<const _Tp*, _Proj>>
        _Comp = ranges::less>
      constexpr _Tp
      operator()(initializer_list<_Tp> __r,
   _Comp __comp = {}, _Proj __proj = {}) const
      {
 return (*this)(ranges::subrange(__r),
         std::move(__comp), std::move(__proj));
      }
  };

  inline constexpr __min_fn min{};

  struct __adjacent_find_fn
  {
    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent,
      typename _Proj = identity,
      indirect_binary_predicate<projected<_Iter, _Proj>,
           projected<_Iter, _Proj>> _Pred
        = ranges::equal_to>
      constexpr _Iter
      operator()(_Iter __first, _Sent __last,
   _Pred __pred = {}, _Proj __proj = {}) const
      {
 if (__first == __last)
   return __first;
 auto __next = __first;
 for (; ++__next != __last; __first = __next)
   {
     if (std::__invoke(__pred,
         std::__invoke(__proj, *__first),
         std::__invoke(__proj, *__next)))
       return __first;
   }
 return __next;
      }

    template<forward_range _Range, typename _Proj = identity,
      indirect_binary_predicate<
        projected<iterator_t<_Range>, _Proj>,
        projected<iterator_t<_Range>, _Proj>> _Pred = ranges::equal_to>
      constexpr borrowed_iterator_t<_Range>
      operator()(_Range&& __r, _Pred __pred = {}, _Proj __proj = {}) const
      {
 return (*this)(ranges::begin(__r), ranges::end(__r),
         std::move(__pred), std::move(__proj));
      }
  };

  inline constexpr __adjacent_find_fn adjacent_find{};

}

  using ranges::get;

  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
    struct tuple_size<ranges::subrange<_Iter, _Sent, _Kind>>
    : integral_constant<size_t, 2>
    { };

  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
    struct tuple_element<0, ranges::subrange<_Iter, _Sent, _Kind>>
    { using type = _Iter; };

  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
    struct tuple_element<1, ranges::subrange<_Iter, _Sent, _Kind>>
    { using type = _Sent; };

  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
    struct tuple_element<0, const ranges::subrange<_Iter, _Sent, _Kind>>
    { using type = _Iter; };

  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
    struct tuple_element<1, const ranges::subrange<_Iter, _Sent, _Kind>>
    { using type = _Sent; };


}
# 45 "/usr/include/c++/14.2.1/tuple" 2 3
# 54 "/usr/include/c++/14.2.1/tuple" 3
# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 55 "/usr/include/c++/14.2.1/tuple" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename... _Elements>
    class tuple;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = __conditional_t<__is_final(_Tp), false_type,
        __is_empty_non_tuple<_Tp>>;

  template<size_t _Idx, typename _Head,
    bool = __empty_not_final<_Head>::value>
    struct _Head_base;


  template<size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
 constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      constexpr
      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 constexpr
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 constexpr
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 constexpr
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      [[__no_unique_address__]] _Head _M_head_impl;
    };
# 195 "/usr/include/c++/14.2.1/tuple" 3
  template<size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      constexpr
      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 constexpr
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 constexpr
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 constexpr
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 274 "/usr/include/c++/14.2.1/tuple" 3
  template<size_t _Idx, typename... _Elements>
    struct _Tuple_impl;






  template<size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head>
    {
      template<size_t, typename...> friend struct _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit constexpr
      _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head)
      { }

      template<typename _UHead, typename... _UTail,
        typename = __enable_if_t<sizeof...(_Tail) == sizeof...(_UTail)>>
 explicit constexpr
 _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head))
 { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;

      _Tuple_impl(_Tuple_impl&&) = default;

      template<typename... _UElements>
 constexpr
 _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in))
 { }

      template<typename _UHead, typename... _UTails>
 constexpr
 _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))
 { }
# 370 "/usr/include/c++/14.2.1/tuple" 3
      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
   _Base(__tag, __use_alloc<_Head>(__a))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head)
 { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
        typename = __enable_if_t<sizeof...(_Tail) == sizeof...(_UTail)>>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
  std::forward<_UHead>(__head))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  std::forward<_Head>(_M_head(__in)))
 { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Tuple_impl<_Idx, _UHead, _UTails...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, const _UHead&>(__a),
  _Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))
 { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
  std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))
 { }
# 465 "/usr/include/c++/14.2.1/tuple" 3
      template<typename... _UElements>
 constexpr
 void
 _M_assign(const _Tuple_impl<_Idx, _UElements...>& __in)
 {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this)._M_assign(
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in));
 }

      template<typename _UHead, typename... _UTails>
 constexpr
 void
 _M_assign(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this)._M_assign(
       std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));
 }
# 525 "/usr/include/c++/14.2.1/tuple" 3
    protected:
      constexpr
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
# 544 "/usr/include/c++/14.2.1/tuple" 3
    };


  template<size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head>
    {
      template<size_t, typename...> friend struct _Tuple_impl;

      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr
      _Tuple_impl()
      : _Base() { }

      explicit constexpr
      _Tuple_impl(const _Head& __head)
      : _Base(__head)
      { }

      template<typename _UHead>
 explicit constexpr
 _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head))
 { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;




      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(static_cast<_Base&&>(__in))
      { }


      template<typename _UHead>
 constexpr
 _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in))
 { }

      template<typename _UHead>
 constexpr
 _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }
# 626 "/usr/include/c++/14.2.1/tuple" 3
      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, const _Head&>(__a), __head)
 { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
  std::forward<_UHead>(__head))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, const _Head&>(__a), _M_head(__in))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  std::forward<_Head>(_M_head(__in)))
 { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, const _UHead&>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in))
 { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
  std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }
# 705 "/usr/include/c++/14.2.1/tuple" 3
      template<typename _UHead>
 constexpr
 void
 _M_assign(const _Tuple_impl<_Idx, _UHead>& __in)
 {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
 }

      template<typename _UHead>
 constexpr
 void
 _M_assign(_Tuple_impl<_Idx, _UHead>&& __in)
 {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
 }
# 751 "/usr/include/c++/14.2.1/tuple" 3
    protected:
      constexpr
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
# 768 "/usr/include/c++/14.2.1/tuple" 3
    };



  template<bool, typename... _Types>
    struct _TupleConstraints
    {
      template<typename... _UTypes>
 using __constructible = __and_<is_constructible<_Types, _UTypes>...>;

      template<typename... _UTypes>
 using __convertible = __and_<is_convertible<_UTypes, _Types>...>;




      template<typename... _UTypes>
 static constexpr bool __is_implicitly_constructible()
 {
   return __and_<__constructible<_UTypes...>,
   __convertible<_UTypes...>
   >::value;
 }




      template<typename... _UTypes>
 static constexpr bool __is_explicitly_constructible()
 {
   return __and_<__constructible<_UTypes...>,
   __not_<__convertible<_UTypes...>>
   >::value;
 }

      static constexpr bool __is_implicitly_default_constructible()
      {
 return __and_<std::__is_implicitly_default_constructible<_Types>...
        >::value;
      }

      static constexpr bool __is_explicitly_default_constructible()
      {
 return __and_<is_default_constructible<_Types>...,
        __not_<__and_<
   std::__is_implicitly_default_constructible<_Types>...>
        >>::value;
      }
    };



  template<typename... _Types>
    struct _TupleConstraints<false, _Types...>
    {
      template<typename... _UTypes>
 static constexpr bool __is_implicitly_constructible()
 { return false; }

      template<typename... _UTypes>
 static constexpr bool __is_explicitly_constructible()
 { return false; }
    };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      using _Inherited = _Tuple_impl<0, _Elements...>;


      template<typename... _UTypes>
 static consteval bool
 __constructible()
 {
   if constexpr (sizeof...(_UTypes) == sizeof...(_Elements))
     return __and_v<is_constructible<_Elements, _UTypes>...>;
   else
     return false;
 }

      template<typename... _UTypes>
 static consteval bool
 __nothrow_constructible()
 {
   if constexpr (sizeof...(_UTypes) == sizeof...(_Elements))
     return __and_v<is_nothrow_constructible<_Elements, _UTypes>...>;
   else
     return false;
 }

      template<typename... _UTypes>
 static consteval bool
 __convertible()
 {
   if constexpr (sizeof...(_UTypes) == sizeof...(_Elements))
     return __and_v<is_convertible<_UTypes, _Elements>...>;
   else
     return false;
 }



      template<typename... _UTypes>
 static consteval bool
 __disambiguating_constraint()
 {
   if constexpr (sizeof...(_Elements) != sizeof...(_UTypes))
     return false;
   else if constexpr (sizeof...(_Elements) == 1)
     {
       using _U0 = typename _Nth_type<0, _UTypes...>::type;
       return !is_same_v<remove_cvref_t<_U0>, tuple>;
     }
   else if constexpr (sizeof...(_Elements) < 4)
     {
       using _U0 = typename _Nth_type<0, _UTypes...>::type;
       if constexpr (!is_same_v<remove_cvref_t<_U0>, allocator_arg_t>)
  return true;
       else
  {
    using _T0 = typename _Nth_type<0, _Elements...>::type;
    return is_same_v<remove_cvref_t<_T0>, allocator_arg_t>;
  }
     }
   return true;
 }




      template<typename _Tuple>
 static consteval bool
 __use_other_ctor()
 {
   if constexpr (sizeof...(_Elements) != 1)
     return false;
   else if constexpr (is_same_v<remove_cvref_t<_Tuple>, tuple>)
     return true;
   else
     {
       using _Tp = typename _Nth_type<0, _Elements...>::type;
       if constexpr (is_convertible_v<_Tuple, _Tp>)
  return true;
       else if constexpr (is_constructible_v<_Tp, _Tuple>)
  return true;
     }
   return false;
 }

      template<typename... _Up>
 static consteval bool
 __dangles()
 {

   return (__reference_constructs_from_temporary(_Elements, _Up&&)
      || ...);



 }
# 961 "/usr/include/c++/14.2.1/tuple" 3
    public:
      constexpr
      explicit(!(__is_implicitly_default_constructible_v<_Elements> && ...))
      tuple()
      noexcept((is_nothrow_default_constructible_v<_Elements> && ...))
      requires (is_default_constructible_v<_Elements> && ...)
      : _Inherited()
      { }

      constexpr explicit(!__convertible<const _Elements&...>())
      tuple(const _Elements&... __elements)
      noexcept(__nothrow_constructible<const _Elements&...>())
      requires (__constructible<const _Elements&...>())
      : _Inherited(__elements...)
      { }

      template<typename... _UTypes>
 requires (__disambiguating_constraint<_UTypes...>())
   && (__constructible<_UTypes...>())
   && (!__dangles<_UTypes...>())
 constexpr explicit(!__convertible<_UTypes...>())
 tuple(_UTypes&&... __u)
 noexcept(__nothrow_constructible<_UTypes...>())
 : _Inherited(std::forward<_UTypes>(__u)...)
 { }

      template<typename... _UTypes>
 requires (__disambiguating_constraint<_UTypes...>())
   && (__constructible<_UTypes...>())
   && (__dangles<_UTypes...>())
 tuple(_UTypes&&...) = delete;

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename... _UTypes>
 requires (__constructible<const _UTypes&...>())
   && (!__use_other_ctor<const tuple<_UTypes...>&>())
   && (!__dangles<const _UTypes&...>())
 constexpr explicit(!__convertible<const _UTypes&...>())
 tuple(const tuple<_UTypes...>& __u)
 noexcept(__nothrow_constructible<const _UTypes&...>())
 : _Inherited(static_cast<const _Tuple_impl<0, _UTypes...>&>(__u))
 { }

      template<typename... _UTypes>
 requires (__constructible<const _UTypes&...>())
   && (!__use_other_ctor<const tuple<_UTypes...>&>())
   && (__dangles<const _UTypes&...>())
 tuple(const tuple<_UTypes...>&) = delete;

      template<typename... _UTypes>
 requires (__constructible<_UTypes...>())
   && (!__use_other_ctor<tuple<_UTypes...>>())
   && (!__dangles<_UTypes...>())
 constexpr explicit(!__convertible<_UTypes...>())
 tuple(tuple<_UTypes...>&& __u)
 noexcept(__nothrow_constructible<_UTypes...>())
 : _Inherited(static_cast<_Tuple_impl<0, _UTypes...>&&>(__u))
 { }

      template<typename... _UTypes>
 requires (__constructible<_UTypes...>())
   && (!__use_other_ctor<tuple<_UTypes...>>())
   && (__dangles<_UTypes...>())
 tuple(tuple<_UTypes...>&&) = delete;
# 1063 "/usr/include/c++/14.2.1/tuple" 3
      template<typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<const _U1&, const _U2&>())
   && (!__dangles<const _U1&, const _U2&>())
 constexpr explicit(!__convertible<const _U1&, const _U2&>())
 tuple(const pair<_U1, _U2>& __u)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(__u.first, __u.second)
 { }

      template<typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<const _U1&, const _U2&>())
   && (__dangles<const _U1&, const _U2&>())
 tuple(const pair<_U1, _U2>&) = delete;

      template<typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<_U1, _U2>())
   && (!__dangles<_U1, _U2>())
 constexpr explicit(!__convertible<_U1, _U2>())
 tuple(pair<_U1, _U2>&& __u)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__u.first),
       std::forward<_U2>(__u.second))
 { }

      template<typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<_U1, _U2>())
   && (__dangles<_U1, _U2>())
 tuple(pair<_U1, _U2>&&) = delete;
# 1152 "/usr/include/c++/14.2.1/tuple" 3
      template<typename _Alloc>
 constexpr
 explicit(!(__is_implicitly_default_constructible_v<_Elements> && ...))
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 requires (is_default_constructible_v<_Elements> && ...)
 : _Inherited(__tag, __a)
 { }

      template<typename _Alloc>
 constexpr explicit(!__convertible<const _Elements&...>())
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 requires (__constructible<const _Elements&...>())
 : _Inherited(__tag, __a, __elements...)
 { }

      template<typename _Alloc, typename... _UTypes>
 requires (__disambiguating_constraint<_UTypes...>())
   && (__constructible<_UTypes...>())
   && (!__dangles<_UTypes...>())
 constexpr explicit(!__convertible<_UTypes...>())
 tuple(allocator_arg_t __tag, const _Alloc& __a, _UTypes&&... __u)
 : _Inherited(__tag, __a, std::forward<_UTypes>(__u)...)
 { }

      template<typename _Alloc, typename... _UTypes>
 requires (__disambiguating_constraint<_UTypes...>())
   && (__constructible<_UTypes...>())
   && (__dangles<_UTypes...>())
 tuple(allocator_arg_t, const _Alloc&, _UTypes&&...) = delete;

      template<typename _Alloc>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __u)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__u))
 { }

      template<typename _Alloc>
 requires (__constructible<_Elements...>())
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __u)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__u))
 { }

      template<typename _Alloc, typename... _UTypes>
 requires (__constructible<const _UTypes&...>())
   && (!__use_other_ctor<const tuple<_UTypes...>&>())
   && (!__dangles<const _UTypes&...>())
 constexpr explicit(!__convertible<const _UTypes&...>())
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UTypes...>& __u)
 : _Inherited(__tag, __a,
       static_cast<const _Tuple_impl<0, _UTypes...>&>(__u))
 { }

      template<typename _Alloc, typename... _UTypes>
 requires (__constructible<const _UTypes&...>())
   && (!__use_other_ctor<const tuple<_UTypes...>&>())
   && (__dangles<const _UTypes&...>())
 tuple(allocator_arg_t, const _Alloc&, const tuple<_UTypes...>&) = delete;

      template<typename _Alloc, typename... _UTypes>
 requires (__constructible<_UTypes...>())
   && (!__use_other_ctor<tuple<_UTypes...>>())
   && (!__dangles<_UTypes...>())
 constexpr explicit(!__use_other_ctor<tuple<_UTypes...>>())
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_UTypes...>&& __u)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _UTypes...>&&>(__u))
 { }

      template<typename _Alloc, typename... _UTypes>
 requires (__constructible<_UTypes...>())
   && (!__use_other_ctor<tuple<_UTypes...>>())
   && (__dangles<_UTypes...>())
 tuple(allocator_arg_t, const _Alloc&, tuple<_UTypes...>&&) = delete;
# 1262 "/usr/include/c++/14.2.1/tuple" 3
      template<typename _Alloc, typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<const _U1&, const _U2&>())
   && (!__dangles<const _U1&, const _U2&>())
 constexpr explicit(!__convertible<const _U1&, const _U2&>())
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __u)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(__tag, __a, __u.first, __u.second)
 { }

      template<typename _Alloc, typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<const _U1&, const _U2&>())
   && (__dangles<const _U1&, const _U2&>())
 tuple(allocator_arg_t, const _Alloc&, const pair<_U1, _U2>&) = delete;

      template<typename _Alloc, typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<_U1, _U2>())
   && (!__dangles<_U1, _U2>())
 constexpr explicit(!__convertible<_U1, _U2>())
 tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __u)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(__tag, __a, std::move(__u.first), std::move(__u.second))
 { }

      template<typename _Alloc, typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<_U1, _U2>())
   && (__dangles<_U1, _U2>())
 tuple(allocator_arg_t, const _Alloc&, pair<_U1, _U2>&&) = delete;
# 1654 "/usr/include/c++/14.2.1/tuple" 3
    private:
      template<typename... _UTypes>
 static consteval bool
 __assignable()
 {
   if constexpr (sizeof...(_UTypes) == sizeof...(_Elements))
     return __and_v<is_assignable<_Elements&, _UTypes>...>;
   else
     return false;
 }

      template<typename... _UTypes>
 static consteval bool
 __nothrow_assignable()
 {
   if constexpr (sizeof...(_UTypes) == sizeof...(_Elements))
     return __and_v<is_nothrow_assignable<_Elements&, _UTypes>...>;
   else
     return false;
 }
# 1707 "/usr/include/c++/14.2.1/tuple" 3
    public:

      tuple& operator=(const tuple& __u) = delete;

      constexpr tuple&
      operator=(const tuple& __u)
      noexcept(__nothrow_assignable<const _Elements&...>())
      requires (__assignable<const _Elements&...>())
      {
 this->_M_assign(__u);
 return *this;
      }

      constexpr tuple&
      operator=(tuple&& __u)
      noexcept(__nothrow_assignable<_Elements...>())
      requires (__assignable<_Elements...>())
      {
 this->_M_assign(std::move(__u));
 return *this;
      }

      template<typename... _UTypes>
 requires (__assignable<const _UTypes&...>())
 constexpr tuple&
 operator=(const tuple<_UTypes...>& __u)
 noexcept(__nothrow_assignable<const _UTypes&...>())
 {
   this->_M_assign(__u);
   return *this;
 }

      template<typename... _UTypes>
 requires (__assignable<_UTypes...>())
 constexpr tuple&
 operator=(tuple<_UTypes...>&& __u)
 noexcept(__nothrow_assignable<_UTypes...>())
 {
   this->_M_assign(std::move(__u));
   return *this;
 }
# 1785 "/usr/include/c++/14.2.1/tuple" 3
      template<typename _U1, typename _U2>
 requires (__assignable<const _U1&, const _U2&>())
 constexpr tuple&
 operator=(const pair<_U1, _U2>& __u)
 noexcept(__nothrow_assignable<const _U1&, const _U2&>())
 {
   this->_M_head(*this) = __u.first;
   this->_M_tail(*this)._M_head(*this) = __u.second;
   return *this;
 }

      template<typename _U1, typename _U2>
 requires (__assignable<_U1, _U2>())
 constexpr tuple&
 operator=(pair<_U1, _U2>&& __u)
 noexcept(__nothrow_assignable<_U1, _U2>())
 {
   this->_M_head(*this) = std::forward<_U1>(__u.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__u.second);
   return *this;
 }
# 1947 "/usr/include/c++/14.2.1/tuple" 3
      constexpr
      void
      swap(tuple& __in)
      noexcept(__and_<__is_nothrow_swappable<_Elements>...>::value)
      { _Inherited::_M_swap(__in); }
# 1966 "/usr/include/c++/14.2.1/tuple" 3
    };


  template<typename... _UTypes>
    tuple(_UTypes...) -> tuple<_UTypes...>;
  template<typename _T1, typename _T2>
    tuple(pair<_T1, _T2>) -> tuple<_T1, _T2>;
  template<typename _Alloc, typename... _UTypes>
    tuple(allocator_arg_t, _Alloc, _UTypes...) -> tuple<_UTypes...>;
  template<typename _Alloc, typename _T1, typename _T2>
    tuple(allocator_arg_t, _Alloc, pair<_T1, _T2>) -> tuple<_T1, _T2>;
  template<typename _Alloc, typename... _UTypes>
    tuple(allocator_arg_t, _Alloc, tuple<_UTypes...>) -> tuple<_UTypes...>;



  template<>
    class tuple<>
    {
    public:
      constexpr
      void swap(tuple&) noexcept { }





      tuple() = default;

      template<typename _Alloc>
 constexpr
 tuple(allocator_arg_t, const _Alloc&) noexcept { }
      template<typename _Alloc>
 constexpr
 tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept { }
    };
# 2402 "/usr/include/c++/14.2.1/tuple" 3
  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<size_t, sizeof...(_Elements)> { };


  template<typename... _Types>
    inline constexpr size_t tuple_size_v<tuple<_Types...>>
      = sizeof...(_Types);

  template<typename... _Types>
    inline constexpr size_t tuple_size_v<const tuple<_Types...>>
      = sizeof...(_Types);



  template<size_t __i, typename... _Types>
    struct tuple_element<__i, tuple<_Types...>>
    {
      static_assert(__i < sizeof...(_Types), "tuple index must be in range");

      using type = typename _Nth_type<__i, _Types...>::type;
    };

  template<size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<size_t __i, typename... _Types>
    __enable_if_t<(__i >= sizeof...(_Types))>
    __get_helper(const tuple<_Types...>&) = delete;


  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type>(std::__get_helper<__i>(__t));
    }


  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
    get(const tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<const __element_type>(std::__get_helper<__i>(__t));
    }



  template<size_t __i, typename... _Elements>
    constexpr __enable_if_t<(__i >= sizeof...(_Elements))>
    get(const tuple<_Elements...>&) = delete;




  template <typename _Tp, typename... _Types>
    constexpr _Tp&
    get(tuple<_Types...>& __t) noexcept
    {
      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
      static_assert(__idx < sizeof...(_Types),
   "the type T in std::get<T> must occur exactly once in the tuple");
      return std::__get_helper<__idx>(__t);
    }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&&
    get(tuple<_Types...>&& __t) noexcept
    {
      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
      static_assert(__idx < sizeof...(_Types),
   "the type T in std::get<T> must occur exactly once in the tuple");
      return std::forward<_Tp>(std::__get_helper<__idx>(__t));
    }


  template <typename _Tp, typename... _Types>
    constexpr const _Tp&
    get(const tuple<_Types...>& __t) noexcept
    {
      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
      static_assert(__idx < sizeof...(_Types),
   "the type T in std::get<T> must occur exactly once in the tuple");
      return std::__get_helper<__idx>(__t);
    }



  template <typename _Tp, typename... _Types>
    constexpr const _Tp&&
    get(const tuple<_Types...>&& __t) noexcept
    {
      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
      static_assert(__idx < sizeof...(_Types),
   "the type T in std::get<T> must occur exactly once in the tuple");
      return std::forward<const _Tp>(std::__get_helper<__idx>(__t));
    }



  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }


  template<typename _Cat, typename _Tp, typename _Up>
    constexpr _Cat
    __tuple_cmp(const _Tp&, const _Up&, index_sequence<>)
    { return _Cat::equivalent; }

  template<typename _Cat, typename _Tp, typename _Up,
    size_t _Idx0, size_t... _Idxs>
    constexpr _Cat
    __tuple_cmp(const _Tp& __t, const _Up& __u,
  index_sequence<_Idx0, _Idxs...>)
    {
      auto __c
 = __detail::__synth3way(std::get<_Idx0>(__t), std::get<_Idx0>(__u));
      if (__c != 0)
 return __c;
      return std::__tuple_cmp<_Cat>(__t, __u, index_sequence<_Idxs...>());
    }

  template<typename... _Tps, typename... _Ups>
    constexpr
    common_comparison_category_t<__detail::__synth3way_t<_Tps, _Ups>...>
    operator<=>(const tuple<_Tps...>& __t, const tuple<_Ups...>& __u)
    {
      using _Cat
 = common_comparison_category_t<__detail::__synth3way_t<_Tps, _Ups>...>;
      return std::__tuple_cmp<_Cat>(__t, __u, index_sequence_for<_Tps...>());
    }
# 2636 "/usr/include/c++/14.2.1/tuple" 3
  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }


  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<__remove_cvref_t<_Tuple>>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef _Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename _Build_index_tuple<tuple_size<
 typename remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, _Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, _Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };






  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>

    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    constexpr
    inline


    typename enable_if<__and_<__is_swappable<_Elements>...>::value
      >::type



    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 2818 "/usr/include/c++/14.2.1/tuple" 3
  template<typename... _Elements>
    constexpr
    typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type
    swap(tuple<_Elements...>&, tuple<_Elements...>&) = delete;






  struct _Swallow_assign
  {
    template<class _Tp>
      constexpr const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };
# 2853 "/usr/include/c++/14.2.1/tuple" 3
  inline constexpr _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };
# 2868 "/usr/include/c++/14.2.1/tuple" 3
  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      constexpr
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, size_t... _Indexes1,
      typename... _Args2, size_t... _Indexes2>
      constexpr inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
 second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }






  template<template<typename...> class _Trait, typename _Tp, typename _Tuple>
    inline constexpr bool __unpack_std_tuple = false;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, tuple<_Up...>>
      = _Trait<_Tp, _Up...>::value;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, tuple<_Up...>&>
      = _Trait<_Tp, _Up&...>::value;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, const tuple<_Up...>>
      = _Trait<_Tp, const _Up...>::value;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, const tuple<_Up...>&>
      = _Trait<_Tp, const _Up&...>::value;



  template <typename _Fn, typename _Tuple, size_t... _Idx>
    constexpr decltype(auto)
    __apply_impl(_Fn&& __f, _Tuple&& __t, index_sequence<_Idx...>)
    {
      return std::__invoke(std::forward<_Fn>(__f),
      std::get<_Idx>(std::forward<_Tuple>(__t))...);
    }




  template <typename _Fn, typename _Tuple>

    constexpr decltype(auto)
    apply(_Fn&& __f, _Tuple&& __t)
    noexcept(__unpack_std_tuple<is_nothrow_invocable, _Fn, _Tuple>)
    {
      using _Indices
 = make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>;
      return std::__apply_impl(std::forward<_Fn>(__f),
          std::forward<_Tuple>(__t),
          _Indices{});
    }



  template <typename _Tp, typename _Tuple, size_t... _Idx>
    constexpr _Tp
    __make_from_tuple_impl(_Tuple&& __t, index_sequence<_Idx...>)
    { return _Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...); }




  template <typename _Tp, typename _Tuple>

    constexpr _Tp
    make_from_tuple(_Tuple&& __t)
    noexcept(__unpack_std_tuple<is_nothrow_constructible, _Tp, _Tuple>)
    {
      constexpr size_t __n = tuple_size_v<remove_reference_t<_Tuple>>;

      if constexpr (__n == 1)
 {
   using _Elt = decltype(std::get<0>(std::declval<_Tuple>()));
   static_assert(!__reference_constructs_from_temporary(_Tp, _Elt));
 }

      return __make_from_tuple_impl<_Tp>(std::forward<_Tuple>(__t),
      make_index_sequence<__n>{});
    }
# 3030 "/usr/include/c++/14.2.1/tuple" 3

}
# 40 "/usr/include/c++/14.2.1/bits/uses_allocator_args.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp>
    concept _Std_pair = __is_pair<remove_cv_t<_Tp>>;




  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a,
         _Args&&... __args) noexcept
    requires (! _Std_pair<_Tp>)
    {
      if constexpr (uses_allocator_v<remove_cv_t<_Tp>, _Alloc>)
 {
   if constexpr (is_constructible_v<_Tp, allocator_arg_t,
        const _Alloc&, _Args...>)
     {
       return tuple<allocator_arg_t, const _Alloc&, _Args&&...>(
    allocator_arg, __a, std::forward<_Args>(__args)...);
     }
   else
     {
       static_assert(is_constructible_v<_Tp, _Args..., const _Alloc&>,
    "construction with an allocator must be possible"
    " if uses_allocator is true");

       return tuple<_Args&&..., const _Alloc&>(
    std::forward<_Args>(__args)..., __a);
     }
 }
      else
 {
   static_assert(is_constructible_v<_Tp, _Args...>);

   return tuple<_Args&&...>(std::forward<_Args>(__args)...);
 }
    }

  template<_Std_pair _Tp, typename _Alloc, typename _Tuple1, typename _Tuple2>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a, piecewise_construct_t,
         _Tuple1&& __x, _Tuple2&& __y) noexcept;

  template<_Std_pair _Tp, typename _Alloc>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&) noexcept;

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&, _Up&&, _Vp&&) noexcept;

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&,
         const pair<_Up, _Vp>&) noexcept;

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&, pair<_Up, _Vp>&&) noexcept;
# 118 "/usr/include/c++/14.2.1/bits/uses_allocator_args.h" 3
  template<_Std_pair _Tp, typename _Alloc, typename _Tuple1, typename _Tuple2>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a, piecewise_construct_t,
         _Tuple1&& __x, _Tuple2&& __y) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::apply([&__a](auto&&... __args1) {
       return std::uses_allocator_construction_args<_Tp1>(
    __a, std::forward<decltype(__args1)>(__args1)...);
   }, std::forward<_Tuple1>(__x)),
   std::apply([&__a](auto&&... __args2) {
       return std::uses_allocator_construction_args<_Tp2>(
    __a, std::forward<decltype(__args2)>(__args2)...);
   }, std::forward<_Tuple2>(__y)));
    }

  template<_Std_pair _Tp, typename _Alloc>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a),
   std::uses_allocator_construction_args<_Tp2>(__a));
    }

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a, _Up&& __u, _Vp&& __v)
      noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a,
     std::forward<_Up>(__u)),
   std::uses_allocator_construction_args<_Tp2>(__a,
     std::forward<_Vp>(__v)));
    }

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a,
         const pair<_Up, _Vp>& __pr) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a, __pr.first),
   std::uses_allocator_construction_args<_Tp2>(__a, __pr.second));
    }

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a,
         pair<_Up, _Vp>&& __pr) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;




      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a,
     std::get<0>(std::move(__pr))),
   std::uses_allocator_construction_args<_Tp2>(__a,
     std::get<1>(std::move(__pr))));
    }
# 225 "/usr/include/c++/14.2.1/bits/uses_allocator_args.h" 3
  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr _Tp
    make_obj_using_allocator(const _Alloc& __a, _Args&&... __args)
    {
      return std::make_from_tuple<_Tp>(
   std::uses_allocator_construction_args<_Tp>(__a,
     std::forward<_Args>(__args)...));
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr _Tp*
    uninitialized_construct_using_allocator(_Tp* __p, const _Alloc& __a,
         _Args&&... __args)
    {
      return std::apply([&](auto&&... __xs) {
 return std::construct_at(__p, std::forward<decltype(__xs)>(__xs)...);
      }, std::uses_allocator_construction_args<_Tp>(__a,
 std::forward<_Args>(__args)...));
    }


}
# 42 "/usr/include/c++/14.2.1/bits/memory_resource.h" 2 3
# 50 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

namespace pmr
{






  class memory_resource
  {
    static constexpr size_t _S_max_align = alignof(max_align_t);

  public:
    memory_resource() = default;
    memory_resource(const memory_resource&) = default;
    virtual ~memory_resource();

    memory_resource& operator=(const memory_resource&) = default;

    [[nodiscard]]
    void*
    allocate(size_t __bytes, size_t __alignment = _S_max_align)
    __attribute__((__returns_nonnull__,__alloc_size__(2),__alloc_align__(3)))
    { return ::operator new(__bytes, do_allocate(__bytes, __alignment)); }

    void
    deallocate(void* __p, size_t __bytes, size_t __alignment = _S_max_align)
    __attribute__((__nonnull__))
    { return do_deallocate(__p, __bytes, __alignment); }

    [[nodiscard]]
    bool
    is_equal(const memory_resource& __other) const noexcept
    { return do_is_equal(__other); }

  private:
    virtual void*
    do_allocate(size_t __bytes, size_t __alignment) = 0;

    virtual void
    do_deallocate(void* __p, size_t __bytes, size_t __alignment) = 0;

    virtual bool
    do_is_equal(const memory_resource& __other) const noexcept = 0;
  };

  [[nodiscard]]
  inline bool
  operator==(const memory_resource& __a, const memory_resource& __b) noexcept
  { return &__a == &__b || __a.is_equal(__b); }
# 119 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
  template<typename _Tp>
    class polymorphic_allocator
    {


      template<typename _Up>
 struct __not_pair { using type = void; };

      template<typename _Up1, typename _Up2>
 struct __not_pair<pair<_Up1, _Up2>> { };

    public:
      using value_type = _Tp;

      polymorphic_allocator() noexcept
      {
 extern memory_resource* get_default_resource() noexcept
   __attribute__((__returns_nonnull__));
 _M_resource = get_default_resource();
      }

      polymorphic_allocator(memory_resource* __r) noexcept
      __attribute__((__nonnull__))
      : _M_resource(__r)
      { ; }

      polymorphic_allocator(const polymorphic_allocator& __other) = default;

      template<typename _Up>
 polymorphic_allocator(const polymorphic_allocator<_Up>& __x) noexcept
 : _M_resource(__x.resource())
 { }

      polymorphic_allocator&
      operator=(const polymorphic_allocator&) = delete;

      [[nodiscard]]
      _Tp*
      allocate(size_t __n)
      __attribute__((__returns_nonnull__))
      {
 if ((__gnu_cxx::__int_traits<size_t>::__max / sizeof(_Tp)) < __n)
   std::__throw_bad_array_new_length();
 return static_cast<_Tp*>(_M_resource->allocate(__n * sizeof(_Tp),
             alignof(_Tp)));
      }

      void
      deallocate(_Tp* __p, size_t __n) noexcept
      __attribute__((__nonnull__))
      { _M_resource->deallocate(__p, __n * sizeof(_Tp), alignof(_Tp)); }


      [[nodiscard]] void*
      allocate_bytes(size_t __nbytes,
       size_t __alignment = alignof(max_align_t))
      { return _M_resource->allocate(__nbytes, __alignment); }

      void
      deallocate_bytes(void* __p, size_t __nbytes,
         size_t __alignment = alignof(max_align_t))
      { _M_resource->deallocate(__p, __nbytes, __alignment); }

      template<typename _Up>
 [[nodiscard]] _Up*
 allocate_object(size_t __n = 1)
 {
   if ((__gnu_cxx::__int_traits<size_t>::__max / sizeof(_Up)) < __n)
     std::__throw_bad_array_new_length();
   return static_cast<_Up*>(allocate_bytes(__n * sizeof(_Up),
        alignof(_Up)));
 }

      template<typename _Up>
 void
 deallocate_object(_Up* __p, size_t __n = 1)
 { deallocate_bytes(__p, __n * sizeof(_Up), alignof(_Up)); }

      template<typename _Up, typename... _CtorArgs>
 [[nodiscard]] _Up*
 new_object(_CtorArgs&&... __ctor_args)
 {
   _Up* __p = allocate_object<_Up>();
   try
     {
       construct(__p, std::forward<_CtorArgs>(__ctor_args)...);
     }
   catch(...)
     {
       deallocate_object(__p);
       throw;
     }
   return __p;
 }

      template<typename _Up>
 void
 delete_object(_Up* __p)
 {
   __p->~_Up();
   deallocate_object(__p);
 }
# 297 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
      template<typename _Tp1, typename... _Args>
 __attribute__((__nonnull__))
 void
 construct(_Tp1* __p, _Args&&... __args)
 {
   std::uninitialized_construct_using_allocator(__p, *this,
       std::forward<_Args>(__args)...);
 }


      template<typename _Up>
 __attribute__ ((__deprecated__ ("use '" "allocator_traits::destroy" "' instead")))
 __attribute__((__nonnull__))
 void
 destroy(_Up* __p)
 { __p->~_Up(); }

      polymorphic_allocator
      select_on_container_copy_construction() const noexcept
      { return polymorphic_allocator(); }

      memory_resource*
      resource() const noexcept
      __attribute__((__returns_nonnull__))
      { return _M_resource; }



      [[nodiscard]]
      friend bool
      operator==(const polymorphic_allocator& __a,
   const polymorphic_allocator& __b) noexcept
      { return *__a.resource() == *__b.resource(); }
# 339 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
    private:
# 366 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
      memory_resource* _M_resource;
    };

  template<typename _Tp1, typename _Tp2>
    [[nodiscard]]
    inline bool
    operator==(const polymorphic_allocator<_Tp1>& __a,
        const polymorphic_allocator<_Tp2>& __b) noexcept
    { return *__a.resource() == *__b.resource(); }
# 385 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
}

  template<typename _Alloc> struct allocator_traits;


  template<typename _Tp>
    struct allocator_traits<pmr::polymorphic_allocator<_Tp>>
    {

      using allocator_type = pmr::polymorphic_allocator<_Tp>;


      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;





      using propagate_on_container_copy_assignment = false_type;
      using propagate_on_container_move_assignment = false_type;
      using propagate_on_container_swap = false_type;

      static allocator_type
      select_on_container_copy_construction(const allocator_type&) noexcept
      { return allocator_type(); }



      using is_always_equal = false_type;

      template<typename _Up>
 using rebind_alloc = pmr::polymorphic_allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<pmr::polymorphic_allocator<_Up>>;
# 446 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
      [[nodiscard]] static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 461 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
      [[nodiscard]] static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer)
      { return __a.allocate(__n); }
# 473 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 488 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a, _Up* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }
# 500 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
      template<typename _Up>
 static constexpr void
 destroy(allocator_type&, _Up* __p)
 noexcept(is_nothrow_destructible<_Up>::value)
 { __p->~_Up(); }





      static constexpr size_type
      max_size(const allocator_type&) noexcept
      { return size_t(-1) / sizeof(value_type); }
    };


}
# 69 "/usr/include/c++/14.2.1/string" 2 3
namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace pmr {
    template<typename _CharT, typename _Traits = char_traits<_CharT>>
      using basic_string = std::basic_string<_CharT, _Traits,
          polymorphic_allocator<_CharT>>;
    using string = basic_string<char>;

    using u8string = basic_string<char8_t>;

    using u16string = basic_string<char16_t>;
    using u32string = basic_string<char32_t>;
    using wstring = basic_string<wchar_t>;
  }

}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits, typename _Alloc,
    typename _Predicate>
    constexpr
    inline typename basic_string<_CharT, _Traits, _Alloc>::size_type
    erase_if(basic_string<_CharT, _Traits, _Alloc>& __cont, _Predicate __pred)
    {
      using namespace __gnu_cxx;
      const auto __osz = __cont.size();
      const auto __end = __cont.end();
      auto __removed = std::__remove_if(__cont.begin(), __end,
     __ops::__pred_iter(std::ref(__pred)));
      __cont.erase(__removed, __end);
      return __osz - __cont.size();
    }

  template<typename _CharT, typename _Traits, typename _Alloc, typename _Up>
    constexpr
    inline typename basic_string<_CharT, _Traits, _Alloc>::size_type
    erase(basic_string<_CharT, _Traits, _Alloc>& __cont, const _Up& __value)
    {
      using namespace __gnu_cxx;
      const auto __osz = __cont.size();
      const auto __end = __cont.end();
      auto __removed = std::__remove_if(__cont.begin(), __end,
     __ops::__iter_equals_val(__value));
      __cont.erase(__removed, __end);
      return __osz - __cont.size();
    }

}
# 41 "/usr/include/c++/14.2.1/bits/locale_classes.h" 2 3






namespace std __attribute__ ((__visibility__ ("default")))
{

# 66 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend const _Facet*
      __try_use_facet(const locale&) noexcept;

    template<typename _Cache>
      friend struct __use_cache;
# 106 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 125 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
    locale() throw();
# 134 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 144 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 159 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 170 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
    explicit
    locale(const std::string& __s) : locale(__s.c_str()) { }
# 185 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
    locale(const locale& __base, const std::string& __s, category __cat)
    : locale(__base, __s.c_str(), __cat) { }
# 200 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 213 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 227 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 242 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
    template<typename _Facet>
      [[__nodiscard__]]
      locale
      combine(const locale& __other) const;






    [[__nodiscard__]] __attribute ((__abi_tag__ ("cxx11")))
    string
    name() const;
# 273 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
    [[__nodiscard__]]
    bool
    operator==(const locale& __other) const throw();
# 305 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      [[__nodiscard__]]
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 322 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    [[__nodiscard__]]
    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 358 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);


    static const id* const _S_twinned_facets[];

  };
# 396 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 427 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
# 463 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
    facet(const facet&) = delete;

    facet&
    operator=(const facet&) = delete;


  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    const facet* _M_sso_shim(const id*) const;
    const facet* _M_cow_shim(const id*) const;

  protected:
    class __shim;
  };
# 508 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet*
      __try_use_facet(const locale&) noexcept;




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend const _Facet*
      __try_use_facet(const locale&) noexcept;

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    template<typename _Facet>
      void
      _M_init_facet_unchecked(_Facet* __facet)
      {
 __facet->_M_add_reference();
 _M_facets[_Facet::id._M_id()] = __facet;
      }

    void
    _M_install_cache(const facet*, size_t);

    void _M_init_extra(facet**);
    void _M_init_extra(void*, void*, const char*, const char*);




  };
# 678 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
  template<typename _CharT>
    class __cxx11:: collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 705 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 719 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 736 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 755 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 769 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 798 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 812 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 825 "/usr/include/c++/14.2.1/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class __cxx11:: collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }


      explicit
      collate_byname(const string& __s, size_t __refs = 0)
      : collate_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~collate_byname() { }
    };


}

# 1 "/usr/include/c++/14.2.1/bits/locale_classes.tcc" 1 3
# 37 "/usr/include/c++/14.2.1/bits/locale_classes.tcc" 3
       
# 38 "/usr/include/c++/14.2.1/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wc++17-extensions"
  template<typename _Facet>
    inline const _Facet*
    __try_use_facet(const locale& __loc) noexcept
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;







      if constexpr (__is_same(_Facet, ctype<char>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, num_get<char>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, num_put<char>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, codecvt<char, char, mbstate_t>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, collate<char>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, moneypunct<char>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, moneypunct<char, true>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, money_get<char>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, money_put<char>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, numpunct<char>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, time_get<char>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, time_put<char>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, messages<char>)) return static_cast<const _Facet*>(__facets[__i]);


      if constexpr (__is_same(_Facet, ctype<wchar_t>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, num_get<wchar_t>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, num_put<wchar_t>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, codecvt<wchar_t, char, mbstate_t>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, collate<wchar_t>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, moneypunct<wchar_t>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, moneypunct<wchar_t, true>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, money_get<wchar_t>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, money_put<wchar_t>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, numpunct<wchar_t>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, time_get<wchar_t>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, time_put<wchar_t>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, messages<wchar_t>)) return static_cast<const _Facet*>(__facets[__i]);


      if constexpr (__is_same(_Facet, codecvt<char16_t, char, mbstate_t>)) return static_cast<const _Facet*>(__facets[__i]);
      if constexpr (__is_same(_Facet, codecvt<char32_t, char, mbstate_t>)) return static_cast<const _Facet*>(__facets[__i]);




      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
 return 0;


      return dynamic_cast<const _Facet*>(__facets[__i]);



    }
#pragma GCC diagnostic pop
# 164 "/usr/include/c++/14.2.1/bits/locale_classes.tcc" 3
  template<typename _Facet>
    [[__nodiscard__]]
    inline bool
    has_facet(const locale& __loc) throw()
    {

      static_assert(__is_base_of(locale::facet, _Facet),
      "template argument must be derived from locale::facet");



      return std::__try_use_facet<_Facet>(__loc) != 0;
    }
# 192 "/usr/include/c++/14.2.1/bits/locale_classes.tcc" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdangling-reference"
  template<typename _Facet>
    [[__nodiscard__]]
    inline const _Facet&
    use_facet(const locale& __loc)
    {

      static_assert(__is_base_of(locale::facet, _Facet),
      "template argument must be derived from locale::facet");



      if (const _Facet* __f = std::__try_use_facet<_Facet>(__loc))
 return *__f;
      __throw_bad_cast();
    }
#pragma GCC diagnostic pop



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>*
    __try_use_facet<collate<char> >(const locale&) noexcept;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>*
    __try_use_facet<collate<wchar_t> >(const locale&) noexcept;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 889 "/usr/include/c++/14.2.1/bits/locale_classes.h" 2 3
# 42 "/usr/include/c++/14.2.1/bits/ios_base.h" 2 3




# 1 "/usr/include/c++/14.2.1/system_error" 1 3
# 32 "/usr/include/c++/14.2.1/system_error" 3
       
# 33 "/usr/include/c++/14.2.1/system_error" 3
# 41 "/usr/include/c++/14.2.1/system_error" 3
# 1 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/error_constants.h" 1 3
# 34 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/error_constants.h" 3
# 1 "/usr/include/c++/14.2.1/cerrno" 1 3
# 39 "/usr/include/c++/14.2.1/cerrno" 3
       
# 40 "/usr/include/c++/14.2.1/cerrno" 3
# 35 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/error_constants.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  enum class errc
    {
      address_family_not_supported = 97,
      address_in_use = 98,
      address_not_available = 99,
      already_connected = 106,
      argument_list_too_long = 7,
      argument_out_of_domain = 33,
      bad_address = 14,
      bad_file_descriptor = 9,


      bad_message = 74,


      broken_pipe = 32,
      connection_aborted = 103,
      connection_already_in_progress = 114,
      connection_refused = 111,
      connection_reset = 104,
      cross_device_link = 18,
      destination_address_required = 89,
      device_or_resource_busy = 16,
      directory_not_empty = 39,
      executable_format_error = 8,
      file_exists = 17,
      file_too_large = 27,
      filename_too_long = 36,
      function_not_supported = 38,
      host_unreachable = 113,


      identifier_removed = 43,


      illegal_byte_sequence = 84,
      inappropriate_io_control_operation = 25,
      interrupted = 4,
      invalid_argument = 22,
      invalid_seek = 29,
      io_error = 5,
      is_a_directory = 21,
      message_size = 90,
      network_down = 100,
      network_reset = 102,
      network_unreachable = 101,
      no_buffer_space = 105,
      no_child_process = 10,


      no_link = 67,


      no_lock_available = 37,


      no_message_available = 61,


      no_message = 42,
      no_protocol_option = 92,
      no_space_on_device = 28,


      no_stream_resources = 63,


      no_such_device_or_address = 6,
      no_such_device = 19,
      no_such_file_or_directory = 2,
      no_such_process = 3,
      not_a_directory = 20,
      not_a_socket = 88,


      not_a_stream = 60,


      not_connected = 107,
      not_enough_memory = 12,


      not_supported = 95,



      operation_canceled = 125,


      operation_in_progress = 115,
      operation_not_permitted = 1,
      operation_not_supported = 95,
      operation_would_block = 11,


      owner_dead = 130,


      permission_denied = 13,


      protocol_error = 71,


      protocol_not_supported = 93,
      read_only_file_system = 30,
      resource_deadlock_would_occur = 35,
      resource_unavailable_try_again = 11,
      result_out_of_range = 34,


      state_not_recoverable = 131,



      stream_timeout = 62,



      text_file_busy = 26,


      timed_out = 110,
      too_many_files_open_in_system = 23,
      too_many_files_open = 24,
      too_many_links = 31,
      too_many_symbolic_link_levels = 40,


      value_too_large = 75,




      wrong_protocol_type = 91
    };


}
# 42 "/usr/include/c++/14.2.1/system_error" 2 3

# 1 "/usr/include/c++/14.2.1/stdexcept" 1 3
# 36 "/usr/include/c++/14.2.1/stdexcept" 3
       
# 37 "/usr/include/c++/14.2.1/stdexcept" 3




namespace std __attribute__ ((__visibility__ ("default")))
{





  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) noexcept;
    __cow_string& operator=(const __cow_string&) noexcept;
    ~__cow_string();

    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;

  };

  typedef basic_string<char> __sso_string;
# 113 "/usr/include/c++/14.2.1/stdexcept" 3
  class logic_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    logic_error(const string& __arg) ;


    explicit
    logic_error(const char*) ;

    logic_error(logic_error&&) noexcept;
    logic_error& operator=(logic_error&&) noexcept;



    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;





    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;





  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg) ;

    explicit domain_error(const char*) ;
    domain_error(const domain_error&) = default;
    domain_error& operator=(const domain_error&) = default;
    domain_error(domain_error&&) = default;
    domain_error& operator=(domain_error&&) = default;

    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg) ;

    explicit invalid_argument(const char*) ;
    invalid_argument(const invalid_argument&) = default;
    invalid_argument& operator=(const invalid_argument&) = default;
    invalid_argument(invalid_argument&&) = default;
    invalid_argument& operator=(invalid_argument&&) = default;

    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg) ;

    explicit length_error(const char*) ;
    length_error(const length_error&) = default;
    length_error& operator=(const length_error&) = default;
    length_error(length_error&&) = default;
    length_error& operator=(length_error&&) = default;

    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg) ;

    explicit out_of_range(const char*) ;
    out_of_range(const out_of_range&) = default;
    out_of_range& operator=(const out_of_range&) = default;
    out_of_range(out_of_range&&) = default;
    out_of_range& operator=(out_of_range&&) = default;

    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg) ;


    explicit
    runtime_error(const char*) ;

    runtime_error(runtime_error&&) noexcept;
    runtime_error& operator=(runtime_error&&) noexcept;



    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;





    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;





  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg) ;

    explicit range_error(const char*) ;
    range_error(const range_error&) = default;
    range_error& operator=(const range_error&) = default;
    range_error(range_error&&) = default;
    range_error& operator=(range_error&&) = default;

    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg) ;

    explicit overflow_error(const char*) ;
    overflow_error(const overflow_error&) = default;
    overflow_error& operator=(const overflow_error&) = default;
    overflow_error(overflow_error&&) = default;
    overflow_error& operator=(overflow_error&&) = default;

    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg) ;

    explicit underflow_error(const char*) ;
    underflow_error(const underflow_error&) = default;
    underflow_error& operator=(const underflow_error&) = default;
    underflow_error(underflow_error&&) = default;
    underflow_error& operator=(underflow_error&&) = default;

    virtual ~underflow_error() noexcept;
  };




}
# 44 "/usr/include/c++/14.2.1/system_error" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{






  class error_code;
  class error_condition;
  class system_error;


  template<typename _Tp>
    struct is_error_code_enum : public false_type { };


  template<typename _Tp>
    struct is_error_condition_enum : public false_type { };

  template<>
    struct is_error_condition_enum<errc>
    : public true_type { };


  template <typename _Tp>
    inline constexpr bool is_error_code_enum_v =
      is_error_code_enum<_Tp>::value;
  template <typename _Tp>
    inline constexpr bool is_error_condition_enum_v =
      is_error_condition_enum<_Tp>::value;



inline namespace _V2 {
# 106 "/usr/include/c++/14.2.1/system_error" 3
  class error_category
  {
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category();

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;


    virtual const char*
    name() const noexcept = 0;






  private:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual __cow_string
    _M_message(int) const;

  public:

    __attribute ((__abi_tag__ ("cxx11")))
    virtual string
    message(int) const = 0;
# 144 "/usr/include/c++/14.2.1/system_error" 3
  public:

    virtual error_condition
    default_error_condition(int __i) const noexcept;


    virtual bool
    equivalent(int __i, const error_condition& __cond) const noexcept;


    virtual bool
    equivalent(const error_code& __code, int __i) const noexcept;


    [[__nodiscard__]]
    bool
    operator==(const error_category& __other) const noexcept
    { return this == &__other; }



    [[nodiscard]]
    strong_ordering
    operator<=>(const error_category& __rhs) const noexcept
    { return std::compare_three_way()(this, &__rhs); }
# 178 "/usr/include/c++/14.2.1/system_error" 3
  };




  [[__nodiscard__, __gnu__::__const__]]
  const error_category&
  generic_category() noexcept;


  [[__nodiscard__, __gnu__::__const__]]
  const error_category&
  system_category() noexcept;



}





namespace __adl_only
{
  void make_error_code() = delete;
  void make_error_condition() = delete;
}
# 223 "/usr/include/c++/14.2.1/system_error" 3
  class error_code
  {
    template<typename _ErrorCodeEnum>
      using _Check
 = __enable_if_t<is_error_code_enum<_ErrorCodeEnum>::value>;

  public:
    error_code() noexcept
    : _M_value(0), _M_cat(&system_category()) { }

    error_code(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }


    template<typename _ErrorCodeEnum,
      typename = _Check<_ErrorCodeEnum>>
      error_code(_ErrorCodeEnum __e) noexcept
      {
 using __adl_only::make_error_code;
 *this = make_error_code(__e);
      }

    error_code(const error_code&) = default;
    error_code& operator=(const error_code&) = default;

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void
    clear() noexcept
    { assign(0, system_category()); }


    [[__nodiscard__]]
    int
    value() const noexcept { return _M_value; }


    [[__nodiscard__]]
    const error_category&
    category() const noexcept { return *_M_cat; }


    error_condition
    default_error_condition() const noexcept;


    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }


    [[__nodiscard__]]
    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };
# 300 "/usr/include/c++/14.2.1/system_error" 3
  [[__nodiscard__]]
  inline error_code
  make_error_code(errc __e) noexcept
  { return error_code(static_cast<int>(__e), generic_category()); }
# 314 "/usr/include/c++/14.2.1/system_error" 3
  [[nodiscard]]
  inline strong_ordering
  operator<=>(const error_code& __lhs, const error_code& __rhs) noexcept
  {
    if (auto __c = __lhs.category() <=> __rhs.category(); __c != 0)
      return __c;
    return __lhs.value() <=> __rhs.value();
  }
# 337 "/usr/include/c++/14.2.1/system_error" 3
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
    { return (__os << __e.category().name() << ':' << __e.value()); }
# 354 "/usr/include/c++/14.2.1/system_error" 3
  class error_condition
  {
    template<typename _ErrorConditionEnum>
      using _Check
 = __enable_if_t<is_error_condition_enum<_ErrorConditionEnum>::value>;

  public:

    error_condition() noexcept
    : _M_value(0), _M_cat(&generic_category()) { }


    error_condition(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }


    template<typename _ErrorConditionEnum,
      typename = _Check<_ErrorConditionEnum>>
      error_condition(_ErrorConditionEnum __e) noexcept
      {
 using __adl_only::make_error_condition;
 *this = make_error_condition(__e);
      }

    error_condition(const error_condition&) = default;
    error_condition& operator=(const error_condition&) = default;


    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }


    void
    clear() noexcept
    { assign(0, generic_category()); }




    [[__nodiscard__]]
    int
    value() const noexcept { return _M_value; }


    [[__nodiscard__]]
    const error_category&
    category() const noexcept { return *_M_cat; }


    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }


    [[__nodiscard__]]
    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };
# 433 "/usr/include/c++/14.2.1/system_error" 3
  [[__nodiscard__]]
  inline error_condition
  make_error_condition(errc __e) noexcept
  { return error_condition(static_cast<int>(__e), generic_category()); }
# 447 "/usr/include/c++/14.2.1/system_error" 3
  [[__nodiscard__]]
  inline bool
  operator==(const error_code& __lhs, const error_code& __rhs) noexcept
  {
    return __lhs.category() == __rhs.category()
      && __lhs.value() == __rhs.value();
  }
# 463 "/usr/include/c++/14.2.1/system_error" 3
  [[__nodiscard__]]
  inline bool
  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
  {
    return __lhs.category().equivalent(__lhs.value(), __rhs)
      || __rhs.category().equivalent(__lhs, __rhs.value());
  }
# 478 "/usr/include/c++/14.2.1/system_error" 3
  [[__nodiscard__]]
  inline bool
  operator==(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  {
    return __lhs.category() == __rhs.category()
      && __lhs.value() == __rhs.value();
  }
# 496 "/usr/include/c++/14.2.1/system_error" 3
  [[nodiscard]]
  inline strong_ordering
  operator<=>(const error_condition& __lhs,
       const error_condition& __rhs) noexcept
  {
    if (auto __c = __lhs.category() <=> __rhs.category(); __c != 0)
      return __c;
    return __lhs.value() <=> __rhs.value();
  }
# 556 "/usr/include/c++/14.2.1/system_error" 3
  class system_error : public std::runtime_error
  {
  private:
    error_code _M_code;

  public:
    system_error(error_code __ec = error_code())
    : runtime_error(__ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const string& __what)
    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }

    system_error(error_code __ec, const char* __what)
    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }

    system_error(int __v, const error_category& __ecat, const char* __what)
    : system_error(error_code(__v, __ecat), __what) { }

    system_error(int __v, const error_category& __ecat)
    : runtime_error(error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    system_error(int __v, const error_category& __ecat, const string& __what)
    : runtime_error(__what + (": " + error_code(__v, __ecat).message())),
      _M_code(__v, __ecat) { }


    system_error (const system_error &) = default;
    system_error &operator= (const system_error &) = default;


    virtual ~system_error() noexcept;

    const error_code&
    code() const noexcept { return _M_code; }
  };


}



namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<error_code>
    : public __hash_base<size_t, error_code>
    {
      size_t
      operator()(const error_code& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e.value());
 return std::_Hash_impl::__hash_combine(&__e.category(), __tmp);
      }
    };






  template<>
    struct hash<error_condition>
    : public __hash_base<size_t, error_condition>
    {
      size_t
      operator()(const error_condition& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e.value());
 return std::_Hash_impl::__hash_combine(&__e.category(), __tmp);
      }
    };



}
# 47 "/usr/include/c++/14.2.1/bits/ios_base.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16,
      _S_ios_fmtflags_max = 0x7fffffff,
      _S_ios_fmtflags_min = ~0x7fffffff
    };

  [[__nodiscard__]] constexpr
  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b) noexcept
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  [[__nodiscard__]] constexpr
  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b) noexcept
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  [[__nodiscard__]] constexpr
  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b) noexcept
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  [[__nodiscard__]] constexpr
  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a) noexcept
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  constexpr
  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b) noexcept
  { return __a = __a | __b; }

  constexpr
  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b) noexcept
  { return __a = __a & __b; }

  constexpr
  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b) noexcept
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_noreplace = 1L << 6,
      _S_ios_openmode_end = 1L << 16,
      _S_ios_openmode_max = 0x7fffffff,
      _S_ios_openmode_min = ~0x7fffffff
    };

  [[__nodiscard__]] constexpr
  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b) noexcept
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  [[__nodiscard__]] constexpr
  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b) noexcept
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  [[__nodiscard__]] constexpr
  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b) noexcept
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  [[__nodiscard__]] constexpr
  inline _Ios_Openmode
  operator~(_Ios_Openmode __a) noexcept
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  constexpr
  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b) noexcept
  { return __a = __a | __b; }

  constexpr
  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b) noexcept
  { return __a = __a & __b; }

  constexpr
  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b) noexcept
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16,
      _S_ios_iostate_max = 0x7fffffff,
      _S_ios_iostate_min = ~0x7fffffff
    };

  [[__nodiscard__]] constexpr
  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b) noexcept
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  [[__nodiscard__]] constexpr
  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b) noexcept
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  [[__nodiscard__]] constexpr
  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b) noexcept
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  [[__nodiscard__]] constexpr
  inline _Ios_Iostate
  operator~(_Ios_Iostate __a) noexcept
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  constexpr
  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b) noexcept
  { return __a = __a | __b; }

  constexpr
  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b) noexcept
  { return __a = __a & __b; }

  constexpr
  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b) noexcept
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };



  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type { };

  [[__nodiscard__, __gnu__::__const__]]
  const error_category&
  iostream_category() noexcept;

  [[__nodiscard__]]
  inline error_code
  make_error_code(io_errc __e) noexcept
  { return error_code(static_cast<int>(__e), iostream_category()); }

  [[__nodiscard__]]
  inline error_condition
  make_error_condition(io_errc __e) noexcept
  { return error_condition(static_cast<int>(__e), iostream_category()); }
# 254 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
  class ios_base
  {
# 272 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
  public:
# 281 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error
    {
    public:
      explicit
      failure(const string& __str);


      explicit
      failure(const string&, const error_code&);

      explicit
      failure(const char*, const error_code& = io_errc::stream);


      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();
    };
# 367 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 442 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 473 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;

    static const openmode __noreplace = _S_noreplace;
# 512 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;
# 545 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 562 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 574 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();


      Init(const Init&) = default;
      Init& operator=(const Init&) = default;


    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 692 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 708 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 725 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 751 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 802 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 814 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 825 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 836 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 855 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 871 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = ((unsigned)__ix < (unsigned)_M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 892 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = ((unsigned)__ix < (unsigned)_M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 909 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();
# 923 "/usr/include/c++/14.2.1/bits/ios_base.h" 3
  public:
    ios_base(const ios_base&) = delete;

    ios_base&
    operator=(const ios_base&) = delete;

  protected:
    void
    _M_move(ios_base&) noexcept;

    void
    _M_swap(ios_base& __rhs) noexcept;

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }






  inline ios_base&
  hexfloat(ios_base& __base)
  {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  defaultfloat(ios_base& __base)
  {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }



}
# 45 "/usr/include/c++/14.2.1/ios" 2 3
# 1 "/usr/include/c++/14.2.1/streambuf" 1 3
# 36 "/usr/include/c++/14.2.1/streambuf" 3
       
# 37 "/usr/include/c++/14.2.1/streambuf" 3
# 47 "/usr/include/c++/14.2.1/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 123 "/usr/include/c++/14.2.1/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
        advance(istreambuf_iterator<_CharT2>&, _Distance);

      friend void __istream_extract(istream&, char*, streamsize);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 215 "/usr/include/c++/14.2.1/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 232 "/usr/include/c++/14.2.1/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 245 "/usr/include/c++/14.2.1/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 257 "/usr/include/c++/14.2.1/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 269 "/usr/include/c++/14.2.1/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 290 "/usr/include/c++/14.2.1/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 304 "/usr/include/c++/14.2.1/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 322 "/usr/include/c++/14.2.1/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 344 "/usr/include/c++/14.2.1/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 363 "/usr/include/c++/14.2.1/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 378 "/usr/include/c++/14.2.1/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 403 "/usr/include/c++/14.2.1/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 430 "/usr/include/c++/14.2.1/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 456 "/usr/include/c++/14.2.1/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 470 "/usr/include/c++/14.2.1/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 488 "/usr/include/c++/14.2.1/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 504 "/usr/include/c++/14.2.1/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 515 "/usr/include/c++/14.2.1/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 535 "/usr/include/c++/14.2.1/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 551 "/usr/include/c++/14.2.1/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 561 "/usr/include/c++/14.2.1/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 582 "/usr/include/c++/14.2.1/streambuf" 3
      virtual void
      imbue(const locale& __loc __attribute__ ((__unused__)))
      { }
# 597 "/usr/include/c++/14.2.1/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 608 "/usr/include/c++/14.2.1/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 620 "/usr/include/c++/14.2.1/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 633 "/usr/include/c++/14.2.1/streambuf" 3
      virtual int
      sync() { return 0; }
# 655 "/usr/include/c++/14.2.1/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 671 "/usr/include/c++/14.2.1/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 693 "/usr/include/c++/14.2.1/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 706 "/usr/include/c++/14.2.1/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 730 "/usr/include/c++/14.2.1/streambuf" 3
      virtual int_type
      pbackfail(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }
# 748 "/usr/include/c++/14.2.1/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 774 "/usr/include/c++/14.2.1/streambuf" 3
      virtual int_type
      overflow(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }
# 801 "/usr/include/c++/14.2.1/streambuf" 3
      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }




    protected:

      basic_streambuf(const basic_streambuf&);

      basic_streambuf&
      operator=(const basic_streambuf&);


      void
      swap(basic_streambuf& __sb)
      {
 std::swap(_M_in_beg, __sb._M_in_beg);
 std::swap(_M_in_cur, __sb._M_in_cur);
 std::swap(_M_in_end, __sb._M_in_end);
 std::swap(_M_out_beg, __sb._M_out_beg);
 std::swap(_M_out_cur, __sb._M_out_cur);
 std::swap(_M_out_end, __sb._M_out_end);
 std::swap(_M_buf_locale, __sb._M_buf_locale);
      }

    };


  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>::
    basic_streambuf(const basic_streambuf&) = default;

  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>&
    std::basic_streambuf<_CharT, _Traits>::
    operator=(const basic_streambuf&) = default;



  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);





}

# 1 "/usr/include/c++/14.2.1/bits/streambuf.tcc" 1 3
# 37 "/usr/include/c++/14.2.1/bits/streambuf.tcc" 3
       
# 38 "/usr/include/c++/14.2.1/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;

  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);


  extern template class basic_streambuf<wchar_t>;

  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);




}
# 861 "/usr/include/c++/14.2.1/streambuf" 2 3
# 46 "/usr/include/c++/14.2.1/ios" 2 3
# 1 "/usr/include/c++/14.2.1/bits/basic_ios.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/basic_ios.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/basic_ios.h" 3



# 1 "/usr/include/c++/14.2.1/bits/locale_facets.h" 1 3
# 37 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
       
# 38 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3

# 1 "/usr/include/c++/14.2.1/cwctype" 1 3
# 39 "/usr/include/c++/14.2.1/cwctype" 3
       
# 40 "/usr/include/c++/14.2.1/cwctype" 3
# 50 "/usr/include/c++/14.2.1/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 38 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/bits/wctype-wchar.h" 1 3 4
# 38 "/usr/include/bits/wctype-wchar.h" 3 4
typedef unsigned long int wctype_t;
# 56 "/usr/include/bits/wctype-wchar.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {







extern int iswalnum (wint_t __wc) noexcept (true);





extern int iswalpha (wint_t __wc) noexcept (true);


extern int iswcntrl (wint_t __wc) noexcept (true);



extern int iswdigit (wint_t __wc) noexcept (true);



extern int iswgraph (wint_t __wc) noexcept (true);




extern int iswlower (wint_t __wc) noexcept (true);


extern int iswprint (wint_t __wc) noexcept (true);




extern int iswpunct (wint_t __wc) noexcept (true);




extern int iswspace (wint_t __wc) noexcept (true);




extern int iswupper (wint_t __wc) noexcept (true);




extern int iswxdigit (wint_t __wc) noexcept (true);





extern int iswblank (wint_t __wc) noexcept (true);
# 155 "/usr/include/bits/wctype-wchar.h" 3 4
extern wctype_t wctype (const char *__property) noexcept (true);



extern int iswctype (wint_t __wc, wctype_t __desc) noexcept (true);






extern wint_t towlower (wint_t __wc) noexcept (true);


extern wint_t towupper (wint_t __wc) noexcept (true);

}
# 39 "/usr/include/wctype.h" 2 3 4





extern "C" {



typedef const __int32_t *wctrans_t;



extern wctrans_t wctrans (const char *__property) noexcept (true);


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) noexcept (true);







extern int iswalnum_l (wint_t __wc, locale_t __locale) noexcept (true);





extern int iswalpha_l (wint_t __wc, locale_t __locale) noexcept (true);


extern int iswcntrl_l (wint_t __wc, locale_t __locale) noexcept (true);



extern int iswdigit_l (wint_t __wc, locale_t __locale) noexcept (true);



extern int iswgraph_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswlower_l (wint_t __wc, locale_t __locale) noexcept (true);


extern int iswprint_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswpunct_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswspace_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswupper_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswxdigit_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswblank_l (wint_t __wc, locale_t __locale) noexcept (true);



extern wctype_t wctype_l (const char *__property, locale_t __locale)
     noexcept (true);



extern int iswctype_l (wint_t __wc, wctype_t __desc, locale_t __locale)
     noexcept (true);






extern wint_t towlower_l (wint_t __wc, locale_t __locale) noexcept (true);


extern wint_t towupper_l (wint_t __wc, locale_t __locale) noexcept (true);



extern wctrans_t wctrans_l (const char *__property, locale_t __locale)
     noexcept (true);


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      locale_t __locale) noexcept (true);



}
# 51 "/usr/include/c++/14.2.1/cwctype" 2 3
# 80 "/usr/include/c++/14.2.1/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "/usr/include/c++/14.2.1/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/14.2.1/cctype" 1 3
# 39 "/usr/include/c++/14.2.1/cctype" 3
       
# 40 "/usr/include/c++/14.2.1/cctype" 3
# 41 "/usr/include/c++/14.2.1/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/ctype_base.h" 1 3
# 36 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;

    static const mask blank = _ISblank;

  };


}
# 42 "/usr/include/c++/14.2.1/bits/locale_facets.h" 2 3






# 1 "/usr/include/c++/14.2.1/bits/streambuf_iterator.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/streambuf_iterator.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/streambuf_iterator.h" 3





namespace std __attribute__ ((__visibility__ ("default")))
{








 
# 49 "/usr/include/c++/14.2.1/bits/streambuf_iterator.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT>
    {
    public:
# 67 "/usr/include/c++/14.2.1/bits/streambuf_iterator.h" 3
      using pointer = void;


      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2, typename _Size>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_n_a(istreambuf_iterator<_CharT2>, _Size, _CharT2*, bool);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
 advance(istreambuf_iterator<_CharT2>&, _Distance);

    private:







      mutable streambuf_type* _M_sbuf;
      int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      constexpr istreambuf_iterator(default_sentinel_t) noexcept
      : istreambuf_iterator() { }



      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }


      istreambuf_iterator&
      operator=(const istreambuf_iterator&) noexcept = default;





      [[__nodiscard__]]
      char_type
      operator*() const
      {
 int_type __c = _M_get();
# 161 "/usr/include/c++/14.2.1/bits/streambuf_iterator.h" 3
 return traits_type::to_char_type(__c);
      }


      istreambuf_iterator&
      operator++()
      {



                        ;

 _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {



                        ;

 istreambuf_iterator __old = *this;
 __old._M_c = _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return __old;
      }





      [[__nodiscard__]]
      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 int_type __ret = _M_c;
 if (_M_sbuf && _S_is_eof(__ret) && _S_is_eof(__ret = _M_sbuf->sgetc()))
   _M_sbuf = 0;
 return __ret;
      }

      bool
      _M_at_eof() const
      { return _S_is_eof(_M_get()); }

      static bool
      _S_is_eof(int_type __c)
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(__c, __eof);
      }


      [[nodiscard]]
      friend bool
      operator==(const istreambuf_iterator& __i, default_sentinel_t)
      { return __i._M_at_eof(); }

    };

  template<typename _CharT, typename _Traits>
    [[__nodiscard__]]
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }
# 248 "/usr/include/c++/14.2.1/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:




      using difference_type = ptrdiff_t;

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:


      constexpr
      ostreambuf_iterator() noexcept
      : _M_sbuf(nullptr), _M_failed(true) { }



      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      [[__nodiscard__]]
      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      [[__nodiscard__]]
      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };
#pragma GCC diagnostic pop


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_n_a(istreambuf_iterator<_CharT> __it, _Size __n, _CharT* __result,
        bool __strict __attribute__((__unused__)))
    {
      if (__n == 0)
 return __result;

     

                            ;
      _CharT* __beg = __result;
      __result += __it._M_sbuf->sgetn(__beg, __n);
     

                            ;
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, __eof)
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   __first._M_c = __eof;
 }

      return __first;
    }

  template<typename _CharT, typename _Distance>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        void>::__type
    advance(istreambuf_iterator<_CharT>& __i, _Distance __n)
    {
      if (__n == 0)
 return;

      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n > 0), false)) std::__glibcxx_assert_fail(); } while (false);
     

                           ;

      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      streambuf_type* __sb = __i._M_sbuf;
      while (__n > 0)
 {
   streamsize __size = __sb->egptr() - __sb->gptr();
   if (__size > __n)
     {
       __sb->__safe_gbump(__n);
       break;
     }

   __sb->__safe_gbump(__size);
   __n -= __size;
   if (traits_type::eq_int_type(__sb->underflow(), __eof))
     {
      

                      ;
       break;
     }
 }

      __i._M_c = __eof;
    }




}
# 49 "/usr/include/c++/14.2.1/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 152 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 171 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 188 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 204 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 220 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 234 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 249 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 263 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 278 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 295 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 314 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 333 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 355 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 380 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 399 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 418 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 437 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 455 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 472 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 488 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 505 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 524 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 545 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 566 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 591 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 614 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;



  template<typename _CharT, typename _Traits, typename _Alloc>
    class ctype<basic_string<_CharT, _Traits, _Alloc> >;
# 688 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 725 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 738 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 751 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 766 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 780 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 794 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 809 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 826 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 842 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 859 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 879 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 906 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     if (__builtin_expect(__hi != __lo, true))
       __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 938 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 971 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     if (__builtin_expect(__hi != __lo, true))
       __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1021 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1038 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1054 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1071 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1091 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1114 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (__builtin_expect(__hi != __lo, true))
   __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1141 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault __attribute__((__unused__))) const
      { return __c; }
# 1167 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault __attribute__((__unused__)), char* __to) const
      {
 if (__builtin_expect(__hi != __lo, true))
   __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1193 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1226 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1237 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1261 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1280 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1298 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1316 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1333 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1350 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1366 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1383 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1403 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1425 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1448 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1474 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0)
      : ctype_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~ctype_byname() { }
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };



}


# 1 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/ctype_inline.h" 1 3
# 37 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
# 1547 "/usr/include/c++/14.2.1/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }

namespace __cxx11 {
# 1677 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1715 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1729 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1743 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1756 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1787 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1800 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1813 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1830 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1842 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1855 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1868 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1881 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      numpunct_byname(const string& __s, size_t __refs = 0)
      : numpunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~numpunct_byname() { }
    };

}


# 1959 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1980 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 2006 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2043 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2103 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2146 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      __attribute ((__abi_tag__ ("cxx11")))
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 __attribute ((__abi_tag__ ("cxx11")))
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2219 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;
# 2271 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2299 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2317 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2338 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2356 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2398 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2461 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2486 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { }
# 2534 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;
# 2586 "/usr/include/c++/14.2.1/bits/locale_facets.h" 3
    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }



  template<typename _CharT>
    inline bool
    isblank(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }



  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

# 1 "/usr/include/c++/14.2.1/bits/locale_facets.tcc" 1 3
# 33 "/usr/include/c++/14.2.1/bits/locale_facets.tcc" 3
       
# 34 "/usr/include/c++/14.2.1/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   const string& __g = __np.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __tn = __np.truename();
   _M_truename_size = __tn.size();
   __truename = new _CharT[_M_truename_size];
   __tn.copy(__truename, _M_truename_size);

   const basic_string<_CharT>& __fn = __np.falsename();
   _M_falsename_size = __fn.size();
   __falsename = new _CharT[_M_falsename_size];
   __fn.copy(__falsename, _M_falsename_size);

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);

   _M_grouping = __grouping;
   _M_truename = __truename;
   _M_falsename = __falsename;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 139 "/usr/include/c++/14.2.1/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    __attribute ((__abi_tag__ ("cxx11")))
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      __attribute ((__abi_tag__ ("cxx11")))
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 typedef __gnu_cxx::__numeric_traits<_ValueT> __num_traits;
 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __num_traits::__is_signed)
   ? -static_cast<__unsigned_type>(__num_traits::__min)
   : __num_traits::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative && __num_traits::__is_signed)
       __v = __num_traits::__min;
     else
       __v = __num_traits::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 735 "/usr/include/c++/14.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }
# 795 "/usr/include/c++/14.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 989 "/usr/include/c++/14.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);



 const bool __use_prec =
   (__io.flags() & ios_base::floatfield) != ios_base::floatfield;



 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 if (__use_prec)
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __prec, __v);
 else
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     if (__use_prec)
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __prec, __v);
     else
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __v);
   }
# 1062 "/usr/include/c++/14.2.1/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1187 "/usr/include/c++/14.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }
# 1224 "/usr/include/c++/14.2.1/bits/locale_facets.tcc" 3

# 1233 "/usr/include/c++/14.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class __cxx11:: numpunct<char>;
  extern template class __cxx11:: numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>*
    __try_use_facet<ctype<char> >(const locale&) noexcept;

  extern template
    const numpunct<char>*
    __try_use_facet<numpunct<char> >(const locale&) noexcept;

  extern template
    const num_put<char>*
    __try_use_facet<num_put<char> >(const locale&) noexcept;

  extern template
    const num_get<char>*
    __try_use_facet<num_get<char> >(const locale&) noexcept;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class __cxx11:: numpunct<wchar_t>;
  extern template class __cxx11:: numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>*
    __try_use_facet<ctype<wchar_t> >(const locale&) noexcept;

  extern template
    const numpunct<wchar_t>*
    __try_use_facet<numpunct<wchar_t> >(const locale&) noexcept;

  extern template
    const num_put<wchar_t>*
    __try_use_facet<num_put<wchar_t> >(const locale&) noexcept;

  extern template
    const num_get<wchar_t>*
    __try_use_facet<num_get<wchar_t> >(const locale&) noexcept;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2688 "/usr/include/c++/14.2.1/bits/locale_facets.h" 2 3
# 38 "/usr/include/c++/14.2.1/bits/basic_ios.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 66 "/usr/include/c++/14.2.1/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {

      static_assert(is_same_v<_CharT, typename _Traits::char_type>);


    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:
# 121 "/usr/include/c++/14.2.1/bits/basic_ios.h" 3
      explicit operator bool() const
      { return !this->fail(); }





      bool
      operator!() const
      { return this->fail(); }
# 140 "/usr/include/c++/14.2.1/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 151 "/usr/include/c++/14.2.1/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 204 "/usr/include/c++/14.2.1/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 225 "/usr/include/c++/14.2.1/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 260 "/usr/include/c++/14.2.1/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 298 "/usr/include/c++/14.2.1/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 310 "/usr/include/c++/14.2.1/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 350 "/usr/include/c++/14.2.1/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 364 "/usr/include/c++/14.2.1/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 393 "/usr/include/c++/14.2.1/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 413 "/usr/include/c++/14.2.1/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 433 "/usr/include/c++/14.2.1/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 452 "/usr/include/c++/14.2.1/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);


      basic_ios(const basic_ios&) = delete;
      basic_ios& operator=(const basic_ios&) = delete;

      void
      move(basic_ios& __rhs)
      {
 ios_base::_M_move(__rhs);
 _M_cache_locale(_M_ios_locale);
 this->tie(__rhs.tie(nullptr));
 _M_fill = __rhs._M_fill;
 _M_fill_init = __rhs._M_fill_init;
 _M_streambuf = nullptr;
      }

      void
      move(basic_ios&& __rhs)
      { this->move(__rhs); }

      void
      swap(basic_ios& __rhs) noexcept
      {
 ios_base::_M_swap(__rhs);
 _M_cache_locale(_M_ios_locale);
 __rhs._M_cache_locale(__rhs._M_ios_locale);
 std::swap(_M_tie, __rhs._M_tie);
 std::swap(_M_fill, __rhs._M_fill);
 std::swap(_M_fill_init, __rhs._M_fill_init);
      }

      void
      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
      { _M_streambuf = __sb; }


      void
      _M_cache_locale(const locale& __loc);
    };


}

# 1 "/usr/include/c++/14.2.1/bits/basic_ios.tcc" 1 3
# 33 "/usr/include/c++/14.2.1/bits/basic_ios.tcc" 3
       
# 34 "/usr/include/c++/14.2.1/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
 _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != std::__addressof(__rhs))
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "/usr/include/c++/14.2.1/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      _M_ctype = std::__try_use_facet<__ctype_type>(__loc);
      _M_num_put = std::__try_use_facet<__num_put_type>(__loc);
      _M_num_get = std::__try_use_facet<__num_get_type>(__loc);
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 521 "/usr/include/c++/14.2.1/bits/basic_ios.h" 2 3
# 47 "/usr/include/c++/14.2.1/ios" 2 3


# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 50 "/usr/include/c++/14.2.1/ios" 2 3
# 41 "/usr/include/c++/14.2.1/istream" 2 3
# 1 "/usr/include/c++/14.2.1/ostream" 1 3
# 36 "/usr/include/c++/14.2.1/ostream" 3
       
# 37 "/usr/include/c++/14.2.1/ostream" 3
# 47 "/usr/include/c++/14.2.1/ostream" 3
# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 48 "/usr/include/c++/14.2.1/ostream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/14.2.1/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 91 "/usr/include/c++/14.2.1/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 115 "/usr/include/c++/14.2.1/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 173 "/usr/include/c++/14.2.1/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 227 "/usr/include/c++/14.2.1/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 297 "/usr/include/c++/14.2.1/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }


      __ostream_type&
      operator<<(nullptr_t)
      { return *this << "nullptr"; }
# 335 "/usr/include/c++/14.2.1/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 368 "/usr/include/c++/14.2.1/ostream" 3
      __ostream_type&
      put(char_type __c);
# 387 "/usr/include/c++/14.2.1/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 400 "/usr/include/c++/14.2.1/ostream" 3
      __ostream_type&
      flush();
# 410 "/usr/include/c++/14.2.1/ostream" 3
      pos_type
      tellp();
# 421 "/usr/include/c++/14.2.1/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 433 "/usr/include/c++/14.2.1/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }



      basic_ostream(basic_iostream<_CharT, _Traits>&) { }

      basic_ostream(const basic_ostream&) = delete;

      basic_ostream(basic_ostream&& __rhs)
      : __ios_type()
      { __ios_type::move(__rhs); }



      basic_ostream& operator=(const basic_ostream&) = delete;

      basic_ostream&
      operator=(basic_ostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_ostream& __rhs)
      { __ios_type::swap(__rhs); }


      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);

    private:

      void
      _M_write(const char_type* __s, streamsize __n)
      { std::__ostream_insert(*this, __s, __n); }

    };
# 485 "/usr/include/c++/14.2.1/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 504 "/usr/include/c++/14.2.1/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"







      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
#pragma GCC diagnostic pop
# 536 "/usr/include/c++/14.2.1/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 558 "/usr/include/c++/14.2.1/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    {
      if (__out.width() != 0)
 return __ostream_insert(__out, &__c, 1);
      __out.put(__c);
      return __out;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    {
      if (__out.width() != 0)
 return __ostream_insert(__out, &__c, 1);
      __out.put(__c);
      return __out;
    }


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }





  template<typename _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>&, wchar_t) = delete;


  template<typename _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>&, char8_t) = delete;


  template<typename _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>&, char16_t) = delete;

  template<typename _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>&, char32_t) = delete;



  template<typename _Traits>
    basic_ostream<wchar_t, _Traits>&
    operator<<(basic_ostream<wchar_t, _Traits>&, char8_t) = delete;


  template<typename _Traits>
    basic_ostream<wchar_t, _Traits>&
    operator<<(basic_ostream<wchar_t, _Traits>&, char16_t) = delete;

  template<typename _Traits>
    basic_ostream<wchar_t, _Traits>&
    operator<<(basic_ostream<wchar_t, _Traits>&, char32_t) = delete;
# 649 "/usr/include/c++/14.2.1/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<typename _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }





  template<typename _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>&, const wchar_t*) = delete;


  template<typename _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>&, const char8_t*) = delete;


  template<typename _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>&, const char16_t*) = delete;

  template<typename _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>&, const char32_t*) = delete;



  template<typename _Traits>
    basic_ostream<wchar_t, _Traits>&
    operator<<(basic_ostream<wchar_t, _Traits>&, const char8_t*) = delete;


  template<typename _Traits>
    basic_ostream<wchar_t, _Traits>&
    operator<<(basic_ostream<wchar_t, _Traits>&, const char16_t*) = delete;

  template<typename _Traits>
    basic_ostream<wchar_t, _Traits>&
    operator<<(basic_ostream<wchar_t, _Traits>&, const char32_t*) = delete;
# 739 "/usr/include/c++/14.2.1/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 751 "/usr/include/c++/14.2.1/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
# 773 "/usr/include/c++/14.2.1/ostream" 3
  template<typename _Tp>
    concept __derived_from_ios_base = is_class_v<_Tp>
      && (!is_same_v<_Tp, ios_base>)
      && requires (_Tp* __t, ios_base* __b) { __b = __t; };

  template<typename _Os, typename _Tp>
    requires __derived_from_ios_base<_Os>
      && requires (_Os& __os, const _Tp& __t) { __os << __t; }
    using __rvalue_stream_insertion_t = _Os&&;
# 805 "/usr/include/c++/14.2.1/ostream" 3
  template<typename _Ostream, typename _Tp>
    inline __rvalue_stream_insertion_t<_Ostream, _Tp>
    operator<<(_Ostream&& __os, const _Tp& __x)
    {
      __os << __x;
      return std::move(__os);
    }


  template<typename _CharT, typename _Traits>
    class __syncbuf_base : public basic_streambuf<_CharT, _Traits>
    {
    public:
      static bool*
      _S_get(basic_streambuf<_CharT, _Traits>* __buf [[maybe_unused]]) noexcept
      {

 if (auto __p = dynamic_cast<__syncbuf_base*>(__buf))
   return &__p->_M_emit_on_sync;

 return nullptr;
      }

    protected:
      __syncbuf_base(basic_streambuf<_CharT, _Traits>* __w = nullptr)
      : _M_wrapped(__w)
      { }

      basic_streambuf<_CharT, _Traits>* _M_wrapped = nullptr;
      bool _M_emit_on_sync = false;
      bool _M_needs_sync = false;
    };

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    emit_on_flush(basic_ostream<_CharT, _Traits>& __os)
    {
      if (bool* __flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf()))
 *__flag = true;
      return __os;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    noemit_on_flush(basic_ostream<_CharT, _Traits>& __os)
    {
      if (bool* __flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf()))
 *__flag = false;
      return __os;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush_emit(basic_ostream<_CharT, _Traits>& __os)
    {
      struct _Restore
      {
 ~_Restore() { *_M_flag = _M_prev; }

 bool _M_prev = false;
 bool* _M_flag = &_M_prev;
      } __restore;

      if (bool* __flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf()))
 {
   __restore._M_prev = *__flag;
   __restore._M_flag = __flag;
   *__flag = true;
 }

      __os.flush();
      return __os;
    }
# 1014 "/usr/include/c++/14.2.1/ostream" 3

}

# 1 "/usr/include/c++/14.2.1/bits/ostream.tcc" 1 3
# 37 "/usr/include/c++/14.2.1/bits/ostream.tcc" 3
       
# 38 "/usr/include/c++/14.2.1/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else if (__os.bad())
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {

  const __num_put_type& __np = __check_facet(this->_M_num_put);




  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (this->rdbuf()->sputn(__s, __n) != __n)
  __err = ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(ios_base::badbit);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {





      if (__streambuf_type* __buf = this->rdbuf())
 {
   sentry __cerb(*this);
   if (__cerb)
     {
       ios_base::iostate __err = ios_base::goodbit;
       try
  {
    if (this->rdbuf()->pubsync() == -1)
      __err |= ios_base::badbit;
  }
       catch(__cxxabiv1::__forced_unwind&)
  {
    this->_M_setstate(ios_base::badbit);
    throw;
  }
       catch(...)
  { this->_M_setstate(ios_base::badbit); }
       if (__err)
  this->setstate(__err);
     }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      sentry __cerb(*this);
      pos_type __ret = pos_type(-1);
      if (!this->fail())
 __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      sentry __cerb(*this);
      if (!this->fail())
 {


   const pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::out);


   if (__p == pos_type(off_type(-1)))
     this->setstate(ios_base::failbit);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      sentry __cerb(*this);
      if (!this->fail())
 {


   const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
        ios_base::out);


   if (__p == pos_type(off_type(-1)))
     this->setstate(ios_base::failbit);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 1018 "/usr/include/c++/14.2.1/ostream" 2 3
# 42 "/usr/include/c++/14.2.1/istream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 59 "/usr/include/c++/14.2.1/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 121 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 169 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 215 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 324 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 348 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 358 "/usr/include/c++/14.2.1/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 391 "/usr/include/c++/14.2.1/istream" 3
      int_type
      get();
# 405 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      get(char_type& __c);
# 432 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 443 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 466 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 476 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 505 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 516 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 540 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 557 "/usr/include/c++/14.2.1/istream" 3
      int_type
      peek();
# 575 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 594 "/usr/include/c++/14.2.1/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 611 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      putback(char_type __c);
# 627 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      unget();
# 645 "/usr/include/c++/14.2.1/istream" 3
      int
      sync();
# 660 "/usr/include/c++/14.2.1/istream" 3
      pos_type
      tellg();
# 675 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      seekg(pos_type);
# 691 "/usr/include/c++/14.2.1/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }


      basic_istream(const basic_istream&) = delete;

      basic_istream(basic_istream&& __rhs)
      : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
 __ios_type::move(__rhs);
 __rhs._M_gcount = 0;
      }



      basic_istream& operator=(const basic_istream&) = delete;

      basic_istream&
      operator=(basic_istream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_istream& __rhs)
      {
 __ios_type::swap(__rhs);
 std::swap(_M_gcount, __rhs._M_gcount);
      }


      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 775 "/usr/include/c++/14.2.1/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 811 "/usr/include/c++/14.2.1/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 822 "/usr/include/c++/14.2.1/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 840 "/usr/include/c++/14.2.1/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }



  template<typename _CharT, typename _Traits>
    void
    __istream_extract(basic_istream<_CharT, _Traits>&, _CharT*, streamsize);

  void __istream_extract(istream&, char*, streamsize);
# 947 "/usr/include/c++/14.2.1/istream" 3
  template<typename _CharT, typename _Traits, size_t _Num>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT (&__s)[_Num])
    {
      static_assert(_Num <= __gnu_cxx::__numeric_traits<streamsize>::__max);
      std::__istream_extract(__in, __s, _Num);
      return __in;
    }

  template<class _Traits, size_t _Num>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char (&__s)[_Num])
    { return __in >> reinterpret_cast<char(&)[_Num]>(__s); }

  template<class _Traits, size_t _Num>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char (&__s)[_Num])
    { return __in >> reinterpret_cast<char(&)[_Num]>(__s); }
# 979 "/usr/include/c++/14.2.1/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }


      basic_iostream(const basic_iostream&) = delete;

      basic_iostream(basic_iostream&& __rhs)
      : __istream_type(std::move(__rhs)), __ostream_type(*this)
      { }



      basic_iostream& operator=(const basic_iostream&) = delete;

      basic_iostream&
      operator=(basic_iostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_iostream& __rhs)
      { __istream_type::swap(__rhs); }

    };
# 1062 "/usr/include/c++/14.2.1/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
# 1073 "/usr/include/c++/14.2.1/istream" 3
  template<typename _Is, typename _Tp>
    requires __derived_from_ios_base<_Is>
      && requires (_Is& __is, _Tp&& __t) { __is >> std::forward<_Tp>(__t); }
    using __rvalue_stream_extraction_t = _Is&&;
# 1094 "/usr/include/c++/14.2.1/istream" 3
  template<typename _Istream, typename _Tp>
    inline __rvalue_stream_extraction_t<_Istream, _Tp>
    operator>>(_Istream&& __is, _Tp&& __x)
    {
      __is >> std::forward<_Tp>(__x);
      return std::move(__is);
    }



}

# 1 "/usr/include/c++/14.2.1/bits/istream.tcc" 1 3
# 37 "/usr/include/c++/14.2.1/bits/istream.tcc" 3
       
# 38 "/usr/include/c++/14.2.1/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   try
     {
       if (__in.tie())
  __in.tie()->flush();
       if (!__noskip && bool(__in.flags() & ios_base::skipws))
  {
    const __int_type __eof = traits_type::eof();
    __streambuf_type* __sb = __in.rdbuf();
    __int_type __c = __sb->sgetc();

    const __ctype_type& __ct = __check_facet(__in._M_ctype);
    while (!traits_type::eq_int_type(__c, __eof)
    && __ct.is(ctype_base::space,
        traits_type::to_char_type(__c)))
      __c = __sb->snextc();




    if (traits_type::eq_int_type(__c, __eof))
      __err |= ios_base::eofbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {

  const __num_get_type& __ng = __check_facet(this->_M_num_get);




  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;

       const __num_get_type& __ng = __check_facet(this->_M_num_get);




       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;

       const __num_get_type& __ng = __check_facet(this->_M_num_get);




       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);
       unsigned long long __gcount = 0;

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++__gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;


       if (__gcount <= __gnu_cxx::__numeric_traits<streamsize>::__max)
  _M_gcount = __gcount;
       else
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 545 "/usr/include/c++/14.2.1/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max)
  {
    if (__large_ignore)
      _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

    if (traits_type::eq_int_type(__c, __eof))
      __err |= ios_base::eofbit;
  }
       else if (_M_gcount < __n)
  {
    if (traits_type::eq_int_type(__c, __eof))
      __err |= ios_base::eofbit;
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max)
  {
    if (__large_ignore)
      _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

    if (traits_type::eq_int_type(__c, __eof))
      __err |= ios_base::eofbit;
    else
      {
        if (_M_gcount != __n)
   ++_M_gcount;
        __sb->sbumpc();
      }
  }
       else if (_M_gcount < __n)
  {
    if (traits_type::eq_int_type(__c, __eof))
      __err |= ios_base::eofbit;
    else
      {
        ++_M_gcount;
        __sb->sbumpc();
      }
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    void
    __istream_extract(basic_istream<_CharT, _Traits>& __in, _CharT* __s,
        streamsize __num)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __width = __in.width();
       if (0 < __width && __width < __num)
  __num = __width;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }

       if (__extracted < __num - 1
    && _Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;



      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       while (true)
  {
    if (_Traits::eq_int_type(__c, __eof))
      {
        __err = ios_base::eofbit;
        break;
      }
    if (!__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
      break;
    __c = __sb->snextc();
  }
     }
   catch(const __cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     {
       __in._M_setstate(ios_base::badbit);
     }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template void __istream_extract(wistream&, wchar_t*, streamsize);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 1107 "/usr/include/c++/14.2.1/istream" 2 3
# 41 "/usr/include/c++/14.2.1/fstream" 2 3

# 1 "/usr/include/c++/14.2.1/bits/codecvt.h" 1 3
# 39 "/usr/include/c++/14.2.1/bits/codecvt.h" 3
       
# 40 "/usr/include/c++/14.2.1/bits/codecvt.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 70 "/usr/include/c++/14.2.1/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 118 "/usr/include/c++/14.2.1/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 157 "/usr/include/c++/14.2.1/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 198 "/usr/include/c++/14.2.1/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 239 "/usr/include/c++/14.2.1/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };
# 276 "/usr/include/c++/14.2.1/bits/codecvt.h" 3
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),
 _M_c_locale_codecvt(0)
      { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
      friend class messages<char>;

    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };






  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
      friend class messages<wchar_t>;

    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };







  template<>
    class codecvt<char16_t, char, mbstate_t>
    : public __codecvt_abstract_base<char16_t, char, mbstate_t>
    {
    public:

      typedef char16_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char16_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<>
    class codecvt<char32_t, char, mbstate_t>
    : public __codecvt_abstract_base<char32_t, char, mbstate_t>
    {
    public:

      typedef char32_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char32_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };






  template<>
    class codecvt<char16_t, char8_t, mbstate_t>
    : public __codecvt_abstract_base<char16_t, char8_t, mbstate_t>
    {
    public:

      typedef char16_t intern_type;
      typedef char8_t extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char16_t, char8_t, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<>
    class codecvt<char32_t, char8_t, mbstate_t>
    : public __codecvt_abstract_base<char32_t, char8_t, mbstate_t>
    {
    public:

      typedef char32_t intern_type;
      typedef char8_t extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char32_t, char8_t, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }


      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~codecvt_byname() { }
    };


  template<>
    class codecvt_byname<char16_t, char, mbstate_t>
    : public codecvt<char16_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char*, size_t __refs = 0)
      : codecvt<char16_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };

  template<>
    class codecvt_byname<char32_t, char, mbstate_t>
    : public codecvt<char32_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char*, size_t __refs = 0)
      : codecvt<char32_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };


  template<>
    class codecvt_byname<char16_t, char8_t, mbstate_t>
    : public codecvt<char16_t, char8_t, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char*, size_t __refs = 0)
      : codecvt<char16_t, char8_t, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };

  template<>
    class codecvt_byname<char32_t, char8_t, mbstate_t>
    : public codecvt<char32_t, char8_t, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char*, size_t __refs = 0)
      : codecvt<char32_t, char8_t, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };







  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);



  extern template class codecvt_byname<char16_t, char, mbstate_t>;
  extern template class codecvt_byname<char32_t, char, mbstate_t>;


  extern template class codecvt_byname<char16_t, char8_t, mbstate_t>;
  extern template class codecvt_byname<char32_t, char8_t, mbstate_t>;







}
# 43 "/usr/include/c++/14.2.1/fstream" 2 3
# 1 "/usr/include/c++/14.2.1/cstdio" 1 3
# 39 "/usr/include/c++/14.2.1/cstdio" 3
       
# 40 "/usr/include/c++/14.2.1/cstdio" 3
# 44 "/usr/include/c++/14.2.1/fstream" 2 3
# 1 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/basic_file.h" 1 3
# 37 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/basic_file.h" 3
       
# 38 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/basic_file.h" 3


# 1 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++io.h" 1 3
# 35 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++io.h" 3
# 1 "/usr/include/c++/14.2.1/cstdio" 1 3
# 39 "/usr/include/c++/14.2.1/cstdio" 3
       
# 40 "/usr/include/c++/14.2.1/cstdio" 3
# 36 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++io.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{








  typedef __gthread_mutex_t __c_lock;



  typedef FILE __c_file;


}
# 41 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/basic_file.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _CharT>
    class __basic_file;


  template<>
    class __basic_file<char>
    {

      __c_file* _M_cfile;


      bool _M_cfile_created;

    public:
      __basic_file(__c_lock* __lock = 0) throw ();


      __basic_file(__basic_file&& __rv, __c_lock* = 0) noexcept
      : _M_cfile(__rv._M_cfile), _M_cfile_created(__rv._M_cfile_created)
      {
 __rv._M_cfile = nullptr;
 __rv._M_cfile_created = false;
      }

      __basic_file& operator=(const __basic_file&) = delete;
      __basic_file& operator=(__basic_file&&) = delete;

      void
      swap(__basic_file& __f) noexcept
      {
 std::swap(_M_cfile, __f._M_cfile);
 std::swap(_M_cfile_created, __f._M_cfile_created);
      }


      __basic_file*
      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);






      __basic_file*
      sys_open(__c_file* __file, ios_base::openmode);

      __basic_file*
      sys_open(int __fd, ios_base::openmode __mode) throw ();

      __basic_file*
      close();

      __attribute__ ((__pure__)) bool
      is_open() const throw ();

      __attribute__ ((__pure__)) int
      fd() throw ();

      __attribute__ ((__pure__)) __c_file*
      file() throw ();

      ~__basic_file();

      streamsize
      xsputn(const char* __s, streamsize __n);

      streamsize
      xsputn_2(const char* __s1, streamsize __n1,
        const char* __s2, streamsize __n2);

      streamsize
      xsgetn(char* __s, streamsize __n);

      streamoff
      seekoff(streamoff __off, ios_base::seekdir __way) throw ();

      int
      sync();

      streamsize
      showmanyc();







      using native_handle_type = int;


      native_handle_type
      native_handle() const noexcept;

    };


}
# 45 "/usr/include/c++/14.2.1/fstream" 2 3





# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 51 "/usr/include/c++/14.2.1/fstream" 2 3






namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Path, typename _Result = _Path, typename _Path2
    = decltype(std::declval<_Path&>().make_preferred().filename())>
    using _If_fs_path = enable_if_t<is_same_v<_Path, _Path2>, _Result>;
# 89 "/usr/include/c++/14.2.1/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_filebuf : public basic_streambuf<_CharT, _Traits>
    {

      template<typename _Tp>
 using __chk_state = __and_<is_copy_assignable<_Tp>,
       is_copy_constructible<_Tp>,
       is_default_constructible<_Tp>>;

      static_assert(__chk_state<typename _Traits::state_type>::value,
      "state_type must be CopyAssignable, CopyConstructible"
      " and DefaultConstructible");

      static_assert(is_same<typename _Traits::pos_type,
       fpos<typename _Traits::state_type>>::value,
      "pos_type must be fpos<state_type>");

    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef __basic_file<char> __file_type;
      typedef typename traits_type::state_type __state_type;
      typedef codecvt<char_type, char, __state_type> __codecvt_type;

      friend class ios_base;

    protected:


      __c_lock _M_lock;


      __file_type _M_file;


      ios_base::openmode _M_mode;


      __state_type _M_state_beg;




      __state_type _M_state_cur;



      __state_type _M_state_last;


      char_type* _M_buf;






      size_t _M_buf_size;


      bool _M_buf_allocated;
# 165 "/usr/include/c++/14.2.1/fstream" 3
      bool _M_reading;
      bool _M_writing;







      char_type _M_pback;
      char_type* _M_pback_cur_save;
      char_type* _M_pback_end_save;
      bool _M_pback_init;



      const __codecvt_type* _M_codecvt;






      char* _M_ext_buf;




      streamsize _M_ext_buf_size;






      const char* _M_ext_next;
      char* _M_ext_end;






      void
      _M_create_pback()
      {
 if (!_M_pback_init)
   {
     _M_pback_cur_save = this->gptr();
     _M_pback_end_save = this->egptr();
     this->setg(&_M_pback, &_M_pback, &_M_pback + 1);
     _M_pback_init = true;
   }
      }






      void
      _M_destroy_pback() throw()
      {
 if (_M_pback_init)
   {

     _M_pback_cur_save += this->gptr() != this->eback();
     this->setg(_M_buf, _M_pback_cur_save, _M_pback_end_save);
     _M_pback_init = false;
   }
      }

    public:







      basic_filebuf();


      basic_filebuf(const basic_filebuf&) = delete;
      basic_filebuf(basic_filebuf&&);





      virtual
      ~basic_filebuf()
      {
 try
   { this->close(); }
 catch(...)
   { }
      }


      basic_filebuf& operator=(const basic_filebuf&) = delete;
      basic_filebuf& operator=(basic_filebuf&&);
      void swap(basic_filebuf&);






      bool
      is_open() const throw()
      { return _M_file.is_open(); }
# 319 "/usr/include/c++/14.2.1/fstream" 3
      __filebuf_type*
      open(const char* __s, ios_base::openmode __mode);
# 340 "/usr/include/c++/14.2.1/fstream" 3
      __filebuf_type*
      open(const std::string& __s, ios_base::openmode __mode)
      { return open(__s.c_str(), __mode); }
# 351 "/usr/include/c++/14.2.1/fstream" 3
      template<typename _Path>
 _If_fs_path<_Path, __filebuf_type*>
 open(const _Path& __s, ios_base::openmode __mode)
 { return open(__s.c_str(), __mode); }
# 370 "/usr/include/c++/14.2.1/fstream" 3
      __filebuf_type*
      close();
# 403 "/usr/include/c++/14.2.1/fstream" 3
    protected:
      void
      _M_allocate_internal_buffer();

      void
      _M_destroy_internal_buffer() throw();


      virtual streamsize
      showmanyc();






      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = _Traits::eof());
# 432 "/usr/include/c++/14.2.1/fstream" 3
      virtual int_type
      overflow(int_type __c = _Traits::eof());



      bool
      _M_convert_to_external(char_type*, streamsize);
# 452 "/usr/include/c++/14.2.1/fstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n);

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __pos,
       ios_base::openmode __mode = ios_base::in | ios_base::out);


      pos_type
      _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state);

      int
      _M_get_ext_pos(__state_type &__state);

      virtual int
      sync();

      virtual void
      imbue(const locale& __loc);

      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);

      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);


      bool
      _M_terminate_output();
# 498 "/usr/include/c++/14.2.1/fstream" 3
      void
      _M_set_buffer(streamsize __off)
      {
 const bool __testin = _M_mode & ios_base::in;
 const bool __testout = (_M_mode & ios_base::out
    || _M_mode & ios_base::app);

 if (__testin && __off > 0)
   this->setg(_M_buf, _M_buf, _M_buf + __off);
 else
   this->setg(_M_buf, _M_buf, _M_buf);

 if (__testout && __off == 0 && _M_buf_size > 1 )
   this->setp(_M_buf, _M_buf + _M_buf_size - 1);
 else
   this->setp(0, 0);
      }
    };
# 531 "/usr/include/c++/14.2.1/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ifstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 558 "/usr/include/c++/14.2.1/fstream" 3
      basic_ifstream() : __istream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 568 "/usr/include/c++/14.2.1/fstream" 3
      explicit
      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 601 "/usr/include/c++/14.2.1/fstream" 3
      explicit
      basic_ifstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 618 "/usr/include/c++/14.2.1/fstream" 3
      template<typename _Path, typename _Require = _If_fs_path<_Path>>
 basic_ifstream(const _Path& __s,
         ios_base::openmode __mode = ios_base::in)
 : basic_ifstream(__s.c_str(), __mode)
 { }


      basic_ifstream(const basic_ifstream&) = delete;

      basic_ifstream(basic_ifstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __istream_type::set_rdbuf(&_M_filebuf); }
# 639 "/usr/include/c++/14.2.1/fstream" 3
      ~basic_ifstream()
      { }




      basic_ifstream&
      operator=(const basic_ifstream&) = delete;

      basic_ifstream&
      operator=(basic_ifstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_ifstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 671 "/usr/include/c++/14.2.1/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 697 "/usr/include/c++/14.2.1/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 736 "/usr/include/c++/14.2.1/fstream" 3
      void
      open(const std::string& __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 756 "/usr/include/c++/14.2.1/fstream" 3
      template<typename _Path>
 _If_fs_path<_Path, void>
 open(const _Path& __s, ios_base::openmode __mode = ios_base::in)
 { open(__s.c_str(), __mode); }
# 769 "/usr/include/c++/14.2.1/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
# 784 "/usr/include/c++/14.2.1/fstream" 3
    };
# 801 "/usr/include/c++/14.2.1/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ofstream : public basic_ostream<_CharT,_Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 828 "/usr/include/c++/14.2.1/fstream" 3
      basic_ofstream(): __ostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 838 "/usr/include/c++/14.2.1/fstream" 3
      explicit
      basic_ofstream(const char* __s,
       ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 873 "/usr/include/c++/14.2.1/fstream" 3
      explicit
      basic_ofstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 890 "/usr/include/c++/14.2.1/fstream" 3
      template<typename _Path, typename _Require = _If_fs_path<_Path>>
 basic_ofstream(const _Path& __s,
         ios_base::openmode __mode = ios_base::out)
 : basic_ofstream(__s.c_str(), __mode)
 { }


      basic_ofstream(const basic_ofstream&) = delete;

      basic_ofstream(basic_ofstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __ostream_type::set_rdbuf(&_M_filebuf); }
# 911 "/usr/include/c++/14.2.1/fstream" 3
      ~basic_ofstream()
      { }




      basic_ofstream&
      operator=(const basic_ofstream&) = delete;

      basic_ofstream&
      operator=(basic_ofstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_ofstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 943 "/usr/include/c++/14.2.1/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 969 "/usr/include/c++/14.2.1/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1008 "/usr/include/c++/14.2.1/fstream" 3
      void
      open(const std::string& __s, ios_base::openmode __mode = ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1028 "/usr/include/c++/14.2.1/fstream" 3
      template<typename _Path>
 _If_fs_path<_Path, void>
 open(const _Path& __s, ios_base::openmode __mode = ios_base::out)
 { open(__s.c_str(), __mode); }
# 1041 "/usr/include/c++/14.2.1/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
# 1056 "/usr/include/c++/14.2.1/fstream" 3
    };
# 1073 "/usr/include/c++/14.2.1/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_fstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ios<char_type, traits_type> __ios_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 1101 "/usr/include/c++/14.2.1/fstream" 3
      basic_fstream()
      : __iostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }






      explicit
      basic_fstream(const char* __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 1140 "/usr/include/c++/14.2.1/fstream" 3
      explicit
      basic_fstream(const std::string& __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }







      template<typename _Path, typename _Require = _If_fs_path<_Path>>
 basic_fstream(const _Path& __s,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
 : basic_fstream(__s.c_str(), __mode)
 { }


      basic_fstream(const basic_fstream&) = delete;

      basic_fstream(basic_fstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __iostream_type::set_rdbuf(&_M_filebuf); }
# 1176 "/usr/include/c++/14.2.1/fstream" 3
      ~basic_fstream()
      { }




      basic_fstream&
      operator=(const basic_fstream&) = delete;

      basic_fstream&
      operator=(basic_fstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_fstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 1208 "/usr/include/c++/14.2.1/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 1234 "/usr/include/c++/14.2.1/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1275 "/usr/include/c++/14.2.1/fstream" 3
      void
      open(const std::string& __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1296 "/usr/include/c++/14.2.1/fstream" 3
      template<typename _Path>
 _If_fs_path<_Path, void>
 open(const _Path& __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
 { open(__s.c_str(), __mode); }
# 1310 "/usr/include/c++/14.2.1/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
# 1325 "/usr/include/c++/14.2.1/fstream" 3
    };



  template <class _CharT, class _Traits>
    inline void
    swap(basic_filebuf<_CharT, _Traits>& __x,
  basic_filebuf<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_ifstream<_CharT, _Traits>& __x,
  basic_ifstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_ofstream<_CharT, _Traits>& __x,
  basic_ofstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_fstream<_CharT, _Traits>& __x,
  basic_fstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }



}

# 1 "/usr/include/c++/14.2.1/bits/fstream.tcc" 1 3
# 37 "/usr/include/c++/14.2.1/bits/fstream.tcc" 3
       
# 38 "/usr/include/c++/14.2.1/bits/fstream.tcc" 3



# 1 "/usr/include/c++/14.2.1/cerrno" 1 3
# 39 "/usr/include/c++/14.2.1/cerrno" 3
       
# 40 "/usr/include/c++/14.2.1/cerrno" 3
# 42 "/usr/include/c++/14.2.1/bits/fstream.tcc" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_allocate_internal_buffer()
    {


      if (!_M_buf_allocated && !_M_buf)
 {
   _M_buf = new char_type[_M_buf_size];
   _M_buf_allocated = true;
 }
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_destroy_internal_buffer() throw()
    {
      if (_M_buf_allocated)
 {
   delete [] _M_buf;
   _M_buf = 0;
   _M_buf_allocated = false;
 }
      delete [] _M_ext_buf;
      _M_ext_buf = 0;
      _M_ext_buf_size = 0;
      _M_ext_next = 0;
      _M_ext_end = 0;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf() : __streambuf_type(), _M_lock(), _M_file(&_M_lock),
    _M_mode(ios_base::openmode(0)), _M_state_beg(), _M_state_cur(),
    _M_state_last(), _M_buf(0), _M_buf_size(8192),
    _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(),
    _M_pback_cur_save(0), _M_pback_end_save(0), _M_pback_init(false),
    _M_codecvt(0), _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0),
    _M_ext_end(0)
    {
      _M_codecvt = std::__try_use_facet<__codecvt_type>(this->_M_buf_locale);
    }


  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf(basic_filebuf&& __rhs)
    : __streambuf_type(__rhs),
    _M_lock(), _M_file(std::move(__rhs._M_file), &_M_lock),
    _M_mode(std::__exchange(__rhs._M_mode, ios_base::openmode(0))),
    _M_state_beg(std::move(__rhs._M_state_beg)),
    _M_state_cur(std::move(__rhs._M_state_cur)),
    _M_state_last(std::move(__rhs._M_state_last)),
    _M_buf(std::__exchange(__rhs._M_buf, nullptr)),
    _M_buf_size(std::__exchange(__rhs._M_buf_size, 1)),
    _M_buf_allocated(std::__exchange(__rhs._M_buf_allocated, false)),
    _M_reading(std::__exchange(__rhs._M_reading, false)),
    _M_writing(std::__exchange(__rhs._M_writing, false)),
    _M_pback(__rhs._M_pback),
    _M_pback_cur_save(std::__exchange(__rhs._M_pback_cur_save, nullptr)),
    _M_pback_end_save(std::__exchange(__rhs._M_pback_end_save, nullptr)),
    _M_pback_init(std::__exchange(__rhs._M_pback_init, false)),
    _M_codecvt(__rhs._M_codecvt),
    _M_ext_buf(std::__exchange(__rhs._M_ext_buf, nullptr)),
    _M_ext_buf_size(std::__exchange(__rhs._M_ext_buf_size, 0)),
    _M_ext_next(std::__exchange(__rhs._M_ext_next, nullptr)),
    _M_ext_end(std::__exchange(__rhs._M_ext_end, nullptr))
    {
      __rhs._M_set_buffer(-1);
      __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>&
    basic_filebuf<_CharT, _Traits>::
    operator=(basic_filebuf&& __rhs)
    {
      this->close();
      __streambuf_type::operator=(__rhs);
      _M_file.swap(__rhs._M_file);
      _M_mode = std::__exchange(__rhs._M_mode, ios_base::openmode(0));
      _M_state_beg = std::move(__rhs._M_state_beg);
      _M_state_cur = std::move(__rhs._M_state_cur);
      _M_state_last = std::move(__rhs._M_state_last);
      _M_buf = std::__exchange(__rhs._M_buf, nullptr);
      _M_buf_size = std::__exchange(__rhs._M_buf_size, 1);
      _M_buf_allocated = std::__exchange(__rhs._M_buf_allocated, false);
      _M_ext_buf = std::__exchange(__rhs._M_ext_buf, nullptr);
      _M_ext_buf_size = std::__exchange(__rhs._M_ext_buf_size, 0);
      _M_ext_next = std::__exchange(__rhs._M_ext_next, nullptr);
      _M_ext_end = std::__exchange(__rhs._M_ext_end, nullptr);
      _M_reading = std::__exchange(__rhs._M_reading, false);
      _M_writing = std::__exchange(__rhs._M_writing, false);
      _M_pback_cur_save = std::__exchange(__rhs._M_pback_cur_save, nullptr);
      _M_pback_end_save = std::__exchange(__rhs._M_pback_end_save, nullptr);
      _M_pback_init = std::__exchange(__rhs._M_pback_init, false);
      __rhs._M_set_buffer(-1);
      __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
      return *this;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    swap(basic_filebuf& __rhs)
    {
      __streambuf_type::swap(__rhs);
      _M_file.swap(__rhs._M_file);
      std::swap(_M_mode, __rhs._M_mode);
      std::swap(_M_state_beg, __rhs._M_state_beg);
      std::swap(_M_state_cur, __rhs._M_state_cur);
      std::swap(_M_state_last, __rhs._M_state_last);
      std::swap(_M_buf, __rhs._M_buf);
      std::swap(_M_buf_size, __rhs._M_buf_size);
      std::swap(_M_buf_allocated, __rhs._M_buf_allocated);
      std::swap(_M_ext_buf, __rhs._M_ext_buf);
      std::swap(_M_ext_buf_size, __rhs._M_ext_buf_size);
      std::swap(_M_ext_next, __rhs._M_ext_next);
      std::swap(_M_ext_end, __rhs._M_ext_end);
      std::swap(_M_reading, __rhs._M_reading);
      std::swap(_M_writing, __rhs._M_writing);
      std::swap(_M_pback_cur_save, __rhs._M_pback_cur_save);
      std::swap(_M_pback_end_save, __rhs._M_pback_end_save);
      std::swap(_M_pback_init, __rhs._M_pback_init);
    }


  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    open(const char* __s, ios_base::openmode __mode)
    {
      __filebuf_type *__ret = 0;
      if (!this->is_open())
 {
   _M_file.open(__s, __mode);
   if (this->is_open())
     {
       _M_allocate_internal_buffer();
       _M_mode = __mode;


       _M_reading = false;
       _M_writing = false;
       _M_set_buffer(-1);


       _M_state_last = _M_state_cur = _M_state_beg;


       if ((__mode & ios_base::ate)
    && this->seekoff(0, ios_base::end, __mode)
    == pos_type(off_type(-1)))
  this->close();
       else
  __ret = this;
     }
 }
      return __ret;
    }
# 246 "/usr/include/c++/14.2.1/bits/fstream.tcc" 3
  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    close()
    {
      if (!this->is_open())
 return 0;

      bool __testfail = false;
      {

 struct __close_sentry
 {
   basic_filebuf *__fb;
   __close_sentry (basic_filebuf *__fbi): __fb(__fbi) { }
   ~__close_sentry ()
   {
     __fb->_M_mode = ios_base::openmode(0);
     __fb->_M_pback_init = false;
     __fb->_M_destroy_internal_buffer();
     __fb->_M_reading = false;
     __fb->_M_writing = false;
     __fb->_M_set_buffer(-1);
     __fb->_M_state_last = __fb->_M_state_cur = __fb->_M_state_beg;
   }
 } __cs (this);

 try
   {
     if (!_M_terminate_output())
       __testfail = true;
   }
 catch(...)
   {
     _M_file.close();
     throw;
   }
      }

      if (!_M_file.close())
 __testfail = true;

      if (__testfail)
 return 0;
      else
 return this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    showmanyc()
    {
      streamsize __ret = -1;
      const bool __testin = _M_mode & ios_base::in;
      if (__testin && this->is_open())
 {


   __ret = this->egptr() - this->gptr();







   if (__check_facet(_M_codecvt).encoding() >= 0)

     __ret += _M_file.showmanyc() / _M_codecvt->max_length();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }



   _M_destroy_pback();

   if (this->gptr() < this->egptr())
     return traits_type::to_int_type(*this->gptr());


   const size_t __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;


   bool __got_eof = false;

   streamsize __ilen = 0;
   codecvt_base::result __r = codecvt_base::ok;
   if (__check_facet(_M_codecvt).always_noconv())
     {
       __ilen = _M_file.xsgetn(reinterpret_cast<char*>(this->eback()),
          __buflen);
       if (__ilen == 0)
  __got_eof = true;
     }
   else
     {


       const int __enc = _M_codecvt->encoding();
       streamsize __blen;
       streamsize __rlen;
       if (__enc > 0)
  __blen = __rlen = __buflen * __enc;
       else
  {
    __blen = __buflen + _M_codecvt->max_length() - 1;
    __rlen = __buflen;
  }
       const streamsize __remainder = _M_ext_end - _M_ext_next;
       __rlen = __rlen > __remainder ? __rlen - __remainder : 0;



       if (_M_reading && this->egptr() == this->eback() && __remainder)
  __rlen = 0;



       if (_M_ext_buf_size < __blen)
  {
    char* __buf = new char[__blen];
    if (__remainder)
      __builtin_memcpy(__buf, _M_ext_next, __remainder);

    delete [] _M_ext_buf;
    _M_ext_buf = __buf;
    _M_ext_buf_size = __blen;
  }
       else if (__remainder)
  __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

       _M_ext_next = _M_ext_buf;
       _M_ext_end = _M_ext_buf + __remainder;
       _M_state_last = _M_state_cur;

       do
  {
    if (__rlen > 0)
      {



        if (_M_ext_end - _M_ext_buf + __rlen > _M_ext_buf_size)
   {
     __throw_ios_failure(("basic_filebuf::underflow " "codecvt::max_length() " "is not valid")

                          );
   }
        streamsize __elen = _M_file.xsgetn(_M_ext_end, __rlen);
        if (__elen == 0)
   __got_eof = true;
        else if (__elen == -1)
   break;
        _M_ext_end += __elen;
      }

    char_type* __iend = this->eback();
    if (_M_ext_next < _M_ext_end)
      __r = _M_codecvt->in(_M_state_cur, _M_ext_next,
      _M_ext_end, _M_ext_next,
      this->eback(),
      this->eback() + __buflen, __iend);
    if (__r == codecvt_base::noconv)
      {
        size_t __avail = _M_ext_end - _M_ext_buf;
        __ilen = std::min(__avail, __buflen);
        traits_type::copy(this->eback(),
     reinterpret_cast<char_type*>
     (_M_ext_buf), __ilen);
        _M_ext_next = _M_ext_buf + __ilen;
      }
    else
      __ilen = __iend - this->eback();




    if (__r == codecvt_base::error)
      break;

    __rlen = 1;
  }
       while (__ilen == 0 && !__got_eof);
     }

   if (__ilen > 0)
     {
       _M_set_buffer(__ilen);
       _M_reading = true;
       __ret = traits_type::to_int_type(*this->gptr());
     }
   else if (__got_eof)
     {



       _M_set_buffer(-1);
       _M_reading = false;


       if (__r == codecvt_base::partial)
  __throw_ios_failure(("basic_filebuf::underflow " "incomplete character in file")
                                       );
     }
   else if (__r == codecvt_base::error)
     __throw_ios_failure(("basic_filebuf::underflow " "invalid byte sequence in file")
                                    );
   else
     __throw_ios_failure(("basic_filebuf::underflow " "error reading the file")
                             , (*__errno_location ()));
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    pbackfail(int_type __i)
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }


   const bool __testpb = _M_pback_init;
   const bool __testeof = traits_type::eq_int_type(__i, __ret);
   int_type __tmp;
   if (this->eback() < this->gptr())
     {
       this->gbump(-1);
       __tmp = traits_type::to_int_type(*this->gptr());
     }
   else if (this->seekoff(-1, ios_base::cur) != pos_type(off_type(-1)))
     {
       __tmp = this->underflow();
       if (traits_type::eq_int_type(__tmp, __ret))
  return __ret;
     }
   else
     {





       return __ret;
     }



   if (!__testeof && traits_type::eq_int_type(__i, __tmp))
     __ret = __i;
   else if (__testeof)
     __ret = traits_type::not_eof(__i);
   else if (!__testpb)
     {
       _M_create_pback();
       _M_reading = true;
       *this->gptr() = traits_type::to_char_type(__i);
       __ret = __i;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    overflow(int_type __c)
    {
      int_type __ret = traits_type::eof();
      const bool __testeof = traits_type::eq_int_type(__c, __ret);
      const bool __testout = (_M_mode & ios_base::out
         || _M_mode & ios_base::app);
      if (__testout)
 {
          if (_M_reading)
            {
              _M_destroy_pback();
              const int __gptr_off = _M_get_ext_pos(_M_state_last);
              if (_M_seek(__gptr_off, ios_base::cur, _M_state_last)
                  == pos_type(off_type(-1)))
                return __ret;
            }
   if (this->pbase() < this->pptr())
     {

       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }



       if (_M_convert_to_external(this->pbase(),
      this->pptr() - this->pbase()))
  {
    _M_set_buffer(0);
    __ret = traits_type::not_eof(__c);
  }
     }
   else if (_M_buf_size > 1)
     {



       _M_set_buffer(0);
       _M_writing = true;
       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }
       __ret = traits_type::not_eof(__c);
     }
   else
     {

       char_type __conv = traits_type::to_char_type(__c);
       if (__testeof || _M_convert_to_external(&__conv, 1))
  {
    _M_writing = true;
    __ret = traits_type::not_eof(__c);
  }
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_convert_to_external(_CharT* __ibuf, streamsize __ilen)
    {

      streamsize __elen;
      streamsize __plen;
      if (__check_facet(_M_codecvt).always_noconv())
 {
   __elen = _M_file.xsputn(reinterpret_cast<char*>(__ibuf), __ilen);
   __plen = __ilen;
 }
      else
 {


   streamsize __blen = __ilen * _M_codecvt->max_length();
   char* __buf = static_cast<char*>(__builtin_alloca(__blen));

   char* __bend;
   const char_type* __iend;
   codecvt_base::result __r;
   __r = _M_codecvt->out(_M_state_cur, __ibuf, __ibuf + __ilen,
    __iend, __buf, __buf + __blen, __bend);

   if (__r == codecvt_base::ok || __r == codecvt_base::partial)
     __blen = __bend - __buf;
   else if (__r == codecvt_base::noconv)
     {

       __buf = reinterpret_cast<char*>(__ibuf);
       __blen = __ilen;
     }
   else
     __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error")
                           );

   __elen = _M_file.xsputn(__buf, __blen);
   __plen = __blen;


   if (__r == codecvt_base::partial && __elen == __plen)
     {
       const char_type* __iresume = __iend;
       streamsize __rlen = this->pptr() - __iend;
       __r = _M_codecvt->out(_M_state_cur, __iresume,
        __iresume + __rlen, __iend, __buf,
        __buf + __blen, __bend);
       if (__r != codecvt_base::error)
  {
    __rlen = __bend - __buf;
    __elen = _M_file.xsputn(__buf, __rlen);
    __plen = __rlen;
  }
       else
  __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error")
                        );
     }
 }
      return __elen == __plen;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsgetn(_CharT* __s, streamsize __n)
    {

      streamsize __ret = 0;
      if (_M_pback_init)
 {
   if (__n > 0 && this->gptr() == this->eback())
     {
       *__s++ = *this->gptr();
       this->gbump(1);
       __ret = 1;
       --__n;
     }
   _M_destroy_pback();
 }
      else if (_M_writing)
 {
   if (overflow() == traits_type::eof())
     return __ret;
   _M_set_buffer(-1);
   _M_writing = false;
 }




      const bool __testin = _M_mode & ios_base::in;
      const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;

      if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()
   && __testin)
 {

   const streamsize __avail = this->egptr() - this->gptr();
   if (__avail != 0)
     {
       traits_type::copy(__s, this->gptr(), __avail);
       __s += __avail;
       this->setg(this->eback(), this->gptr() + __avail, this->egptr());
       __ret += __avail;
       __n -= __avail;
     }



   streamsize __len;
   for (;;)
     {
       __len = _M_file.xsgetn(reinterpret_cast<char*>(__s), __n);
       if (__len == -1)
  __throw_ios_failure(("basic_filebuf::xsgetn " "error reading the file")
                              , (*__errno_location ()));
       if (__len == 0)
  break;

       __n -= __len;
       __ret += __len;
       if (__n == 0)
  break;

       __s += __len;
     }

   if (__n == 0)
     {

       _M_reading = true;
     }
   else if (__len == 0)
     {



       _M_set_buffer(-1);
       _M_reading = false;
     }
 }
      else
 __ret += __streambuf_type::xsgetn(__s, __n);

      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsputn(const _CharT* __s, streamsize __n)
    {
      streamsize __ret = 0;



      const bool __testout = (_M_mode & ios_base::out
         || _M_mode & ios_base::app);
      if (__check_facet(_M_codecvt).always_noconv()
   && __testout && !_M_reading)
 {
   streamsize __bufavail = this->epptr() - this->pptr();


   if (!_M_writing && _M_buf_size > 1)
     __bufavail = _M_buf_size - 1;

   if (__n >= __bufavail)
     {
       const streamsize __buffill = this->pptr() - this->pbase();
       const char* __buf = reinterpret_cast<const char*>(this->pbase());
       __ret = _M_file.xsputn_2(__buf, __buffill,
           reinterpret_cast<const char*>(__s),
           __n);
       if (__ret == __buffill + __n)
  {
    _M_set_buffer(0);
    _M_writing = true;
  }
       if (__ret > __buffill)
  __ret -= __buffill;
       else
  __ret = 0;
     }
   else
     __ret = __streambuf_type::xsputn(__s, __n);
 }
       else
  __ret = __streambuf_type::xsputn(__s, __n);
       return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__streambuf_type*
    basic_filebuf<_CharT, _Traits>::
    setbuf(char_type* __s, streamsize __n)
    {
      if (!this->is_open())
 {
   if (__s == 0 && __n == 0)
     _M_buf_size = 1;
   else if (__s && __n > 0)
     {
# 816 "/usr/include/c++/14.2.1/bits/fstream.tcc" 3
       _M_buf = __s;
       _M_buf_size = __n;
     }
 }
      return this;
    }




  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode)
    {
      int __width = 0;
      if (_M_codecvt)
 __width = _M_codecvt->encoding();
      if (__width < 0)
 __width = 0;

      pos_type __ret = pos_type(off_type(-1));
      const bool __testfail = __off != 0 && __width <= 0;
      if (this->is_open() && !__testfail)
 {




   bool __no_movement = __way == ios_base::cur && __off == 0
     && (!_M_writing || _M_codecvt->always_noconv());


   if (!__no_movement)
     _M_destroy_pback();






   __state_type __state = _M_state_beg;
   off_type __computed_off = __off * __width;
   if (_M_reading && __way == ios_base::cur)
     {
       __state = _M_state_last;
       __computed_off += _M_get_ext_pos(__state);
     }
   if (!__no_movement)
     __ret = _M_seek(__computed_off, __way, __state);
   else
     {
       if (_M_writing)
  __computed_off = this->pptr() - this->pbase();

       off_type __file_off = _M_file.seekoff(0, ios_base::cur);
       if (__file_off != off_type(-1))
  {
    __ret = __file_off + __computed_off;
    __ret.state(__state);
  }
     }
 }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekpos(pos_type __pos, ios_base::openmode)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (this->is_open())
 {

   _M_destroy_pback();
   __ret = _M_seek(off_type(__pos), ios_base::beg, __pos.state());
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (_M_terminate_output())
 {
   off_type __file_off = _M_file.seekoff(__off, __way);
   if (__file_off != off_type(-1))
     {
       _M_reading = false;
       _M_writing = false;
       _M_ext_next = _M_ext_end = _M_ext_buf;
       _M_set_buffer(-1);
       _M_state_cur = __state;
       __ret = __file_off;
       __ret.state(_M_state_cur);
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    int basic_filebuf<_CharT, _Traits>::
    _M_get_ext_pos(__state_type& __state)
    {
      if (_M_codecvt->always_noconv())
        return this->gptr() - this->egptr();
      else
        {



          const int __gptr_off =
            _M_codecvt->length(__state, _M_ext_buf, _M_ext_next,
                               this->gptr() - this->eback());
          return _M_ext_buf + __gptr_off - _M_ext_end;
        }
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_terminate_output()
    {

      bool __testvalid = true;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __testvalid = false;
 }


      if (_M_writing && !__check_facet(_M_codecvt).always_noconv()
   && __testvalid)
 {



   const size_t __blen = 128;
   char __buf[__blen];
   codecvt_base::result __r;
   streamsize __ilen = 0;

   do
     {
       char* __next;
       __r = _M_codecvt->unshift(_M_state_cur, __buf,
     __buf + __blen, __next);
       if (__r == codecvt_base::error)
  __testvalid = false;
       else if (__r == codecvt_base::ok ||
         __r == codecvt_base::partial)
  {
    __ilen = __next - __buf;
    if (__ilen > 0)
      {
        const streamsize __elen = _M_file.xsputn(__buf, __ilen);
        if (__elen != __ilen)
   __testvalid = false;
      }
  }
     }
   while (__r == codecvt_base::partial && __ilen > 0 && __testvalid);

   if (__testvalid)
     {




       const int_type __tmp = this->overflow();
       if (traits_type::eq_int_type(__tmp, traits_type::eof()))
  __testvalid = false;
     }
 }
      return __testvalid;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_filebuf<_CharT, _Traits>::
    sync()
    {


      int __ret = 0;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __ret = -1;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    imbue(const locale& __loc)
    {
      bool __testvalid = true;

      const __codecvt_type* const _M_codecvt_tmp
 = __try_use_facet<__codecvt_type>(__loc);

      if (this->is_open())
 {

   if ((_M_reading || _M_writing)
       && __check_facet(_M_codecvt).encoding() == -1)
     __testvalid = false;
   else
     {
       if (_M_reading)
  {
    if (__check_facet(_M_codecvt).always_noconv())
      {
        if (_M_codecvt_tmp
     && !__check_facet(_M_codecvt_tmp).always_noconv())
   __testvalid = this->seekoff(0, ios_base::cur, _M_mode)
                 != pos_type(off_type(-1));
      }
    else
      {

        _M_ext_next = _M_ext_buf
   + _M_codecvt->length(_M_state_last, _M_ext_buf,
          _M_ext_next,
          this->gptr() - this->eback());
        const streamsize __remainder = _M_ext_end - _M_ext_next;
        if (__remainder)
   __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

        _M_ext_next = _M_ext_buf;
        _M_ext_end = _M_ext_buf + __remainder;
        _M_set_buffer(-1);
        _M_state_last = _M_state_cur = _M_state_beg;
      }
  }
       else if (_M_writing && (__testvalid = _M_terminate_output()))
  _M_set_buffer(-1);
     }
 }

      if (__testvalid)
 _M_codecvt = _M_codecvt_tmp;
      else
 _M_codecvt = 0;
    }




  extern template class basic_filebuf<char>;
  extern template class basic_ifstream<char>;
  extern template class basic_ofstream<char>;
  extern template class basic_fstream<char>;


  extern template class basic_filebuf<wchar_t>;
  extern template class basic_ifstream<wchar_t>;
  extern template class basic_ofstream<wchar_t>;
  extern template class basic_fstream<wchar_t>;




}
# 1361 "/usr/include/c++/14.2.1/fstream" 2 3
# 2 "/home/tayler/projects/marmalade/src/graphics/shader.cpp" 2
# 1 "/usr/include/c++/14.2.1/iostream" 1 3
# 36 "/usr/include/c++/14.2.1/iostream" 3
       
# 37 "/usr/include/c++/14.2.1/iostream" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 62 "/usr/include/c++/14.2.1/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;
# 82 "/usr/include/c++/14.2.1/iostream" 3
  __extension__ __asm (".globl _ZSt21ios_base_library_initv");



}
# 3 "/home/tayler/projects/marmalade/src/graphics/shader.cpp" 2
# 1 "/usr/include/c++/14.2.1/sstream" 1 3
# 36 "/usr/include/c++/14.2.1/sstream" 3
       
# 37 "/usr/include/c++/14.2.1/sstream" 3
# 55 "/usr/include/c++/14.2.1/sstream" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {
# 78 "/usr/include/c++/14.2.1/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
      struct __xfer_bufptrs;


      using allocator_traits = std::allocator_traits<_Alloc>;
      using _Noexcept_swap
 = __or_<typename allocator_traits::propagate_on_container_swap,
  typename allocator_traits::is_always_equal>;


    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 121 "/usr/include/c++/14.2.1/sstream" 3
      basic_stringbuf()
      : __streambuf_type(), _M_mode(ios_base::in | ios_base::out), _M_string()
      { }
# 132 "/usr/include/c++/14.2.1/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 145 "/usr/include/c++/14.2.1/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(),
 _M_string(__str.data(), __str.size(), __str.get_allocator())
      { _M_stringbuf_init(__mode); }


      basic_stringbuf(const basic_stringbuf&) = delete;

      basic_stringbuf(basic_stringbuf&& __rhs)
      : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this))
      { __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0); }


      explicit
      basic_stringbuf(const allocator_type& __a)
      : basic_stringbuf(ios_base::in | std::ios_base::out, __a)
      { }

      basic_stringbuf(ios_base::openmode __mode,
        const allocator_type& __a)
      : __streambuf_type(), _M_mode(__mode), _M_string(__a)
      { }

      explicit
      basic_stringbuf(__string_type&& __s,
        ios_base::openmode __mode = ios_base::in
        | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string(std::move(__s))
      { _M_stringbuf_init(__mode); }

      template<typename _SAlloc>
 basic_stringbuf(const basic_string<_CharT, _Traits, _SAlloc>& __s,
   const allocator_type& __a)
 : basic_stringbuf(__s, ios_base::in | std::ios_base::out, __a)
 { }

      template<typename _SAlloc>
 basic_stringbuf(const basic_string<_CharT, _Traits, _SAlloc>& __s,
   ios_base::openmode __mode,
   const allocator_type& __a)
 : __streambuf_type(), _M_mode(__mode),
   _M_string(__s.data(), __s.size(), __a)
 { _M_stringbuf_init(__mode); }

      template<typename _SAlloc>
 explicit
 basic_stringbuf(const basic_string<_CharT, _Traits, _SAlloc>& __s,
   ios_base::openmode __mode = ios_base::in
          | ios_base::out)
 : basic_stringbuf(__s, __mode, allocator_type{})
 { }

      basic_stringbuf(basic_stringbuf&& __rhs, const allocator_type& __a)
      : basic_stringbuf(std::move(__rhs), __a, __xfer_bufptrs(__rhs, this))
      { __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0); }

      allocator_type get_allocator() const noexcept
      { return _M_string.get_allocator(); }




      basic_stringbuf&
      operator=(const basic_stringbuf&) = delete;

      basic_stringbuf&
      operator=(basic_stringbuf&& __rhs)
      {
 __xfer_bufptrs __st{__rhs, this};
 const __streambuf_type& __base = __rhs;
 __streambuf_type::operator=(__base);
 this->pubimbue(__rhs.getloc());
 _M_mode = __rhs._M_mode;
 _M_string = std::move(__rhs._M_string);
 __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0);
 return *this;
      }

      void
      swap(basic_stringbuf& __rhs) noexcept(_Noexcept_swap::value)
      {
 __xfer_bufptrs __l_st{*this, std::__addressof(__rhs)};
 __xfer_bufptrs __r_st{__rhs, this};
 __streambuf_type& __base = __rhs;
 __streambuf_type::swap(__base);
 __rhs.pubimbue(this->pubimbue(__rhs.getloc()));
 std::swap(_M_mode, __rhs._M_mode);
 std::swap(_M_string, __rhs._M_string);
      }
# 248 "/usr/include/c++/14.2.1/sstream" 3
      __string_type
      str() const &
      {
 __string_type __ret(_M_string.get_allocator());
 if (char_type* __hi = _M_high_mark())
   __ret.assign(this->pbase(), __hi);
 else
   __ret = _M_string;
 return __ret;
      }




      template<__allocator_like _SAlloc>
 basic_string<_CharT, _Traits, _SAlloc>
 str(const _SAlloc& __sa) const
 {
   auto __sv = view();
   return { __sv.data(), __sv.size(), __sa };
 }


      __string_type
      str() &&
      {
 if (char_type* __hi = _M_high_mark())
   {

     _M_string._M_set_length(_M_high_mark() - this->pbase());
   }
 auto __str = std::move(_M_string);
 _M_string.clear();
 _M_sync(_M_string.data(), 0, 0);
 return __str;
      }


     
      basic_string_view<char_type, traits_type>
      view() const noexcept
      {
 if (char_type* __hi = _M_high_mark())
   return { this->pbase(), __hi };
 else
   return _M_string;
      }
# 304 "/usr/include/c++/14.2.1/sstream" 3
      void
      str(const __string_type& __s)
      {


 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }



      template<__allocator_like _SAlloc>
 requires (!is_same_v<_SAlloc, _Alloc>)
 void
 str(const basic_string<_CharT, _Traits, _SAlloc>& __s)
 {
   _M_string.assign(__s.data(), __s.size());
   _M_stringbuf_init(_M_mode);
 }


      void
      str(__string_type&& __s)
      {
 _M_string = std::move(__s);
 _M_stringbuf_init(_M_mode);
      }


    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 377 "/usr/include/c++/14.2.1/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 if (char_type* __pptr = this->pptr())
   {
     char_type* __egptr = this->egptr();
     if (!__egptr || __pptr > __egptr)
       {
  if (_M_mode & ios_base::in)
    this->setg(this->eback(), this->gptr(), __pptr);
  else
    this->setg(__pptr, __pptr, __pptr);
       }
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);

    private:




      __attribute__((__always_inline__))
      char_type*
      _M_high_mark() const noexcept
      {
 if (char_type* __pptr = this->pptr())
   {
     char_type* __egptr = this->egptr();
     if (!__egptr || __pptr > __egptr)
       return __pptr;
     else
       return __egptr;
   }
 return 0;
      }





      struct __xfer_bufptrs
      {
 __xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)
 : _M_to{__to}, _M_goff{-1, -1, -1}, _M_poff{-1, -1, -1}
 {
   const _CharT* const __str = __from._M_string.data();
   const _CharT* __end = nullptr;
   if (__from.eback())
     {
       _M_goff[0] = __from.eback() - __str;
       _M_goff[1] = __from.gptr() - __str;
       _M_goff[2] = __from.egptr() - __str;
       __end = __from.egptr();
     }
   if (__from.pbase())
     {
       _M_poff[0] = __from.pbase() - __str;
       _M_poff[1] = __from.pptr() - __from.pbase();
       _M_poff[2] = __from.epptr() - __str;
       if (!__end || __from.pptr() > __end)
  __end = __from.pptr();
     }


   if (__end)
     {


       auto& __mut_from = const_cast<basic_stringbuf&>(__from);
       __mut_from._M_string._M_length(__end - __str);
     }
 }

 ~__xfer_bufptrs()
 {
   char_type* __str = const_cast<char_type*>(_M_to->_M_string.data());
   if (_M_goff[0] != -1)
     _M_to->setg(__str+_M_goff[0], __str+_M_goff[1], __str+_M_goff[2]);
   if (_M_poff[0] != -1)
     _M_to->_M_pbump(__str+_M_poff[0], __str+_M_poff[2], _M_poff[1]);
 }

 basic_stringbuf* _M_to;
 off_type _M_goff[3];
 off_type _M_poff[3];
      };
# 513 "/usr/include/c++/14.2.1/sstream" 3
      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)
      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)),
      _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string))
      { }




      basic_stringbuf(basic_stringbuf&& __rhs, const allocator_type& __a,
        __xfer_bufptrs&&)
      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)),
      _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string), __a)
      { }


    };
# 546 "/usr/include/c++/14.2.1/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 580 "/usr/include/c++/14.2.1/sstream" 3
      basic_istringstream()
      : __istream_type(), _M_stringbuf(ios_base::in)
      { this->init(&_M_stringbuf); }
# 596 "/usr/include/c++/14.2.1/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 614 "/usr/include/c++/14.2.1/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }


      basic_istringstream(const basic_istringstream&) = delete;

      basic_istringstream(basic_istringstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __istream_type::set_rdbuf(&_M_stringbuf); }


      basic_istringstream(ios_base::openmode __mode, const allocator_type& __a)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in, __a)
      { this->init(std::__addressof(_M_stringbuf)); }

      explicit
      basic_istringstream(__string_type&& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(std::move(__str), __mode | ios_base::in)
      { this->init(std::__addressof(_M_stringbuf)); }

      template<typename _SAlloc>
 basic_istringstream(const basic_string<_CharT, _Traits, _SAlloc>& __str,
       const allocator_type& __a)
 : basic_istringstream(__str, ios_base::in, __a)
 { }

      template<typename _SAlloc>
 basic_istringstream(const basic_string<_CharT, _Traits, _SAlloc>& __str,
       ios_base::openmode __mode,
       const allocator_type& __a)
 : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in, __a)
 { this->init(std::__addressof(_M_stringbuf)); }

      template<typename _SAlloc>
 explicit
 basic_istringstream(const basic_string<_CharT, _Traits, _SAlloc>& __str,
       ios_base::openmode __mode = ios_base::in)
 : basic_istringstream(__str, __mode, allocator_type())
 { }




      basic_istringstream&
      operator=(const basic_istringstream&) = delete;

      basic_istringstream&
      operator=(basic_istringstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_istringstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 697 "/usr/include/c++/14.2.1/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const &
      { return _M_stringbuf.str(); }




      template<__allocator_like _SAlloc>
 basic_string<_CharT, _Traits, _SAlloc>
 str(const _SAlloc& __sa) const
 { return _M_stringbuf.str(__sa); }


      __string_type
      str() &&
      { return std::move(_M_stringbuf).str(); }


     
      basic_string_view<char_type, traits_type>
      view() const noexcept
      { return _M_stringbuf.view(); }
# 735 "/usr/include/c++/14.2.1/sstream" 3
      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }



      template<__allocator_like _SAlloc>
 requires (!is_same_v<_SAlloc, _Alloc>)
 void
 str(const basic_string<_CharT, _Traits, _SAlloc>& __s)
 { _M_stringbuf.str(__s); }


      void
      str(__string_type&& __s)
      { _M_stringbuf.str(std::move(__s)); }

    };
# 770 "/usr/include/c++/14.2.1/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 804 "/usr/include/c++/14.2.1/sstream" 3
      basic_ostringstream()
      : __ostream_type(), _M_stringbuf(ios_base::out)
      { this->init(&_M_stringbuf); }
# 820 "/usr/include/c++/14.2.1/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 838 "/usr/include/c++/14.2.1/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }


      basic_ostringstream(const basic_ostringstream&) = delete;

      basic_ostringstream(basic_ostringstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __ostream_type::set_rdbuf(&_M_stringbuf); }


      basic_ostringstream(ios_base::openmode __mode, const allocator_type& __a)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out, __a)
      { this->init(std::__addressof(_M_stringbuf)); }

      explicit
      basic_ostringstream(__string_type&& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(std::move(__str), __mode | ios_base::out)
      { this->init(std::__addressof(_M_stringbuf)); }

      template<typename _SAlloc>
 basic_ostringstream(const basic_string<_CharT, _Traits, _SAlloc>& __str,
       const allocator_type& __a)
 : basic_ostringstream(__str, ios_base::out, __a)
 { }

      template<typename _SAlloc>
 basic_ostringstream(const basic_string<_CharT, _Traits, _SAlloc>& __str,
       ios_base::openmode __mode,
       const allocator_type& __a)
 : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out, __a)
 { this->init(std::__addressof(_M_stringbuf)); }

      template<typename _SAlloc>
 explicit
 basic_ostringstream(const basic_string<_CharT, _Traits, _SAlloc>& __str,
       ios_base::openmode __mode = ios_base::out)
 : basic_ostringstream(__str, __mode, allocator_type())
 { }




      basic_ostringstream&
      operator=(const basic_ostringstream&) = delete;

      basic_ostringstream&
      operator=(basic_ostringstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_ostringstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 921 "/usr/include/c++/14.2.1/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const &
      { return _M_stringbuf.str(); }




      template<__allocator_like _SAlloc>
 basic_string<_CharT, _Traits, _SAlloc>
 str(const _SAlloc& __sa) const
 { return _M_stringbuf.str(__sa); }


      __string_type
      str() &&
      { return std::move(_M_stringbuf).str(); }


     
      basic_string_view<char_type, traits_type>
      view() const noexcept
      { return _M_stringbuf.view(); }
# 959 "/usr/include/c++/14.2.1/sstream" 3
      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }



      template<__allocator_like _SAlloc>
 requires (!is_same_v<_SAlloc, _Alloc>)
 void
 str(const basic_string<_CharT, _Traits, _SAlloc>& __s)
 { _M_stringbuf.str(__s); }


      void
      str(__string_type&& __s)
      { _M_stringbuf.str(std::move(__s)); }

    };
# 994 "/usr/include/c++/14.2.1/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 1028 "/usr/include/c++/14.2.1/sstream" 3
      basic_stringstream()
      : __iostream_type(), _M_stringbuf(ios_base::out | ios_base::in)
      { this->init(&_M_stringbuf); }
# 1042 "/usr/include/c++/14.2.1/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 1058 "/usr/include/c++/14.2.1/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }


      basic_stringstream(const basic_stringstream&) = delete;

      basic_stringstream(basic_stringstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __iostream_type::set_rdbuf(&_M_stringbuf); }


      basic_stringstream(ios_base::openmode __mode, const allocator_type& __a)
      : __iostream_type(), _M_stringbuf(__mode, __a)
      { this->init(&_M_stringbuf); }

      explicit
      basic_stringstream(__string_type&& __str,
    ios_base::openmode __mode = ios_base::in
           | ios_base::out)
      : __iostream_type(), _M_stringbuf(std::move(__str), __mode)
      { this->init(std::__addressof(_M_stringbuf)); }

      template<typename _SAlloc>
 basic_stringstream(const basic_string<_CharT, _Traits, _SAlloc>& __str,
      const allocator_type& __a)
 : basic_stringstream(__str, ios_base::in | ios_base::out, __a)
 { }

      template<typename _SAlloc>
 basic_stringstream(const basic_string<_CharT, _Traits, _SAlloc>& __str,
      ios_base::openmode __mode,
      const allocator_type& __a)
 : __iostream_type(), _M_stringbuf(__str, __mode, __a)
 { this->init(std::__addressof(_M_stringbuf)); }

      template<typename _SAlloc>
 explicit
 basic_stringstream(const basic_string<_CharT, _Traits, _SAlloc>& __str,
      ios_base::openmode __mode = ios_base::in
             | ios_base::out)
 : basic_stringstream(__str, __mode, allocator_type())
 { }




      basic_stringstream&
      operator=(const basic_stringstream&) = delete;

      basic_stringstream&
      operator=(basic_stringstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_stringstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 1143 "/usr/include/c++/14.2.1/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const &
      { return _M_stringbuf.str(); }




      template<__allocator_like _SAlloc>
 basic_string<_CharT, _Traits, _SAlloc>
 str(const _SAlloc& __sa) const
 { return _M_stringbuf.str(__sa); }


      __string_type
      str() &&
      { return std::move(_M_stringbuf).str(); }


     
      basic_string_view<char_type, traits_type>
      view() const noexcept
      { return _M_stringbuf.view(); }
# 1181 "/usr/include/c++/14.2.1/sstream" 3
      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }



      template<__allocator_like _SAlloc>
 requires (!is_same_v<_SAlloc, _Alloc>)
 void
 str(const basic_string<_CharT, _Traits, _SAlloc>& __s)
 { _M_stringbuf.str(__s); }


      void
      str(__string_type&& __s)
      { _M_stringbuf.str(std::move(__s)); }

    };



  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
  basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
  basic_istringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
  basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
  basic_stringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


}

}




# 1 "/usr/include/c++/14.2.1/bits/sstream.tcc" 1 3
# 37 "/usr/include/c++/14.2.1/bits/sstream.tcc" 3
       
# 38 "/usr/include/c++/14.2.1/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();


      if (size_t(this->epptr() - this->pbase()) < __capacity)
 {

   char_type* __base = const_cast<char_type*>(_M_string.data());
   _M_pbump(__base, __base + __capacity, this->pptr() - this->pbase());
   if (_M_mode & ios_base::in)
     {
       const __size_type __nget = this->gptr() - this->eback();
       const __size_type __eget = this->egptr() - this->eback();
       this->setg(__base, __base + __nget, __base + __eget + 1);
     }
   *this->pptr() = traits_type::to_char_type(__c);
   this->pbump(1);
   return __c;
 }


      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 129 "/usr/include/c++/14.2.1/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp(_M_string.get_allocator());
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
# 1239 "/usr/include/c++/14.2.1/sstream" 2 3
# 4 "/home/tayler/projects/marmalade/src/graphics/shader.cpp" 2
# 1 "/usr/include/glm/fwd.hpp" 1 3 4
       

# 1 "/usr/include/glm/detail/qualifier.hpp" 1 3 4
       

# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4


# 1 "/usr/include/c++/14.2.1/cassert" 1 3 4
# 41 "/usr/include/c++/14.2.1/cassert" 3 4
       
# 42 "/usr/include/c++/14.2.1/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 64 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     noexcept (true) __attribute__ ((__noreturn__));


}
# 45 "/usr/include/c++/14.2.1/cassert" 2 3
# 4 "/usr/include/glm/detail/setup.hpp" 2 3 4
# 43 "/usr/include/glm/detail/setup.hpp" 3 4
# 1 "/usr/include/glm/simd/platform.h" 1 3 4
       
# 44 "/usr/include/glm/detail/setup.hpp" 2 3 4
# 632 "/usr/include/glm/detail/setup.hpp" 3 4
namespace glm
{
 using std::size_t;



  typedef int length_t;

}







 namespace glm
 {
  template<typename T, std::size_t N>
  constexpr std::size_t countof(T const (&)[N])
  {
   return N;
  }
 }
# 670 "/usr/include/glm/detail/setup.hpp" 3 4
namespace glm{
namespace detail
{
 template<typename T>
 struct is_int
 {
  enum test {value = 0};
 };

 template<>
 struct is_int<unsigned int>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<signed int>
 {
  enum test {value = ~0};
 };
}

 typedef unsigned int uint;
}





# 1 "/usr/include/c++/14.2.1/cstdint" 1 3 4
# 32 "/usr/include/c++/14.2.1/cstdint" 3 4
       
# 33 "/usr/include/c++/14.2.1/cstdint" 3
# 45 "/usr/include/c++/14.2.1/cstdint" 3
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4







# 1 "/usr/include/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4



# 1 "/usr/include/bits/stdint-least.h" 1 3 4
# 25 "/usr/include/bits/stdint-least.h" 3 4
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
# 42 "/usr/include/stdint.h" 2 3 4





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 60 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 76 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 90 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stdint.h" 2 3 4
# 46 "/usr/include/c++/14.2.1/cstdint" 2 3


namespace std
{

  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
# 142 "/usr/include/c++/14.2.1/cstdint" 3
}
# 700 "/usr/include/glm/detail/setup.hpp" 2 3 4


namespace glm{
namespace detail
{

  typedef std::uint64_t uint64;
  typedef std::int64_t int64;
# 726 "/usr/include/glm/detail/setup.hpp" 3 4
}
}







namespace glm{
namespace detail
{
 using std::make_unsigned;
}
}
# 4 "/usr/include/glm/detail/qualifier.hpp" 2 3 4

namespace glm
{

 enum qualifier
 {
  packed_highp,
  packed_mediump,
  packed_lowp,
# 21 "/usr/include/glm/detail/qualifier.hpp" 3 4
  highp = packed_highp,
  mediump = packed_mediump,
  lowp = packed_lowp,
  packed = packed_highp,




   defaultp = highp

 };

 typedef qualifier precision;

 template<length_t L, typename T, qualifier Q = defaultp> struct vec;
 template<length_t C, length_t R, typename T, qualifier Q = defaultp> struct mat;
 template<typename T, qualifier Q = defaultp> struct qua;


  template <typename T, qualifier Q = defaultp> using tvec1 = vec<1, T, Q>;
  template <typename T, qualifier Q = defaultp> using tvec2 = vec<2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tvec3 = vec<3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tvec4 = vec<4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat2x2 = mat<2, 2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat2x3 = mat<2, 3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat2x4 = mat<2, 4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat3x2 = mat<3, 2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat3x3 = mat<3, 3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat3x4 = mat<3, 4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat4x2 = mat<4, 2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat4x3 = mat<4, 3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat4x4 = mat<4, 4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tquat = qua<T, Q>;


namespace detail
{
 template<glm::qualifier P>
 struct is_aligned
 {
  static const bool value = false;
 };
# 84 "/usr/include/glm/detail/qualifier.hpp" 3 4
 template<length_t L, typename T, bool is_aligned>
 struct storage
 {
  typedef struct type {
   T data[L];
  } type;
 };


  template<length_t L, typename T>
  struct storage<L, T, true>
  {
   typedef struct alignas(L * sizeof(T)) type {
    T data[L];
   } type;
  };

  template<typename T>
  struct storage<3, T, true>
  {
   typedef struct alignas(4 * sizeof(T)) type {
    T data[4];
   } type;
  };
# 189 "/usr/include/glm/detail/qualifier.hpp" 3 4
 enum genTypeEnum
 {
  GENTYPE_VEC,
  GENTYPE_MAT,
  GENTYPE_QUAT
 };

 template <typename genType>
 struct genTypeTrait
 {};

 template <length_t C, length_t R, typename T>
 struct genTypeTrait<mat<C, R, T> >
 {
  static const genTypeEnum GENTYPE = GENTYPE_MAT;
 };

 template<typename genType, genTypeEnum type>
 struct init_gentype
 {
 };

 template<typename genType>
 struct init_gentype<genType, GENTYPE_QUAT>
 {
  inline constexpr static genType identity()
  {
   return genType(1, 0, 0, 0);
  }
 };

 template<typename genType>
 struct init_gentype<genType, GENTYPE_MAT>
 {
  inline constexpr static genType identity()
  {
   return genType(1);
  }
 };
}
}
# 4 "/usr/include/glm/fwd.hpp" 2 3 4

namespace glm
{

 typedef std::int8_t int8;
 typedef std::int16_t int16;
 typedef std::int32_t int32;
 typedef std::int64_t int64;

 typedef std::uint8_t uint8;
 typedef std::uint16_t uint16;
 typedef std::uint32_t uint32;
 typedef std::uint64_t uint64;
# 31 "/usr/include/glm/fwd.hpp" 3 4
 typedef int8 lowp_i8;
 typedef int8 mediump_i8;
 typedef int8 highp_i8;
 typedef int8 i8;

 typedef int8 lowp_int8;
 typedef int8 mediump_int8;
 typedef int8 highp_int8;

 typedef int8 lowp_int8_t;
 typedef int8 mediump_int8_t;
 typedef int8 highp_int8_t;
 typedef int8 int8_t;

 typedef int16 lowp_i16;
 typedef int16 mediump_i16;
 typedef int16 highp_i16;
 typedef int16 i16;

 typedef int16 lowp_int16;
 typedef int16 mediump_int16;
 typedef int16 highp_int16;

 typedef int16 lowp_int16_t;
 typedef int16 mediump_int16_t;
 typedef int16 highp_int16_t;
 typedef int16 int16_t;

 typedef int32 lowp_i32;
 typedef int32 mediump_i32;
 typedef int32 highp_i32;
 typedef int32 i32;

 typedef int32 lowp_int32;
 typedef int32 mediump_int32;
 typedef int32 highp_int32;

 typedef int32 lowp_int32_t;
 typedef int32 mediump_int32_t;
 typedef int32 highp_int32_t;
 typedef int32 int32_t;

 typedef int64 lowp_i64;
 typedef int64 mediump_i64;
 typedef int64 highp_i64;
 typedef int64 i64;

 typedef int64 lowp_int64;
 typedef int64 mediump_int64;
 typedef int64 highp_int64;

 typedef int64 lowp_int64_t;
 typedef int64 mediump_int64_t;
 typedef int64 highp_int64_t;
 typedef int64 int64_t;



 typedef unsigned int uint;

 typedef uint8 lowp_u8;
 typedef uint8 mediump_u8;
 typedef uint8 highp_u8;
 typedef uint8 u8;

 typedef uint8 lowp_uint8;
 typedef uint8 mediump_uint8;
 typedef uint8 highp_uint8;

 typedef uint8 lowp_uint8_t;
 typedef uint8 mediump_uint8_t;
 typedef uint8 highp_uint8_t;
 typedef uint8 uint8_t;

 typedef uint16 lowp_u16;
 typedef uint16 mediump_u16;
 typedef uint16 highp_u16;
 typedef uint16 u16;

 typedef uint16 lowp_uint16;
 typedef uint16 mediump_uint16;
 typedef uint16 highp_uint16;

 typedef uint16 lowp_uint16_t;
 typedef uint16 mediump_uint16_t;
 typedef uint16 highp_uint16_t;
 typedef uint16 uint16_t;

 typedef uint32 lowp_u32;
 typedef uint32 mediump_u32;
 typedef uint32 highp_u32;
 typedef uint32 u32;

 typedef uint32 lowp_uint32;
 typedef uint32 mediump_uint32;
 typedef uint32 highp_uint32;

 typedef uint32 lowp_uint32_t;
 typedef uint32 mediump_uint32_t;
 typedef uint32 highp_uint32_t;
 typedef uint32 uint32_t;

 typedef uint64 lowp_u64;
 typedef uint64 mediump_u64;
 typedef uint64 highp_u64;
 typedef uint64 u64;

 typedef uint64 lowp_uint64;
 typedef uint64 mediump_uint64;
 typedef uint64 highp_uint64;

 typedef uint64 lowp_uint64_t;
 typedef uint64 mediump_uint64_t;
 typedef uint64 highp_uint64_t;
 typedef uint64 uint64_t;



 typedef float lowp_f32;
 typedef float mediump_f32;
 typedef float highp_f32;
 typedef float f32;

 typedef float lowp_float32;
 typedef float mediump_float32;
 typedef float highp_float32;
 typedef float float32;

 typedef float lowp_float32_t;
 typedef float mediump_float32_t;
 typedef float highp_float32_t;
 typedef float float32_t;


 typedef double lowp_f64;
 typedef double mediump_f64;
 typedef double highp_f64;
 typedef double f64;

 typedef double lowp_float64;
 typedef double mediump_float64;
 typedef double highp_float64;
 typedef double float64;

 typedef double lowp_float64_t;
 typedef double mediump_float64_t;
 typedef double highp_float64_t;
 typedef double float64_t;



 typedef vec<1, bool, lowp> lowp_bvec1;
 typedef vec<2, bool, lowp> lowp_bvec2;
 typedef vec<3, bool, lowp> lowp_bvec3;
 typedef vec<4, bool, lowp> lowp_bvec4;

 typedef vec<1, bool, mediump> mediump_bvec1;
 typedef vec<2, bool, mediump> mediump_bvec2;
 typedef vec<3, bool, mediump> mediump_bvec3;
 typedef vec<4, bool, mediump> mediump_bvec4;

 typedef vec<1, bool, highp> highp_bvec1;
 typedef vec<2, bool, highp> highp_bvec2;
 typedef vec<3, bool, highp> highp_bvec3;
 typedef vec<4, bool, highp> highp_bvec4;

 typedef vec<1, bool, defaultp> bvec1;
 typedef vec<2, bool, defaultp> bvec2;
 typedef vec<3, bool, defaultp> bvec3;
 typedef vec<4, bool, defaultp> bvec4;



 typedef vec<1, int, lowp> lowp_ivec1;
 typedef vec<2, int, lowp> lowp_ivec2;
 typedef vec<3, int, lowp> lowp_ivec3;
 typedef vec<4, int, lowp> lowp_ivec4;

 typedef vec<1, int, mediump> mediump_ivec1;
 typedef vec<2, int, mediump> mediump_ivec2;
 typedef vec<3, int, mediump> mediump_ivec3;
 typedef vec<4, int, mediump> mediump_ivec4;

 typedef vec<1, int, highp> highp_ivec1;
 typedef vec<2, int, highp> highp_ivec2;
 typedef vec<3, int, highp> highp_ivec3;
 typedef vec<4, int, highp> highp_ivec4;

 typedef vec<1, int, defaultp> ivec1;
 typedef vec<2, int, defaultp> ivec2;
 typedef vec<3, int, defaultp> ivec3;
 typedef vec<4, int, defaultp> ivec4;

 typedef vec<1, i8, lowp> lowp_i8vec1;
 typedef vec<2, i8, lowp> lowp_i8vec2;
 typedef vec<3, i8, lowp> lowp_i8vec3;
 typedef vec<4, i8, lowp> lowp_i8vec4;

 typedef vec<1, i8, mediump> mediump_i8vec1;
 typedef vec<2, i8, mediump> mediump_i8vec2;
 typedef vec<3, i8, mediump> mediump_i8vec3;
 typedef vec<4, i8, mediump> mediump_i8vec4;

 typedef vec<1, i8, highp> highp_i8vec1;
 typedef vec<2, i8, highp> highp_i8vec2;
 typedef vec<3, i8, highp> highp_i8vec3;
 typedef vec<4, i8, highp> highp_i8vec4;

 typedef vec<1, i8, defaultp> i8vec1;
 typedef vec<2, i8, defaultp> i8vec2;
 typedef vec<3, i8, defaultp> i8vec3;
 typedef vec<4, i8, defaultp> i8vec4;

 typedef vec<1, i16, lowp> lowp_i16vec1;
 typedef vec<2, i16, lowp> lowp_i16vec2;
 typedef vec<3, i16, lowp> lowp_i16vec3;
 typedef vec<4, i16, lowp> lowp_i16vec4;

 typedef vec<1, i16, mediump> mediump_i16vec1;
 typedef vec<2, i16, mediump> mediump_i16vec2;
 typedef vec<3, i16, mediump> mediump_i16vec3;
 typedef vec<4, i16, mediump> mediump_i16vec4;

 typedef vec<1, i16, highp> highp_i16vec1;
 typedef vec<2, i16, highp> highp_i16vec2;
 typedef vec<3, i16, highp> highp_i16vec3;
 typedef vec<4, i16, highp> highp_i16vec4;

 typedef vec<1, i16, defaultp> i16vec1;
 typedef vec<2, i16, defaultp> i16vec2;
 typedef vec<3, i16, defaultp> i16vec3;
 typedef vec<4, i16, defaultp> i16vec4;

 typedef vec<1, i32, lowp> lowp_i32vec1;
 typedef vec<2, i32, lowp> lowp_i32vec2;
 typedef vec<3, i32, lowp> lowp_i32vec3;
 typedef vec<4, i32, lowp> lowp_i32vec4;

 typedef vec<1, i32, mediump> mediump_i32vec1;
 typedef vec<2, i32, mediump> mediump_i32vec2;
 typedef vec<3, i32, mediump> mediump_i32vec3;
 typedef vec<4, i32, mediump> mediump_i32vec4;

 typedef vec<1, i32, highp> highp_i32vec1;
 typedef vec<2, i32, highp> highp_i32vec2;
 typedef vec<3, i32, highp> highp_i32vec3;
 typedef vec<4, i32, highp> highp_i32vec4;

 typedef vec<1, i32, defaultp> i32vec1;
 typedef vec<2, i32, defaultp> i32vec2;
 typedef vec<3, i32, defaultp> i32vec3;
 typedef vec<4, i32, defaultp> i32vec4;

 typedef vec<1, i64, lowp> lowp_i64vec1;
 typedef vec<2, i64, lowp> lowp_i64vec2;
 typedef vec<3, i64, lowp> lowp_i64vec3;
 typedef vec<4, i64, lowp> lowp_i64vec4;

 typedef vec<1, i64, mediump> mediump_i64vec1;
 typedef vec<2, i64, mediump> mediump_i64vec2;
 typedef vec<3, i64, mediump> mediump_i64vec3;
 typedef vec<4, i64, mediump> mediump_i64vec4;

 typedef vec<1, i64, highp> highp_i64vec1;
 typedef vec<2, i64, highp> highp_i64vec2;
 typedef vec<3, i64, highp> highp_i64vec3;
 typedef vec<4, i64, highp> highp_i64vec4;

 typedef vec<1, i64, defaultp> i64vec1;
 typedef vec<2, i64, defaultp> i64vec2;
 typedef vec<3, i64, defaultp> i64vec3;
 typedef vec<4, i64, defaultp> i64vec4;



 typedef vec<1, uint, lowp> lowp_uvec1;
 typedef vec<2, uint, lowp> lowp_uvec2;
 typedef vec<3, uint, lowp> lowp_uvec3;
 typedef vec<4, uint, lowp> lowp_uvec4;

 typedef vec<1, uint, mediump> mediump_uvec1;
 typedef vec<2, uint, mediump> mediump_uvec2;
 typedef vec<3, uint, mediump> mediump_uvec3;
 typedef vec<4, uint, mediump> mediump_uvec4;

 typedef vec<1, uint, highp> highp_uvec1;
 typedef vec<2, uint, highp> highp_uvec2;
 typedef vec<3, uint, highp> highp_uvec3;
 typedef vec<4, uint, highp> highp_uvec4;

 typedef vec<1, uint, defaultp> uvec1;
 typedef vec<2, uint, defaultp> uvec2;
 typedef vec<3, uint, defaultp> uvec3;
 typedef vec<4, uint, defaultp> uvec4;

 typedef vec<1, u8, lowp> lowp_u8vec1;
 typedef vec<2, u8, lowp> lowp_u8vec2;
 typedef vec<3, u8, lowp> lowp_u8vec3;
 typedef vec<4, u8, lowp> lowp_u8vec4;

 typedef vec<1, u8, mediump> mediump_u8vec1;
 typedef vec<2, u8, mediump> mediump_u8vec2;
 typedef vec<3, u8, mediump> mediump_u8vec3;
 typedef vec<4, u8, mediump> mediump_u8vec4;

 typedef vec<1, u8, highp> highp_u8vec1;
 typedef vec<2, u8, highp> highp_u8vec2;
 typedef vec<3, u8, highp> highp_u8vec3;
 typedef vec<4, u8, highp> highp_u8vec4;

 typedef vec<1, u8, defaultp> u8vec1;
 typedef vec<2, u8, defaultp> u8vec2;
 typedef vec<3, u8, defaultp> u8vec3;
 typedef vec<4, u8, defaultp> u8vec4;

 typedef vec<1, u16, lowp> lowp_u16vec1;
 typedef vec<2, u16, lowp> lowp_u16vec2;
 typedef vec<3, u16, lowp> lowp_u16vec3;
 typedef vec<4, u16, lowp> lowp_u16vec4;

 typedef vec<1, u16, mediump> mediump_u16vec1;
 typedef vec<2, u16, mediump> mediump_u16vec2;
 typedef vec<3, u16, mediump> mediump_u16vec3;
 typedef vec<4, u16, mediump> mediump_u16vec4;

 typedef vec<1, u16, highp> highp_u16vec1;
 typedef vec<2, u16, highp> highp_u16vec2;
 typedef vec<3, u16, highp> highp_u16vec3;
 typedef vec<4, u16, highp> highp_u16vec4;

 typedef vec<1, u16, defaultp> u16vec1;
 typedef vec<2, u16, defaultp> u16vec2;
 typedef vec<3, u16, defaultp> u16vec3;
 typedef vec<4, u16, defaultp> u16vec4;

 typedef vec<1, u32, lowp> lowp_u32vec1;
 typedef vec<2, u32, lowp> lowp_u32vec2;
 typedef vec<3, u32, lowp> lowp_u32vec3;
 typedef vec<4, u32, lowp> lowp_u32vec4;

 typedef vec<1, u32, mediump> mediump_u32vec1;
 typedef vec<2, u32, mediump> mediump_u32vec2;
 typedef vec<3, u32, mediump> mediump_u32vec3;
 typedef vec<4, u32, mediump> mediump_u32vec4;

 typedef vec<1, u32, highp> highp_u32vec1;
 typedef vec<2, u32, highp> highp_u32vec2;
 typedef vec<3, u32, highp> highp_u32vec3;
 typedef vec<4, u32, highp> highp_u32vec4;

 typedef vec<1, u32, defaultp> u32vec1;
 typedef vec<2, u32, defaultp> u32vec2;
 typedef vec<3, u32, defaultp> u32vec3;
 typedef vec<4, u32, defaultp> u32vec4;

 typedef vec<1, u64, lowp> lowp_u64vec1;
 typedef vec<2, u64, lowp> lowp_u64vec2;
 typedef vec<3, u64, lowp> lowp_u64vec3;
 typedef vec<4, u64, lowp> lowp_u64vec4;

 typedef vec<1, u64, mediump> mediump_u64vec1;
 typedef vec<2, u64, mediump> mediump_u64vec2;
 typedef vec<3, u64, mediump> mediump_u64vec3;
 typedef vec<4, u64, mediump> mediump_u64vec4;

 typedef vec<1, u64, highp> highp_u64vec1;
 typedef vec<2, u64, highp> highp_u64vec2;
 typedef vec<3, u64, highp> highp_u64vec3;
 typedef vec<4, u64, highp> highp_u64vec4;

 typedef vec<1, u64, defaultp> u64vec1;
 typedef vec<2, u64, defaultp> u64vec2;
 typedef vec<3, u64, defaultp> u64vec3;
 typedef vec<4, u64, defaultp> u64vec4;



 typedef vec<1, float, lowp> lowp_vec1;
 typedef vec<2, float, lowp> lowp_vec2;
 typedef vec<3, float, lowp> lowp_vec3;
 typedef vec<4, float, lowp> lowp_vec4;

 typedef vec<1, float, mediump> mediump_vec1;
 typedef vec<2, float, mediump> mediump_vec2;
 typedef vec<3, float, mediump> mediump_vec3;
 typedef vec<4, float, mediump> mediump_vec4;

 typedef vec<1, float, highp> highp_vec1;
 typedef vec<2, float, highp> highp_vec2;
 typedef vec<3, float, highp> highp_vec3;
 typedef vec<4, float, highp> highp_vec4;

 typedef vec<1, float, defaultp> vec1;
 typedef vec<2, float, defaultp> vec2;
 typedef vec<3, float, defaultp> vec3;
 typedef vec<4, float, defaultp> vec4;

 typedef vec<1, float, lowp> lowp_fvec1;
 typedef vec<2, float, lowp> lowp_fvec2;
 typedef vec<3, float, lowp> lowp_fvec3;
 typedef vec<4, float, lowp> lowp_fvec4;

 typedef vec<1, float, mediump> mediump_fvec1;
 typedef vec<2, float, mediump> mediump_fvec2;
 typedef vec<3, float, mediump> mediump_fvec3;
 typedef vec<4, float, mediump> mediump_fvec4;

 typedef vec<1, float, highp> highp_fvec1;
 typedef vec<2, float, highp> highp_fvec2;
 typedef vec<3, float, highp> highp_fvec3;
 typedef vec<4, float, highp> highp_fvec4;

 typedef vec<1, f32, defaultp> fvec1;
 typedef vec<2, f32, defaultp> fvec2;
 typedef vec<3, f32, defaultp> fvec3;
 typedef vec<4, f32, defaultp> fvec4;

 typedef vec<1, f32, lowp> lowp_f32vec1;
 typedef vec<2, f32, lowp> lowp_f32vec2;
 typedef vec<3, f32, lowp> lowp_f32vec3;
 typedef vec<4, f32, lowp> lowp_f32vec4;

 typedef vec<1, f32, mediump> mediump_f32vec1;
 typedef vec<2, f32, mediump> mediump_f32vec2;
 typedef vec<3, f32, mediump> mediump_f32vec3;
 typedef vec<4, f32, mediump> mediump_f32vec4;

 typedef vec<1, f32, highp> highp_f32vec1;
 typedef vec<2, f32, highp> highp_f32vec2;
 typedef vec<3, f32, highp> highp_f32vec3;
 typedef vec<4, f32, highp> highp_f32vec4;

 typedef vec<1, f32, defaultp> f32vec1;
 typedef vec<2, f32, defaultp> f32vec2;
 typedef vec<3, f32, defaultp> f32vec3;
 typedef vec<4, f32, defaultp> f32vec4;

 typedef vec<1, f64, lowp> lowp_dvec1;
 typedef vec<2, f64, lowp> lowp_dvec2;
 typedef vec<3, f64, lowp> lowp_dvec3;
 typedef vec<4, f64, lowp> lowp_dvec4;

 typedef vec<1, f64, mediump> mediump_dvec1;
 typedef vec<2, f64, mediump> mediump_dvec2;
 typedef vec<3, f64, mediump> mediump_dvec3;
 typedef vec<4, f64, mediump> mediump_dvec4;

 typedef vec<1, f64, highp> highp_dvec1;
 typedef vec<2, f64, highp> highp_dvec2;
 typedef vec<3, f64, highp> highp_dvec3;
 typedef vec<4, f64, highp> highp_dvec4;

 typedef vec<1, f64, defaultp> dvec1;
 typedef vec<2, f64, defaultp> dvec2;
 typedef vec<3, f64, defaultp> dvec3;
 typedef vec<4, f64, defaultp> dvec4;

 typedef vec<1, f64, lowp> lowp_f64vec1;
 typedef vec<2, f64, lowp> lowp_f64vec2;
 typedef vec<3, f64, lowp> lowp_f64vec3;
 typedef vec<4, f64, lowp> lowp_f64vec4;

 typedef vec<1, f64, mediump> mediump_f64vec1;
 typedef vec<2, f64, mediump> mediump_f64vec2;
 typedef vec<3, f64, mediump> mediump_f64vec3;
 typedef vec<4, f64, mediump> mediump_f64vec4;

 typedef vec<1, f64, highp> highp_f64vec1;
 typedef vec<2, f64, highp> highp_f64vec2;
 typedef vec<3, f64, highp> highp_f64vec3;
 typedef vec<4, f64, highp> highp_f64vec4;

 typedef vec<1, f64, defaultp> f64vec1;
 typedef vec<2, f64, defaultp> f64vec2;
 typedef vec<3, f64, defaultp> f64vec3;
 typedef vec<4, f64, defaultp> f64vec4;



 typedef mat<2, 2, f32, lowp> lowp_mat2;
 typedef mat<3, 3, f32, lowp> lowp_mat3;
 typedef mat<4, 4, f32, lowp> lowp_mat4;

 typedef mat<2, 2, f32, mediump> mediump_mat2;
 typedef mat<3, 3, f32, mediump> mediump_mat3;
 typedef mat<4, 4, f32, mediump> mediump_mat4;

 typedef mat<2, 2, f32, highp> highp_mat2;
 typedef mat<3, 3, f32, highp> highp_mat3;
 typedef mat<4, 4, f32, highp> highp_mat4;

 typedef mat<2, 2, f32, defaultp> mat2;
 typedef mat<3, 3, f32, defaultp> mat3;
 typedef mat<4, 4, f32, defaultp> mat4;

 typedef mat<2, 2, f32, lowp> lowp_fmat2;
 typedef mat<3, 3, f32, lowp> lowp_fmat3;
 typedef mat<4, 4, f32, lowp> lowp_fmat4;

 typedef mat<2, 2, f32, mediump> mediump_fmat2;
 typedef mat<3, 3, f32, mediump> mediump_fmat3;
 typedef mat<4, 4, f32, mediump> mediump_fmat4;

 typedef mat<2, 2, f32, highp> highp_fmat2;
 typedef mat<3, 3, f32, highp> highp_fmat3;
 typedef mat<4, 4, f32, highp> highp_fmat4;

 typedef mat<2, 2, f32, defaultp> fmat2;
 typedef mat<3, 3, f32, defaultp> fmat3;
 typedef mat<4, 4, f32, defaultp> fmat4;

 typedef mat<2, 2, f32, lowp> lowp_f32mat2;
 typedef mat<3, 3, f32, lowp> lowp_f32mat3;
 typedef mat<4, 4, f32, lowp> lowp_f32mat4;

 typedef mat<2, 2, f32, mediump> mediump_f32mat2;
 typedef mat<3, 3, f32, mediump> mediump_f32mat3;
 typedef mat<4, 4, f32, mediump> mediump_f32mat4;

 typedef mat<2, 2, f32, highp> highp_f32mat2;
 typedef mat<3, 3, f32, highp> highp_f32mat3;
 typedef mat<4, 4, f32, highp> highp_f32mat4;

 typedef mat<2, 2, f32, defaultp> f32mat2;
 typedef mat<3, 3, f32, defaultp> f32mat3;
 typedef mat<4, 4, f32, defaultp> f32mat4;

 typedef mat<2, 2, f64, lowp> lowp_dmat2;
 typedef mat<3, 3, f64, lowp> lowp_dmat3;
 typedef mat<4, 4, f64, lowp> lowp_dmat4;

 typedef mat<2, 2, f64, mediump> mediump_dmat2;
 typedef mat<3, 3, f64, mediump> mediump_dmat3;
 typedef mat<4, 4, f64, mediump> mediump_dmat4;

 typedef mat<2, 2, f64, highp> highp_dmat2;
 typedef mat<3, 3, f64, highp> highp_dmat3;
 typedef mat<4, 4, f64, highp> highp_dmat4;

 typedef mat<2, 2, f64, defaultp> dmat2;
 typedef mat<3, 3, f64, defaultp> dmat3;
 typedef mat<4, 4, f64, defaultp> dmat4;

 typedef mat<2, 2, f64, lowp> lowp_f64mat2;
 typedef mat<3, 3, f64, lowp> lowp_f64mat3;
 typedef mat<4, 4, f64, lowp> lowp_f64mat4;

 typedef mat<2, 2, f64, mediump> mediump_f64mat2;
 typedef mat<3, 3, f64, mediump> mediump_f64mat3;
 typedef mat<4, 4, f64, mediump> mediump_f64mat4;

 typedef mat<2, 2, f64, highp> highp_f64mat2;
 typedef mat<3, 3, f64, highp> highp_f64mat3;
 typedef mat<4, 4, f64, highp> highp_f64mat4;

 typedef mat<2, 2, f64, defaultp> f64mat2;
 typedef mat<3, 3, f64, defaultp> f64mat3;
 typedef mat<4, 4, f64, defaultp> f64mat4;



 typedef mat<2, 2, f32, lowp> lowp_mat2x2;
 typedef mat<2, 3, f32, lowp> lowp_mat2x3;
 typedef mat<2, 4, f32, lowp> lowp_mat2x4;
 typedef mat<3, 2, f32, lowp> lowp_mat3x2;
 typedef mat<3, 3, f32, lowp> lowp_mat3x3;
 typedef mat<3, 4, f32, lowp> lowp_mat3x4;
 typedef mat<4, 2, f32, lowp> lowp_mat4x2;
 typedef mat<4, 3, f32, lowp> lowp_mat4x3;
 typedef mat<4, 4, f32, lowp> lowp_mat4x4;

 typedef mat<2, 2, f32, mediump> mediump_mat2x2;
 typedef mat<2, 3, f32, mediump> mediump_mat2x3;
 typedef mat<2, 4, f32, mediump> mediump_mat2x4;
 typedef mat<3, 2, f32, mediump> mediump_mat3x2;
 typedef mat<3, 3, f32, mediump> mediump_mat3x3;
 typedef mat<3, 4, f32, mediump> mediump_mat3x4;
 typedef mat<4, 2, f32, mediump> mediump_mat4x2;
 typedef mat<4, 3, f32, mediump> mediump_mat4x3;
 typedef mat<4, 4, f32, mediump> mediump_mat4x4;

 typedef mat<2, 2, f32, highp> highp_mat2x2;
 typedef mat<2, 3, f32, highp> highp_mat2x3;
 typedef mat<2, 4, f32, highp> highp_mat2x4;
 typedef mat<3, 2, f32, highp> highp_mat3x2;
 typedef mat<3, 3, f32, highp> highp_mat3x3;
 typedef mat<3, 4, f32, highp> highp_mat3x4;
 typedef mat<4, 2, f32, highp> highp_mat4x2;
 typedef mat<4, 3, f32, highp> highp_mat4x3;
 typedef mat<4, 4, f32, highp> highp_mat4x4;

 typedef mat<2, 2, f32, defaultp> mat2x2;
 typedef mat<2, 3, f32, defaultp> mat2x3;
 typedef mat<2, 4, f32, defaultp> mat2x4;
 typedef mat<3, 2, f32, defaultp> mat3x2;
 typedef mat<3, 3, f32, defaultp> mat3x3;
 typedef mat<3, 4, f32, defaultp> mat3x4;
 typedef mat<4, 2, f32, defaultp> mat4x2;
 typedef mat<4, 3, f32, defaultp> mat4x3;
 typedef mat<4, 4, f32, defaultp> mat4x4;

 typedef mat<2, 2, f32, lowp> lowp_fmat2x2;
 typedef mat<2, 3, f32, lowp> lowp_fmat2x3;
 typedef mat<2, 4, f32, lowp> lowp_fmat2x4;
 typedef mat<3, 2, f32, lowp> lowp_fmat3x2;
 typedef mat<3, 3, f32, lowp> lowp_fmat3x3;
 typedef mat<3, 4, f32, lowp> lowp_fmat3x4;
 typedef mat<4, 2, f32, lowp> lowp_fmat4x2;
 typedef mat<4, 3, f32, lowp> lowp_fmat4x3;
 typedef mat<4, 4, f32, lowp> lowp_fmat4x4;

 typedef mat<2, 2, f32, mediump> mediump_fmat2x2;
 typedef mat<2, 3, f32, mediump> mediump_fmat2x3;
 typedef mat<2, 4, f32, mediump> mediump_fmat2x4;
 typedef mat<3, 2, f32, mediump> mediump_fmat3x2;
 typedef mat<3, 3, f32, mediump> mediump_fmat3x3;
 typedef mat<3, 4, f32, mediump> mediump_fmat3x4;
 typedef mat<4, 2, f32, mediump> mediump_fmat4x2;
 typedef mat<4, 3, f32, mediump> mediump_fmat4x3;
 typedef mat<4, 4, f32, mediump> mediump_fmat4x4;

 typedef mat<2, 2, f32, highp> highp_fmat2x2;
 typedef mat<2, 3, f32, highp> highp_fmat2x3;
 typedef mat<2, 4, f32, highp> highp_fmat2x4;
 typedef mat<3, 2, f32, highp> highp_fmat3x2;
 typedef mat<3, 3, f32, highp> highp_fmat3x3;
 typedef mat<3, 4, f32, highp> highp_fmat3x4;
 typedef mat<4, 2, f32, highp> highp_fmat4x2;
 typedef mat<4, 3, f32, highp> highp_fmat4x3;
 typedef mat<4, 4, f32, highp> highp_fmat4x4;

 typedef mat<2, 2, f32, defaultp> fmat2x2;
 typedef mat<2, 3, f32, defaultp> fmat2x3;
 typedef mat<2, 4, f32, defaultp> fmat2x4;
 typedef mat<3, 2, f32, defaultp> fmat3x2;
 typedef mat<3, 3, f32, defaultp> fmat3x3;
 typedef mat<3, 4, f32, defaultp> fmat3x4;
 typedef mat<4, 2, f32, defaultp> fmat4x2;
 typedef mat<4, 3, f32, defaultp> fmat4x3;
 typedef mat<4, 4, f32, defaultp> fmat4x4;

 typedef mat<2, 2, f32, lowp> lowp_f32mat2x2;
 typedef mat<2, 3, f32, lowp> lowp_f32mat2x3;
 typedef mat<2, 4, f32, lowp> lowp_f32mat2x4;
 typedef mat<3, 2, f32, lowp> lowp_f32mat3x2;
 typedef mat<3, 3, f32, lowp> lowp_f32mat3x3;
 typedef mat<3, 4, f32, lowp> lowp_f32mat3x4;
 typedef mat<4, 2, f32, lowp> lowp_f32mat4x2;
 typedef mat<4, 3, f32, lowp> lowp_f32mat4x3;
 typedef mat<4, 4, f32, lowp> lowp_f32mat4x4;

 typedef mat<2, 2, f32, mediump> mediump_f32mat2x2;
 typedef mat<2, 3, f32, mediump> mediump_f32mat2x3;
 typedef mat<2, 4, f32, mediump> mediump_f32mat2x4;
 typedef mat<3, 2, f32, mediump> mediump_f32mat3x2;
 typedef mat<3, 3, f32, mediump> mediump_f32mat3x3;
 typedef mat<3, 4, f32, mediump> mediump_f32mat3x4;
 typedef mat<4, 2, f32, mediump> mediump_f32mat4x2;
 typedef mat<4, 3, f32, mediump> mediump_f32mat4x3;
 typedef mat<4, 4, f32, mediump> mediump_f32mat4x4;

 typedef mat<2, 2, f32, highp> highp_f32mat2x2;
 typedef mat<2, 3, f32, highp> highp_f32mat2x3;
 typedef mat<2, 4, f32, highp> highp_f32mat2x4;
 typedef mat<3, 2, f32, highp> highp_f32mat3x2;
 typedef mat<3, 3, f32, highp> highp_f32mat3x3;
 typedef mat<3, 4, f32, highp> highp_f32mat3x4;
 typedef mat<4, 2, f32, highp> highp_f32mat4x2;
 typedef mat<4, 3, f32, highp> highp_f32mat4x3;
 typedef mat<4, 4, f32, highp> highp_f32mat4x4;

 typedef mat<2, 2, f32, defaultp> f32mat2x2;
 typedef mat<2, 3, f32, defaultp> f32mat2x3;
 typedef mat<2, 4, f32, defaultp> f32mat2x4;
 typedef mat<3, 2, f32, defaultp> f32mat3x2;
 typedef mat<3, 3, f32, defaultp> f32mat3x3;
 typedef mat<3, 4, f32, defaultp> f32mat3x4;
 typedef mat<4, 2, f32, defaultp> f32mat4x2;
 typedef mat<4, 3, f32, defaultp> f32mat4x3;
 typedef mat<4, 4, f32, defaultp> f32mat4x4;

 typedef mat<2, 2, double, lowp> lowp_dmat2x2;
 typedef mat<2, 3, double, lowp> lowp_dmat2x3;
 typedef mat<2, 4, double, lowp> lowp_dmat2x4;
 typedef mat<3, 2, double, lowp> lowp_dmat3x2;
 typedef mat<3, 3, double, lowp> lowp_dmat3x3;
 typedef mat<3, 4, double, lowp> lowp_dmat3x4;
 typedef mat<4, 2, double, lowp> lowp_dmat4x2;
 typedef mat<4, 3, double, lowp> lowp_dmat4x3;
 typedef mat<4, 4, double, lowp> lowp_dmat4x4;

 typedef mat<2, 2, double, mediump> mediump_dmat2x2;
 typedef mat<2, 3, double, mediump> mediump_dmat2x3;
 typedef mat<2, 4, double, mediump> mediump_dmat2x4;
 typedef mat<3, 2, double, mediump> mediump_dmat3x2;
 typedef mat<3, 3, double, mediump> mediump_dmat3x3;
 typedef mat<3, 4, double, mediump> mediump_dmat3x4;
 typedef mat<4, 2, double, mediump> mediump_dmat4x2;
 typedef mat<4, 3, double, mediump> mediump_dmat4x3;
 typedef mat<4, 4, double, mediump> mediump_dmat4x4;

 typedef mat<2, 2, double, highp> highp_dmat2x2;
 typedef mat<2, 3, double, highp> highp_dmat2x3;
 typedef mat<2, 4, double, highp> highp_dmat2x4;
 typedef mat<3, 2, double, highp> highp_dmat3x2;
 typedef mat<3, 3, double, highp> highp_dmat3x3;
 typedef mat<3, 4, double, highp> highp_dmat3x4;
 typedef mat<4, 2, double, highp> highp_dmat4x2;
 typedef mat<4, 3, double, highp> highp_dmat4x3;
 typedef mat<4, 4, double, highp> highp_dmat4x4;

 typedef mat<2, 2, double, defaultp> dmat2x2;
 typedef mat<2, 3, double, defaultp> dmat2x3;
 typedef mat<2, 4, double, defaultp> dmat2x4;
 typedef mat<3, 2, double, defaultp> dmat3x2;
 typedef mat<3, 3, double, defaultp> dmat3x3;
 typedef mat<3, 4, double, defaultp> dmat3x4;
 typedef mat<4, 2, double, defaultp> dmat4x2;
 typedef mat<4, 3, double, defaultp> dmat4x3;
 typedef mat<4, 4, double, defaultp> dmat4x4;

 typedef mat<2, 2, f64, lowp> lowp_f64mat2x2;
 typedef mat<2, 3, f64, lowp> lowp_f64mat2x3;
 typedef mat<2, 4, f64, lowp> lowp_f64mat2x4;
 typedef mat<3, 2, f64, lowp> lowp_f64mat3x2;
 typedef mat<3, 3, f64, lowp> lowp_f64mat3x3;
 typedef mat<3, 4, f64, lowp> lowp_f64mat3x4;
 typedef mat<4, 2, f64, lowp> lowp_f64mat4x2;
 typedef mat<4, 3, f64, lowp> lowp_f64mat4x3;
 typedef mat<4, 4, f64, lowp> lowp_f64mat4x4;

 typedef mat<2, 2, f64, mediump> mediump_f64mat2x2;
 typedef mat<2, 3, f64, mediump> mediump_f64mat2x3;
 typedef mat<2, 4, f64, mediump> mediump_f64mat2x4;
 typedef mat<3, 2, f64, mediump> mediump_f64mat3x2;
 typedef mat<3, 3, f64, mediump> mediump_f64mat3x3;
 typedef mat<3, 4, f64, mediump> mediump_f64mat3x4;
 typedef mat<4, 2, f64, mediump> mediump_f64mat4x2;
 typedef mat<4, 3, f64, mediump> mediump_f64mat4x3;
 typedef mat<4, 4, f64, mediump> mediump_f64mat4x4;

 typedef mat<2, 2, f64, highp> highp_f64mat2x2;
 typedef mat<2, 3, f64, highp> highp_f64mat2x3;
 typedef mat<2, 4, f64, highp> highp_f64mat2x4;
 typedef mat<3, 2, f64, highp> highp_f64mat3x2;
 typedef mat<3, 3, f64, highp> highp_f64mat3x3;
 typedef mat<3, 4, f64, highp> highp_f64mat3x4;
 typedef mat<4, 2, f64, highp> highp_f64mat4x2;
 typedef mat<4, 3, f64, highp> highp_f64mat4x3;
 typedef mat<4, 4, f64, highp> highp_f64mat4x4;

 typedef mat<2, 2, f64, defaultp> f64mat2x2;
 typedef mat<2, 3, f64, defaultp> f64mat2x3;
 typedef mat<2, 4, f64, defaultp> f64mat2x4;
 typedef mat<3, 2, f64, defaultp> f64mat3x2;
 typedef mat<3, 3, f64, defaultp> f64mat3x3;
 typedef mat<3, 4, f64, defaultp> f64mat3x4;
 typedef mat<4, 2, f64, defaultp> f64mat4x2;
 typedef mat<4, 3, f64, defaultp> f64mat4x3;
 typedef mat<4, 4, f64, defaultp> f64mat4x4;



 typedef mat<2, 2, int, lowp> lowp_imat2x2;
 typedef mat<2, 3, int, lowp> lowp_imat2x3;
 typedef mat<2, 4, int, lowp> lowp_imat2x4;
 typedef mat<3, 2, int, lowp> lowp_imat3x2;
 typedef mat<3, 3, int, lowp> lowp_imat3x3;
 typedef mat<3, 4, int, lowp> lowp_imat3x4;
 typedef mat<4, 2, int, lowp> lowp_imat4x2;
 typedef mat<4, 3, int, lowp> lowp_imat4x3;
 typedef mat<4, 4, int, lowp> lowp_imat4x4;

 typedef mat<2, 2, int, mediump> mediump_imat2x2;
 typedef mat<2, 3, int, mediump> mediump_imat2x3;
 typedef mat<2, 4, int, mediump> mediump_imat2x4;
 typedef mat<3, 2, int, mediump> mediump_imat3x2;
 typedef mat<3, 3, int, mediump> mediump_imat3x3;
 typedef mat<3, 4, int, mediump> mediump_imat3x4;
 typedef mat<4, 2, int, mediump> mediump_imat4x2;
 typedef mat<4, 3, int, mediump> mediump_imat4x3;
 typedef mat<4, 4, int, mediump> mediump_imat4x4;

 typedef mat<2, 2, int, highp> highp_imat2x2;
 typedef mat<2, 3, int, highp> highp_imat2x3;
 typedef mat<2, 4, int, highp> highp_imat2x4;
 typedef mat<3, 2, int, highp> highp_imat3x2;
 typedef mat<3, 3, int, highp> highp_imat3x3;
 typedef mat<3, 4, int, highp> highp_imat3x4;
 typedef mat<4, 2, int, highp> highp_imat4x2;
 typedef mat<4, 3, int, highp> highp_imat4x3;
 typedef mat<4, 4, int, highp> highp_imat4x4;

 typedef mat<2, 2, int, defaultp> imat2x2;
 typedef mat<2, 3, int, defaultp> imat2x3;
 typedef mat<2, 4, int, defaultp> imat2x4;
 typedef mat<3, 2, int, defaultp> imat3x2;
 typedef mat<3, 3, int, defaultp> imat3x3;
 typedef mat<3, 4, int, defaultp> imat3x4;
 typedef mat<4, 2, int, defaultp> imat4x2;
 typedef mat<4, 3, int, defaultp> imat4x3;
 typedef mat<4, 4, int, defaultp> imat4x4;


 typedef mat<2, 2, int8, lowp> lowp_i8mat2x2;
 typedef mat<2, 3, int8, lowp> lowp_i8mat2x3;
 typedef mat<2, 4, int8, lowp> lowp_i8mat2x4;
 typedef mat<3, 2, int8, lowp> lowp_i8mat3x2;
 typedef mat<3, 3, int8, lowp> lowp_i8mat3x3;
 typedef mat<3, 4, int8, lowp> lowp_i8mat3x4;
 typedef mat<4, 2, int8, lowp> lowp_i8mat4x2;
 typedef mat<4, 3, int8, lowp> lowp_i8mat4x3;
 typedef mat<4, 4, int8, lowp> lowp_i8mat4x4;

 typedef mat<2, 2, int8, mediump> mediump_i8mat2x2;
 typedef mat<2, 3, int8, mediump> mediump_i8mat2x3;
 typedef mat<2, 4, int8, mediump> mediump_i8mat2x4;
 typedef mat<3, 2, int8, mediump> mediump_i8mat3x2;
 typedef mat<3, 3, int8, mediump> mediump_i8mat3x3;
 typedef mat<3, 4, int8, mediump> mediump_i8mat3x4;
 typedef mat<4, 2, int8, mediump> mediump_i8mat4x2;
 typedef mat<4, 3, int8, mediump> mediump_i8mat4x3;
 typedef mat<4, 4, int8, mediump> mediump_i8mat4x4;

 typedef mat<2, 2, int8, highp> highp_i8mat2x2;
 typedef mat<2, 3, int8, highp> highp_i8mat2x3;
 typedef mat<2, 4, int8, highp> highp_i8mat2x4;
 typedef mat<3, 2, int8, highp> highp_i8mat3x2;
 typedef mat<3, 3, int8, highp> highp_i8mat3x3;
 typedef mat<3, 4, int8, highp> highp_i8mat3x4;
 typedef mat<4, 2, int8, highp> highp_i8mat4x2;
 typedef mat<4, 3, int8, highp> highp_i8mat4x3;
 typedef mat<4, 4, int8, highp> highp_i8mat4x4;

 typedef mat<2, 2, int8, defaultp> i8mat2x2;
 typedef mat<2, 3, int8, defaultp> i8mat2x3;
 typedef mat<2, 4, int8, defaultp> i8mat2x4;
 typedef mat<3, 2, int8, defaultp> i8mat3x2;
 typedef mat<3, 3, int8, defaultp> i8mat3x3;
 typedef mat<3, 4, int8, defaultp> i8mat3x4;
 typedef mat<4, 2, int8, defaultp> i8mat4x2;
 typedef mat<4, 3, int8, defaultp> i8mat4x3;
 typedef mat<4, 4, int8, defaultp> i8mat4x4;


 typedef mat<2, 2, int16, lowp> lowp_i16mat2x2;
 typedef mat<2, 3, int16, lowp> lowp_i16mat2x3;
 typedef mat<2, 4, int16, lowp> lowp_i16mat2x4;
 typedef mat<3, 2, int16, lowp> lowp_i16mat3x2;
 typedef mat<3, 3, int16, lowp> lowp_i16mat3x3;
 typedef mat<3, 4, int16, lowp> lowp_i16mat3x4;
 typedef mat<4, 2, int16, lowp> lowp_i16mat4x2;
 typedef mat<4, 3, int16, lowp> lowp_i16mat4x3;
 typedef mat<4, 4, int16, lowp> lowp_i16mat4x4;

 typedef mat<2, 2, int16, mediump> mediump_i16mat2x2;
 typedef mat<2, 3, int16, mediump> mediump_i16mat2x3;
 typedef mat<2, 4, int16, mediump> mediump_i16mat2x4;
 typedef mat<3, 2, int16, mediump> mediump_i16mat3x2;
 typedef mat<3, 3, int16, mediump> mediump_i16mat3x3;
 typedef mat<3, 4, int16, mediump> mediump_i16mat3x4;
 typedef mat<4, 2, int16, mediump> mediump_i16mat4x2;
 typedef mat<4, 3, int16, mediump> mediump_i16mat4x3;
 typedef mat<4, 4, int16, mediump> mediump_i16mat4x4;

 typedef mat<2, 2, int16, highp> highp_i16mat2x2;
 typedef mat<2, 3, int16, highp> highp_i16mat2x3;
 typedef mat<2, 4, int16, highp> highp_i16mat2x4;
 typedef mat<3, 2, int16, highp> highp_i16mat3x2;
 typedef mat<3, 3, int16, highp> highp_i16mat3x3;
 typedef mat<3, 4, int16, highp> highp_i16mat3x4;
 typedef mat<4, 2, int16, highp> highp_i16mat4x2;
 typedef mat<4, 3, int16, highp> highp_i16mat4x3;
 typedef mat<4, 4, int16, highp> highp_i16mat4x4;

 typedef mat<2, 2, int16, defaultp> i16mat2x2;
 typedef mat<2, 3, int16, defaultp> i16mat2x3;
 typedef mat<2, 4, int16, defaultp> i16mat2x4;
 typedef mat<3, 2, int16, defaultp> i16mat3x2;
 typedef mat<3, 3, int16, defaultp> i16mat3x3;
 typedef mat<3, 4, int16, defaultp> i16mat3x4;
 typedef mat<4, 2, int16, defaultp> i16mat4x2;
 typedef mat<4, 3, int16, defaultp> i16mat4x3;
 typedef mat<4, 4, int16, defaultp> i16mat4x4;


 typedef mat<2, 2, int32, lowp> lowp_i32mat2x2;
 typedef mat<2, 3, int32, lowp> lowp_i32mat2x3;
 typedef mat<2, 4, int32, lowp> lowp_i32mat2x4;
 typedef mat<3, 2, int32, lowp> lowp_i32mat3x2;
 typedef mat<3, 3, int32, lowp> lowp_i32mat3x3;
 typedef mat<3, 4, int32, lowp> lowp_i32mat3x4;
 typedef mat<4, 2, int32, lowp> lowp_i32mat4x2;
 typedef mat<4, 3, int32, lowp> lowp_i32mat4x3;
 typedef mat<4, 4, int32, lowp> lowp_i32mat4x4;

 typedef mat<2, 2, int32, mediump> mediump_i32mat2x2;
 typedef mat<2, 3, int32, mediump> mediump_i32mat2x3;
 typedef mat<2, 4, int32, mediump> mediump_i32mat2x4;
 typedef mat<3, 2, int32, mediump> mediump_i32mat3x2;
 typedef mat<3, 3, int32, mediump> mediump_i32mat3x3;
 typedef mat<3, 4, int32, mediump> mediump_i32mat3x4;
 typedef mat<4, 2, int32, mediump> mediump_i32mat4x2;
 typedef mat<4, 3, int32, mediump> mediump_i32mat4x3;
 typedef mat<4, 4, int32, mediump> mediump_i32mat4x4;

 typedef mat<2, 2, int32, highp> highp_i32mat2x2;
 typedef mat<2, 3, int32, highp> highp_i32mat2x3;
 typedef mat<2, 4, int32, highp> highp_i32mat2x4;
 typedef mat<3, 2, int32, highp> highp_i32mat3x2;
 typedef mat<3, 3, int32, highp> highp_i32mat3x3;
 typedef mat<3, 4, int32, highp> highp_i32mat3x4;
 typedef mat<4, 2, int32, highp> highp_i32mat4x2;
 typedef mat<4, 3, int32, highp> highp_i32mat4x3;
 typedef mat<4, 4, int32, highp> highp_i32mat4x4;

 typedef mat<2, 2, int32, defaultp> i32mat2x2;
 typedef mat<2, 3, int32, defaultp> i32mat2x3;
 typedef mat<2, 4, int32, defaultp> i32mat2x4;
 typedef mat<3, 2, int32, defaultp> i32mat3x2;
 typedef mat<3, 3, int32, defaultp> i32mat3x3;
 typedef mat<3, 4, int32, defaultp> i32mat3x4;
 typedef mat<4, 2, int32, defaultp> i32mat4x2;
 typedef mat<4, 3, int32, defaultp> i32mat4x3;
 typedef mat<4, 4, int32, defaultp> i32mat4x4;


 typedef mat<2, 2, int64, lowp> lowp_i64mat2x2;
 typedef mat<2, 3, int64, lowp> lowp_i64mat2x3;
 typedef mat<2, 4, int64, lowp> lowp_i64mat2x4;
 typedef mat<3, 2, int64, lowp> lowp_i64mat3x2;
 typedef mat<3, 3, int64, lowp> lowp_i64mat3x3;
 typedef mat<3, 4, int64, lowp> lowp_i64mat3x4;
 typedef mat<4, 2, int64, lowp> lowp_i64mat4x2;
 typedef mat<4, 3, int64, lowp> lowp_i64mat4x3;
 typedef mat<4, 4, int64, lowp> lowp_i64mat4x4;

 typedef mat<2, 2, int64, mediump> mediump_i64mat2x2;
 typedef mat<2, 3, int64, mediump> mediump_i64mat2x3;
 typedef mat<2, 4, int64, mediump> mediump_i64mat2x4;
 typedef mat<3, 2, int64, mediump> mediump_i64mat3x2;
 typedef mat<3, 3, int64, mediump> mediump_i64mat3x3;
 typedef mat<3, 4, int64, mediump> mediump_i64mat3x4;
 typedef mat<4, 2, int64, mediump> mediump_i64mat4x2;
 typedef mat<4, 3, int64, mediump> mediump_i64mat4x3;
 typedef mat<4, 4, int64, mediump> mediump_i64mat4x4;

 typedef mat<2, 2, int64, highp> highp_i64mat2x2;
 typedef mat<2, 3, int64, highp> highp_i64mat2x3;
 typedef mat<2, 4, int64, highp> highp_i64mat2x4;
 typedef mat<3, 2, int64, highp> highp_i64mat3x2;
 typedef mat<3, 3, int64, highp> highp_i64mat3x3;
 typedef mat<3, 4, int64, highp> highp_i64mat3x4;
 typedef mat<4, 2, int64, highp> highp_i64mat4x2;
 typedef mat<4, 3, int64, highp> highp_i64mat4x3;
 typedef mat<4, 4, int64, highp> highp_i64mat4x4;

 typedef mat<2, 2, int64, defaultp> i64mat2x2;
 typedef mat<2, 3, int64, defaultp> i64mat2x3;
 typedef mat<2, 4, int64, defaultp> i64mat2x4;
 typedef mat<3, 2, int64, defaultp> i64mat3x2;
 typedef mat<3, 3, int64, defaultp> i64mat3x3;
 typedef mat<3, 4, int64, defaultp> i64mat3x4;
 typedef mat<4, 2, int64, defaultp> i64mat4x2;
 typedef mat<4, 3, int64, defaultp> i64mat4x3;
 typedef mat<4, 4, int64, defaultp> i64mat4x4;




 typedef mat<2, 2, uint, lowp> lowp_umat2x2;
 typedef mat<2, 3, uint, lowp> lowp_umat2x3;
 typedef mat<2, 4, uint, lowp> lowp_umat2x4;
 typedef mat<3, 2, uint, lowp> lowp_umat3x2;
 typedef mat<3, 3, uint, lowp> lowp_umat3x3;
 typedef mat<3, 4, uint, lowp> lowp_umat3x4;
 typedef mat<4, 2, uint, lowp> lowp_umat4x2;
 typedef mat<4, 3, uint, lowp> lowp_umat4x3;
 typedef mat<4, 4, uint, lowp> lowp_umat4x4;

 typedef mat<2, 2, uint, mediump> mediump_umat2x2;
 typedef mat<2, 3, uint, mediump> mediump_umat2x3;
 typedef mat<2, 4, uint, mediump> mediump_umat2x4;
 typedef mat<3, 2, uint, mediump> mediump_umat3x2;
 typedef mat<3, 3, uint, mediump> mediump_umat3x3;
 typedef mat<3, 4, uint, mediump> mediump_umat3x4;
 typedef mat<4, 2, uint, mediump> mediump_umat4x2;
 typedef mat<4, 3, uint, mediump> mediump_umat4x3;
 typedef mat<4, 4, uint, mediump> mediump_umat4x4;

 typedef mat<2, 2, uint, highp> highp_umat2x2;
 typedef mat<2, 3, uint, highp> highp_umat2x3;
 typedef mat<2, 4, uint, highp> highp_umat2x4;
 typedef mat<3, 2, uint, highp> highp_umat3x2;
 typedef mat<3, 3, uint, highp> highp_umat3x3;
 typedef mat<3, 4, uint, highp> highp_umat3x4;
 typedef mat<4, 2, uint, highp> highp_umat4x2;
 typedef mat<4, 3, uint, highp> highp_umat4x3;
 typedef mat<4, 4, uint, highp> highp_umat4x4;

 typedef mat<2, 2, uint, defaultp> umat2x2;
 typedef mat<2, 3, uint, defaultp> umat2x3;
 typedef mat<2, 4, uint, defaultp> umat2x4;
 typedef mat<3, 2, uint, defaultp> umat3x2;
 typedef mat<3, 3, uint, defaultp> umat3x3;
 typedef mat<3, 4, uint, defaultp> umat3x4;
 typedef mat<4, 2, uint, defaultp> umat4x2;
 typedef mat<4, 3, uint, defaultp> umat4x3;
 typedef mat<4, 4, uint, defaultp> umat4x4;


 typedef mat<2, 2, uint8, lowp> lowp_u8mat2x2;
 typedef mat<2, 3, uint8, lowp> lowp_u8mat2x3;
 typedef mat<2, 4, uint8, lowp> lowp_u8mat2x4;
 typedef mat<3, 2, uint8, lowp> lowp_u8mat3x2;
 typedef mat<3, 3, uint8, lowp> lowp_u8mat3x3;
 typedef mat<3, 4, uint8, lowp> lowp_u8mat3x4;
 typedef mat<4, 2, uint8, lowp> lowp_u8mat4x2;
 typedef mat<4, 3, uint8, lowp> lowp_u8mat4x3;
 typedef mat<4, 4, uint8, lowp> lowp_u8mat4x4;

 typedef mat<2, 2, uint8, mediump> mediump_u8mat2x2;
 typedef mat<2, 3, uint8, mediump> mediump_u8mat2x3;
 typedef mat<2, 4, uint8, mediump> mediump_u8mat2x4;
 typedef mat<3, 2, uint8, mediump> mediump_u8mat3x2;
 typedef mat<3, 3, uint8, mediump> mediump_u8mat3x3;
 typedef mat<3, 4, uint8, mediump> mediump_u8mat3x4;
 typedef mat<4, 2, uint8, mediump> mediump_u8mat4x2;
 typedef mat<4, 3, uint8, mediump> mediump_u8mat4x3;
 typedef mat<4, 4, uint8, mediump> mediump_u8mat4x4;

 typedef mat<2, 2, uint8, highp> highp_u8mat2x2;
 typedef mat<2, 3, uint8, highp> highp_u8mat2x3;
 typedef mat<2, 4, uint8, highp> highp_u8mat2x4;
 typedef mat<3, 2, uint8, highp> highp_u8mat3x2;
 typedef mat<3, 3, uint8, highp> highp_u8mat3x3;
 typedef mat<3, 4, uint8, highp> highp_u8mat3x4;
 typedef mat<4, 2, uint8, highp> highp_u8mat4x2;
 typedef mat<4, 3, uint8, highp> highp_u8mat4x3;
 typedef mat<4, 4, uint8, highp> highp_u8mat4x4;

 typedef mat<2, 2, uint8, defaultp> u8mat2x2;
 typedef mat<2, 3, uint8, defaultp> u8mat2x3;
 typedef mat<2, 4, uint8, defaultp> u8mat2x4;
 typedef mat<3, 2, uint8, defaultp> u8mat3x2;
 typedef mat<3, 3, uint8, defaultp> u8mat3x3;
 typedef mat<3, 4, uint8, defaultp> u8mat3x4;
 typedef mat<4, 2, uint8, defaultp> u8mat4x2;
 typedef mat<4, 3, uint8, defaultp> u8mat4x3;
 typedef mat<4, 4, uint8, defaultp> u8mat4x4;


 typedef mat<2, 2, uint16, lowp> lowp_u16mat2x2;
 typedef mat<2, 3, uint16, lowp> lowp_u16mat2x3;
 typedef mat<2, 4, uint16, lowp> lowp_u16mat2x4;
 typedef mat<3, 2, uint16, lowp> lowp_u16mat3x2;
 typedef mat<3, 3, uint16, lowp> lowp_u16mat3x3;
 typedef mat<3, 4, uint16, lowp> lowp_u16mat3x4;
 typedef mat<4, 2, uint16, lowp> lowp_u16mat4x2;
 typedef mat<4, 3, uint16, lowp> lowp_u16mat4x3;
 typedef mat<4, 4, uint16, lowp> lowp_u16mat4x4;

 typedef mat<2, 2, uint16, mediump> mediump_u16mat2x2;
 typedef mat<2, 3, uint16, mediump> mediump_u16mat2x3;
 typedef mat<2, 4, uint16, mediump> mediump_u16mat2x4;
 typedef mat<3, 2, uint16, mediump> mediump_u16mat3x2;
 typedef mat<3, 3, uint16, mediump> mediump_u16mat3x3;
 typedef mat<3, 4, uint16, mediump> mediump_u16mat3x4;
 typedef mat<4, 2, uint16, mediump> mediump_u16mat4x2;
 typedef mat<4, 3, uint16, mediump> mediump_u16mat4x3;
 typedef mat<4, 4, uint16, mediump> mediump_u16mat4x4;

 typedef mat<2, 2, uint16, highp> highp_u16mat2x2;
 typedef mat<2, 3, uint16, highp> highp_u16mat2x3;
 typedef mat<2, 4, uint16, highp> highp_u16mat2x4;
 typedef mat<3, 2, uint16, highp> highp_u16mat3x2;
 typedef mat<3, 3, uint16, highp> highp_u16mat3x3;
 typedef mat<3, 4, uint16, highp> highp_u16mat3x4;
 typedef mat<4, 2, uint16, highp> highp_u16mat4x2;
 typedef mat<4, 3, uint16, highp> highp_u16mat4x3;
 typedef mat<4, 4, uint16, highp> highp_u16mat4x4;

 typedef mat<2, 2, uint16, defaultp> u16mat2x2;
 typedef mat<2, 3, uint16, defaultp> u16mat2x3;
 typedef mat<2, 4, uint16, defaultp> u16mat2x4;
 typedef mat<3, 2, uint16, defaultp> u16mat3x2;
 typedef mat<3, 3, uint16, defaultp> u16mat3x3;
 typedef mat<3, 4, uint16, defaultp> u16mat3x4;
 typedef mat<4, 2, uint16, defaultp> u16mat4x2;
 typedef mat<4, 3, uint16, defaultp> u16mat4x3;
 typedef mat<4, 4, uint16, defaultp> u16mat4x4;


 typedef mat<2, 2, uint32, lowp> lowp_u32mat2x2;
 typedef mat<2, 3, uint32, lowp> lowp_u32mat2x3;
 typedef mat<2, 4, uint32, lowp> lowp_u32mat2x4;
 typedef mat<3, 2, uint32, lowp> lowp_u32mat3x2;
 typedef mat<3, 3, uint32, lowp> lowp_u32mat3x3;
 typedef mat<3, 4, uint32, lowp> lowp_u32mat3x4;
 typedef mat<4, 2, uint32, lowp> lowp_u32mat4x2;
 typedef mat<4, 3, uint32, lowp> lowp_u32mat4x3;
 typedef mat<4, 4, uint32, lowp> lowp_u32mat4x4;

 typedef mat<2, 2, uint32, mediump> mediump_u32mat2x2;
 typedef mat<2, 3, uint32, mediump> mediump_u32mat2x3;
 typedef mat<2, 4, uint32, mediump> mediump_u32mat2x4;
 typedef mat<3, 2, uint32, mediump> mediump_u32mat3x2;
 typedef mat<3, 3, uint32, mediump> mediump_u32mat3x3;
 typedef mat<3, 4, uint32, mediump> mediump_u32mat3x4;
 typedef mat<4, 2, uint32, mediump> mediump_u32mat4x2;
 typedef mat<4, 3, uint32, mediump> mediump_u32mat4x3;
 typedef mat<4, 4, uint32, mediump> mediump_u32mat4x4;

 typedef mat<2, 2, uint32, highp> highp_u32mat2x2;
 typedef mat<2, 3, uint32, highp> highp_u32mat2x3;
 typedef mat<2, 4, uint32, highp> highp_u32mat2x4;
 typedef mat<3, 2, uint32, highp> highp_u32mat3x2;
 typedef mat<3, 3, uint32, highp> highp_u32mat3x3;
 typedef mat<3, 4, uint32, highp> highp_u32mat3x4;
 typedef mat<4, 2, uint32, highp> highp_u32mat4x2;
 typedef mat<4, 3, uint32, highp> highp_u32mat4x3;
 typedef mat<4, 4, uint32, highp> highp_u32mat4x4;

 typedef mat<2, 2, uint32, defaultp> u32mat2x2;
 typedef mat<2, 3, uint32, defaultp> u32mat2x3;
 typedef mat<2, 4, uint32, defaultp> u32mat2x4;
 typedef mat<3, 2, uint32, defaultp> u32mat3x2;
 typedef mat<3, 3, uint32, defaultp> u32mat3x3;
 typedef mat<3, 4, uint32, defaultp> u32mat3x4;
 typedef mat<4, 2, uint32, defaultp> u32mat4x2;
 typedef mat<4, 3, uint32, defaultp> u32mat4x3;
 typedef mat<4, 4, uint32, defaultp> u32mat4x4;


 typedef mat<2, 2, uint64, lowp> lowp_u64mat2x2;
 typedef mat<2, 3, uint64, lowp> lowp_u64mat2x3;
 typedef mat<2, 4, uint64, lowp> lowp_u64mat2x4;
 typedef mat<3, 2, uint64, lowp> lowp_u64mat3x2;
 typedef mat<3, 3, uint64, lowp> lowp_u64mat3x3;
 typedef mat<3, 4, uint64, lowp> lowp_u64mat3x4;
 typedef mat<4, 2, uint64, lowp> lowp_u64mat4x2;
 typedef mat<4, 3, uint64, lowp> lowp_u64mat4x3;
 typedef mat<4, 4, uint64, lowp> lowp_u64mat4x4;

 typedef mat<2, 2, uint64, mediump> mediump_u64mat2x2;
 typedef mat<2, 3, uint64, mediump> mediump_u64mat2x3;
 typedef mat<2, 4, uint64, mediump> mediump_u64mat2x4;
 typedef mat<3, 2, uint64, mediump> mediump_u64mat3x2;
 typedef mat<3, 3, uint64, mediump> mediump_u64mat3x3;
 typedef mat<3, 4, uint64, mediump> mediump_u64mat3x4;
 typedef mat<4, 2, uint64, mediump> mediump_u64mat4x2;
 typedef mat<4, 3, uint64, mediump> mediump_u64mat4x3;
 typedef mat<4, 4, uint64, mediump> mediump_u64mat4x4;

 typedef mat<2, 2, uint64, highp> highp_u64mat2x2;
 typedef mat<2, 3, uint64, highp> highp_u64mat2x3;
 typedef mat<2, 4, uint64, highp> highp_u64mat2x4;
 typedef mat<3, 2, uint64, highp> highp_u64mat3x2;
 typedef mat<3, 3, uint64, highp> highp_u64mat3x3;
 typedef mat<3, 4, uint64, highp> highp_u64mat3x4;
 typedef mat<4, 2, uint64, highp> highp_u64mat4x2;
 typedef mat<4, 3, uint64, highp> highp_u64mat4x3;
 typedef mat<4, 4, uint64, highp> highp_u64mat4x4;

 typedef mat<2, 2, uint64, defaultp> u64mat2x2;
 typedef mat<2, 3, uint64, defaultp> u64mat2x3;
 typedef mat<2, 4, uint64, defaultp> u64mat2x4;
 typedef mat<3, 2, uint64, defaultp> u64mat3x2;
 typedef mat<3, 3, uint64, defaultp> u64mat3x3;
 typedef mat<3, 4, uint64, defaultp> u64mat3x4;
 typedef mat<4, 2, uint64, defaultp> u64mat4x2;
 typedef mat<4, 3, uint64, defaultp> u64mat4x3;
 typedef mat<4, 4, uint64, defaultp> u64mat4x4;



 typedef qua<float, lowp> lowp_quat;
 typedef qua<float, mediump> mediump_quat;
 typedef qua<float, highp> highp_quat;
 typedef qua<float, defaultp> quat;

 typedef qua<float, lowp> lowp_fquat;
 typedef qua<float, mediump> mediump_fquat;
 typedef qua<float, highp> highp_fquat;
 typedef qua<float, defaultp> fquat;

 typedef qua<f32, lowp> lowp_f32quat;
 typedef qua<f32, mediump> mediump_f32quat;
 typedef qua<f32, highp> highp_f32quat;
 typedef qua<f32, defaultp> f32quat;

 typedef qua<double, lowp> lowp_dquat;
 typedef qua<double, mediump> mediump_dquat;
 typedef qua<double, highp> highp_dquat;
 typedef qua<double, defaultp> dquat;

 typedef qua<f64, lowp> lowp_f64quat;
 typedef qua<f64, mediump> mediump_f64quat;
 typedef qua<f64, highp> highp_f64quat;
 typedef qua<f64, defaultp> f64quat;
}
# 5 "/home/tayler/projects/marmalade/src/graphics/shader.cpp" 2
# 1 "/home/tayler/projects/marmalade/src/graphics/../../include/graphics/shader.h" 1





# 1 "/usr/include/glm/glm.hpp" 1 3 4
# 104 "/usr/include/glm/glm.hpp" 3 4
# 1 "/usr/include/glm/detail/_fixes.hpp" 1 3 4
# 1 "/usr/include/c++/14.2.1/cmath" 1 3 4
# 39 "/usr/include/c++/14.2.1/cmath" 3 4
       
# 40 "/usr/include/c++/14.2.1/cmath" 3







# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4






extern "C" {





# 1 "/usr/include/bits/math-vector.h" 1 3 4
# 25 "/usr/include/bits/math-vector.h" 3 4
# 1 "/usr/include/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 152 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/flt-eval-method.h" 1 3 4
# 153 "/usr/include/math.h" 2 3 4
# 163 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 204 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/fp-logb.h" 1 3 4
# 205 "/usr/include/math.h" 2 3 4
# 247 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/fp-fast.h" 1 3 4
# 248 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 312 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbit (double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinf (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnan (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) noexcept (true);


extern int __issignaling (double __value) noexcept (true)
     __attribute__ ((__const__));
# 313 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern double acos (double __x) noexcept (true); extern double __acos (double __x) noexcept (true);

 extern double asin (double __x) noexcept (true); extern double __asin (double __x) noexcept (true);

 extern double atan (double __x) noexcept (true); extern double __atan (double __x) noexcept (true);

 extern double atan2 (double __y, double __x) noexcept (true); extern double __atan2 (double __y, double __x) noexcept (true);


 extern double cos (double __x) noexcept (true); extern double __cos (double __x) noexcept (true);

 extern double sin (double __x) noexcept (true); extern double __sin (double __x) noexcept (true);

 extern double tan (double __x) noexcept (true); extern double __tan (double __x) noexcept (true);




 extern double cosh (double __x) noexcept (true); extern double __cosh (double __x) noexcept (true);

 extern double sinh (double __x) noexcept (true); extern double __sinh (double __x) noexcept (true);

 extern double tanh (double __x) noexcept (true); extern double __tanh (double __x) noexcept (true);



 extern void sincos (double __x, double *__sinx, double *__cosx) noexcept (true); extern void __sincos (double __x, double *__sinx, double *__cosx) noexcept (true)
                                                        ;




 extern double acosh (double __x) noexcept (true); extern double __acosh (double __x) noexcept (true);

 extern double asinh (double __x) noexcept (true); extern double __asinh (double __x) noexcept (true);

 extern double atanh (double __x) noexcept (true); extern double __atanh (double __x) noexcept (true);





 extern double exp (double __x) noexcept (true); extern double __exp (double __x) noexcept (true);


extern double frexp (double __x, int *__exponent) noexcept (true); extern double __frexp (double __x, int *__exponent) noexcept (true);


extern double ldexp (double __x, int __exponent) noexcept (true); extern double __ldexp (double __x, int __exponent) noexcept (true);


 extern double log (double __x) noexcept (true); extern double __log (double __x) noexcept (true);


 extern double log10 (double __x) noexcept (true); extern double __log10 (double __x) noexcept (true);


extern double modf (double __x, double *__iptr) noexcept (true); extern double __modf (double __x, double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern double exp10 (double __x) noexcept (true); extern double __exp10 (double __x) noexcept (true);


extern double exp2m1 (double __x) noexcept (true); extern double __exp2m1 (double __x) noexcept (true);


extern double exp10m1 (double __x) noexcept (true); extern double __exp10m1 (double __x) noexcept (true);


extern double log2p1 (double __x) noexcept (true); extern double __log2p1 (double __x) noexcept (true);


extern double log10p1 (double __x) noexcept (true); extern double __log10p1 (double __x) noexcept (true);


extern double logp1 (double __x) noexcept (true); extern double __logp1 (double __x) noexcept (true);




 extern double expm1 (double __x) noexcept (true); extern double __expm1 (double __x) noexcept (true);


 extern double log1p (double __x) noexcept (true); extern double __log1p (double __x) noexcept (true);


extern double logb (double __x) noexcept (true); extern double __logb (double __x) noexcept (true);




 extern double exp2 (double __x) noexcept (true); extern double __exp2 (double __x) noexcept (true);


 extern double log2 (double __x) noexcept (true); extern double __log2 (double __x) noexcept (true);






 extern double pow (double __x, double __y) noexcept (true); extern double __pow (double __x, double __y) noexcept (true);


extern double sqrt (double __x) noexcept (true); extern double __sqrt (double __x) noexcept (true);



 extern double hypot (double __x, double __y) noexcept (true); extern double __hypot (double __x, double __y) noexcept (true);




 extern double cbrt (double __x) noexcept (true); extern double __cbrt (double __x) noexcept (true);






extern double ceil (double __x) noexcept (true) __attribute__ ((__const__)); extern double __ceil (double __x) noexcept (true) __attribute__ ((__const__));


extern double fabs (double __x) noexcept (true) __attribute__ ((__const__)); extern double __fabs (double __x) noexcept (true) __attribute__ ((__const__));


extern double floor (double __x) noexcept (true) __attribute__ ((__const__)); extern double __floor (double __x) noexcept (true) __attribute__ ((__const__));


extern double fmod (double __x, double __y) noexcept (true); extern double __fmod (double __x, double __y) noexcept (true);
# 198 "/usr/include/bits/mathcalls.h" 3 4
extern int finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern double drem (double __x, double __y) noexcept (true); extern double __drem (double __x, double __y) noexcept (true);



extern double significand (double __x) noexcept (true); extern double __significand (double __x) noexcept (true);






extern double copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double nan (const char *__tagb) noexcept (true); extern double __nan (const char *__tagb) noexcept (true);
# 235 "/usr/include/bits/mathcalls.h" 3 4
extern double j0 (double) noexcept (true); extern double __j0 (double) noexcept (true);
extern double j1 (double) noexcept (true); extern double __j1 (double) noexcept (true);
extern double jn (int, double) noexcept (true); extern double __jn (int, double) noexcept (true);
extern double y0 (double) noexcept (true); extern double __y0 (double) noexcept (true);
extern double y1 (double) noexcept (true); extern double __y1 (double) noexcept (true);
extern double yn (int, double) noexcept (true); extern double __yn (int, double) noexcept (true);





 extern double erf (double) noexcept (true); extern double __erf (double) noexcept (true);
 extern double erfc (double) noexcept (true); extern double __erfc (double) noexcept (true);
extern double lgamma (double) noexcept (true); extern double __lgamma (double) noexcept (true);




extern double tgamma (double) noexcept (true); extern double __tgamma (double) noexcept (true);





extern double gamma (double) noexcept (true); extern double __gamma (double) noexcept (true);







extern double lgamma_r (double, int *__signgamp) noexcept (true); extern double __lgamma_r (double, int *__signgamp) noexcept (true);






extern double rint (double __x) noexcept (true); extern double __rint (double __x) noexcept (true);


extern double nextafter (double __x, double __y) noexcept (true); extern double __nextafter (double __x, double __y) noexcept (true);

extern double nexttoward (double __x, long double __y) noexcept (true); extern double __nexttoward (double __x, long double __y) noexcept (true);




extern double nextdown (double __x) noexcept (true); extern double __nextdown (double __x) noexcept (true);

extern double nextup (double __x) noexcept (true); extern double __nextup (double __x) noexcept (true);



extern double remainder (double __x, double __y) noexcept (true); extern double __remainder (double __x, double __y) noexcept (true);



extern double scalbn (double __x, int __n) noexcept (true); extern double __scalbn (double __x, int __n) noexcept (true);



extern int ilogb (double __x) noexcept (true); extern int __ilogb (double __x) noexcept (true);




extern long int llogb (double __x) noexcept (true); extern long int __llogb (double __x) noexcept (true);




extern double scalbln (double __x, long int __n) noexcept (true); extern double __scalbln (double __x, long int __n) noexcept (true);



extern double nearbyint (double __x) noexcept (true); extern double __nearbyint (double __x) noexcept (true);



extern double round (double __x) noexcept (true) __attribute__ ((__const__)); extern double __round (double __x) noexcept (true) __attribute__ ((__const__));



extern double trunc (double __x) noexcept (true) __attribute__ ((__const__)); extern double __trunc (double __x) noexcept (true) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) noexcept (true); extern double __remquo (double __x, double __y, int *__quo) noexcept (true);






extern long int lrint (double __x) noexcept (true); extern long int __lrint (double __x) noexcept (true);
__extension__
extern long long int llrint (double __x) noexcept (true); extern long long int __llrint (double __x) noexcept (true);



extern long int lround (double __x) noexcept (true); extern long int __lround (double __x) noexcept (true);
__extension__
extern long long int llround (double __x) noexcept (true); extern long long int __llround (double __x) noexcept (true);



extern double fdim (double __x, double __y) noexcept (true); extern double __fdim (double __x, double __y) noexcept (true);



extern double fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) noexcept (true); extern double __fma (double __x, double __y, double __z) noexcept (true);




extern double roundeven (double __x) noexcept (true) __attribute__ ((__const__)); extern double __roundeven (double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalize (double *__cx, const double *__x) noexcept (true);






extern double fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double fmaximum (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorder (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermag (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern double getpayload (const double *__x) noexcept (true); extern double __getpayload (const double *__x) noexcept (true);


extern int setpayload (double *__x, double __payload) noexcept (true);


extern int setpayloadsig (double *__x, double __payload) noexcept (true);







extern double scalb (double __x, double __n) noexcept (true); extern double __scalb (double __x, double __n) noexcept (true);
# 314 "/usr/include/math.h" 2 3 4
# 329 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitf (float __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinff (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) noexcept (true);


extern int __issignalingf (float __value) noexcept (true)
     __attribute__ ((__const__));
# 330 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern float acosf (float __x) noexcept (true); extern float __acosf (float __x) noexcept (true);

 extern float asinf (float __x) noexcept (true); extern float __asinf (float __x) noexcept (true);

 extern float atanf (float __x) noexcept (true); extern float __atanf (float __x) noexcept (true);

 extern float atan2f (float __y, float __x) noexcept (true); extern float __atan2f (float __y, float __x) noexcept (true);


 extern float cosf (float __x) noexcept (true); extern float __cosf (float __x) noexcept (true);

 extern float sinf (float __x) noexcept (true); extern float __sinf (float __x) noexcept (true);

 extern float tanf (float __x) noexcept (true); extern float __tanf (float __x) noexcept (true);




 extern float coshf (float __x) noexcept (true); extern float __coshf (float __x) noexcept (true);

 extern float sinhf (float __x) noexcept (true); extern float __sinhf (float __x) noexcept (true);

 extern float tanhf (float __x) noexcept (true); extern float __tanhf (float __x) noexcept (true);



 extern void sincosf (float __x, float *__sinx, float *__cosx) noexcept (true); extern void __sincosf (float __x, float *__sinx, float *__cosx) noexcept (true)
                                                        ;




 extern float acoshf (float __x) noexcept (true); extern float __acoshf (float __x) noexcept (true);

 extern float asinhf (float __x) noexcept (true); extern float __asinhf (float __x) noexcept (true);

 extern float atanhf (float __x) noexcept (true); extern float __atanhf (float __x) noexcept (true);





 extern float expf (float __x) noexcept (true); extern float __expf (float __x) noexcept (true);


extern float frexpf (float __x, int *__exponent) noexcept (true); extern float __frexpf (float __x, int *__exponent) noexcept (true);


extern float ldexpf (float __x, int __exponent) noexcept (true); extern float __ldexpf (float __x, int __exponent) noexcept (true);


 extern float logf (float __x) noexcept (true); extern float __logf (float __x) noexcept (true);


 extern float log10f (float __x) noexcept (true); extern float __log10f (float __x) noexcept (true);


extern float modff (float __x, float *__iptr) noexcept (true); extern float __modff (float __x, float *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern float exp10f (float __x) noexcept (true); extern float __exp10f (float __x) noexcept (true);


extern float exp2m1f (float __x) noexcept (true); extern float __exp2m1f (float __x) noexcept (true);


extern float exp10m1f (float __x) noexcept (true); extern float __exp10m1f (float __x) noexcept (true);


extern float log2p1f (float __x) noexcept (true); extern float __log2p1f (float __x) noexcept (true);


extern float log10p1f (float __x) noexcept (true); extern float __log10p1f (float __x) noexcept (true);


extern float logp1f (float __x) noexcept (true); extern float __logp1f (float __x) noexcept (true);




 extern float expm1f (float __x) noexcept (true); extern float __expm1f (float __x) noexcept (true);


 extern float log1pf (float __x) noexcept (true); extern float __log1pf (float __x) noexcept (true);


extern float logbf (float __x) noexcept (true); extern float __logbf (float __x) noexcept (true);




 extern float exp2f (float __x) noexcept (true); extern float __exp2f (float __x) noexcept (true);


 extern float log2f (float __x) noexcept (true); extern float __log2f (float __x) noexcept (true);






 extern float powf (float __x, float __y) noexcept (true); extern float __powf (float __x, float __y) noexcept (true);


extern float sqrtf (float __x) noexcept (true); extern float __sqrtf (float __x) noexcept (true);



 extern float hypotf (float __x, float __y) noexcept (true); extern float __hypotf (float __x, float __y) noexcept (true);




 extern float cbrtf (float __x) noexcept (true); extern float __cbrtf (float __x) noexcept (true);






extern float ceilf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __ceilf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fabsf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __fabsf (float __x) noexcept (true) __attribute__ ((__const__));


extern float floorf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __floorf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) noexcept (true); extern float __fmodf (float __x, float __y) noexcept (true);
# 192 "/usr/include/bits/mathcalls.h" 3 4
extern int isinff (float __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern float dremf (float __x, float __y) noexcept (true); extern float __dremf (float __x, float __y) noexcept (true);



extern float significandf (float __x) noexcept (true); extern float __significandf (float __x) noexcept (true);






extern float copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float nanf (const char *__tagb) noexcept (true); extern float __nanf (const char *__tagb) noexcept (true);
# 228 "/usr/include/bits/mathcalls.h" 3 4
extern int isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));





extern float j0f (float) noexcept (true); extern float __j0f (float) noexcept (true);
extern float j1f (float) noexcept (true); extern float __j1f (float) noexcept (true);
extern float jnf (int, float) noexcept (true); extern float __jnf (int, float) noexcept (true);
extern float y0f (float) noexcept (true); extern float __y0f (float) noexcept (true);
extern float y1f (float) noexcept (true); extern float __y1f (float) noexcept (true);
extern float ynf (int, float) noexcept (true); extern float __ynf (int, float) noexcept (true);





 extern float erff (float) noexcept (true); extern float __erff (float) noexcept (true);
 extern float erfcf (float) noexcept (true); extern float __erfcf (float) noexcept (true);
extern float lgammaf (float) noexcept (true); extern float __lgammaf (float) noexcept (true);




extern float tgammaf (float) noexcept (true); extern float __tgammaf (float) noexcept (true);





extern float gammaf (float) noexcept (true); extern float __gammaf (float) noexcept (true);







extern float lgammaf_r (float, int *__signgamp) noexcept (true); extern float __lgammaf_r (float, int *__signgamp) noexcept (true);






extern float rintf (float __x) noexcept (true); extern float __rintf (float __x) noexcept (true);


extern float nextafterf (float __x, float __y) noexcept (true); extern float __nextafterf (float __x, float __y) noexcept (true);

extern float nexttowardf (float __x, long double __y) noexcept (true); extern float __nexttowardf (float __x, long double __y) noexcept (true);




extern float nextdownf (float __x) noexcept (true); extern float __nextdownf (float __x) noexcept (true);

extern float nextupf (float __x) noexcept (true); extern float __nextupf (float __x) noexcept (true);



extern float remainderf (float __x, float __y) noexcept (true); extern float __remainderf (float __x, float __y) noexcept (true);



extern float scalbnf (float __x, int __n) noexcept (true); extern float __scalbnf (float __x, int __n) noexcept (true);



extern int ilogbf (float __x) noexcept (true); extern int __ilogbf (float __x) noexcept (true);




extern long int llogbf (float __x) noexcept (true); extern long int __llogbf (float __x) noexcept (true);




extern float scalblnf (float __x, long int __n) noexcept (true); extern float __scalblnf (float __x, long int __n) noexcept (true);



extern float nearbyintf (float __x) noexcept (true); extern float __nearbyintf (float __x) noexcept (true);



extern float roundf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundf (float __x) noexcept (true) __attribute__ ((__const__));



extern float truncf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __truncf (float __x) noexcept (true) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) noexcept (true); extern float __remquof (float __x, float __y, int *__quo) noexcept (true);






extern long int lrintf (float __x) noexcept (true); extern long int __lrintf (float __x) noexcept (true);
__extension__
extern long long int llrintf (float __x) noexcept (true); extern long long int __llrintf (float __x) noexcept (true);



extern long int lroundf (float __x) noexcept (true); extern long int __lroundf (float __x) noexcept (true);
__extension__
extern long long int llroundf (float __x) noexcept (true); extern long long int __llroundf (float __x) noexcept (true);



extern float fdimf (float __x, float __y) noexcept (true); extern float __fdimf (float __x, float __y) noexcept (true);



extern float fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) noexcept (true); extern float __fmaf (float __x, float __y, float __z) noexcept (true);




extern float roundevenf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundevenf (float __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef (float *__cx, const float *__x) noexcept (true);






extern float fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float fmaximumf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimumf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern float getpayloadf (const float *__x) noexcept (true); extern float __getpayloadf (const float *__x) noexcept (true);


extern int setpayloadf (float *__x, float __payload) noexcept (true);


extern int setpayloadsigf (float *__x, float __payload) noexcept (true);







extern float scalbf (float __x, float __n) noexcept (true); extern float __scalbf (float __x, float __n) noexcept (true);
# 331 "/usr/include/math.h" 2 3 4
# 398 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitl (long double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) noexcept (true);


extern int __issignalingl (long double __value) noexcept (true)
     __attribute__ ((__const__));
# 399 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern long double acosl (long double __x) noexcept (true); extern long double __acosl (long double __x) noexcept (true);

 extern long double asinl (long double __x) noexcept (true); extern long double __asinl (long double __x) noexcept (true);

 extern long double atanl (long double __x) noexcept (true); extern long double __atanl (long double __x) noexcept (true);

 extern long double atan2l (long double __y, long double __x) noexcept (true); extern long double __atan2l (long double __y, long double __x) noexcept (true);


 extern long double cosl (long double __x) noexcept (true); extern long double __cosl (long double __x) noexcept (true);

 extern long double sinl (long double __x) noexcept (true); extern long double __sinl (long double __x) noexcept (true);

 extern long double tanl (long double __x) noexcept (true); extern long double __tanl (long double __x) noexcept (true);




 extern long double coshl (long double __x) noexcept (true); extern long double __coshl (long double __x) noexcept (true);

 extern long double sinhl (long double __x) noexcept (true); extern long double __sinhl (long double __x) noexcept (true);

 extern long double tanhl (long double __x) noexcept (true); extern long double __tanhl (long double __x) noexcept (true);



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true)
                                                        ;




 extern long double acoshl (long double __x) noexcept (true); extern long double __acoshl (long double __x) noexcept (true);

 extern long double asinhl (long double __x) noexcept (true); extern long double __asinhl (long double __x) noexcept (true);

 extern long double atanhl (long double __x) noexcept (true); extern long double __atanhl (long double __x) noexcept (true);





 extern long double expl (long double __x) noexcept (true); extern long double __expl (long double __x) noexcept (true);


extern long double frexpl (long double __x, int *__exponent) noexcept (true); extern long double __frexpl (long double __x, int *__exponent) noexcept (true);


extern long double ldexpl (long double __x, int __exponent) noexcept (true); extern long double __ldexpl (long double __x, int __exponent) noexcept (true);


 extern long double logl (long double __x) noexcept (true); extern long double __logl (long double __x) noexcept (true);


 extern long double log10l (long double __x) noexcept (true); extern long double __log10l (long double __x) noexcept (true);


extern long double modfl (long double __x, long double *__iptr) noexcept (true); extern long double __modfl (long double __x, long double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern long double exp10l (long double __x) noexcept (true); extern long double __exp10l (long double __x) noexcept (true);


extern long double exp2m1l (long double __x) noexcept (true); extern long double __exp2m1l (long double __x) noexcept (true);


extern long double exp10m1l (long double __x) noexcept (true); extern long double __exp10m1l (long double __x) noexcept (true);


extern long double log2p1l (long double __x) noexcept (true); extern long double __log2p1l (long double __x) noexcept (true);


extern long double log10p1l (long double __x) noexcept (true); extern long double __log10p1l (long double __x) noexcept (true);


extern long double logp1l (long double __x) noexcept (true); extern long double __logp1l (long double __x) noexcept (true);




 extern long double expm1l (long double __x) noexcept (true); extern long double __expm1l (long double __x) noexcept (true);


 extern long double log1pl (long double __x) noexcept (true); extern long double __log1pl (long double __x) noexcept (true);


extern long double logbl (long double __x) noexcept (true); extern long double __logbl (long double __x) noexcept (true);




 extern long double exp2l (long double __x) noexcept (true); extern long double __exp2l (long double __x) noexcept (true);


 extern long double log2l (long double __x) noexcept (true); extern long double __log2l (long double __x) noexcept (true);






 extern long double powl (long double __x, long double __y) noexcept (true); extern long double __powl (long double __x, long double __y) noexcept (true);


extern long double sqrtl (long double __x) noexcept (true); extern long double __sqrtl (long double __x) noexcept (true);



 extern long double hypotl (long double __x, long double __y) noexcept (true); extern long double __hypotl (long double __x, long double __y) noexcept (true);




 extern long double cbrtl (long double __x) noexcept (true); extern long double __cbrtl (long double __x) noexcept (true);






extern long double ceill (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __ceill (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fabsl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __fabsl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double floorl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __floorl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) noexcept (true); extern long double __fmodl (long double __x, long double __y) noexcept (true);
# 192 "/usr/include/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) noexcept (true); extern long double __dreml (long double __x, long double __y) noexcept (true);



extern long double significandl (long double __x) noexcept (true); extern long double __significandl (long double __x) noexcept (true);






extern long double copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double nanl (const char *__tagb) noexcept (true); extern long double __nanl (const char *__tagb) noexcept (true);
# 228 "/usr/include/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));





extern long double j0l (long double) noexcept (true); extern long double __j0l (long double) noexcept (true);
extern long double j1l (long double) noexcept (true); extern long double __j1l (long double) noexcept (true);
extern long double jnl (int, long double) noexcept (true); extern long double __jnl (int, long double) noexcept (true);
extern long double y0l (long double) noexcept (true); extern long double __y0l (long double) noexcept (true);
extern long double y1l (long double) noexcept (true); extern long double __y1l (long double) noexcept (true);
extern long double ynl (int, long double) noexcept (true); extern long double __ynl (int, long double) noexcept (true);





 extern long double erfl (long double) noexcept (true); extern long double __erfl (long double) noexcept (true);
 extern long double erfcl (long double) noexcept (true); extern long double __erfcl (long double) noexcept (true);
extern long double lgammal (long double) noexcept (true); extern long double __lgammal (long double) noexcept (true);




extern long double tgammal (long double) noexcept (true); extern long double __tgammal (long double) noexcept (true);





extern long double gammal (long double) noexcept (true); extern long double __gammal (long double) noexcept (true);







extern long double lgammal_r (long double, int *__signgamp) noexcept (true); extern long double __lgammal_r (long double, int *__signgamp) noexcept (true);






extern long double rintl (long double __x) noexcept (true); extern long double __rintl (long double __x) noexcept (true);


extern long double nextafterl (long double __x, long double __y) noexcept (true); extern long double __nextafterl (long double __x, long double __y) noexcept (true);

extern long double nexttowardl (long double __x, long double __y) noexcept (true); extern long double __nexttowardl (long double __x, long double __y) noexcept (true);




extern long double nextdownl (long double __x) noexcept (true); extern long double __nextdownl (long double __x) noexcept (true);

extern long double nextupl (long double __x) noexcept (true); extern long double __nextupl (long double __x) noexcept (true);



extern long double remainderl (long double __x, long double __y) noexcept (true); extern long double __remainderl (long double __x, long double __y) noexcept (true);



extern long double scalbnl (long double __x, int __n) noexcept (true); extern long double __scalbnl (long double __x, int __n) noexcept (true);



extern int ilogbl (long double __x) noexcept (true); extern int __ilogbl (long double __x) noexcept (true);




extern long int llogbl (long double __x) noexcept (true); extern long int __llogbl (long double __x) noexcept (true);




extern long double scalblnl (long double __x, long int __n) noexcept (true); extern long double __scalblnl (long double __x, long int __n) noexcept (true);



extern long double nearbyintl (long double __x) noexcept (true); extern long double __nearbyintl (long double __x) noexcept (true);



extern long double roundl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundl (long double __x) noexcept (true) __attribute__ ((__const__));



extern long double truncl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __truncl (long double __x) noexcept (true) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) noexcept (true); extern long double __remquol (long double __x, long double __y, int *__quo) noexcept (true);






extern long int lrintl (long double __x) noexcept (true); extern long int __lrintl (long double __x) noexcept (true);
__extension__
extern long long int llrintl (long double __x) noexcept (true); extern long long int __llrintl (long double __x) noexcept (true);



extern long int lroundl (long double __x) noexcept (true); extern long int __lroundl (long double __x) noexcept (true);
__extension__
extern long long int llroundl (long double __x) noexcept (true); extern long long int __llroundl (long double __x) noexcept (true);



extern long double fdiml (long double __x, long double __y) noexcept (true); extern long double __fdiml (long double __x, long double __y) noexcept (true);



extern long double fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) noexcept (true); extern long double __fmal (long double __x, long double __y, long double __z) noexcept (true);




extern long double roundevenl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundevenl (long double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizel (long double *__cx, const long double *__x) noexcept (true);






extern long double fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double fmaximuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern long double getpayloadl (const long double *__x) noexcept (true); extern long double __getpayloadl (const long double *__x) noexcept (true);


extern int setpayloadl (long double *__x, long double __payload) noexcept (true);


extern int setpayloadsigl (long double *__x, long double __payload) noexcept (true);







extern long double scalbl (long double __x, long double __n) noexcept (true); extern long double __scalbl (long double __x, long double __n) noexcept (true);
# 400 "/usr/include/math.h" 2 3 4
# 450 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern _Float32 acosf32 (_Float32 __x) noexcept (true); extern _Float32 __acosf32 (_Float32 __x) noexcept (true);

 extern _Float32 asinf32 (_Float32 __x) noexcept (true); extern _Float32 __asinf32 (_Float32 __x) noexcept (true);

 extern _Float32 atanf32 (_Float32 __x) noexcept (true); extern _Float32 __atanf32 (_Float32 __x) noexcept (true);

 extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) noexcept (true); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) noexcept (true);


 extern _Float32 cosf32 (_Float32 __x) noexcept (true); extern _Float32 __cosf32 (_Float32 __x) noexcept (true);

 extern _Float32 sinf32 (_Float32 __x) noexcept (true); extern _Float32 __sinf32 (_Float32 __x) noexcept (true);

 extern _Float32 tanf32 (_Float32 __x) noexcept (true); extern _Float32 __tanf32 (_Float32 __x) noexcept (true);




 extern _Float32 coshf32 (_Float32 __x) noexcept (true); extern _Float32 __coshf32 (_Float32 __x) noexcept (true);

 extern _Float32 sinhf32 (_Float32 __x) noexcept (true); extern _Float32 __sinhf32 (_Float32 __x) noexcept (true);

 extern _Float32 tanhf32 (_Float32 __x) noexcept (true); extern _Float32 __tanhf32 (_Float32 __x) noexcept (true);



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true)
                                                        ;




 extern _Float32 acoshf32 (_Float32 __x) noexcept (true); extern _Float32 __acoshf32 (_Float32 __x) noexcept (true);

 extern _Float32 asinhf32 (_Float32 __x) noexcept (true); extern _Float32 __asinhf32 (_Float32 __x) noexcept (true);

 extern _Float32 atanhf32 (_Float32 __x) noexcept (true); extern _Float32 __atanhf32 (_Float32 __x) noexcept (true);





 extern _Float32 expf32 (_Float32 __x) noexcept (true); extern _Float32 __expf32 (_Float32 __x) noexcept (true);


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) noexcept (true); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) noexcept (true);


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) noexcept (true); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) noexcept (true);


 extern _Float32 logf32 (_Float32 __x) noexcept (true); extern _Float32 __logf32 (_Float32 __x) noexcept (true);


 extern _Float32 log10f32 (_Float32 __x) noexcept (true); extern _Float32 __log10f32 (_Float32 __x) noexcept (true);


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float32 exp10f32 (_Float32 __x) noexcept (true); extern _Float32 __exp10f32 (_Float32 __x) noexcept (true);


extern _Float32 exp2m1f32 (_Float32 __x) noexcept (true); extern _Float32 __exp2m1f32 (_Float32 __x) noexcept (true);


extern _Float32 exp10m1f32 (_Float32 __x) noexcept (true); extern _Float32 __exp10m1f32 (_Float32 __x) noexcept (true);


extern _Float32 log2p1f32 (_Float32 __x) noexcept (true); extern _Float32 __log2p1f32 (_Float32 __x) noexcept (true);


extern _Float32 log10p1f32 (_Float32 __x) noexcept (true); extern _Float32 __log10p1f32 (_Float32 __x) noexcept (true);


extern _Float32 logp1f32 (_Float32 __x) noexcept (true); extern _Float32 __logp1f32 (_Float32 __x) noexcept (true);




 extern _Float32 expm1f32 (_Float32 __x) noexcept (true); extern _Float32 __expm1f32 (_Float32 __x) noexcept (true);


 extern _Float32 log1pf32 (_Float32 __x) noexcept (true); extern _Float32 __log1pf32 (_Float32 __x) noexcept (true);


extern _Float32 logbf32 (_Float32 __x) noexcept (true); extern _Float32 __logbf32 (_Float32 __x) noexcept (true);




 extern _Float32 exp2f32 (_Float32 __x) noexcept (true); extern _Float32 __exp2f32 (_Float32 __x) noexcept (true);


 extern _Float32 log2f32 (_Float32 __x) noexcept (true); extern _Float32 __log2f32 (_Float32 __x) noexcept (true);






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) noexcept (true);


extern _Float32 sqrtf32 (_Float32 __x) noexcept (true); extern _Float32 __sqrtf32 (_Float32 __x) noexcept (true);



 extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) noexcept (true);




 extern _Float32 cbrtf32 (_Float32 __x) noexcept (true); extern _Float32 __cbrtf32 (_Float32 __x) noexcept (true);






extern _Float32 ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) noexcept (true);
# 213 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) noexcept (true); extern _Float32 __nanf32 (const char *__tagb) noexcept (true);
# 235 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) noexcept (true); extern _Float32 __j0f32 (_Float32) noexcept (true);
extern _Float32 j1f32 (_Float32) noexcept (true); extern _Float32 __j1f32 (_Float32) noexcept (true);
extern _Float32 jnf32 (int, _Float32) noexcept (true); extern _Float32 __jnf32 (int, _Float32) noexcept (true);
extern _Float32 y0f32 (_Float32) noexcept (true); extern _Float32 __y0f32 (_Float32) noexcept (true);
extern _Float32 y1f32 (_Float32) noexcept (true); extern _Float32 __y1f32 (_Float32) noexcept (true);
extern _Float32 ynf32 (int, _Float32) noexcept (true); extern _Float32 __ynf32 (int, _Float32) noexcept (true);





 extern _Float32 erff32 (_Float32) noexcept (true); extern _Float32 __erff32 (_Float32) noexcept (true);
 extern _Float32 erfcf32 (_Float32) noexcept (true); extern _Float32 __erfcf32 (_Float32) noexcept (true);
extern _Float32 lgammaf32 (_Float32) noexcept (true); extern _Float32 __lgammaf32 (_Float32) noexcept (true);




extern _Float32 tgammaf32 (_Float32) noexcept (true); extern _Float32 __tgammaf32 (_Float32) noexcept (true);
# 267 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) noexcept (true); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) noexcept (true);






extern _Float32 rintf32 (_Float32 __x) noexcept (true); extern _Float32 __rintf32 (_Float32 __x) noexcept (true);


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true);






extern _Float32 nextdownf32 (_Float32 __x) noexcept (true); extern _Float32 __nextdownf32 (_Float32 __x) noexcept (true);

extern _Float32 nextupf32 (_Float32 __x) noexcept (true); extern _Float32 __nextupf32 (_Float32 __x) noexcept (true);



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 scalbnf32 (_Float32 __x, int __n) noexcept (true); extern _Float32 __scalbnf32 (_Float32 __x, int __n) noexcept (true);



extern int ilogbf32 (_Float32 __x) noexcept (true); extern int __ilogbf32 (_Float32 __x) noexcept (true);




extern long int llogbf32 (_Float32 __x) noexcept (true); extern long int __llogbf32 (_Float32 __x) noexcept (true);




extern _Float32 scalblnf32 (_Float32 __x, long int __n) noexcept (true); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) noexcept (true);



extern _Float32 nearbyintf32 (_Float32 __x) noexcept (true); extern _Float32 __nearbyintf32 (_Float32 __x) noexcept (true);



extern _Float32 roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true);






extern long int lrintf32 (_Float32 __x) noexcept (true); extern long int __lrintf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llrintf32 (_Float32 __x) noexcept (true); extern long long int __llrintf32 (_Float32 __x) noexcept (true);



extern long int lroundf32 (_Float32 __x) noexcept (true); extern long int __lroundf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llroundf32 (_Float32 __x) noexcept (true); extern long long int __llroundf32 (_Float32 __x) noexcept (true);



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));



extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true);




extern _Float32 roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) noexcept (true);






extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 fmaximumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32 getpayloadf32 (const _Float32 *__x) noexcept (true); extern _Float32 __getpayloadf32 (const _Float32 *__x) noexcept (true);


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) noexcept (true);


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) noexcept (true);
# 451 "/usr/include/math.h" 2 3 4
# 467 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern _Float64 acosf64 (_Float64 __x) noexcept (true); extern _Float64 __acosf64 (_Float64 __x) noexcept (true);

 extern _Float64 asinf64 (_Float64 __x) noexcept (true); extern _Float64 __asinf64 (_Float64 __x) noexcept (true);

 extern _Float64 atanf64 (_Float64 __x) noexcept (true); extern _Float64 __atanf64 (_Float64 __x) noexcept (true);

 extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) noexcept (true); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) noexcept (true);


 extern _Float64 cosf64 (_Float64 __x) noexcept (true); extern _Float64 __cosf64 (_Float64 __x) noexcept (true);

 extern _Float64 sinf64 (_Float64 __x) noexcept (true); extern _Float64 __sinf64 (_Float64 __x) noexcept (true);

 extern _Float64 tanf64 (_Float64 __x) noexcept (true); extern _Float64 __tanf64 (_Float64 __x) noexcept (true);




 extern _Float64 coshf64 (_Float64 __x) noexcept (true); extern _Float64 __coshf64 (_Float64 __x) noexcept (true);

 extern _Float64 sinhf64 (_Float64 __x) noexcept (true); extern _Float64 __sinhf64 (_Float64 __x) noexcept (true);

 extern _Float64 tanhf64 (_Float64 __x) noexcept (true); extern _Float64 __tanhf64 (_Float64 __x) noexcept (true);



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true)
                                                        ;




 extern _Float64 acoshf64 (_Float64 __x) noexcept (true); extern _Float64 __acoshf64 (_Float64 __x) noexcept (true);

 extern _Float64 asinhf64 (_Float64 __x) noexcept (true); extern _Float64 __asinhf64 (_Float64 __x) noexcept (true);

 extern _Float64 atanhf64 (_Float64 __x) noexcept (true); extern _Float64 __atanhf64 (_Float64 __x) noexcept (true);





 extern _Float64 expf64 (_Float64 __x) noexcept (true); extern _Float64 __expf64 (_Float64 __x) noexcept (true);


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) noexcept (true); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) noexcept (true);


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) noexcept (true); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) noexcept (true);


 extern _Float64 logf64 (_Float64 __x) noexcept (true); extern _Float64 __logf64 (_Float64 __x) noexcept (true);


 extern _Float64 log10f64 (_Float64 __x) noexcept (true); extern _Float64 __log10f64 (_Float64 __x) noexcept (true);


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float64 exp10f64 (_Float64 __x) noexcept (true); extern _Float64 __exp10f64 (_Float64 __x) noexcept (true);


extern _Float64 exp2m1f64 (_Float64 __x) noexcept (true); extern _Float64 __exp2m1f64 (_Float64 __x) noexcept (true);


extern _Float64 exp10m1f64 (_Float64 __x) noexcept (true); extern _Float64 __exp10m1f64 (_Float64 __x) noexcept (true);


extern _Float64 log2p1f64 (_Float64 __x) noexcept (true); extern _Float64 __log2p1f64 (_Float64 __x) noexcept (true);


extern _Float64 log10p1f64 (_Float64 __x) noexcept (true); extern _Float64 __log10p1f64 (_Float64 __x) noexcept (true);


extern _Float64 logp1f64 (_Float64 __x) noexcept (true); extern _Float64 __logp1f64 (_Float64 __x) noexcept (true);




 extern _Float64 expm1f64 (_Float64 __x) noexcept (true); extern _Float64 __expm1f64 (_Float64 __x) noexcept (true);


 extern _Float64 log1pf64 (_Float64 __x) noexcept (true); extern _Float64 __log1pf64 (_Float64 __x) noexcept (true);


extern _Float64 logbf64 (_Float64 __x) noexcept (true); extern _Float64 __logbf64 (_Float64 __x) noexcept (true);




 extern _Float64 exp2f64 (_Float64 __x) noexcept (true); extern _Float64 __exp2f64 (_Float64 __x) noexcept (true);


 extern _Float64 log2f64 (_Float64 __x) noexcept (true); extern _Float64 __log2f64 (_Float64 __x) noexcept (true);






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float64 sqrtf64 (_Float64 __x) noexcept (true); extern _Float64 __sqrtf64 (_Float64 __x) noexcept (true);



 extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) noexcept (true);




 extern _Float64 cbrtf64 (_Float64 __x) noexcept (true); extern _Float64 __cbrtf64 (_Float64 __x) noexcept (true);






extern _Float64 ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 213 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) noexcept (true); extern _Float64 __nanf64 (const char *__tagb) noexcept (true);
# 235 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) noexcept (true); extern _Float64 __j0f64 (_Float64) noexcept (true);
extern _Float64 j1f64 (_Float64) noexcept (true); extern _Float64 __j1f64 (_Float64) noexcept (true);
extern _Float64 jnf64 (int, _Float64) noexcept (true); extern _Float64 __jnf64 (int, _Float64) noexcept (true);
extern _Float64 y0f64 (_Float64) noexcept (true); extern _Float64 __y0f64 (_Float64) noexcept (true);
extern _Float64 y1f64 (_Float64) noexcept (true); extern _Float64 __y1f64 (_Float64) noexcept (true);
extern _Float64 ynf64 (int, _Float64) noexcept (true); extern _Float64 __ynf64 (int, _Float64) noexcept (true);





 extern _Float64 erff64 (_Float64) noexcept (true); extern _Float64 __erff64 (_Float64) noexcept (true);
 extern _Float64 erfcf64 (_Float64) noexcept (true); extern _Float64 __erfcf64 (_Float64) noexcept (true);
extern _Float64 lgammaf64 (_Float64) noexcept (true); extern _Float64 __lgammaf64 (_Float64) noexcept (true);




extern _Float64 tgammaf64 (_Float64) noexcept (true); extern _Float64 __tgammaf64 (_Float64) noexcept (true);
# 267 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) noexcept (true); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) noexcept (true);






extern _Float64 rintf64 (_Float64 __x) noexcept (true); extern _Float64 __rintf64 (_Float64 __x) noexcept (true);


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true);






extern _Float64 nextdownf64 (_Float64 __x) noexcept (true); extern _Float64 __nextdownf64 (_Float64 __x) noexcept (true);

extern _Float64 nextupf64 (_Float64 __x) noexcept (true); extern _Float64 __nextupf64 (_Float64 __x) noexcept (true);



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 scalbnf64 (_Float64 __x, int __n) noexcept (true); extern _Float64 __scalbnf64 (_Float64 __x, int __n) noexcept (true);



extern int ilogbf64 (_Float64 __x) noexcept (true); extern int __ilogbf64 (_Float64 __x) noexcept (true);




extern long int llogbf64 (_Float64 __x) noexcept (true); extern long int __llogbf64 (_Float64 __x) noexcept (true);




extern _Float64 scalblnf64 (_Float64 __x, long int __n) noexcept (true); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) noexcept (true);



extern _Float64 nearbyintf64 (_Float64 __x) noexcept (true); extern _Float64 __nearbyintf64 (_Float64 __x) noexcept (true);



extern _Float64 roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true);






extern long int lrintf64 (_Float64 __x) noexcept (true); extern long int __lrintf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llrintf64 (_Float64 __x) noexcept (true); extern long long int __llrintf64 (_Float64 __x) noexcept (true);



extern long int lroundf64 (_Float64 __x) noexcept (true); extern long int __lroundf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llroundf64 (_Float64 __x) noexcept (true); extern long long int __llroundf64 (_Float64 __x) noexcept (true);



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));



extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);




extern _Float64 roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) noexcept (true);






extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 fmaximumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64 getpayloadf64 (const _Float64 *__x) noexcept (true); extern _Float64 __getpayloadf64 (const _Float64 *__x) noexcept (true);


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) noexcept (true);


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) noexcept (true);
# 468 "/usr/include/math.h" 2 3 4
# 481 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinff128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitef128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanf128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern int __issignalingf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));
# 482 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern _Float128 acosf128 (_Float128 __x) noexcept (true); extern _Float128 __acosf128 (_Float128 __x) noexcept (true);

 extern _Float128 asinf128 (_Float128 __x) noexcept (true); extern _Float128 __asinf128 (_Float128 __x) noexcept (true);

 extern _Float128 atanf128 (_Float128 __x) noexcept (true); extern _Float128 __atanf128 (_Float128 __x) noexcept (true);

 extern _Float128 atan2f128 (_Float128 __y, _Float128 __x) noexcept (true); extern _Float128 __atan2f128 (_Float128 __y, _Float128 __x) noexcept (true);


 extern _Float128 cosf128 (_Float128 __x) noexcept (true); extern _Float128 __cosf128 (_Float128 __x) noexcept (true);

 extern _Float128 sinf128 (_Float128 __x) noexcept (true); extern _Float128 __sinf128 (_Float128 __x) noexcept (true);

 extern _Float128 tanf128 (_Float128 __x) noexcept (true); extern _Float128 __tanf128 (_Float128 __x) noexcept (true);




 extern _Float128 coshf128 (_Float128 __x) noexcept (true); extern _Float128 __coshf128 (_Float128 __x) noexcept (true);

 extern _Float128 sinhf128 (_Float128 __x) noexcept (true); extern _Float128 __sinhf128 (_Float128 __x) noexcept (true);

 extern _Float128 tanhf128 (_Float128 __x) noexcept (true); extern _Float128 __tanhf128 (_Float128 __x) noexcept (true);



 extern void sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) noexcept (true); extern void __sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) noexcept (true)
                                                        ;




 extern _Float128 acoshf128 (_Float128 __x) noexcept (true); extern _Float128 __acoshf128 (_Float128 __x) noexcept (true);

 extern _Float128 asinhf128 (_Float128 __x) noexcept (true); extern _Float128 __asinhf128 (_Float128 __x) noexcept (true);

 extern _Float128 atanhf128 (_Float128 __x) noexcept (true); extern _Float128 __atanhf128 (_Float128 __x) noexcept (true);





 extern _Float128 expf128 (_Float128 __x) noexcept (true); extern _Float128 __expf128 (_Float128 __x) noexcept (true);


extern _Float128 frexpf128 (_Float128 __x, int *__exponent) noexcept (true); extern _Float128 __frexpf128 (_Float128 __x, int *__exponent) noexcept (true);


extern _Float128 ldexpf128 (_Float128 __x, int __exponent) noexcept (true); extern _Float128 __ldexpf128 (_Float128 __x, int __exponent) noexcept (true);


 extern _Float128 logf128 (_Float128 __x) noexcept (true); extern _Float128 __logf128 (_Float128 __x) noexcept (true);


 extern _Float128 log10f128 (_Float128 __x) noexcept (true); extern _Float128 __log10f128 (_Float128 __x) noexcept (true);


extern _Float128 modff128 (_Float128 __x, _Float128 *__iptr) noexcept (true); extern _Float128 __modff128 (_Float128 __x, _Float128 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float128 exp10f128 (_Float128 __x) noexcept (true); extern _Float128 __exp10f128 (_Float128 __x) noexcept (true);


extern _Float128 exp2m1f128 (_Float128 __x) noexcept (true); extern _Float128 __exp2m1f128 (_Float128 __x) noexcept (true);


extern _Float128 exp10m1f128 (_Float128 __x) noexcept (true); extern _Float128 __exp10m1f128 (_Float128 __x) noexcept (true);


extern _Float128 log2p1f128 (_Float128 __x) noexcept (true); extern _Float128 __log2p1f128 (_Float128 __x) noexcept (true);


extern _Float128 log10p1f128 (_Float128 __x) noexcept (true); extern _Float128 __log10p1f128 (_Float128 __x) noexcept (true);


extern _Float128 logp1f128 (_Float128 __x) noexcept (true); extern _Float128 __logp1f128 (_Float128 __x) noexcept (true);




 extern _Float128 expm1f128 (_Float128 __x) noexcept (true); extern _Float128 __expm1f128 (_Float128 __x) noexcept (true);


 extern _Float128 log1pf128 (_Float128 __x) noexcept (true); extern _Float128 __log1pf128 (_Float128 __x) noexcept (true);


extern _Float128 logbf128 (_Float128 __x) noexcept (true); extern _Float128 __logbf128 (_Float128 __x) noexcept (true);




 extern _Float128 exp2f128 (_Float128 __x) noexcept (true); extern _Float128 __exp2f128 (_Float128 __x) noexcept (true);


 extern _Float128 log2f128 (_Float128 __x) noexcept (true); extern _Float128 __log2f128 (_Float128 __x) noexcept (true);






 extern _Float128 powf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __powf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float128 sqrtf128 (_Float128 __x) noexcept (true); extern _Float128 __sqrtf128 (_Float128 __x) noexcept (true);



 extern _Float128 hypotf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __hypotf128 (_Float128 __x, _Float128 __y) noexcept (true);




 extern _Float128 cbrtf128 (_Float128 __x) noexcept (true); extern _Float128 __cbrtf128 (_Float128 __x) noexcept (true);






extern _Float128 ceilf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __ceilf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 fabsf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fabsf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 floorf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __floorf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmodf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __fmodf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 213 "/usr/include/bits/mathcalls.h" 3 4
extern _Float128 copysignf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __copysignf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern _Float128 nanf128 (const char *__tagb) noexcept (true); extern _Float128 __nanf128 (const char *__tagb) noexcept (true);
# 235 "/usr/include/bits/mathcalls.h" 3 4
extern _Float128 j0f128 (_Float128) noexcept (true); extern _Float128 __j0f128 (_Float128) noexcept (true);
extern _Float128 j1f128 (_Float128) noexcept (true); extern _Float128 __j1f128 (_Float128) noexcept (true);
extern _Float128 jnf128 (int, _Float128) noexcept (true); extern _Float128 __jnf128 (int, _Float128) noexcept (true);
extern _Float128 y0f128 (_Float128) noexcept (true); extern _Float128 __y0f128 (_Float128) noexcept (true);
extern _Float128 y1f128 (_Float128) noexcept (true); extern _Float128 __y1f128 (_Float128) noexcept (true);
extern _Float128 ynf128 (int, _Float128) noexcept (true); extern _Float128 __ynf128 (int, _Float128) noexcept (true);





 extern _Float128 erff128 (_Float128) noexcept (true); extern _Float128 __erff128 (_Float128) noexcept (true);
 extern _Float128 erfcf128 (_Float128) noexcept (true); extern _Float128 __erfcf128 (_Float128) noexcept (true);
extern _Float128 lgammaf128 (_Float128) noexcept (true); extern _Float128 __lgammaf128 (_Float128) noexcept (true);




extern _Float128 tgammaf128 (_Float128) noexcept (true); extern _Float128 __tgammaf128 (_Float128) noexcept (true);
# 267 "/usr/include/bits/mathcalls.h" 3 4
extern _Float128 lgammaf128_r (_Float128, int *__signgamp) noexcept (true); extern _Float128 __lgammaf128_r (_Float128, int *__signgamp) noexcept (true);






extern _Float128 rintf128 (_Float128 __x) noexcept (true); extern _Float128 __rintf128 (_Float128 __x) noexcept (true);


extern _Float128 nextafterf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __nextafterf128 (_Float128 __x, _Float128 __y) noexcept (true);






extern _Float128 nextdownf128 (_Float128 __x) noexcept (true); extern _Float128 __nextdownf128 (_Float128 __x) noexcept (true);

extern _Float128 nextupf128 (_Float128 __x) noexcept (true); extern _Float128 __nextupf128 (_Float128 __x) noexcept (true);



extern _Float128 remainderf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __remainderf128 (_Float128 __x, _Float128 __y) noexcept (true);



extern _Float128 scalbnf128 (_Float128 __x, int __n) noexcept (true); extern _Float128 __scalbnf128 (_Float128 __x, int __n) noexcept (true);



extern int ilogbf128 (_Float128 __x) noexcept (true); extern int __ilogbf128 (_Float128 __x) noexcept (true);




extern long int llogbf128 (_Float128 __x) noexcept (true); extern long int __llogbf128 (_Float128 __x) noexcept (true);




extern _Float128 scalblnf128 (_Float128 __x, long int __n) noexcept (true); extern _Float128 __scalblnf128 (_Float128 __x, long int __n) noexcept (true);



extern _Float128 nearbyintf128 (_Float128 __x) noexcept (true); extern _Float128 __nearbyintf128 (_Float128 __x) noexcept (true);



extern _Float128 roundf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __roundf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));



extern _Float128 truncf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __truncf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));




extern _Float128 remquof128 (_Float128 __x, _Float128 __y, int *__quo) noexcept (true); extern _Float128 __remquof128 (_Float128 __x, _Float128 __y, int *__quo) noexcept (true);






extern long int lrintf128 (_Float128 __x) noexcept (true); extern long int __lrintf128 (_Float128 __x) noexcept (true);
__extension__
extern long long int llrintf128 (_Float128 __x) noexcept (true); extern long long int __llrintf128 (_Float128 __x) noexcept (true);



extern long int lroundf128 (_Float128 __x) noexcept (true); extern long int __lroundf128 (_Float128 __x) noexcept (true);
__extension__
extern long long int llroundf128 (_Float128 __x) noexcept (true); extern long long int __llroundf128 (_Float128 __x) noexcept (true);



extern _Float128 fdimf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __fdimf128 (_Float128 __x, _Float128 __y) noexcept (true);



extern _Float128 fmaxf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaxf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));



extern _Float128 fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true); extern _Float128 __fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);




extern _Float128 roundevenf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __roundevenf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef128 (_Float128 *__cx, const _Float128 *__x) noexcept (true);






extern _Float128 fmaxmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaxmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern _Float128 fmaximumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf128 (const _Float128 *__x, const _Float128 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf128 (const _Float128 *__x, const _Float128 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float128 getpayloadf128 (const _Float128 *__x) noexcept (true); extern _Float128 __getpayloadf128 (const _Float128 *__x) noexcept (true);


extern int setpayloadf128 (_Float128 *__x, _Float128 __payload) noexcept (true);


extern int setpayloadsigf128 (_Float128 *__x, _Float128 __payload) noexcept (true);
# 485 "/usr/include/math.h" 2 3 4
# 501 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern _Float32x acosf32x (_Float32x __x) noexcept (true); extern _Float32x __acosf32x (_Float32x __x) noexcept (true);

 extern _Float32x asinf32x (_Float32x __x) noexcept (true); extern _Float32x __asinf32x (_Float32x __x) noexcept (true);

 extern _Float32x atanf32x (_Float32x __x) noexcept (true); extern _Float32x __atanf32x (_Float32x __x) noexcept (true);

 extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) noexcept (true); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) noexcept (true);


 extern _Float32x cosf32x (_Float32x __x) noexcept (true); extern _Float32x __cosf32x (_Float32x __x) noexcept (true);

 extern _Float32x sinf32x (_Float32x __x) noexcept (true); extern _Float32x __sinf32x (_Float32x __x) noexcept (true);

 extern _Float32x tanf32x (_Float32x __x) noexcept (true); extern _Float32x __tanf32x (_Float32x __x) noexcept (true);




 extern _Float32x coshf32x (_Float32x __x) noexcept (true); extern _Float32x __coshf32x (_Float32x __x) noexcept (true);

 extern _Float32x sinhf32x (_Float32x __x) noexcept (true); extern _Float32x __sinhf32x (_Float32x __x) noexcept (true);

 extern _Float32x tanhf32x (_Float32x __x) noexcept (true); extern _Float32x __tanhf32x (_Float32x __x) noexcept (true);



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true)
                                                        ;




 extern _Float32x acoshf32x (_Float32x __x) noexcept (true); extern _Float32x __acoshf32x (_Float32x __x) noexcept (true);

 extern _Float32x asinhf32x (_Float32x __x) noexcept (true); extern _Float32x __asinhf32x (_Float32x __x) noexcept (true);

 extern _Float32x atanhf32x (_Float32x __x) noexcept (true); extern _Float32x __atanhf32x (_Float32x __x) noexcept (true);





 extern _Float32x expf32x (_Float32x __x) noexcept (true); extern _Float32x __expf32x (_Float32x __x) noexcept (true);


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) noexcept (true); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) noexcept (true);


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) noexcept (true); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) noexcept (true);


 extern _Float32x logf32x (_Float32x __x) noexcept (true); extern _Float32x __logf32x (_Float32x __x) noexcept (true);


 extern _Float32x log10f32x (_Float32x __x) noexcept (true); extern _Float32x __log10f32x (_Float32x __x) noexcept (true);


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float32x exp10f32x (_Float32x __x) noexcept (true); extern _Float32x __exp10f32x (_Float32x __x) noexcept (true);


extern _Float32x exp2m1f32x (_Float32x __x) noexcept (true); extern _Float32x __exp2m1f32x (_Float32x __x) noexcept (true);


extern _Float32x exp10m1f32x (_Float32x __x) noexcept (true); extern _Float32x __exp10m1f32x (_Float32x __x) noexcept (true);


extern _Float32x log2p1f32x (_Float32x __x) noexcept (true); extern _Float32x __log2p1f32x (_Float32x __x) noexcept (true);


extern _Float32x log10p1f32x (_Float32x __x) noexcept (true); extern _Float32x __log10p1f32x (_Float32x __x) noexcept (true);


extern _Float32x logp1f32x (_Float32x __x) noexcept (true); extern _Float32x __logp1f32x (_Float32x __x) noexcept (true);




 extern _Float32x expm1f32x (_Float32x __x) noexcept (true); extern _Float32x __expm1f32x (_Float32x __x) noexcept (true);


 extern _Float32x log1pf32x (_Float32x __x) noexcept (true); extern _Float32x __log1pf32x (_Float32x __x) noexcept (true);


extern _Float32x logbf32x (_Float32x __x) noexcept (true); extern _Float32x __logbf32x (_Float32x __x) noexcept (true);




 extern _Float32x exp2f32x (_Float32x __x) noexcept (true); extern _Float32x __exp2f32x (_Float32x __x) noexcept (true);


 extern _Float32x log2f32x (_Float32x __x) noexcept (true); extern _Float32x __log2f32x (_Float32x __x) noexcept (true);






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32x sqrtf32x (_Float32x __x) noexcept (true); extern _Float32x __sqrtf32x (_Float32x __x) noexcept (true);



 extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) noexcept (true);




 extern _Float32x cbrtf32x (_Float32x __x) noexcept (true); extern _Float32x __cbrtf32x (_Float32x __x) noexcept (true);






extern _Float32x ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 213 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) noexcept (true); extern _Float32x __nanf32x (const char *__tagb) noexcept (true);
# 235 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) noexcept (true); extern _Float32x __j0f32x (_Float32x) noexcept (true);
extern _Float32x j1f32x (_Float32x) noexcept (true); extern _Float32x __j1f32x (_Float32x) noexcept (true);
extern _Float32x jnf32x (int, _Float32x) noexcept (true); extern _Float32x __jnf32x (int, _Float32x) noexcept (true);
extern _Float32x y0f32x (_Float32x) noexcept (true); extern _Float32x __y0f32x (_Float32x) noexcept (true);
extern _Float32x y1f32x (_Float32x) noexcept (true); extern _Float32x __y1f32x (_Float32x) noexcept (true);
extern _Float32x ynf32x (int, _Float32x) noexcept (true); extern _Float32x __ynf32x (int, _Float32x) noexcept (true);





 extern _Float32x erff32x (_Float32x) noexcept (true); extern _Float32x __erff32x (_Float32x) noexcept (true);
 extern _Float32x erfcf32x (_Float32x) noexcept (true); extern _Float32x __erfcf32x (_Float32x) noexcept (true);
extern _Float32x lgammaf32x (_Float32x) noexcept (true); extern _Float32x __lgammaf32x (_Float32x) noexcept (true);




extern _Float32x tgammaf32x (_Float32x) noexcept (true); extern _Float32x __tgammaf32x (_Float32x) noexcept (true);
# 267 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true);






extern _Float32x rintf32x (_Float32x __x) noexcept (true); extern _Float32x __rintf32x (_Float32x __x) noexcept (true);


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true);






extern _Float32x nextdownf32x (_Float32x __x) noexcept (true); extern _Float32x __nextdownf32x (_Float32x __x) noexcept (true);

extern _Float32x nextupf32x (_Float32x __x) noexcept (true); extern _Float32x __nextupf32x (_Float32x __x) noexcept (true);



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x scalbnf32x (_Float32x __x, int __n) noexcept (true); extern _Float32x __scalbnf32x (_Float32x __x, int __n) noexcept (true);



extern int ilogbf32x (_Float32x __x) noexcept (true); extern int __ilogbf32x (_Float32x __x) noexcept (true);




extern long int llogbf32x (_Float32x __x) noexcept (true); extern long int __llogbf32x (_Float32x __x) noexcept (true);




extern _Float32x scalblnf32x (_Float32x __x, long int __n) noexcept (true); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) noexcept (true);



extern _Float32x nearbyintf32x (_Float32x __x) noexcept (true); extern _Float32x __nearbyintf32x (_Float32x __x) noexcept (true);



extern _Float32x roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true);






extern long int lrintf32x (_Float32x __x) noexcept (true); extern long int __lrintf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llrintf32x (_Float32x __x) noexcept (true); extern long long int __llrintf32x (_Float32x __x) noexcept (true);



extern long int lroundf32x (_Float32x __x) noexcept (true); extern long int __lroundf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llroundf32x (_Float32x __x) noexcept (true); extern long long int __llroundf32x (_Float32x __x) noexcept (true);



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));



extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);




extern _Float32x roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) noexcept (true);






extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x fmaximumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32x getpayloadf32x (const _Float32x *__x) noexcept (true); extern _Float32x __getpayloadf32x (const _Float32x *__x) noexcept (true);


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) noexcept (true);


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) noexcept (true);
# 502 "/usr/include/math.h" 2 3 4
# 518 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern _Float64x acosf64x (_Float64x __x) noexcept (true); extern _Float64x __acosf64x (_Float64x __x) noexcept (true);

 extern _Float64x asinf64x (_Float64x __x) noexcept (true); extern _Float64x __asinf64x (_Float64x __x) noexcept (true);

 extern _Float64x atanf64x (_Float64x __x) noexcept (true); extern _Float64x __atanf64x (_Float64x __x) noexcept (true);

 extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) noexcept (true); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) noexcept (true);


 extern _Float64x cosf64x (_Float64x __x) noexcept (true); extern _Float64x __cosf64x (_Float64x __x) noexcept (true);

 extern _Float64x sinf64x (_Float64x __x) noexcept (true); extern _Float64x __sinf64x (_Float64x __x) noexcept (true);

 extern _Float64x tanf64x (_Float64x __x) noexcept (true); extern _Float64x __tanf64x (_Float64x __x) noexcept (true);




 extern _Float64x coshf64x (_Float64x __x) noexcept (true); extern _Float64x __coshf64x (_Float64x __x) noexcept (true);

 extern _Float64x sinhf64x (_Float64x __x) noexcept (true); extern _Float64x __sinhf64x (_Float64x __x) noexcept (true);

 extern _Float64x tanhf64x (_Float64x __x) noexcept (true); extern _Float64x __tanhf64x (_Float64x __x) noexcept (true);



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true)
                                                        ;




 extern _Float64x acoshf64x (_Float64x __x) noexcept (true); extern _Float64x __acoshf64x (_Float64x __x) noexcept (true);

 extern _Float64x asinhf64x (_Float64x __x) noexcept (true); extern _Float64x __asinhf64x (_Float64x __x) noexcept (true);

 extern _Float64x atanhf64x (_Float64x __x) noexcept (true); extern _Float64x __atanhf64x (_Float64x __x) noexcept (true);





 extern _Float64x expf64x (_Float64x __x) noexcept (true); extern _Float64x __expf64x (_Float64x __x) noexcept (true);


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) noexcept (true); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) noexcept (true);


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) noexcept (true); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) noexcept (true);


 extern _Float64x logf64x (_Float64x __x) noexcept (true); extern _Float64x __logf64x (_Float64x __x) noexcept (true);


 extern _Float64x log10f64x (_Float64x __x) noexcept (true); extern _Float64x __log10f64x (_Float64x __x) noexcept (true);


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float64x exp10f64x (_Float64x __x) noexcept (true); extern _Float64x __exp10f64x (_Float64x __x) noexcept (true);


extern _Float64x exp2m1f64x (_Float64x __x) noexcept (true); extern _Float64x __exp2m1f64x (_Float64x __x) noexcept (true);


extern _Float64x exp10m1f64x (_Float64x __x) noexcept (true); extern _Float64x __exp10m1f64x (_Float64x __x) noexcept (true);


extern _Float64x log2p1f64x (_Float64x __x) noexcept (true); extern _Float64x __log2p1f64x (_Float64x __x) noexcept (true);


extern _Float64x log10p1f64x (_Float64x __x) noexcept (true); extern _Float64x __log10p1f64x (_Float64x __x) noexcept (true);


extern _Float64x logp1f64x (_Float64x __x) noexcept (true); extern _Float64x __logp1f64x (_Float64x __x) noexcept (true);




 extern _Float64x expm1f64x (_Float64x __x) noexcept (true); extern _Float64x __expm1f64x (_Float64x __x) noexcept (true);


 extern _Float64x log1pf64x (_Float64x __x) noexcept (true); extern _Float64x __log1pf64x (_Float64x __x) noexcept (true);


extern _Float64x logbf64x (_Float64x __x) noexcept (true); extern _Float64x __logbf64x (_Float64x __x) noexcept (true);




 extern _Float64x exp2f64x (_Float64x __x) noexcept (true); extern _Float64x __exp2f64x (_Float64x __x) noexcept (true);


 extern _Float64x log2f64x (_Float64x __x) noexcept (true); extern _Float64x __log2f64x (_Float64x __x) noexcept (true);






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64x sqrtf64x (_Float64x __x) noexcept (true); extern _Float64x __sqrtf64x (_Float64x __x) noexcept (true);



 extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) noexcept (true);




 extern _Float64x cbrtf64x (_Float64x __x) noexcept (true); extern _Float64x __cbrtf64x (_Float64x __x) noexcept (true);






extern _Float64x ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 213 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) noexcept (true); extern _Float64x __nanf64x (const char *__tagb) noexcept (true);
# 235 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) noexcept (true); extern _Float64x __j0f64x (_Float64x) noexcept (true);
extern _Float64x j1f64x (_Float64x) noexcept (true); extern _Float64x __j1f64x (_Float64x) noexcept (true);
extern _Float64x jnf64x (int, _Float64x) noexcept (true); extern _Float64x __jnf64x (int, _Float64x) noexcept (true);
extern _Float64x y0f64x (_Float64x) noexcept (true); extern _Float64x __y0f64x (_Float64x) noexcept (true);
extern _Float64x y1f64x (_Float64x) noexcept (true); extern _Float64x __y1f64x (_Float64x) noexcept (true);
extern _Float64x ynf64x (int, _Float64x) noexcept (true); extern _Float64x __ynf64x (int, _Float64x) noexcept (true);





 extern _Float64x erff64x (_Float64x) noexcept (true); extern _Float64x __erff64x (_Float64x) noexcept (true);
 extern _Float64x erfcf64x (_Float64x) noexcept (true); extern _Float64x __erfcf64x (_Float64x) noexcept (true);
extern _Float64x lgammaf64x (_Float64x) noexcept (true); extern _Float64x __lgammaf64x (_Float64x) noexcept (true);




extern _Float64x tgammaf64x (_Float64x) noexcept (true); extern _Float64x __tgammaf64x (_Float64x) noexcept (true);
# 267 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true);






extern _Float64x rintf64x (_Float64x __x) noexcept (true); extern _Float64x __rintf64x (_Float64x __x) noexcept (true);


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true);






extern _Float64x nextdownf64x (_Float64x __x) noexcept (true); extern _Float64x __nextdownf64x (_Float64x __x) noexcept (true);

extern _Float64x nextupf64x (_Float64x __x) noexcept (true); extern _Float64x __nextupf64x (_Float64x __x) noexcept (true);



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x scalbnf64x (_Float64x __x, int __n) noexcept (true); extern _Float64x __scalbnf64x (_Float64x __x, int __n) noexcept (true);



extern int ilogbf64x (_Float64x __x) noexcept (true); extern int __ilogbf64x (_Float64x __x) noexcept (true);




extern long int llogbf64x (_Float64x __x) noexcept (true); extern long int __llogbf64x (_Float64x __x) noexcept (true);




extern _Float64x scalblnf64x (_Float64x __x, long int __n) noexcept (true); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) noexcept (true);



extern _Float64x nearbyintf64x (_Float64x __x) noexcept (true); extern _Float64x __nearbyintf64x (_Float64x __x) noexcept (true);



extern _Float64x roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true);






extern long int lrintf64x (_Float64x __x) noexcept (true); extern long int __lrintf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llrintf64x (_Float64x __x) noexcept (true); extern long long int __llrintf64x (_Float64x __x) noexcept (true);



extern long int lroundf64x (_Float64x __x) noexcept (true); extern long int __lroundf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llroundf64x (_Float64x __x) noexcept (true); extern long long int __llroundf64x (_Float64x __x) noexcept (true);



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));



extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);




extern _Float64x roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) noexcept (true);






extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x fmaximumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64x getpayloadf64x (const _Float64x *__x) noexcept (true); extern _Float64x __getpayloadf64x (const _Float64x *__x) noexcept (true);


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) noexcept (true);


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) noexcept (true);
# 519 "/usr/include/math.h" 2 3 4
# 566 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern float fadd (double __x, double __y) noexcept (true);


extern float fdiv (double __x, double __y) noexcept (true);


extern float ffma (double __x, double __y, double __z) noexcept (true);


extern float fmul (double __x, double __y) noexcept (true);


extern float fsqrt (double __x) noexcept (true);


extern float fsub (double __x, double __y) noexcept (true);
# 567 "/usr/include/math.h" 2 3 4
# 587 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern float faddl (long double __x, long double __y) noexcept (true);


extern float fdivl (long double __x, long double __y) noexcept (true);


extern float ffmal (long double __x, long double __y, long double __z) noexcept (true);


extern float fmull (long double __x, long double __y) noexcept (true);


extern float fsqrtl (long double __x) noexcept (true);


extern float fsubl (long double __x, long double __y) noexcept (true);
# 588 "/usr/include/math.h" 2 3 4
# 616 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern double daddl (long double __x, long double __y) noexcept (true);


extern double ddivl (long double __x, long double __y) noexcept (true);


extern double dfmal (long double __x, long double __y, long double __z) noexcept (true);


extern double dmull (long double __x, long double __y) noexcept (true);


extern double dsqrtl (long double __x) noexcept (true);


extern double dsubl (long double __x, long double __y) noexcept (true);
# 617 "/usr/include/math.h" 2 3 4
# 697 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32divf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);


extern _Float32 f32mulf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32sqrtf32x (_Float32x __x) noexcept (true);


extern _Float32 f32subf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 698 "/usr/include/math.h" 2 3 4
# 707 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32divf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32 f32mulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32sqrtf64 (_Float64 __x) noexcept (true);


extern _Float32 f32subf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 708 "/usr/include/math.h" 2 3 4
# 717 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32 f32mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32sqrtf64x (_Float64x __x) noexcept (true);


extern _Float32 f32subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 718 "/usr/include/math.h" 2 3 4
# 727 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32divf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float32 f32mulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32sqrtf128 (_Float128 __x) noexcept (true);


extern _Float32 f32subf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 728 "/usr/include/math.h" 2 3 4
# 747 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xdivf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xfmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32x f32xmulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xsqrtf64 (_Float64 __x) noexcept (true);


extern _Float32x f32xsubf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 748 "/usr/include/math.h" 2 3 4
# 757 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xdivf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xfmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32x f32xmulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xsqrtf64x (_Float64x __x) noexcept (true);


extern _Float32x f32xsubf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 758 "/usr/include/math.h" 2 3 4
# 767 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xdivf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xfmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float32x f32xmulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xsqrtf128 (_Float128 __x) noexcept (true);


extern _Float32x f32xsubf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 768 "/usr/include/math.h" 2 3 4
# 787 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float64 f64mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64sqrtf64x (_Float64x __x) noexcept (true);


extern _Float64 f64subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 788 "/usr/include/math.h" 2 3 4
# 797 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64divf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float64 f64mulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64sqrtf128 (_Float128 __x) noexcept (true);


extern _Float64 f64subf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 798 "/usr/include/math.h" 2 3 4
# 817 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float64x f64xaddf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xdivf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xfmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float64x f64xmulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xsqrtf128 (_Float128 __x) noexcept (true);


extern _Float64x f64xsubf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 818 "/usr/include/math.h" 2 3 4
# 854 "/usr/include/math.h" 3 4
extern int signgam;
# 934 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 1055 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     noexcept (true) __attribute__ ((__const__));
# 46 "/usr/include/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical (float __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (double __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (long double __val) { return __iscanonicall (__val); }

inline int iscanonical (_Float128 __val) { return ((void) (__typeof (__val)) (__val), 1); }

}
# 1056 "/usr/include/math.h" 2 3 4
# 1067 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}



inline int issignaling (_Float128 __val) { return __issignalingf128 (__val); }

}
# 1098 "/usr/include/math.h" 3 4
extern "C++" {
# 1129 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 1364 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (long double __x, long double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};


template<> struct __iseqsig_type<_Float32>
{
  static int __call (_Float32 __x, _Float32 __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};



template<> struct __iseqsig_type<_Float64>
{
  static int __call (_Float64 __x, _Float64 __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};





template<> struct __iseqsig_type<_Float128>
{
  static int __call (_Float128 __x, _Float128 __y) throw ()
  {

    return __iseqsigf128 (__x, __y);



  }
};



template<> struct __iseqsig_type<_Float32x>
{
  static int __call (_Float32x __x, _Float32x __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};



template<> struct __iseqsig_type<_Float64x>
{
  static int __call (_Float64x __x, _Float64x __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};


template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 48 "/usr/include/c++/14.2.1/cmath" 2 3
# 56 "/usr/include/c++/14.2.1/cmath" 3
# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 57 "/usr/include/c++/14.2.1/cmath" 2 3
# 83 "/usr/include/c++/14.2.1/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 400 "/usr/include/c++/14.2.1/cmath" 3
  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
# 1053 "/usr/include/c++/14.2.1/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }
# 1100 "/usr/include/c++/14.2.1/cmath" 3
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 1820 "/usr/include/c++/14.2.1/cmath" 3
  using ::acosf;


  using ::acosl;



  using ::asinf;


  using ::asinl;



  using ::atanf;


  using ::atanl;



  using ::atan2f;


  using ::atan2l;



  using ::ceilf;


  using ::ceill;



  using ::cosf;


  using ::cosl;



  using ::coshf;


  using ::coshl;



  using ::expf;


  using ::expl;



  using ::fabsf;


  using ::fabsl;



  using ::floorf;


  using ::floorl;



  using ::fmodf;


  using ::fmodl;



  using ::frexpf;


  using ::frexpl;



  using ::ldexpf;


  using ::ldexpl;



  using ::logf;


  using ::logl;



  using ::log10f;


  using ::log10l;



  using ::modff;


  using ::modfl;



  using ::powf;


  using ::powl;



  using ::sinf;


  using ::sinl;



  using ::sinhf;


  using ::sinhl;



  using ::sqrtf;


  using ::sqrtl;



  using ::tanf;


  using ::tanl;



  using ::tanhf;


  using ::tanhl;
# 2085 "/usr/include/c++/14.2.1/cmath" 3
  using ::double_t;
  using ::float_t;



  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }
# 3674 "/usr/include/c++/14.2.1/cmath" 3
  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }

  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }







  template<typename _Tp>
    inline _Tp
    __hypot3(_Tp __x, _Tp __y, _Tp __z)
    {
      __x = std::abs(__x);
      __y = std::abs(__y);
      __z = std::abs(__z);
      if (_Tp __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
 return __a * std::sqrt((__x / __a) * (__x / __a)
          + (__y / __a) * (__y / __a)
          + (__z / __a) * (__z / __a));
      else
 return {};
    }

  inline float
  hypot(float __x, float __y, float __z)
  { return std::__hypot3<float>(__x, __y, __z); }

  inline double
  hypot(double __x, double __y, double __z)
  { return std::__hypot3<double>(__x, __y, __z); }

  inline long double
  hypot(long double __x, long double __y, long double __z)
  { return std::__hypot3<long double>(__x, __y, __z); }

  template<typename _Tp, typename _Up, typename _Vp>
    __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>
    hypot(_Tp __x, _Up __y, _Vp __z)
    {
      using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
      return std::__hypot3<__type>(__x, __y, __z);
    }
# 3823 "/usr/include/c++/14.2.1/cmath" 3
  template<typename _Fp>
    constexpr _Fp
    __lerp(_Fp __a, _Fp __b, _Fp __t) noexcept
    {
      if ((__a <= 0 && __b >= 0) || (__a >= 0 && __b <= 0))
 return __t * __b + (1 - __t) * __a;

      if (__t == 1)
 return __b;



      const _Fp __x = __a + __t * (__b - __a);
      return (__t > 1) == (__b > __a)
 ? (__b < __x ? __x : __b)
 : (__b > __x ? __x : __b);
    }

  constexpr float
  lerp(float __a, float __b, float __t) noexcept
  { return std::__lerp(__a, __b, __t); }

  constexpr double
  lerp(double __a, double __b, double __t) noexcept
  { return std::__lerp(__a, __b, __t); }

  constexpr long double
  lerp(long double __a, long double __b, long double __t) noexcept
  { return std::__lerp(__a, __b, __t); }

  template<typename _Tp, typename _Up, typename _Vp>
    constexpr __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>
    lerp(_Tp __x, _Up __y, _Vp __z) noexcept
    {
      using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
      return std::__lerp<__type>(__x, __y, __z);
    }
# 3894 "/usr/include/c++/14.2.1/cmath" 3

}


# 1 "/usr/include/c++/14.2.1/bits/specfun.h" 1 3
# 37 "/usr/include/c++/14.2.1/bits/specfun.h" 3
# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 38 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3






# 1 "/usr/include/c++/14.2.1/limits" 1 3
# 40 "/usr/include/c++/14.2.1/limits" 3
       
# 41 "/usr/include/c++/14.2.1/limits" 3
# 158 "/usr/include/c++/14.2.1/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "/usr/include/c++/14.2.1/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "/usr/include/c++/14.2.1/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "/usr/include/c++/14.2.1/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 383 "/usr/include/c++/14.2.1/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char8_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char8_t
      min() noexcept { return (((char8_t)(-1) < 0) ? -(((char8_t)(-1) < 0) ? (((((char8_t)1 << ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char8_t)0) - 1 : (char8_t)0); }

      static constexpr char8_t
      max() noexcept { return (((char8_t)(-1) < 0) ? (((((char8_t)1 << ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char8_t)0); }

      static constexpr char8_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char8_t) * 8 - ((char8_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char8_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char8_t
      epsilon() noexcept { return 0; }

      static constexpr char8_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
 = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char8_t
      infinity() noexcept { return char8_t(); }

      static constexpr char8_t
      quiet_NaN() noexcept { return char8_t(); }

      static constexpr char8_t
      signaling_NaN() noexcept { return char8_t(); }

      static constexpr char8_t
      denorm_min() noexcept { return char8_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
 = round_toward_zero;
    };




  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffffffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffffffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffffffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1637 "/usr/include/c++/14.2.1/limits" 3
  __extension__ template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; __extension__ template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
# 1669 "/usr/include/c++/14.2.1/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750796873653722224568e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859811704183484516925e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859811704183484516925e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309023271733240406e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570814527423731704357e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570814527423731704357e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308084726333618164062e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544176568792868221372e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502126385303097021e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502126385303097021e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443400745280086994171e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460252840593361941982e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };
# 1989 "/usr/include/c++/14.2.1/limits" 3
__extension__ template<> struct numeric_limits<_Float32> { static constexpr bool is_specialized = true; static constexpr _Float32 min() noexcept { return 1.17549435082228750796873653722224568e-38F32; } static constexpr _Float32 max() noexcept { return 3.40282346638528859811704183484516925e+38F32; } static constexpr _Float32 lowest() noexcept { return -3.40282346638528859811704183484516925e+38F32; } static constexpr int digits = 24; static constexpr int digits10 = 6; static constexpr int max_digits10 = (2 + (24) * 643L / 2136); static constexpr bool is_signed = true; static constexpr bool is_integer = false; static constexpr bool is_exact = false; static constexpr int radix = 2; static constexpr _Float32 epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F32; } static constexpr _Float32 round_error() noexcept { return 0.5F32; } static constexpr int min_exponent = (-125); static constexpr int min_exponent10 = (-37); static constexpr int max_exponent = 128; static constexpr int max_exponent10 = 38; static constexpr bool has_infinity = 1; static constexpr bool has_quiet_NaN = 1; static constexpr bool has_signaling_NaN = has_quiet_NaN; static constexpr float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr _Float32 infinity() noexcept { return __builtin_huge_valf32(); } static constexpr _Float32 quiet_NaN() noexcept { return __builtin_nanf32(""); } static constexpr _Float32 signaling_NaN() noexcept { return __builtin_nansf32(""); } static constexpr _Float32 denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F32; } static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = false; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_to_nearest; };


__extension__ template<> struct numeric_limits<_Float64> { static constexpr bool is_specialized = true; static constexpr _Float64 min() noexcept { return 2.22507385850720138309023271733240406e-308F64; } static constexpr _Float64 max() noexcept { return 1.79769313486231570814527423731704357e+308F64; } static constexpr _Float64 lowest() noexcept { return -1.79769313486231570814527423731704357e+308F64; } static constexpr int digits = 53; static constexpr int digits10 = 15; static constexpr int max_digits10 = (2 + (53) * 643L / 2136); static constexpr bool is_signed = true; static constexpr bool is_integer = false; static constexpr bool is_exact = false; static constexpr int radix = 2; static constexpr _Float64 epsilon() noexcept { return 2.22044604925031308084726333618164062e-16F64; } static constexpr _Float64 round_error() noexcept { return 0.5F64; } static constexpr int min_exponent = (-1021); static constexpr int min_exponent10 = (-307); static constexpr int max_exponent = 1024; static constexpr int max_exponent10 = 308; static constexpr bool has_infinity = 1; static constexpr bool has_quiet_NaN = 1; static constexpr bool has_signaling_NaN = has_quiet_NaN; static constexpr float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr _Float64 infinity() noexcept { return __builtin_huge_valf64(); } static constexpr _Float64 quiet_NaN() noexcept { return __builtin_nanf64(""); } static constexpr _Float64 signaling_NaN() noexcept { return __builtin_nansf64(""); } static constexpr _Float64 denorm_min() noexcept { return 4.94065645841246544176568792868221372e-324F64; } static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = false; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_to_nearest; };


__extension__ template<> struct numeric_limits<_Float128> { static constexpr bool is_specialized = true; static constexpr _Float128 min() noexcept { return 3.36210314311209350626267781732175260e-4932F128; } static constexpr _Float128 max() noexcept { return 1.18973149535723176508575932662800702e+4932F128; } static constexpr _Float128 lowest() noexcept { return -1.18973149535723176508575932662800702e+4932F128; } static constexpr int digits = 113; static constexpr int digits10 = 33; static constexpr int max_digits10 = (2 + (113) * 643L / 2136); static constexpr bool is_signed = true; static constexpr bool is_integer = false; static constexpr bool is_exact = false; static constexpr int radix = 2; static constexpr _Float128 epsilon() noexcept { return 1.92592994438723585305597794258492732e-34F128; } static constexpr _Float128 round_error() noexcept { return 0.5F128; } static constexpr int min_exponent = (-16381); static constexpr int min_exponent10 = (-4931); static constexpr int max_exponent = 16384; static constexpr int max_exponent10 = 4932; static constexpr bool has_infinity = 1; static constexpr bool has_quiet_NaN = 1; static constexpr bool has_signaling_NaN = has_quiet_NaN; static constexpr float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr _Float128 infinity() noexcept { return __builtin_huge_valf128(); } static constexpr _Float128 quiet_NaN() noexcept { return __builtin_nanf128(""); } static constexpr _Float128 signaling_NaN() noexcept { return __builtin_nansf128(""); } static constexpr _Float128 denorm_min() noexcept { return 6.47517511943802511092443895822764655e-4966F128; } static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = false; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_to_nearest; };
# 2087 "/usr/include/c++/14.2.1/limits" 3
  __extension__
  template<>
    struct numeric_limits<__float128>
    {
      static constexpr bool is_specialized = true;

      static constexpr __float128
      min() noexcept
      {




 return __extension__ 0x1.0p-16382Q;

      }

      static constexpr __float128
      max() noexcept
      {







 return __extension__ 0x1.ffffffffffffffffffffffffffffp+16383Q;

      }

      static constexpr __float128
      lowest() noexcept
      { return -max(); }

      static constexpr int digits = 113;
      static constexpr int digits10 = 33;

      static constexpr int max_digits10 = 35;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr __float128
      epsilon() noexcept
      { return double(1.9259299443872359e-34); }

      static constexpr __float128
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = -16381;
      static constexpr int min_exponent10 = -4931;
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;


      static constexpr bool has_signaling_NaN = true;



      static constexpr float_denorm_style has_denorm
 = denorm_present;
      static constexpr bool has_denorm_loss = false;

      static constexpr __float128
      infinity() noexcept
      { return __builtin_huge_val(); }

      static constexpr __float128
      quiet_NaN() noexcept
      { return __builtin_nan(""); }

      static constexpr __float128
      signaling_NaN() noexcept
      {

 return __builtin_nansq("");





      }

      static constexpr __float128
      denorm_min() noexcept
      {




 return __extension__ 0x1.0p-16494Q;

      }

      static constexpr bool is_iec559 = has_signaling_NaN;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
 = round_to_nearest;
# 2218 "/usr/include/c++/14.2.1/limits" 3
    };




}
# 45 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3


# 1 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 1 3
# 49 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
# 1 "/usr/include/c++/14.2.1/tr1/special_function_util.h" 1 3
# 39 "/usr/include/c++/14.2.1/tr1/special_function_util.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 50 "/usr/include/c++/14.2.1/tr1/special_function_util.h" 3
  namespace __detail
  {



    template<typename _Tp>
    struct __floating_point_constant
    {
      static const _Tp __value;
    };



    template<typename _Tp>
      struct __numeric_constants
      {

        static _Tp __pi() throw()
        { return static_cast<_Tp>(3.1415926535897932384626433832795029L); }

        static _Tp __pi_2() throw()
        { return static_cast<_Tp>(1.5707963267948966192313216916397514L); }

        static _Tp __pi_3() throw()
        { return static_cast<_Tp>(1.0471975511965977461542144610931676L); }

        static _Tp __pi_4() throw()
        { return static_cast<_Tp>(0.7853981633974483096156608458198757L); }

        static _Tp __1_pi() throw()
        { return static_cast<_Tp>(0.3183098861837906715377675267450287L); }

        static _Tp __2_sqrtpi() throw()
        { return static_cast<_Tp>(1.1283791670955125738961589031215452L); }

        static _Tp __sqrt2() throw()
        { return static_cast<_Tp>(1.4142135623730950488016887242096981L); }

        static _Tp __sqrt3() throw()
        { return static_cast<_Tp>(1.7320508075688772935274463415058723L); }

        static _Tp __sqrtpio2() throw()
        { return static_cast<_Tp>(1.2533141373155002512078826424055226L); }

        static _Tp __sqrt1_2() throw()
        { return static_cast<_Tp>(0.7071067811865475244008443621048490L); }

        static _Tp __lnpi() throw()
        { return static_cast<_Tp>(1.1447298858494001741434273513530587L); }

        static _Tp __gamma_e() throw()
        { return static_cast<_Tp>(0.5772156649015328606065120900824024L); }

        static _Tp __euler() throw()
        { return static_cast<_Tp>(2.7182818284590452353602874713526625L); }
      };
# 114 "/usr/include/c++/14.2.1/tr1/special_function_util.h" 3
    template<typename _Tp>
    inline bool __isnan(_Tp __x)
    { return std::isnan(__x); }
# 133 "/usr/include/c++/14.2.1/tr1/special_function_util.h" 3
  }





}
# 50 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
  namespace __detail
  {
# 76 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template <typename _Tp>
    _Tp
    __bernoulli_series(unsigned int __n)
    {

      static const _Tp __num[28] = {
        _Tp(1UL), -_Tp(1UL) / _Tp(2UL),
        _Tp(1UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(1UL) / _Tp(42UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(5UL) / _Tp(66UL), _Tp(0UL),
        -_Tp(691UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(7UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(3617UL) / _Tp(510UL), _Tp(0UL),
        _Tp(43867UL) / _Tp(798UL), _Tp(0UL),
        -_Tp(174611) / _Tp(330UL), _Tp(0UL),
        _Tp(854513UL) / _Tp(138UL), _Tp(0UL),
        -_Tp(236364091UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(8553103UL) / _Tp(6UL), _Tp(0UL)
      };

      if (__n == 0)
        return _Tp(1);

      if (__n == 1)
        return -_Tp(1) / _Tp(2);


      if (__n % 2 == 1)
        return _Tp(0);


      if (__n < 28)
        return __num[__n];


      _Tp __fact = _Tp(1);
      if ((__n / 2) % 2 == 0)
        __fact *= _Tp(-1);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __fact *= __k / (_Tp(2) * __numeric_constants<_Tp>::__pi());
      __fact *= _Tp(2);

      _Tp __sum = _Tp(0);
      for (unsigned int __i = 1; __i < 1000; ++__i)
        {
          _Tp __term = std::pow(_Tp(__i), -_Tp(__n));
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __fact * __sum;
    }
# 139 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    inline _Tp
    __bernoulli(int __n)
    { return __bernoulli_series<_Tp>(__n); }
# 153 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_bernoulli(_Tp __x)
    {
      _Tp __lg = (__x - _Tp(0.5L)) * std::log(__x) - __x
               + _Tp(0.5L) * std::log(_Tp(2)
               * __numeric_constants<_Tp>::__pi());

      const _Tp __xx = __x * __x;
      _Tp __help = _Tp(1) / __x;
      for ( unsigned int __i = 1; __i < 20; ++__i )
        {
          const _Tp __2i = _Tp(2 * __i);
          __help /= __2i * (__2i - _Tp(1)) * __xx;
          __lg += __bernoulli<_Tp>(2 * __i) * __help;
        }

      return __lg;
    }
# 181 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_lanczos(_Tp __x)
    {
      const _Tp __xm1 = __x - _Tp(1);

      static const _Tp __lanczos_cheb_7[9] = {
       _Tp( 0.99999999999980993227684700473478L),
       _Tp( 676.520368121885098567009190444019L),
       _Tp(-1259.13921672240287047156078755283L),
       _Tp( 771.3234287776530788486528258894L),
       _Tp(-176.61502916214059906584551354L),
       _Tp( 12.507343278686904814458936853L),
       _Tp(-0.13857109526572011689554707L),
       _Tp( 9.984369578019570859563e-6L),
       _Tp( 1.50563273514931155834e-7L)
      };

      static const _Tp __LOGROOT2PI
          = _Tp(0.9189385332046727417803297364056176L);

      _Tp __sum = __lanczos_cheb_7[0];
      for(unsigned int __k = 1; __k < 9; ++__k)
        __sum += __lanczos_cheb_7[__k] / (__xm1 + __k);

      const _Tp __term1 = (__xm1 + _Tp(0.5L))
                        * std::log((__xm1 + _Tp(7.5L))
                       / __numeric_constants<_Tp>::__euler());
      const _Tp __term2 = __LOGROOT2PI + std::log(__sum);
      const _Tp __result = __term1 + (__term2 - _Tp(7));

      return __result;
    }
# 225 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma(_Tp __x)
    {
      if (__x > _Tp(0.5L))
        return __log_gamma_lanczos(__x);
      else
        {
          const _Tp __sin_fact
                 = std::abs(std::sin(__numeric_constants<_Tp>::__pi() * __x));
          if (__sin_fact == _Tp(0))
            std::__throw_domain_error(("Argument is nonpositive integer " "in __log_gamma")
                                                           );
          return __numeric_constants<_Tp>::__lnpi()
                     - std::log(__sin_fact)
                     - __log_gamma_lanczos(_Tp(1) - __x);
        }
    }
# 252 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_sign(_Tp __x)
    {
      if (__x > _Tp(0))
        return _Tp(1);
      else
        {
          const _Tp __sin_fact
                  = std::sin(__numeric_constants<_Tp>::__pi() * __x);
          if (__sin_fact > _Tp(0))
            return (1);
          else if (__sin_fact < _Tp(0))
            return -_Tp(1);
          else
            return _Tp(0);
        }
    }
# 283 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      _Tp __coeff = ::std::lgamma(_Tp(1 + __n))
                  - ::std::lgamma(_Tp(1 + __k))
                  - ::std::lgamma(_Tp(1 + __n - __k));





    }
# 314 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      const _Tp __log_coeff = __log_bincoef<_Tp>(__n, __k);
      if (__log_coeff > __max_bincoeff)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return std::exp(__log_coeff);
    }
# 337 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    inline _Tp
    __gamma(_Tp __x)
    { return std::exp(__log_gamma(__x)); }
# 356 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi_series(_Tp __x)
    {
      _Tp __sum = -__numeric_constants<_Tp>::__gamma_e() - _Tp(1) / __x;
      const unsigned int __max_iter = 100000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __x / (__k * (__k + __x));
          __sum += __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
        }
      return __sum;
    }
# 386 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi_asymp(_Tp __x)
    {
      _Tp __sum = std::log(__x) - _Tp(0.5L) / __x;
      const _Tp __xx = __x * __x;
      _Tp __xp = __xx;
      const unsigned int __max_iter = 100;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __bernoulli<_Tp>(2 * __k) / (2 * __k * __xp);
          __sum -= __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
          __xp *= __xx;
        }
      return __sum;
    }
# 417 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi(_Tp __x)
    {
      const int __n = static_cast<int>(__x + 0.5L);
      const _Tp __eps = _Tp(4) * std::numeric_limits<_Tp>::epsilon();
      if (__n <= 0 && std::abs(__x - _Tp(__n)) < __eps)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x < _Tp(0))
        {
          const _Tp __pi = __numeric_constants<_Tp>::__pi();
          return __psi(_Tp(1) - __x)
               - __pi * std::cos(__pi * __x) / std::sin(__pi * __x);
        }
      else if (__x > _Tp(100))
        return __psi_asymp(__x);
      else
        return __psi_series(__x);
    }
# 446 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi(unsigned int __n, _Tp __x)
    {
      if (__x <= _Tp(0))
        std::__throw_domain_error(("Argument out of range " "in __psi")
                                                 );
      else if (__n == 0)
        return __psi(__x);
      else
        {
          const _Tp __hzeta = __hurwitz_zeta(_Tp(__n + 1), __x);

          const _Tp __ln_nfact = ::std::lgamma(_Tp(__n + 1));



          _Tp __result = std::exp(__ln_nfact) * __hzeta;
          if (__n % 2 == 1)
            __result = -__result;
          return __result;
        }
    }
  }






}
# 48 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 1 3
# 55 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
  namespace __detail
  {
# 98 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __gamma_temme(_Tp __mu,
                  _Tp & __gam1, _Tp & __gam2, _Tp & __gampl, _Tp & __gammi)
    {

      __gampl = _Tp(1) / ::std::tgamma(_Tp(1) + __mu);
      __gammi = _Tp(1) / ::std::tgamma(_Tp(1) - __mu);





      if (std::abs(__mu) < std::numeric_limits<_Tp>::epsilon())
        __gam1 = -_Tp(__numeric_constants<_Tp>::__gamma_e());
      else
        __gam1 = (__gammi - __gampl) / (_Tp(2) * __mu);

      __gam2 = (__gammi + __gampl) / (_Tp(2));

      return;
    }
# 136 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __bessel_jn(_Tp __nu, _Tp __x,
                _Tp & __Jnu, _Tp & __Nnu, _Tp & __Jpnu, _Tp & __Npnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Jnu = _Tp(1);
              __Jpnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0.5L);
            }
          else
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0);
            }
          __Nnu = -std::numeric_limits<_Tp>::infinity();
          __Npnu = std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();




      const _Tp __fp_min = std::sqrt(std::numeric_limits<_Tp>::min());
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = (__x < __x_min
                    ? static_cast<int>(__nu + _Tp(0.5L))
                    : std::max(0, static_cast<int>(__nu - __x + _Tp(1.5L))));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __w = __xi2 / __numeric_constants<_Tp>::__pi();
      int __isign = 1;
      _Tp __h = __nu * __xi;
      if (__h < __fp_min)
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for (__i = 1; __i <= __max_iter; ++__i)
        {
          __b += __xi2;
          __d = __b - __d;
          if (std::abs(__d) < __fp_min)
            __d = __fp_min;
          __c = __b - _Tp(1) / __c;
          if (std::abs(__c) < __fp_min)
            __c = __fp_min;
          __d = _Tp(1) / __d;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (__d < _Tp(0))
            __isign = -__isign;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large in __bessel_jn; " "try asymptotic expansion.")
                                                                   );
      _Tp __Jnul = __isign * __fp_min;
      _Tp __Jpnul = __h * __Jnul;
      _Tp __Jnul1 = __Jnul;
      _Tp __Jpnu1 = __Jpnul;
      _Tp __fact = __nu * __xi;
      for ( int __l = __nl; __l >= 1; --__l )
        {
          const _Tp __Jnutemp = __fact * __Jnul + __Jpnul;
          __fact -= __xi;
          __Jpnul = __fact * __Jnutemp - __Jnul;
          __Jnul = __Jnutemp;
        }
      if (__Jnul == _Tp(0))
        __Jnul = __eps;
      _Tp __f= __Jpnul / __Jnul;
      _Tp __Nmu, __Nnu1, __Npmu, __Jmu;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          _Tp __fact = (std::abs(__pimu) < __eps
                      ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          _Tp __fact2 = (std::abs(__e) < __eps
                       ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = (_Tp(2) / __numeric_constants<_Tp>::__pi())
                   * __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          __e = std::exp(__e);
          _Tp __p = __e / (__numeric_constants<_Tp>::__pi() * __gampl);
          _Tp __q = _Tp(1) / (__e * __numeric_constants<_Tp>::__pi() * __gammi);
          const _Tp __pimu2 = __pimu / _Tp(2);
          _Tp __fact3 = (std::abs(__pimu2) < __eps
                       ? _Tp(1) : std::sin(__pimu2) / __pimu2 );
          _Tp __r = __numeric_constants<_Tp>::__pi() * __pimu2 * __fact3 * __fact3;
          _Tp __c = _Tp(1);
          __d = -__x2 * __x2;
          _Tp __sum = __ff + __r * __q;
          _Tp __sum1 = __p;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / _Tp(__i);
              __p /= _Tp(__i) - __mu;
              __q /= _Tp(__i) + __mu;
              const _Tp __del = __c * (__ff + __r * __q);
              __sum += __del;
              const _Tp __del1 = __c * __p - __i * __del;
              __sum1 += __del1;
              if ( std::abs(__del) < __eps * (_Tp(1) + std::abs(__sum)) )
                break;
            }
          if ( __i > __max_iter )
            std::__throw_runtime_error(("Bessel y series failed to converge " "in __bessel_jn.")
                                                             );
          __Nmu = -__sum;
          __Nnu1 = -__sum1 * __xi2;
          __Npmu = __mu * __xi * __Nmu - __Nnu1;
          __Jmu = __w / (__Npmu - __f * __Nmu);
        }
      else
        {
          _Tp __a = _Tp(0.25L) - __mu2;
          _Tp __q = _Tp(1);
          _Tp __p = -__xi / _Tp(2);
          _Tp __br = _Tp(2) * __x;
          _Tp __bi = _Tp(2);
          _Tp __fact = __a * __xi / (__p * __p + __q * __q);
          _Tp __cr = __br + __q * __fact;
          _Tp __ci = __bi + __p * __fact;
          _Tp __den = __br * __br + __bi * __bi;
          _Tp __dr = __br / __den;
          _Tp __di = -__bi / __den;
          _Tp __dlr = __cr * __dr - __ci * __di;
          _Tp __dli = __cr * __di + __ci * __dr;
          _Tp __temp = __p * __dlr - __q * __dli;
          __q = __p * __dli + __q * __dlr;
          __p = __temp;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a += _Tp(2 * (__i - 1));
              __bi += _Tp(2);
              __dr = __a * __dr + __br;
              __di = __a * __di + __bi;
              if (std::abs(__dr) + std::abs(__di) < __fp_min)
                __dr = __fp_min;
              __fact = __a / (__cr * __cr + __ci * __ci);
              __cr = __br + __cr * __fact;
              __ci = __bi - __ci * __fact;
              if (std::abs(__cr) + std::abs(__ci) < __fp_min)
                __cr = __fp_min;
              __den = __dr * __dr + __di * __di;
              __dr /= __den;
              __di /= -__den;
              __dlr = __cr * __dr - __ci * __di;
              __dli = __cr * __di + __ci * __dr;
              __temp = __p * __dlr - __q * __dli;
              __q = __p * __dli + __q * __dlr;
              __p = __temp;
              if (std::abs(__dlr - _Tp(1)) + std::abs(__dli) < __eps)
                break;
          }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Lentz's method failed " "in __bessel_jn.")
                                                             );
          const _Tp __gam = (__p - __f) / __q;
          __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));

          __Jmu = ::std::copysign(__Jmu, __Jnul);




          __Nmu = __gam * __Jmu;
          __Npmu = (__p + __q / __gam) * __Nmu;
          __Nnu1 = __mu * __xi * __Nmu - __Npmu;
      }
      __fact = __Jmu / __Jnul;
      __Jnu = __fact * __Jnul1;
      __Jpnu = __fact * __Jpnu1;
      for (__i = 1; __i <= __nl; ++__i)
        {
          const _Tp __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;
          __Nmu = __Nnu1;
          __Nnu1 = __Nnutemp;
        }
      __Nnu = __Nmu;
      __Npnu = __nu * __xi * __Nmu - __Nnu1;

      return;
    }
# 361 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __cyl_bessel_jn_asymp(_Tp __nu, _Tp __x, _Tp & __Jnu, _Tp & __Nnu)
    {
      const _Tp __mu = _Tp(4) * __nu * __nu;
      const _Tp __8x = _Tp(8) * __x;

      _Tp __P = _Tp(0);
      _Tp __Q = _Tp(0);

      _Tp __k = _Tp(0);
      _Tp __term = _Tp(1);

      int __epsP = 0;
      int __epsQ = 0;

      _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      do
        {
          __term *= (__k == 0
                     ? _Tp(1)
                     : -(__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x));

          __epsP = std::abs(__term) < __eps * std::abs(__P);
          __P += __term;

          __k++;

          __term *= (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x);
          __epsQ = std::abs(__term) < __eps * std::abs(__Q);
          __Q += __term;

          if (__epsP && __epsQ && __k > (__nu / 2.))
            break;

          __k++;
        }
      while (__k < 1000);

      const _Tp __chi = __x - (__nu + _Tp(0.5L))
                             * __numeric_constants<_Tp>::__pi_2();

      const _Tp __c = std::cos(__chi);
      const _Tp __s = std::sin(__chi);

      const _Tp __coef = std::sqrt(_Tp(2)
                             / (__numeric_constants<_Tp>::__pi() * __x));

      __Jnu = __coef * (__c * __P - __s * __Q);
      __Nnu = __coef * (__s * __P + __c * __Q);

      return;
    }
# 444 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __cyl_bessel_ij_series(_Tp __nu, _Tp __x, _Tp __sgn,
                           unsigned int __max_iter)
    {
      if (__x == _Tp(0))
 return __nu == _Tp(0) ? _Tp(1) : _Tp(0);

      const _Tp __x2 = __x / _Tp(2);
      _Tp __fact = __nu * std::log(__x2);

      __fact -= ::std::lgamma(__nu + _Tp(1));



      __fact = std::exp(__fact);
      const _Tp __xx4 = __sgn * __x2 * __x2;
      _Tp __Jn = _Tp(1);
      _Tp __term = _Tp(1);

      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __xx4 / (_Tp(__i) * (__nu + _Tp(__i)));
          __Jn += __term;
          if (std::abs(__term / __Jn) < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      return __fact * __Jn;
    }
# 490 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_j(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_j.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, -_Tp(1), 200);
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __J_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __J_nu;
        }
    }
# 532 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_neumann_n(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_neumann_n.")
                                                            );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __N_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __N_nu;
        }
    }
# 569 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __sph_bessel_jn(unsigned int __n, _Tp __x,
                    _Tp & __j_n, _Tp & __n_n, _Tp & __jp_n, _Tp & __np_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
      __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __j_n = __factor * __J_nu;
      __n_n = __factor * __N_nu;
      __jp_n = __factor * __Jp_nu - __j_n / (_Tp(2) * __x);
      __np_n = __factor * __Np_nu - __n_n / (_Tp(2) * __x);

      return;
    }
# 604 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_bessel(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_bessel.")
                                                         );
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        {
          if (__n == 0)
            return _Tp(1);
          else
            return _Tp(0);
        }
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __j_n;
        }
    }
# 642 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_neumann(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_neumann.")
                                                          );
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        return -std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __n_n;
        }
    }
  }






}
# 49 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/beta_function.tcc" 1 3
# 49 "/usr/include/c++/14.2.1/tr1/beta_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/14.2.1/tr1/beta_function.tcc" 3
  namespace __detail
  {
# 79 "/usr/include/c++/14.2.1/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_gamma(_Tp __x, _Tp __y)
    {

      _Tp __bet;

      if (__x > __y)
        {
          __bet = ::std::tgamma(__x)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__y);
        }
      else
        {
          __bet = ::std::tgamma(__y)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__x);
        }
# 111 "/usr/include/c++/14.2.1/tr1/beta_function.tcc" 3
      return __bet;
    }
# 127 "/usr/include/c++/14.2.1/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_lgamma(_Tp __x, _Tp __y)
    {

      _Tp __bet = ::std::lgamma(__x)
                + ::std::lgamma(__y)
                - ::std::lgamma(__x + __y);





      __bet = std::exp(__bet);
      return __bet;
    }
# 158 "/usr/include/c++/14.2.1/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_product(_Tp __x, _Tp __y)
    {

      _Tp __bet = (__x + __y) / (__x * __y);

      unsigned int __max_iter = 1000000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          _Tp __term = (_Tp(1) + (__x + __y) / __k)
                     / ((_Tp(1) + __x / __k) * (_Tp(1) + __y / __k));
          __bet *= __term;
        }

      return __bet;
    }
# 189 "/usr/include/c++/14.2.1/tr1/beta_function.tcc" 3
    template<typename _Tp>
    inline _Tp
    __beta(_Tp __x, _Tp __y)
    {
      if (__isnan(__x) || __isnan(__y))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __beta_lgamma(__x, __y);
    }
  }






}
# 50 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 1 3
# 45 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 59 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
  namespace __detail
  {
# 76 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rf(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = _Tp(5) * __min;

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rf.")
                                                        );
      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim)
        std::__throw_domain_error(("Argument too small in __ellint_rf"));
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(24);
          const _Tp __c2 = _Tp(1) / _Tp(10);
          const _Tp __c3 = _Tp(3) / _Tp(44);
          const _Tp __c4 = _Tp(1) / _Tp(14);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps, _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn) / _Tp(3);
              __xndev = 2 - (__mu + __xn) / __mu;
              __yndev = 2 - (__mu + __yn) / __mu;
              __zndev = 2 - (__mu + __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }

          const _Tp __e2 = __xndev * __yndev - __zndev * __zndev;
          const _Tp __e3 = __xndev * __yndev * __zndev;
          const _Tp __s = _Tp(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2
                   + __c4 * __e3;

          return __s / std::sqrt(__mu);
        }
    }
# 153 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_1_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk / _Tp(4);
      _Tp __sum = _Tp(1) + __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          __term *= (2 * __i - 1) * __kk / (2 * __i);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __numeric_constants<_Tp>::__pi_2() * __sum;
    }
# 191 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_1(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) >= _Tp(1))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __ellint_rf(_Tp(0), _Tp(1) - __k * __k, _Tp(1));
    }
# 219 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_1(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_1."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __s = std::sin(__phi_red);
          const _Tp __c = std::cos(__phi_red);

          const _Tp __F = __s
                        * __ellint_rf(__c * __c,
                                _Tp(1) - __k * __k * __s * __s, _Tp(1));

          if (__n == 0)
            return __F;
          else
            return __F + _Tp(2) * __n * __comp_ellint_1(__k);
        }
    }
# 266 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_2_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk;
      _Tp __sum = __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          const _Tp __i2m = 2 * __i - 1;
          const _Tp __i2 = 2 * __i;
          __term *= __i2m * __i2m * __kk / (__i2 * __i2);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term / __i2m;
        }

      return __numeric_constants<_Tp>::__pi_2() * (_Tp(1) - __sum);
    }
# 314 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rd(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));
      const _Tp __max = std::numeric_limits<_Tp>::max();
      const _Tp __lolim = _Tp(2) / std::pow(__max, _Tp(2) / _Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rd.")
                                                        );
      else if (__x + __y < __lolim || __z < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rd.")
                                                        );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(6);
          const _Tp __c3 = _Tp(9) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + _Tp(3) * __zn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              _Tp __xnroot = std::sqrt(__xn);
              _Tp __ynroot = std::sqrt(__yn);
              _Tp __znroot = std::sqrt(__zn);
              _Tp __lambda = __xnroot * (__ynroot + __znroot)
                           + __ynroot * __znroot;
              __sigma += __power4 / (__znroot * (__zn + __lambda));
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }

          _Tp __ea = __xndev * __yndev;
          _Tp __eb = __zndev * __zndev;
          _Tp __ec = __ea - __eb;
          _Tp __ed = __ea - _Tp(6) * __eb;
          _Tp __ef = __ed + __ec + __ec;
          _Tp __s1 = __ed * (-__c1 + __c3 * __ed
                                   / _Tp(3) - _Tp(3) * __c4 * __zndev * __ef
                                   / _Tp(2));
          _Tp __s2 = __zndev
                   * (__c2 * __ef
                    + __zndev * (-__c3 * __ec - __zndev * __c4 - __ea));

          return _Tp(3) * __sigma + __power4 * (_Tp(1) + __s1 + __s2)
                                        / (__mu * std::sqrt(__mu));
        }
    }
# 399 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_2(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) == 1)
        return _Tp(1);
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_2."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               - __kk * __ellint_rd(_Tp(0), _Tp(1) - __kk, _Tp(1)) / _Tp(3);
        }
    }
# 433 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_2(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_2."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __E = __s
                        * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        - __kk * __sss
                        * __ellint_rd(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        / _Tp(3);

          if (__n == 0)
            return __E;
          else
            return __E + _Tp(2) * __n * __comp_ellint_2(__k);
        }
    }
# 492 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rc(_Tp __x, _Tp __y)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = _Tp(5) * __min;

      if (__x < _Tp(0) || __y < _Tp(0) || __x + __y < __lolim)
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rc.")
                                                        );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(7);
          const _Tp __c2 = _Tp(9) / _Tp(22);
          const _Tp __c3 = _Tp(3) / _Tp(10);
          const _Tp __c4 = _Tp(3) / _Tp(8);

          _Tp __xn = __x;
          _Tp __yn = __y;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(30), _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __sn;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + _Tp(2) * __yn) / _Tp(3);
              __sn = (__yn + __mu) / __mu - _Tp(2);
              if (std::abs(__sn) < __errtol)
                break;
              const _Tp __lambda = _Tp(2) * std::sqrt(__xn) * std::sqrt(__yn)
                             + __yn;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
            }

          _Tp __s = __sn * __sn
                  * (__c3 + __sn*(__c1 + __sn * (__c4 + __sn * __c2)));

          return (_Tp(1) + __s) / std::sqrt(__mu);
        }
    }
# 561 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rj(_Tp __x, _Tp __y, _Tp __z, _Tp __p)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = std::pow(_Tp(5) * __min, _Tp(1)/_Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rj.")
                                                        );
      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim || __p < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rj")
                                                       );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(3);
          const _Tp __c3 = _Tp(3) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __pn = __p;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));

          _Tp __mu;
          _Tp __xndev, __yndev, __zndev, __pndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn + _Tp(2) * __pn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              __pndev = (__mu - __pn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              __epsilon = std::max(__epsilon, std::abs(__pndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              const _Tp __alpha1 = __pn * (__xnroot + __ynroot + __znroot)
                                + __xnroot * __ynroot * __znroot;
              const _Tp __alpha2 = __alpha1 * __alpha1;
              const _Tp __beta = __pn * (__pn + __lambda)
                                      * (__pn + __lambda);
              __sigma += __power4 * __ellint_rc(__alpha2, __beta);
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
              __pn = __c0 * (__pn + __lambda);
            }

          _Tp __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;
          _Tp __eb = __xndev * __yndev * __zndev;
          _Tp __ec = __pndev * __pndev;
          _Tp __e2 = __ea - _Tp(3) * __ec;
          _Tp __e3 = __eb + _Tp(2) * __pndev * (__ea - __ec);
          _Tp __s1 = _Tp(1) + __e2 * (-__c1 + _Tp(3) * __c3 * __e2 / _Tp(4)
                            - _Tp(3) * __c4 * __e3 / _Tp(2));
          _Tp __s2 = __eb * (__c2 / _Tp(2)
                   + __pndev * (-__c3 - __c3 + __pndev * __c4));
          _Tp __s3 = __pndev * __ea * (__c2 - __pndev * __c3)
                   - __c2 * __pndev * __ec;

          return _Tp(3) * __sigma + __power4 * (__s1 + __s2 + __s3)
                                             / (__mu * std::sqrt(__mu));
        }
    }
# 661 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_3(_Tp __k, _Tp __nu)
    {

      if (__isnan(__k) || __isnan(__nu))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__nu == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_3."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               + __nu
               * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) - __nu)
               / _Tp(3);
        }
    }
# 701 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_3(_Tp __k, _Tp __nu, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_3."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __Pi = __s
                         * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                         + __nu * __sss
                         * __ellint_rj(__cc, _Tp(1) - __kk * __ss, _Tp(1),
                                       _Tp(1) - __nu * __ss) / _Tp(3);

          if (__n == 0)
            return __Pi;
          else
            return __Pi + _Tp(2) * __n * __comp_ellint_3(__k, __nu);
        }
    }
  }





}
# 51 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 1 3
# 50 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 64 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
  namespace __detail
  {
    template<typename _Tp> _Tp __expint_E1(_Tp);
# 81 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1_series(_Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(0);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= - __x / __i;
          if (std::abs(__term) < __eps)
            break;
          if (__term >= _Tp(0))
            __esum += __term / __i;
          else
            __osum += __term / __i;
        }

      return - __esum - __osum
             - __numeric_constants<_Tp>::__gamma_e() - std::log(__x);
    }
# 118 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(1);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= - __i / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          if (__term >= _Tp(0))
            __esum += __term;
          else
            __osum += __term;
        }

      return std::exp(- __x) * (__esum + __osum) / __x;
    }
# 155 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_series(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const int __nm1 = __n - 1;
      _Tp __ans = (__nm1 != 0
                ? _Tp(1) / __nm1 : -std::log(__x)
                                   - __numeric_constants<_Tp>::__gamma_e());
      _Tp __fact = _Tp(1);
      for (int __i = 1; __i <= __max_iter; ++__i)
        {
          __fact *= -__x / _Tp(__i);
          _Tp __del;
          if ( __i != __nm1 )
            __del = -__fact / _Tp(__i - __nm1);
          else
            {
              _Tp __psi = -__numeric_constants<_Tp>::gamma_e();
              for (int __ii = 1; __ii <= __nm1; ++__ii)
                __psi += _Tp(1) / _Tp(__ii);
              __del = __fact * (__psi - std::log(__x));
            }
          __ans += __del;
          if (std::abs(__del) < __eps * std::abs(__ans))
            return __ans;
        }
      std::__throw_runtime_error(("Series summation failed " "in __expint_En_series.")
                                                              );
    }
# 201 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_cont_frac(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = std::numeric_limits<_Tp>::min();
      const int __nm1 = __n - 1;
      _Tp __b = __x + _Tp(__n);
      _Tp __c = _Tp(1) / __fp_min;
      _Tp __d = _Tp(1) / __b;
      _Tp __h = __d;
      for ( unsigned int __i = 1; __i <= __max_iter; ++__i )
        {
          _Tp __a = -_Tp(__i * (__nm1 + __i));
          __b += _Tp(2);
          __d = _Tp(1) / (__a * __d + __b);
          __c = __b + __a / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            {
              const _Tp __ans = __h * std::exp(-__x);
              return __ans;
            }
        }
      std::__throw_runtime_error(("Continued fraction failed " "in __expint_En_cont_frac.")
                                                                 );
    }
# 246 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_recursion(unsigned int __n, _Tp __x)
    {
      _Tp __En;
      _Tp __E1 = __expint_E1(__x);
      if (__x < _Tp(__n))
        {

          __En = __E1;
          for (unsigned int __j = 2; __j < __n; ++__j)
            __En = (std::exp(-__x) - __x * __En) / _Tp(__j - 1);
        }
      else
        {

          __En = _Tp(1);
          const int __N = __n + 20;
          _Tp __save = _Tp(0);
          for (int __j = __N; __j > 0; --__j)
            {
              __En = (std::exp(-__x) - __j * __En) / __x;
              if (__j == __n)
                __save = __En;
            }
            _Tp __norm = __En / __E1;
            __En /= __norm;
        }

      return __En;
    }
# 290 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei_series(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __x / __i;
          __sum += __term / __i;
          if (__term < std::numeric_limits<_Tp>::epsilon() * __sum)
            break;
        }

      return __numeric_constants<_Tp>::__gamma_e() + __sum + std::log(__x);
    }
# 321 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= __i / __x;
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          if (__term >= __prev)
            break;
          __sum += __term;
        }

      return std::exp(__x) * __sum / __x;
    }
# 354 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_E1(-__x);
      else if (__x < -std::log(std::numeric_limits<_Tp>::epsilon()))
        return __expint_Ei_series(__x);
      else
        return __expint_Ei_asymp(__x);
    }
# 378 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_Ei(-__x);
      else if (__x < _Tp(1))
        return __expint_E1_series(__x);
      else if (__x < _Tp(100))
        return __expint_En_cont_frac(1, __x);
      else
        return __expint_E1_asymp(__x);
    }
# 408 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_asymp(unsigned int __n, _Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= -(__n - __i + 1) / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __x;
    }
# 442 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_large_n(unsigned int __n, _Tp __x)
    {
      const _Tp __xpn = __x + __n;
      const _Tp __xpn2 = __xpn * __xpn;
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= (__n - 2 * (__i - 1) * __x) / __xpn2;
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __xpn;
    }
# 476 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint(unsigned int __n, _Tp __x)
    {

      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n <= 1 && __x == _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __E0 = std::exp(__x) / __x;
          if (__n == 0)
            return __E0;

          _Tp __E1 = __expint_E1(__x);
          if (__n == 1)
            return __E1;

          if (__x == _Tp(0))
            return _Tp(1) / static_cast<_Tp>(__n - 1);

          _Tp __En = __expint_En_recursion(__n, __x);

          return __En;
        }
    }
# 516 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    inline _Tp
    __expint(_Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __expint_Ei(__x);
    }
  }





}
# 52 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 1 3
# 44 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 3
  namespace __detail
  {
# 83 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg_series(_Tp __a, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fac = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fac += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __conf_hyperg_series.")
                                                                  );

      return __Fac;
    }
# 120 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg_luke(_Tp __a, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a / __c;
      const _Tp __t1 = (__a + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));
      _Tp __F = _Tp(1);
      _Tp __prec;

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while(1)
        {
          _Tp __npam1 = _Tp(__n - 1) + __a;
          _Tp __npcm1 = _Tp(__n - 1) + __c;
          _Tp __npam2 = _Tp(__n - 2) + __a;
          _Tp __npcm2 = _Tp(__n - 2) + __c;
          _Tp __tnm1 = _Tp(2 * __n - 1);
          _Tp __tnm3 = _Tp(2 * __n - 3);
          _Tp __tnm5 = _Tp(2 * __n - 5);
          _Tp __F1 = (_Tp(__n - 2) - __a) / (_Tp(2) * __tnm3 * __npcm1);
          _Tp __F2 = (_Tp(__n) + __a) * __npam1
                   / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          _Tp __F3 = -__npam2 * __npam1 * (_Tp(__n - 2) - __a)
                   / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                   * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          _Tp __E = -__npam1 * (_Tp(__n - 1) - __c)
                   / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          _Tp __r = __An / __Bn;

          __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __conf_hyperg_luke.")
                                                                );

      return __F;
    }
# 227 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg(_Tp __a, _Tp __c, _Tp __x)
    {

      const _Tp __c_nint = ::std::nearbyint(__c);



      if (__isnan(__a) || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= 0)
        return std::numeric_limits<_Tp>::infinity();
      else if (__a == _Tp(0))
        return _Tp(1);
      else if (__c == __a)
        return std::exp(__x);
      else if (__x < _Tp(0))
        return __conf_hyperg_luke(__a, __c, __x);
      else
        return __conf_hyperg_series(__a, __c, __x);
    }
# 271 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg_series(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fabc = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * (__b + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fabc += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __hyperg_series.")
                                                             );

      return __Fabc;
    }







    template<typename _Tp>
    _Tp
    __hyperg_luke(_Tp __a, _Tp __b, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a * __b / __c;
      const _Tp __t1 = (__a + _Tp(1)) * (__b + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) * (__b + _Tp(2))
                     / (_Tp(2) * (__c + _Tp(1)));

      _Tp __F = _Tp(1);

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while (1)
        {
          const _Tp __npam1 = _Tp(__n - 1) + __a;
          const _Tp __npbm1 = _Tp(__n - 1) + __b;
          const _Tp __npcm1 = _Tp(__n - 1) + __c;
          const _Tp __npam2 = _Tp(__n - 2) + __a;
          const _Tp __npbm2 = _Tp(__n - 2) + __b;
          const _Tp __npcm2 = _Tp(__n - 2) + __c;
          const _Tp __tnm1 = _Tp(2 * __n - 1);
          const _Tp __tnm3 = _Tp(2 * __n - 3);
          const _Tp __tnm5 = _Tp(2 * __n - 5);
          const _Tp __n2 = __n * __n;
          const _Tp __F1 = (_Tp(3) * __n2 + (__a + __b - _Tp(6)) * __n
                         + _Tp(2) - __a * __b - _Tp(2) * (__a + __b))
                         / (_Tp(2) * __tnm3 * __npcm1);
          const _Tp __F2 = -(_Tp(3) * __n2 - (__a + __b + _Tp(6)) * __n
                         + _Tp(2) - __a * __b) * __npam1 * __npbm1
                         / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          const _Tp __F3 = (__npam2 * __npam1 * __npbm2 * __npbm1
                         * (_Tp(__n - 2) - __a) * (_Tp(__n - 2) - __b))
                         / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                         * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          const _Tp __E = -__npam1 * __npbm1 * (_Tp(__n - 1) - __c)
                         / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          const _Tp __r = __An / __Bn;

          const _Tp __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __hyperg_luke.")
                                                           );

      return __F;
    }
# 438 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg_reflect(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __d = __c - __a - __b;
      const int __intd = std::floor(__d + _Tp(0.5L));
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __toler = _Tp(1000) * __eps;
      const _Tp __log_max = std::log(std::numeric_limits<_Tp>::max());
      const bool __d_integer = (std::abs(__d - __intd) < __toler);

      if (__d_integer)
        {
          const _Tp __ln_omx = std::log(_Tp(1) - __x);
          const _Tp __ad = std::abs(__d);
          _Tp __F1, __F2;

          _Tp __d1, __d2;
          if (__d >= _Tp(0))
            {
              __d1 = __d;
              __d2 = _Tp(0);
            }
          else
            {
              __d1 = _Tp(0);
              __d2 = __d;
            }

          const _Tp __lng_c = __log_gamma(__c);


          if (__ad < __eps)
            {

              __F1 = _Tp(0);
            }
          else
            {

              bool __ok_d1 = true;
              _Tp __lng_ad, __lng_ad1, __lng_bd1;
              try
                {
                  __lng_ad = __log_gamma(__ad);
                  __lng_ad1 = __log_gamma(__a + __d1);
                  __lng_bd1 = __log_gamma(__b + __d1);
                }
              catch(...)
                {
                  __ok_d1 = false;
                }

              if (__ok_d1)
                {



                  _Tp __sum1 = _Tp(1);
                  _Tp __term = _Tp(1);
                  _Tp __ln_pre1 = __lng_ad + __lng_c + __d2 * __ln_omx
                                - __lng_ad1 - __lng_bd1;



                  for (int __i = 1; __i < __ad; ++__i)
                    {
                      const int __j = __i - 1;
                      __term *= (__a + __d2 + __j) * (__b + __d2 + __j)
                              / (_Tp(1) + __d2 + __j) / __i * (_Tp(1) - __x);
                      __sum1 += __term;
                    }

                  if (__ln_pre1 > __log_max)
                    std::__throw_runtime_error(("Overflow of gamma functions" " in __hyperg_luke.")
                                                                        );
                  else
                    __F1 = std::exp(__ln_pre1) * __sum1;
                }
              else
                {


                  __F1 = _Tp(0);
                }
            }


          bool __ok_d2 = true;
          _Tp __lng_ad2, __lng_bd2;
          try
            {
              __lng_ad2 = __log_gamma(__a + __d2);
              __lng_bd2 = __log_gamma(__b + __d2);
            }
          catch(...)
            {
              __ok_d2 = false;
            }

          if (__ok_d2)
            {


              const int __maxiter = 2000;
              const _Tp __psi_1 = -__numeric_constants<_Tp>::__gamma_e();
              const _Tp __psi_1pd = __psi(_Tp(1) + __ad);
              const _Tp __psi_apd1 = __psi(__a + __d1);
              const _Tp __psi_bpd1 = __psi(__b + __d1);

              _Tp __psi_term = __psi_1 + __psi_1pd - __psi_apd1
                             - __psi_bpd1 - __ln_omx;
              _Tp __fact = _Tp(1);
              _Tp __sum2 = __psi_term;
              _Tp __ln_pre2 = __lng_c + __d1 * __ln_omx
                            - __lng_ad2 - __lng_bd2;


              int __j;
              for (__j = 1; __j < __maxiter; ++__j)
                {


                  const _Tp __term1 = _Tp(1) / _Tp(__j)
                                    + _Tp(1) / (__ad + __j);
                  const _Tp __term2 = _Tp(1) / (__a + __d1 + _Tp(__j - 1))
                                    + _Tp(1) / (__b + __d1 + _Tp(__j - 1));
                  __psi_term += __term1 - __term2;
                  __fact *= (__a + __d1 + _Tp(__j - 1))
                          * (__b + __d1 + _Tp(__j - 1))
                          / ((__ad + __j) * __j) * (_Tp(1) - __x);
                  const _Tp __delta = __fact * __psi_term;
                  __sum2 += __delta;
                  if (std::abs(__delta) < __eps * std::abs(__sum2))
                    break;
                }
              if (__j == __maxiter)
                std::__throw_runtime_error(("Sum F2 failed to converge " "in __hyperg_reflect")
                                                                     );

              if (__sum2 == _Tp(0))
                __F2 = _Tp(0);
              else
                __F2 = std::exp(__ln_pre2) * __sum2;
            }
          else
            {


              __F2 = _Tp(0);
            }

          const _Tp __sgn_2 = (__intd % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __F = __F1 + __sgn_2 * __F2;

          return __F;
        }
      else
        {




          bool __ok1 = true;
          _Tp __sgn_g1ca = _Tp(0), __ln_g1ca = _Tp(0);
          _Tp __sgn_g1cb = _Tp(0), __ln_g1cb = _Tp(0);
          try
            {
              __sgn_g1ca = __log_gamma_sign(__c - __a);
              __ln_g1ca = __log_gamma(__c - __a);
              __sgn_g1cb = __log_gamma_sign(__c - __b);
              __ln_g1cb = __log_gamma(__c - __b);
            }
          catch(...)
            {
              __ok1 = false;
            }

          bool __ok2 = true;
          _Tp __sgn_g2a = _Tp(0), __ln_g2a = _Tp(0);
          _Tp __sgn_g2b = _Tp(0), __ln_g2b = _Tp(0);
          try
            {
              __sgn_g2a = __log_gamma_sign(__a);
              __ln_g2a = __log_gamma(__a);
              __sgn_g2b = __log_gamma_sign(__b);
              __ln_g2b = __log_gamma(__b);
            }
          catch(...)
            {
              __ok2 = false;
            }

          const _Tp __sgn_gc = __log_gamma_sign(__c);
          const _Tp __ln_gc = __log_gamma(__c);
          const _Tp __sgn_gd = __log_gamma_sign(__d);
          const _Tp __ln_gd = __log_gamma(__d);
          const _Tp __sgn_gmd = __log_gamma_sign(-__d);
          const _Tp __ln_gmd = __log_gamma(-__d);

          const _Tp __sgn1 = __sgn_gc * __sgn_gd * __sgn_g1ca * __sgn_g1cb;
          const _Tp __sgn2 = __sgn_gc * __sgn_gmd * __sgn_g2a * __sgn_g2b;

          _Tp __pre1, __pre2;
          if (__ok1 && __ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre1 < __log_max && __ln_pre2 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre2 = std::exp(__ln_pre2);
                  __pre1 *= __sgn1;
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else if (__ok1 && !__ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              if (__ln_pre1 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre1 *= __sgn1;
                  __pre2 = _Tp(0);
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else if (!__ok1 && __ok2)
            {
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre2 < __log_max)
                {
                  __pre1 = _Tp(0);
                  __pre2 = std::exp(__ln_pre2);
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else
            {
              __pre1 = _Tp(0);
              __pre2 = _Tp(0);
              std::__throw_runtime_error(("Underflow of gamma functions " "in __hyperg_reflect")
                                                                   );
            }

          const _Tp __F1 = __hyperg_series(__a, __b, _Tp(1) - __d,
                                           _Tp(1) - __x);
          const _Tp __F2 = __hyperg_series(__c - __a, __c - __b, _Tp(1) + __d,
                                           _Tp(1) - __x);

          const _Tp __F = __pre1 * __F1 + __pre2 * __F2;

          return __F;
        }
    }
# 728 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {

      const _Tp __a_nint = ::std::nearbyint(__a);
      const _Tp __b_nint = ::std::nearbyint(__b);
      const _Tp __c_nint = ::std::nearbyint(__c);





      const _Tp __toler = _Tp(1000) * std::numeric_limits<_Tp>::epsilon();
      if (std::abs(__x) >= _Tp(1))
        std::__throw_domain_error(("Argument outside unit circle " "in __hyperg.")
                                                     );
      else if (__isnan(__a) || __isnan(__b)
            || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__c - __b) < __toler || std::abs(__c - __a) < __toler)
        return std::pow(_Tp(1) - __x, __c - __a - __b);
      else if (__a >= _Tp(0) && __b >= _Tp(0) && __c >= _Tp(0)
            && __x >= _Tp(0) && __x < _Tp(0.995L))
        return __hyperg_series(__a, __b, __c, __x);
      else if (std::abs(__a) < _Tp(10) && std::abs(__b) < _Tp(10))
        {


          if (__a < _Tp(0) && std::abs(__a - __a_nint) < __toler)
            return __hyperg_series(__a_nint, __b, __c, __x);
          else if (__b < _Tp(0) && std::abs(__b - __b_nint) < __toler)
            return __hyperg_series(__a, __b_nint, __c, __x);
          else if (__x < -_Tp(0.25L))
            return __hyperg_luke(__a, __b, __c, __x);
          else if (__x < _Tp(0.5L))
            return __hyperg_series(__a, __b, __c, __x);
          else
            if (std::abs(__c) > _Tp(10))
              return __hyperg_series(__a, __b, __c, __x);
            else
              return __hyperg_reflect(__a, __b, __c, __x);
        }
      else
        return __hyperg_luke(__a, __b, __c, __x);
    }
  }






}
# 53 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/legendre_function.tcc" 1 3
# 49 "/usr/include/c++/14.2.1/tr1/legendre_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/14.2.1/tr1/legendre_function.tcc" 3
  namespace __detail
  {
# 80 "/usr/include/c++/14.2.1/tr1/legendre_function.tcc" 3
    template<typename _Tp>
    _Tp
    __poly_legendre_p(unsigned int __l, _Tp __x)
    {

      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == +_Tp(1))
        return +_Tp(1);
      else if (__x == -_Tp(1))
        return (__l % 2 == 1 ? -_Tp(1) : +_Tp(1));
      else
        {
          _Tp __p_lm2 = _Tp(1);
          if (__l == 0)
            return __p_lm2;

          _Tp __p_lm1 = __x;
          if (__l == 1)
            return __p_lm1;

          _Tp __p_l = 0;
          for (unsigned int __ll = 2; __ll <= __l; ++__ll)
            {


              __p_l = _Tp(2) * __x * __p_lm1 - __p_lm2
                    - (__x * __p_lm1 - __p_lm2) / _Tp(__ll);
              __p_lm2 = __p_lm1;
              __p_lm1 = __p_l;
            }

          return __p_l;
        }
    }
# 136 "/usr/include/c++/14.2.1/tr1/legendre_function.tcc" 3
    template<typename _Tp>
    _Tp
    __assoc_legendre_p(unsigned int __l, unsigned int __m, _Tp __x,
         _Tp __phase = _Tp(+1))
    {

      if (__m > __l)
        return _Tp(0);
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__m == 0)
        return __poly_legendre_p(__l, __x);
      else
        {
          _Tp __p_mm = _Tp(1);
          if (__m > 0)
            {


              _Tp __root = std::sqrt(_Tp(1) - __x) * std::sqrt(_Tp(1) + __x);
              _Tp __fact = _Tp(1);
              for (unsigned int __i = 1; __i <= __m; ++__i)
                {
                  __p_mm *= __phase * __fact * __root;
                  __fact += _Tp(2);
                }
            }
          if (__l == __m)
            return __p_mm;

          _Tp __p_mp1m = _Tp(2 * __m + 1) * __x * __p_mm;
          if (__l == __m + 1)
            return __p_mp1m;

          _Tp __p_lm2m = __p_mm;
          _Tp __P_lm1m = __p_mp1m;
          _Tp __p_lm = _Tp(0);
          for (unsigned int __j = __m + 2; __j <= __l; ++__j)
            {
              __p_lm = (_Tp(2 * __j - 1) * __x * __P_lm1m
                      - _Tp(__j + __m - 1) * __p_lm2m) / _Tp(__j - __m);
              __p_lm2m = __P_lm1m;
              __P_lm1m = __p_lm;
            }

          return __p_lm;
        }
    }
# 214 "/usr/include/c++/14.2.1/tr1/legendre_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      if (__isnan(__theta))
        return std::numeric_limits<_Tp>::quiet_NaN();

      const _Tp __x = std::cos(__theta);

      if (__m > __l)
        return _Tp(0);
      else if (__m == 0)
        {
          _Tp __P = __poly_legendre_p(__l, __x);
          _Tp __fact = std::sqrt(_Tp(2 * __l + 1)
                     / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          __P *= __fact;
          return __P;
        }
      else if (__x == _Tp(1) || __x == -_Tp(1))
        {

          return _Tp(0);
        }
      else
        {





          const _Tp __sgn = ( __m % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __y_mp1m_factor = __x * std::sqrt(_Tp(2 * __m + 3));

          const _Tp __lncirc = ::std::log1p(-__x * __x);





          const _Tp __lnpoch = ::std::lgamma(_Tp(__m + _Tp(0.5L)))
                             - ::std::lgamma(_Tp(__m));




          const _Tp __lnpre_val =
                    -_Tp(0.25L) * __numeric_constants<_Tp>::__lnpi()
                    + _Tp(0.5L) * (__lnpoch + __m * __lncirc);
          const _Tp __sr = std::sqrt((_Tp(2) + _Tp(1) / __m)
                         / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          _Tp __y_mm = __sgn * __sr * std::exp(__lnpre_val);
          _Tp __y_mp1m = __y_mp1m_factor * __y_mm;

          if (__l == __m)
            return __y_mm;
          else if (__l == __m + 1)
            return __y_mp1m;
          else
            {
              _Tp __y_lm = _Tp(0);


              for (unsigned int __ll = __m + 2; __ll <= __l; ++__ll)
                {
                  const _Tp __rat1 = _Tp(__ll - __m) / _Tp(__ll + __m);
                  const _Tp __rat2 = _Tp(__ll - __m - 1) / _Tp(__ll + __m - 1);
                  const _Tp __fact1 = std::sqrt(__rat1 * _Tp(2 * __ll + 1)
                                                       * _Tp(2 * __ll - 1));
                  const _Tp __fact2 = std::sqrt(__rat1 * __rat2 * _Tp(2 * __ll + 1)
                                                                / _Tp(2 * __ll - 3));
                  __y_lm = (__x * __y_mp1m * __fact1
                         - (__ll + __m - 1) * __y_mm * __fact2) / _Tp(__ll - __m);
                  __y_mm = __y_mp1m;
                  __y_mp1m = __y_lm;
                }

              return __y_lm;
            }
        }
    }
  }






}
# 54 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/modified_bessel_func.tcc" 1 3
# 51 "/usr/include/c++/14.2.1/tr1/modified_bessel_func.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/14.2.1/tr1/modified_bessel_func.tcc" 3
  namespace __detail
  {
# 83 "/usr/include/c++/14.2.1/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __bessel_ik(_Tp __nu, _Tp __x,
                _Tp & __Inu, _Tp & __Knu, _Tp & __Ipnu, _Tp & __Kpnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Inu = _Tp(1);
              __Ipnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0.5L);
            }
          else
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0);
            }
          __Knu = std::numeric_limits<_Tp>::infinity();
          __Kpnu = -std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = _Tp(10) * std::numeric_limits<_Tp>::epsilon();
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = static_cast<int>(__nu + _Tp(0.5L));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __h = __nu * __xi;
      if ( __h < __fp_min )
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for ( __i = 1; __i <= __max_iter; ++__i )
        {
          __b += __xi2;
          __d = _Tp(1) / (__b + __d);
          __c = __b + _Tp(1) / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large " "in __bessel_ik; " "try asymptotic expansion.")

                                                                   );
      _Tp __Inul = __fp_min;
      _Tp __Ipnul = __h * __Inul;
      _Tp __Inul1 = __Inul;
      _Tp __Ipnu1 = __Ipnul;
      _Tp __fact = __nu * __xi;
      for (int __l = __nl; __l >= 1; --__l)
        {
          const _Tp __Inutemp = __fact * __Inul + __Ipnul;
          __fact -= __xi;
          __Ipnul = __fact * __Inutemp + __Inul;
          __Inul = __Inutemp;
        }
      _Tp __f = __Ipnul / __Inul;
      _Tp __Kmu, __Knu1;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          const _Tp __fact = (std::abs(__pimu) < __eps
                            ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          const _Tp __fact2 = (std::abs(__e) < __eps
                            ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = __fact
                   * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          _Tp __sum = __ff;
          __e = std::exp(__e);
          _Tp __p = __e / (_Tp(2) * __gampl);
          _Tp __q = _Tp(1) / (_Tp(2) * __e * __gammi);
          _Tp __c = _Tp(1);
          __d = __x2 * __x2;
          _Tp __sum1 = __p;
          int __i;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / __i;
              __p /= __i - __mu;
              __q /= __i + __mu;
              const _Tp __del = __c * __ff;
              __sum += __del;
              const _Tp __del1 = __c * (__p - __i * __ff);
              __sum1 += __del1;
              if (std::abs(__del) < __eps * std::abs(__sum))
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Bessel k series failed to converge " "in __bessel_ik.")
                                                             );
          __Kmu = __sum;
          __Knu1 = __sum1 * __xi2;
        }
      else
        {
          _Tp __b = _Tp(2) * (_Tp(1) + __x);
          _Tp __d = _Tp(1) / __b;
          _Tp __delh = __d;
          _Tp __h = __delh;
          _Tp __q1 = _Tp(0);
          _Tp __q2 = _Tp(1);
          _Tp __a1 = _Tp(0.25L) - __mu2;
          _Tp __q = __c = __a1;
          _Tp __a = -__a1;
          _Tp __s = _Tp(1) + __q * __delh;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a -= 2 * (__i - 1);
              __c = -__a * __c / __i;
              const _Tp __qnew = (__q1 - __b * __q2) / __a;
              __q1 = __q2;
              __q2 = __qnew;
              __q += __c * __qnew;
              __b += _Tp(2);
              __d = _Tp(1) / (__b + __a * __d);
              __delh = (__b * __d - _Tp(1)) * __delh;
              __h += __delh;
              const _Tp __dels = __q * __delh;
              __s += __dels;
              if ( std::abs(__dels / __s) < __eps )
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Steed's method failed " "in __bessel_ik.")
                                                             );
          __h = __a1 * __h;
          __Kmu = std::sqrt(__numeric_constants<_Tp>::__pi() / (_Tp(2) * __x))
                * std::exp(-__x) / __s;
          __Knu1 = __Kmu * (__mu + __x + _Tp(0.5L) - __h) * __xi;
        }

      _Tp __Kpmu = __mu * __xi * __Kmu - __Knu1;
      _Tp __Inumu = __xi / (__f * __Kmu - __Kpmu);
      __Inu = __Inumu * __Inul1 / __Inul;
      __Ipnu = __Inumu * __Ipnu1 / __Inul;
      for ( __i = 1; __i <= __nl; ++__i )
        {
          const _Tp __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;
          __Kmu = __Knu1;
          __Knu1 = __Knutemp;
        }
      __Knu = __Kmu;
      __Kpnu = __nu * __xi * __Kmu - __Knu1;

      return;
    }
# 267 "/usr/include/c++/14.2.1/tr1/modified_bessel_func.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_i(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_i.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, +_Tp(1), 200);
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __I_nu;
        }
    }
# 303 "/usr/include/c++/14.2.1/tr1/modified_bessel_func.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_k(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_k.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __K_nu;
        }
    }
# 337 "/usr/include/c++/14.2.1/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __sph_bessel_ik(unsigned int __n, _Tp __x,
                    _Tp & __i_n, _Tp & __k_n, _Tp & __ip_n, _Tp & __kp_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;
      __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __i_n = __factor * __I_nu;
      __k_n = __factor * __K_nu;
      __ip_n = __factor * __Ip_nu - __i_n / (_Tp(2) * __x);
      __kp_n = __factor * __Kp_nu - __k_n / (_Tp(2) * __x);

      return;
    }
# 373 "/usr/include/c++/14.2.1/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __airy(_Tp __x, _Tp & __Ai, _Tp & __Bi, _Tp & __Aip, _Tp & __Bip)
    {
      const _Tp __absx = std::abs(__x);
      const _Tp __rootx = std::sqrt(__absx);
      const _Tp __z = _Tp(2) * __absx * __rootx / _Tp(3);
      const _Tp _S_inf = std::numeric_limits<_Tp>::infinity();

      if (__isnan(__x))
        __Bip = __Aip = __Bi = __Ai = std::numeric_limits<_Tp>::quiet_NaN();
      else if (__z == _S_inf)
        {
   __Aip = __Ai = _Tp(0);
   __Bip = __Bi = _S_inf;
 }
      else if (__z == -_S_inf)
 __Bip = __Aip = __Bi = __Ai = _Tp(0);
      else if (__x > _Tp(0))
        {
          _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;

          __bessel_ik(_Tp(1) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Ai = __rootx * __K_nu
               / (__numeric_constants<_Tp>::__sqrt3()
                * __numeric_constants<_Tp>::__pi());
          __Bi = __rootx * (__K_nu / __numeric_constants<_Tp>::__pi()
                 + _Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());

          __bessel_ik(_Tp(2) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Aip = -__x * __K_nu
                / (__numeric_constants<_Tp>::__sqrt3()
                 * __numeric_constants<_Tp>::__pi());
          __Bip = __x * (__K_nu / __numeric_constants<_Tp>::__pi()
                      + _Tp(2) * __I_nu
                      / __numeric_constants<_Tp>::__sqrt3());
        }
      else if (__x < _Tp(0))
        {
          _Tp __J_nu, __Jp_nu, __N_nu, __Np_nu;

          __bessel_jn(_Tp(1) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Ai = __rootx * (__J_nu
                    - __N_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);
          __Bi = -__rootx * (__N_nu
                    + __J_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);

          __bessel_jn(_Tp(2) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Aip = __absx * (__N_nu / __numeric_constants<_Tp>::__sqrt3()
                          + __J_nu) / _Tp(2);
          __Bip = __absx * (__J_nu / __numeric_constants<_Tp>::__sqrt3()
                          - __N_nu) / _Tp(2);
        }
      else
        {



          __Ai = _Tp(0.35502805388781723926L);
          __Bi = __Ai * __numeric_constants<_Tp>::__sqrt3();




          __Aip = -_Tp(0.25881940379280679840L);
          __Bip = -__Aip * __numeric_constants<_Tp>::__sqrt3();
        }

      return;
    }
  }





}
# 55 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/poly_hermite.tcc" 1 3
# 42 "/usr/include/c++/14.2.1/tr1/poly_hermite.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/include/c++/14.2.1/tr1/poly_hermite.tcc" 3
  namespace __detail
  {
# 72 "/usr/include/c++/14.2.1/tr1/poly_hermite.tcc" 3
    template<typename _Tp>
    _Tp
    __poly_hermite_recursion(unsigned int __n, _Tp __x)
    {

      _Tp __H_0 = 1;
      if (__n == 0)
        return __H_0;


      _Tp __H_1 = 2 * __x;
      if (__n == 1)
        return __H_1;


      _Tp __H_n, __H_nm1, __H_nm2;
      unsigned int __i;
      for (__H_nm2 = __H_0, __H_nm1 = __H_1, __i = 2; __i <= __n; ++__i)
        {
          __H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
          __H_nm2 = __H_nm1;
          __H_nm1 = __H_n;
        }

      return __H_n;
    }
# 114 "/usr/include/c++/14.2.1/tr1/poly_hermite.tcc" 3
    template<typename _Tp>
    inline _Tp
    __poly_hermite(unsigned int __n, _Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __poly_hermite_recursion(__n, __x);
    }
  }





}
# 56 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 1 3
# 44 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 3
  namespace __detail
  {
# 75 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_large_n(unsigned __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __a = -_Tp(__n);
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __eta = _Tp(2) * __b - _Tp(4) * __a;
      const _Tp __cos2th = __x / __eta;
      const _Tp __sin2th = _Tp(1) - __cos2th;
      const _Tp __th = std::acos(std::sqrt(__cos2th));
      const _Tp __pre_h = __numeric_constants<_Tp>::__pi_2()
                        * __numeric_constants<_Tp>::__pi_2()
                        * __eta * __eta * __cos2th * __sin2th;


      const _Tp __lg_b = ::std::lgamma(_Tp(__n) + __b);
      const _Tp __lnfact = ::std::lgamma(_Tp(__n + 1));





      _Tp __pre_term1 = _Tp(0.5L) * (_Tp(1) - __b)
                      * std::log(_Tp(0.25L) * __x * __eta);
      _Tp __pre_term2 = _Tp(0.25L) * std::log(__pre_h);
      _Tp __lnpre = __lg_b - __lnfact + _Tp(0.5L) * __x
                      + __pre_term1 - __pre_term2;
      _Tp __ser_term1 = std::sin(__a * __numeric_constants<_Tp>::__pi());
      _Tp __ser_term2 = std::sin(_Tp(0.25L) * __eta
                              * (_Tp(2) * __th
                               - std::sin(_Tp(2) * __th))
                               + __numeric_constants<_Tp>::__pi_4());
      _Tp __ser = __ser_term1 + __ser_term2;

      return std::exp(__lnpre) * __ser;
    }
# 129 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_hyperg(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __mx = -__x;
      const _Tp __tc_sgn = (__x < _Tp(0) ? _Tp(1)
                         : ((__n % 2 == 1) ? -_Tp(1) : _Tp(1)));

      _Tp __tc = _Tp(1);
      const _Tp __ax = std::abs(__x);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __tc *= (__ax / __k);

      _Tp __term = __tc * __tc_sgn;
      _Tp __sum = __term;
      for (int __k = int(__n) - 1; __k >= 0; --__k)
        {
          __term *= ((__b + _Tp(__k)) / _Tp(int(__n) - __k))
                  * _Tp(__k + 1) / __mx;
          __sum += __term;
        }

      return __sum;
    }
# 185 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_recursion(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {

      _Tp __l_0 = _Tp(1);
      if (__n == 0)
        return __l_0;


      _Tp __l_1 = -__x + _Tp(1) + _Tp(__alpha1);
      if (__n == 1)
        return __l_1;


      _Tp __l_n2 = __l_0;
      _Tp __l_n1 = __l_1;
      _Tp __l_n = _Tp(0);
      for (unsigned int __nn = 2; __nn <= __n; ++__nn)
        {
            __l_n = (_Tp(2 * __nn - 1) + _Tp(__alpha1) - __x)
                  * __l_n1 / _Tp(__nn)
                  - (_Tp(__nn - 1) + _Tp(__alpha1)) * __l_n2 / _Tp(__nn);
            __l_n2 = __l_n1;
            __l_n1 = __l_n;
        }

      return __l_n;
    }
# 244 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Negative argument " "in __poly_laguerre.")
                                                            );

      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n == 0)
        return _Tp(1);
      else if (__n == 1)
        return _Tp(1) + _Tp(__alpha1) - __x;
      else if (__x == _Tp(0))
        {
          _Tp __prod = _Tp(__alpha1) + _Tp(1);
          for (unsigned int __k = 2; __k <= __n; ++__k)
            __prod *= (_Tp(__alpha1) + _Tp(__k)) / _Tp(__k);
          return __prod;
        }
      else if (__n > 10000000 && _Tp(__alpha1) > -_Tp(1)
            && __x < _Tp(2) * (_Tp(__alpha1) + _Tp(1)) + _Tp(4 * __n))
        return __poly_laguerre_large_n(__n, __alpha1, __x);
      else if (_Tp(__alpha1) >= _Tp(0)
           || (__x > _Tp(0) && _Tp(__alpha1) < -_Tp(__n + 1)))
        return __poly_laguerre_recursion(__n, __alpha1, __x);
      else
        return __poly_laguerre_hyperg(__n, __alpha1, __x);
    }
# 296 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 3
    template<typename _Tp>
    inline _Tp
    __assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, __m, __x); }
# 316 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 3
    template<typename _Tp>
    inline _Tp
    __laguerre(unsigned int __n, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, 0, __x); }
  }






}
# 57 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 1 3
# 47 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
  namespace __detail
  {
# 78 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_sum(_Tp __s)
    {

      if (__s < _Tp(1))
        std::__throw_domain_error(("Bad argument in zeta sum."));

      const unsigned int max_iter = 10000;
      _Tp __zeta = _Tp(0);
      for (unsigned int __k = 1; __k < max_iter; ++__k)
        {
          _Tp __term = std::pow(static_cast<_Tp>(__k), -__s);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            {
              break;
            }
          __zeta += __term;
        }

      return __zeta;
    }
# 115 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_alt(_Tp __s)
    {
      _Tp __sgn = _Tp(1);
      _Tp __zeta = _Tp(0);
      for (unsigned int __i = 1; __i < 10000000; ++__i)
        {
          _Tp __term = __sgn / std::pow(__i, __s);
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __zeta += __term;
          __sgn *= _Tp(-1);
        }
      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
# 157 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_glob(_Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);



      if (__s < _Tp(0))
        {

          if (::std::fmod(__s,_Tp(2)) == _Tp(0))
            return _Tp(0);
          else

            {
              _Tp __zeta = __riemann_zeta_glob(_Tp(1) - __s);
              __zeta *= std::pow(_Tp(2)
                     * __numeric_constants<_Tp>::__pi(), __s)
                     * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                     * std::exp(::std::lgamma(_Tp(1) - __s))



                     / __numeric_constants<_Tp>::__pi();
              return __zeta;
            }
        }

      _Tp __num = _Tp(0.5L);
      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(1 + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term *= __num;
          __zeta += __term;
          if (std::abs(__term/__zeta) < __eps)
            break;
          __num *= _Tp(0.5L);
        }

      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
# 252 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_product(_Tp __s)
    {
      static const _Tp __prime[] = {
        _Tp(2), _Tp(3), _Tp(5), _Tp(7), _Tp(11), _Tp(13), _Tp(17), _Tp(19),
        _Tp(23), _Tp(29), _Tp(31), _Tp(37), _Tp(41), _Tp(43), _Tp(47),
        _Tp(53), _Tp(59), _Tp(61), _Tp(67), _Tp(71), _Tp(73), _Tp(79),
        _Tp(83), _Tp(89), _Tp(97), _Tp(101), _Tp(103), _Tp(107), _Tp(109)
      };
      static const unsigned int __num_primes = sizeof(__prime) / sizeof(_Tp);

      _Tp __zeta = _Tp(1);
      for (unsigned int __i = 0; __i < __num_primes; ++__i)
        {
          const _Tp __fact = _Tp(1) - std::pow(__prime[__i], -__s);
          __zeta *= __fact;
          if (_Tp(1) - __fact < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      __zeta = _Tp(1) / __zeta;

      return __zeta;
    }
# 293 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta(_Tp __s)
    {
      if (__isnan(__s))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__s == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (__s < -_Tp(19))
        {
          _Tp __zeta = __riemann_zeta_product(_Tp(1) - __s);
          __zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s)
                 * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                 * std::exp(::std::lgamma(_Tp(1) - __s))



                 / __numeric_constants<_Tp>::__pi();
          return __zeta;
        }
      else if (__s < _Tp(20))
        {

          bool __glob = true;
          if (__glob)
            return __riemann_zeta_glob(__s);
          else
            {
              if (__s > _Tp(1))
                return __riemann_zeta_sum(__s);
              else
                {
                  _Tp __zeta = std::pow(_Tp(2)
                                * __numeric_constants<_Tp>::__pi(), __s)
                         * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                             * ::std::tgamma(_Tp(1) - __s)



                             * __riemann_zeta_sum(_Tp(1) - __s);
                  return __zeta;
                }
            }
        }
      else
        return __riemann_zeta_product(__s);
    }
# 365 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __hurwitz_zeta_glob(_Tp __a, _Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);

      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(__a + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term /= _Tp(__i + 1);
          if (std::abs(__term / __zeta) < __eps)
            break;
          __zeta += __term;
        }

      __zeta /= __s - _Tp(1);

      return __zeta;
    }
# 430 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    inline _Tp
    __hurwitz_zeta(_Tp __a, _Tp __s)
    { return __hurwitz_zeta_glob(__a, __s); }
  }






}
# 58 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 203 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  assoc_laguerref(unsigned int __n, unsigned int __m, float __x)
  { return __detail::__assoc_laguerre<float>(__n, __m, __x); }







  inline long double
  assoc_laguerrel(unsigned int __n, unsigned int __m, long double __x)
  { return __detail::__assoc_laguerre<long double>(__n, __m, __x); }
# 248 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_laguerre<__type>(__n, __m, __x);
    }
# 264 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  assoc_legendref(unsigned int __l, unsigned int __m, float __x)
  { return __detail::__assoc_legendre_p<float>(__l, __m, __x); }






  inline long double
  assoc_legendrel(unsigned int __l, unsigned int __m, long double __x)
  { return __detail::__assoc_legendre_p<long double>(__l, __m, __x); }
# 294 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_legendre(unsigned int __l, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_legendre_p<__type>(__l, __m, __x);
    }
# 309 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  betaf(float __a, float __b)
  { return __detail::__beta<float>(__a, __b); }







  inline long double
  betal(long double __a, long double __b)
  { return __detail::__beta<long double>(__a, __b); }
# 339 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpb>
    inline typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type
    beta(_Tpa __a, _Tpb __b)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type __type;
      return __detail::__beta<__type>(__a, __b);
    }
# 355 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  comp_ellint_1f(float __k)
  { return __detail::__comp_ellint_1<float>(__k); }







  inline long double
  comp_ellint_1l(long double __k)
  { return __detail::__comp_ellint_1<long double>(__k); }
# 387 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_1(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_1<__type>(__k);
    }
# 403 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  comp_ellint_2f(float __k)
  { return __detail::__comp_ellint_2<float>(__k); }







  inline long double
  comp_ellint_2l(long double __k)
  { return __detail::__comp_ellint_2<long double>(__k); }
# 434 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_2(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_2<__type>(__k);
    }
# 450 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  comp_ellint_3f(float __k, float __nu)
  { return __detail::__comp_ellint_3<float>(__k, __nu); }







  inline long double
  comp_ellint_3l(long double __k, long double __nu)
  { return __detail::__comp_ellint_3<long double>(__k, __nu); }
# 485 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp, typename _Tpn>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type
    comp_ellint_3(_Tp __k, _Tpn __nu)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type __type;
      return __detail::__comp_ellint_3<__type>(__k, __nu);
    }
# 501 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  cyl_bessel_if(float __nu, float __x)
  { return __detail::__cyl_bessel_i<float>(__nu, __x); }







  inline long double
  cyl_bessel_il(long double __nu, long double __x)
  { return __detail::__cyl_bessel_i<long double>(__nu, __x); }
# 531 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_i(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_i<__type>(__nu, __x);
    }
# 547 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  cyl_bessel_jf(float __nu, float __x)
  { return __detail::__cyl_bessel_j<float>(__nu, __x); }







  inline long double
  cyl_bessel_jl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_j<long double>(__nu, __x); }
# 577 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_j(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_j<__type>(__nu, __x);
    }
# 593 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  cyl_bessel_kf(float __nu, float __x)
  { return __detail::__cyl_bessel_k<float>(__nu, __x); }







  inline long double
  cyl_bessel_kl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_k<long double>(__nu, __x); }
# 629 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_k(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_k<__type>(__nu, __x);
    }
# 645 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  cyl_neumannf(float __nu, float __x)
  { return __detail::__cyl_neumann_n<float>(__nu, __x); }







  inline long double
  cyl_neumannl(long double __nu, long double __x)
  { return __detail::__cyl_neumann_n<long double>(__nu, __x); }
# 677 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_neumann(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_neumann_n<__type>(__nu, __x);
    }
# 693 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  ellint_1f(float __k, float __phi)
  { return __detail::__ellint_1<float>(__k, __phi); }







  inline long double
  ellint_1l(long double __k, long double __phi)
  { return __detail::__ellint_1<long double>(__k, __phi); }
# 725 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_1(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_1<__type>(__k, __phi);
    }
# 741 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  ellint_2f(float __k, float __phi)
  { return __detail::__ellint_2<float>(__k, __phi); }







  inline long double
  ellint_2l(long double __k, long double __phi)
  { return __detail::__ellint_2<long double>(__k, __phi); }
# 773 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_2(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_2<__type>(__k, __phi);
    }
# 789 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  ellint_3f(float __k, float __nu, float __phi)
  { return __detail::__ellint_3<float>(__k, __nu, __phi); }







  inline long double
  ellint_3l(long double __k, long double __nu, long double __phi)
  { return __detail::__ellint_3<long double>(__k, __nu, __phi); }
# 826 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp, typename _Tpn, typename _Tpp>
    inline typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type
    ellint_3(_Tp __k, _Tpn __nu, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type __type;
      return __detail::__ellint_3<__type>(__k, __nu, __phi);
    }
# 841 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  expintf(float __x)
  { return __detail::__expint<float>(__x); }







  inline long double
  expintl(long double __x)
  { return __detail::__expint<long double>(__x); }
# 866 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    expint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__expint<__type>(__x);
    }
# 882 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  hermitef(unsigned int __n, float __x)
  { return __detail::__poly_hermite<float>(__n, __x); }







  inline long double
  hermitel(unsigned int __n, long double __x)
  { return __detail::__poly_hermite<long double>(__n, __x); }
# 914 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    hermite(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_hermite<__type>(__n, __x);
    }
# 930 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  laguerref(unsigned int __n, float __x)
  { return __detail::__laguerre<float>(__n, __x); }







  inline long double
  laguerrel(unsigned int __n, long double __x)
  { return __detail::__laguerre<long double>(__n, __x); }
# 958 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    laguerre(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__laguerre<__type>(__n, __x);
    }
# 974 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  legendref(unsigned int __l, float __x)
  { return __detail::__poly_legendre_p<float>(__l, __x); }







  inline long double
  legendrel(unsigned int __l, long double __x)
  { return __detail::__poly_legendre_p<long double>(__l, __x); }
# 1003 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    legendre(unsigned int __l, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_legendre_p<__type>(__l, __x);
    }
# 1019 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  riemann_zetaf(float __s)
  { return __detail::__riemann_zeta<float>(__s); }







  inline long double
  riemann_zetal(long double __s)
  { return __detail::__riemann_zeta<long double>(__s); }
# 1054 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    riemann_zeta(_Tp __s)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__riemann_zeta<__type>(__s);
    }
# 1070 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  sph_besself(unsigned int __n, float __x)
  { return __detail::__sph_bessel<float>(__n, __x); }







  inline long double
  sph_bessell(unsigned int __n, long double __x)
  { return __detail::__sph_bessel<long double>(__n, __x); }
# 1098 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_bessel(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_bessel<__type>(__n, __x);
    }
# 1114 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  sph_legendref(unsigned int __l, unsigned int __m, float __theta)
  { return __detail::__sph_legendre<float>(__l, __m, __theta); }
# 1125 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline long double
  sph_legendrel(unsigned int __l, unsigned int __m, long double __theta)
  { return __detail::__sph_legendre<long double>(__l, __m, __theta); }
# 1145 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_legendre<__type>(__l, __m, __theta);
    }
# 1161 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  sph_neumannf(unsigned int __n, float __x)
  { return __detail::__sph_neumann<float>(__n, __x); }







  inline long double
  sph_neumannl(unsigned int __n, long double __x)
  { return __detail::__sph_neumann<long double>(__n, __x); }
# 1189 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_neumann(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_neumann<__type>(__n, __x);
    }




}


namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 1216 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  airy_aif(float __x)
  {
    float __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Ai;
  }




  inline long double
  airy_ail(long double __x)
  {
    long double __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Ai;
  }




  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    airy_ai(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      __type __Ai, __Bi, __Aip, __Bip;
      std::__detail::__airy<__type>(__x, __Ai, __Bi, __Aip, __Bip);
      return __Ai;
    }




  inline float
  airy_bif(float __x)
  {
    float __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Bi;
  }




  inline long double
  airy_bil(long double __x)
  {
    long double __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Bi;
  }




  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    airy_bi(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      __type __Ai, __Bi, __Aip, __Bip;
      std::__detail::__airy<__type>(__x, __Ai, __Bi, __Aip, __Bip);
      return __Bi;
    }
# 1292 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  conf_hypergf(float __a, float __c, float __x)
  { return std::__detail::__conf_hyperg<float>(__a, __c, __x); }
# 1303 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline long double
  conf_hypergl(long double __a, long double __c, long double __x)
  { return std::__detail::__conf_hyperg<long double>(__a, __c, __x); }
# 1323 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type
    conf_hyperg(_Tpa __a, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type __type;
      return std::__detail::__conf_hyperg<__type>(__a, __c, __x);
    }
# 1340 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  hypergf(float __a, float __b, float __c, float __x)
  { return std::__detail::__hyperg<float>(__a, __b, __c, __x); }
# 1351 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline long double
  hypergl(long double __a, long double __b, long double __c, long double __x)
  { return std::__detail::__hyperg<long double>(__a, __b, __c, __x); }
# 1372 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpb, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type
    hyperg(_Tpa __a, _Tpb __b, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>
  ::__type __type;
      return std::__detail::__hyperg<__type>(__a, __b, __c, __x);
    }



}
# 3899 "/usr/include/c++/14.2.1/cmath" 2 3


}
# 2 "/usr/include/glm/detail/_fixes.hpp" 2 3 4
# 105 "/usr/include/glm/glm.hpp" 2 3 4

# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 107 "/usr/include/glm/glm.hpp" 2 3 4

       

# 1 "/usr/include/c++/14.2.1/cmath" 1 3 4
# 39 "/usr/include/c++/14.2.1/cmath" 3 4
       
# 40 "/usr/include/c++/14.2.1/cmath" 3
# 111 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/c++/14.2.1/climits" 1 3 4
# 39 "/usr/include/c++/14.2.1/climits" 3 4
       
# 40 "/usr/include/c++/14.2.1/climits" 3


# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/limits.h" 1 3 4
# 210 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 195 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 38 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/bits/local_lim.h" 2 3 4
# 162 "/usr/include/bits/posix1_lim.h" 2 3 4
# 196 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 200 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/bits/xopen_lim.h" 2 3 4
# 204 "/usr/include/limits.h" 2 3 4
# 211 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/limits.h" 2 3 4
# 43 "/usr/include/c++/14.2.1/climits" 2 3
# 112 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/c++/14.2.1/cfloat" 1 3 4
# 39 "/usr/include/c++/14.2.1/cfloat" 3 4
       
# 40 "/usr/include/c++/14.2.1/cfloat" 3


# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/float.h" 1 3 4
# 43 "/usr/include/c++/14.2.1/cfloat" 2 3
# 113 "/usr/include/glm/glm.hpp" 2 3 4

# 1 "/usr/include/c++/14.2.1/cassert" 1 3 4
# 41 "/usr/include/c++/14.2.1/cassert" 3 4
       
# 42 "/usr/include/c++/14.2.1/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 64 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     noexcept (true) __attribute__ ((__noreturn__));


}
# 45 "/usr/include/c++/14.2.1/cassert" 2 3
# 115 "/usr/include/glm/glm.hpp" 2 3 4


# 1 "/usr/include/glm/vec2.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/vector_bool2.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_vec2.hpp" 1 3 4



       
# 14 "/usr/include/glm/detail/type_vec2.hpp" 3 4
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<2, T, Q>
 {


  typedef T value_type;
  typedef vec<2, T, Q> type;
  typedef vec<2, bool, Q> bool_type;





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 68 "/usr/include/glm/detail/type_vec2.hpp" 3 4
   union {T x, r, s;};
   union {T y, g, t;};
# 80 "/usr/include/glm/detail/type_vec2.hpp" 3 4
#pragma GCC diagnostic pop
# 89 "/usr/include/glm/detail/type_vec2.hpp" 3 4
  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length(){return 2;}

  [[nodiscard]] constexpr T& operator[](length_type i);
  [[nodiscard]] constexpr T const& operator[](length_type i) const;



  constexpr vec() = default;
  constexpr vec(vec const& v) = default;
  template<qualifier P>
  constexpr vec(vec<2, T, P> const& v);



  constexpr explicit vec(T scalar);
  constexpr vec(T x, T y);



  template<typename U, qualifier P>
  constexpr explicit vec(vec<1, U, P> const& v);


  template<typename A, typename B>
  constexpr vec(A x, B y);
  template<typename A, typename B>
  constexpr vec(vec<1, A, Q> const& x, B y);
  template<typename A, typename B>
  constexpr vec(A x, vec<1, B, Q> const& y);
  template<typename A, typename B>
  constexpr vec(vec<1, A, Q> const& x, vec<1, B, Q> const& y);




  template<typename U, qualifier P>
  constexpr vec(vec<3, U, P> const& v);

  template<typename U, qualifier P>
  constexpr vec(vec<4, U, P> const& v);


  template<typename U, qualifier P>
  constexpr vec(vec<2, U, P> const& v);
# 146 "/usr/include/glm/detail/type_vec2.hpp" 3 4
  constexpr vec<2, T, Q> & operator=(vec const& v) = default;

  template<typename U>
  constexpr vec<2, T, Q> & operator=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator+=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator+=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator+=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator-=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator-=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator-=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator*=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator*=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator*=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator/=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator/=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator/=(vec<2, U, Q> const& v);



  constexpr vec<2, T, Q> & operator++();
  constexpr vec<2, T, Q> & operator--();
  [[nodiscard]] constexpr vec<2, T, Q> operator++(int);
  [[nodiscard]] constexpr vec<2, T, Q> operator--(int);



  template<typename U>
  constexpr vec<2, T, Q> & operator%=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator%=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator&=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator&=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator|=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator|=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator^=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator^=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator<<=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator<<=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator>>=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator>>=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator>>=(vec<2, U, Q> const& v);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator~(vec<2, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);
}


# 1 "/usr/include/glm/detail/type_vec2.inl" 1 3 4


# 1 "/usr/include/glm/detail/compute_vector_relational.hpp" 1 3 4
       


# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 5 "/usr/include/glm/detail/compute_vector_relational.hpp" 2 3 4


namespace glm{
namespace detail
{
 template <typename T, bool isFloat>
 struct compute_equal
 {
  inline constexpr static bool call(T a, T b)
  {
   return a == b;
  }
 };
# 29 "/usr/include/glm/detail/compute_vector_relational.hpp" 3 4
}
}
# 4 "/usr/include/glm/detail/type_vec2.inl" 2 3 4

namespace glm
{
# 25 "/usr/include/glm/detail/type_vec2.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr vec<2, T, Q>::vec(vec<2, T, P> const& v)
  : x(v.x), y(v.y)
 {}



 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q>::vec(T scalar)
  : x(scalar), y(scalar)
 {}

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q>::vec(T _x, T _y)
  : x(_x), y(_y)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<2, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline constexpr vec<2, T, Q>::vec(A _x, B _y)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline constexpr vec<2, T, Q>::vec(vec<1, A, Q> const& _x, B _y)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline constexpr vec<2, T, Q>::vec(A _x, vec<1, B, Q> const& _y)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline constexpr vec<2, T, Q>::vec(vec<1, A, Q> const& _x, vec<1, B, Q> const& _y)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<2, T, Q>::vec(vec<2, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<2, T, Q>::vec(vec<3, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<2, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}



 template<typename T, qualifier Q>
 inline constexpr T & vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i)
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  }
 }

 template<typename T, qualifier Q>
 inline constexpr T const& vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i) const
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  }
 }
# 145 "/usr/include/glm/detail/type_vec2.inl" 3 4
 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator=(vec<2, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  this->y += static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<2, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  this->y -= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<2, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  this->y *= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<2, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(U scalar)
 {
  this->x /= static_cast<T>(scalar);
  this->y /= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<2, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator++()
 {
  ++this->x;
  ++this->y;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator--()
 {
  --this->x;
  --this->y;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> vec<2, T, Q>::operator++(int)
 {
  vec<2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> vec<2, T, Q>::operator--(int)
 {
  vec<2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(U scalar)
 {
  this->x %= static_cast<T>(scalar);
  this->y %= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<2, U, Q> const& v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(U scalar)
 {
  this->x &= static_cast<T>(scalar);
  this->y &= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<2, U, Q> const& v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(U scalar)
 {
  this->x |= static_cast<T>(scalar);
  this->y |= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<2, U, Q> const& v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(U scalar)
 {
  this->x ^= static_cast<T>(scalar);
  this->y ^= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<2, U, Q> const& v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(U scalar)
 {
  this->x <<= static_cast<T>(scalar);
  this->y <<= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<2, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  this->y >>= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<2, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   -v.x,
   -v.y);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x + scalar,
   v.y + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.y + v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar + v.x,
   scalar + v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.x + v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.y + v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x - scalar,
   v.y - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.y - v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar - v.x,
   scalar - v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.x - v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.y - v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x * scalar,
   v.y * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.y * v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar * v.x,
   scalar * v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.x * v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.y * v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x / scalar,
   v.y / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.y / v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar / v.x,
   scalar / v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.x / v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.y / v2.y);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x % scalar,
   v.y % scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.y % v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar % v.x,
   scalar % v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.x % v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.y % v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x & scalar,
   v.y & scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.y & v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar & v.x,
   scalar & v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.x & v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.y & v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x | scalar,
   v.y | scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.y | v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar | v.x,
   scalar | v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.x | v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.y | v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x ^ scalar,
   v.y ^ scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.y ^ v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar ^ v.x,
   scalar ^ v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.x ^ v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.y ^ v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x << scalar,
   v.y << scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.y << v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar << v.x,
   scalar << v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.x << v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.y << v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x >> scalar,
   v.y >> scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.y >> v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar >> v.x,
   scalar >> v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.x >> v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.y >> v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator~(vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   ~v.x,
   ~v.y);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return !(v1 == v2);
 }

 template<qualifier Q>
 inline constexpr vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
 {
  return vec<2, bool, Q>(v1.x && v2.x, v1.y && v2.y);
 }

 template<qualifier Q>
 inline constexpr vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
 {
  return vec<2, bool, Q>(v1.x || v2.x, v1.y || v2.y);
 }
}
# 402 "/usr/include/glm/detail/type_vec2.hpp" 2 3 4
# 6 "/usr/include/glm/ext/vector_bool2.hpp" 2 3 4

namespace glm
{






 typedef vec<2, bool, defaultp> bvec2;


}
# 6 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_bool2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef vec<2, bool, highp> highp_bvec2;





 typedef vec<2, bool, mediump> mediump_bvec2;





 typedef vec<2, bool, lowp> lowp_bvec2;


}
# 7 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_float2.hpp" 1 3 4



       


namespace glm
{






 typedef vec<2, float, defaultp> vec2;


}
# 8 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_float2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef vec<2, float, highp> highp_vec2;





 typedef vec<2, float, mediump> mediump_vec2;





 typedef vec<2, float, lowp> lowp_vec2;


}
# 9 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_double2.hpp" 1 3 4



       


namespace glm
{






 typedef vec<2, double, defaultp> dvec2;


}
# 10 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_double2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef vec<2, double, highp> highp_dvec2;





 typedef vec<2, double, mediump> mediump_dvec2;





 typedef vec<2, double, lowp> lowp_dvec2;


}
# 11 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_int2.hpp" 1 3 4



       


namespace glm
{






 typedef vec<2, int, defaultp> ivec2;


}
# 12 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_int2_sized.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_int2_sized.hpp" 3 4
       


# 1 "/usr/include/glm/ext/scalar_int_sized.hpp" 1 3 4
# 13 "/usr/include/glm/ext/scalar_int_sized.hpp" 3 4
       

# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 16 "/usr/include/glm/ext/scalar_int_sized.hpp" 2 3 4





namespace glm{
namespace detail
{

  typedef std::int8_t int8;
  typedef std::int16_t int16;
  typedef std::int32_t int32;






 template<>
 struct is_int<int8>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<int16>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<int64>
 {
  enum test {value = ~0};
 };
}






 typedef detail::int8 int8;


 typedef detail::int16 int16;


 typedef detail::int32 int32;


 typedef detail::int64 int64;


}
# 18 "/usr/include/glm/ext/vector_int2_sized.hpp" 2 3 4





namespace glm
{






 typedef vec<2, int8, defaultp> i8vec2;




 typedef vec<2, int16, defaultp> i16vec2;




 typedef vec<2, int32, defaultp> i32vec2;




 typedef vec<2, int64, defaultp> i64vec2;


}
# 13 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_uint2.hpp" 1 3 4



       


namespace glm
{






 typedef vec<2, unsigned int, defaultp> uvec2;


}
# 14 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_uint2_sized.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_uint2_sized.hpp" 3 4
       


# 1 "/usr/include/glm/ext/scalar_uint_sized.hpp" 1 3 4
# 13 "/usr/include/glm/ext/scalar_uint_sized.hpp" 3 4
       

# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 16 "/usr/include/glm/ext/scalar_uint_sized.hpp" 2 3 4





namespace glm{
namespace detail
{

  typedef std::uint8_t uint8;
  typedef std::uint16_t uint16;
  typedef std::uint32_t uint32;






 template<>
 struct is_int<uint8>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<uint16>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<uint64>
 {
  enum test {value = ~0};
 };
}






 typedef detail::uint8 uint8;


 typedef detail::uint16 uint16;


 typedef detail::uint32 uint32;


 typedef detail::uint64 uint64;


}
# 18 "/usr/include/glm/ext/vector_uint2_sized.hpp" 2 3 4





namespace glm
{






 typedef vec<2, uint8, defaultp> u8vec2;




 typedef vec<2, uint16, defaultp> u16vec2;




 typedef vec<2, uint32, defaultp> u32vec2;




 typedef vec<2, uint64, defaultp> u64vec2;


}
# 15 "/usr/include/glm/vec2.hpp" 2 3 4
# 118 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/vec3.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/vector_bool3.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_vec3.hpp" 1 3 4



       
# 14 "/usr/include/glm/detail/type_vec3.hpp" 3 4
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<3, T, Q>
 {


  typedef T value_type;
  typedef vec<3, T, Q> type;
  typedef vec<3, bool, Q> bool_type;





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 72 "/usr/include/glm/detail/type_vec3.hpp" 3 4
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };
# 85 "/usr/include/glm/detail/type_vec3.hpp" 3 4
#pragma GCC diagnostic pop
# 94 "/usr/include/glm/detail/type_vec3.hpp" 3 4
  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length(){return 3;}

  [[nodiscard]] constexpr T & operator[](length_type i);
  [[nodiscard]] constexpr T const& operator[](length_type i) const;



  constexpr vec() = default;
  constexpr vec(vec const& v) = default;
  template<qualifier P>
  constexpr vec(vec<3, T, P> const& v);



  constexpr explicit vec(T scalar);
  constexpr vec(T a, T b, T c);



  template<typename U, qualifier P>
  constexpr explicit vec(vec<1, U, P> const& v);


  template<typename X, typename Y, typename Z>
  constexpr vec(X x, Y y, Z z);
  template<typename X, typename Y, typename Z>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z);




  template<typename A, typename B, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, B _z);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z);

  template<typename A, typename B, qualifier P>
  constexpr vec(A _x, vec<2, B, P> const& _yz);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz);

  template<typename U, qualifier P>
  constexpr vec(vec<4, U, P> const& v);


  template<typename U, qualifier P>
  constexpr vec(vec<3, U, P> const& v);
# 180 "/usr/include/glm/detail/type_vec3.hpp" 3 4
  constexpr vec<3, T, Q>& operator=(vec<3, T, Q> const& v) = default;

  template<typename U>
  constexpr vec<3, T, Q> & operator=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator+=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator+=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator+=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator-=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator-=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator-=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator*=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator*=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator*=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator/=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator/=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator/=(vec<3, U, Q> const& v);



  constexpr vec<3, T, Q> & operator++();
  constexpr vec<3, T, Q> & operator--();
  [[nodiscard]] constexpr vec<3, T, Q> operator++(int);
  [[nodiscard]] constexpr vec<3, T, Q> operator--(int);



  template<typename U>
  constexpr vec<3, T, Q> & operator%=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator%=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator&=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator&=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator|=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator|=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator^=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator^=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator<<=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator<<=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator>>=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator>>=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator>>=(vec<3, U, Q> const& v);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator/(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator/(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator%(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator%(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator&(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator&(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator|(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator|(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator^(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator^(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator<<(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator<<(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator>>(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator>>(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator~(vec<3, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<3, bool, Q> operator&&(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<3, bool, Q> operator||(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2);
}


# 1 "/usr/include/glm/detail/type_vec3.inl" 1 3 4




namespace glm
{
# 25 "/usr/include/glm/detail/type_vec3.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<3, T, P> const& v)
  : x(v.x), y(v.y), z(v.z)
 {}



 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q>::vec(T scalar)
  : x(scalar), y(scalar), z(scalar)
 {}

 template <typename T, qualifier Q>
 inline constexpr vec<3, T, Q>::vec(T _x, T _y, T _z)
  : x(_x), y(_y), z(_z)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.x))
  , z(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(X _x, Y _y, Z _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
 {}



 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<2, A, P> const& _xy, B _z)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<3, T, Q>::vec(A _x, vec<2, B, P> const& _yz)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<3, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
  , z(static_cast<T>(v.z))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
  , z(static_cast<T>(v.z))
 {}



 template<typename T, qualifier Q>
 inline constexpr T & vec<3, T, Q>::operator[](typename vec<3, T, Q>::length_type i)
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  switch(i)
  {
  default:
   case 0:
  return x;
   case 1:
  return y;
   case 2:
  return z;
  }
 }

 template<typename T, qualifier Q>
 inline constexpr T const& vec<3, T, Q>::operator[](typename vec<3, T, Q>::length_type i) const
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  case 2:
   return z;
  }
 }
# 214 "/usr/include/glm/detail/type_vec3.inl" 3 4
 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q>& vec<3, T, Q>::operator=(vec<3, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  this->y += static_cast<T>(scalar);
  this->z += static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.x);
  this->z += static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(vec<3, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  this->z += static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  this->y -= static_cast<T>(scalar);
  this->z -= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.x);
  this->z -= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(vec<3, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  this->z -= static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  this->y *= static_cast<T>(scalar);
  this->z *= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  this->z *= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(vec<3, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  this->z *= static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(U v)
 {
  this->x /= static_cast<T>(v);
  this->y /= static_cast<T>(v);
  this->z /= static_cast<T>(v);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  this->z /= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(vec<3, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  this->z /= static_cast<T>(v.z);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> vec<3, T, Q>::operator++(int)
 {
  vec<3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> vec<3, T, Q>::operator--(int)
 {
  vec<3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(U scalar)
 {
  this->x %= scalar;
  this->y %= scalar;
  this->z %= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  this->x %= v.x;
  this->y %= v.x;
  this->z %= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(vec<3, U, Q> const& v)
 {
  this->x %= v.x;
  this->y %= v.y;
  this->z %= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(U scalar)
 {
  this->x &= scalar;
  this->y &= scalar;
  this->z &= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  this->x &= v.x;
  this->y &= v.x;
  this->z &= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(vec<3, U, Q> const& v)
 {
  this->x &= v.x;
  this->y &= v.y;
  this->z &= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(U scalar)
 {
  this->x |= scalar;
  this->y |= scalar;
  this->z |= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  this->x |= v.x;
  this->y |= v.x;
  this->z |= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(vec<3, U, Q> const& v)
 {
  this->x |= v.x;
  this->y |= v.y;
  this->z |= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(U scalar)
 {
  this->x ^= scalar;
  this->y ^= scalar;
  this->z ^= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  this->x ^= v.x;
  this->y ^= v.x;
  this->z ^= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(vec<3, U, Q> const& v)
 {
  this->x ^= v.x;
  this->y ^= v.y;
  this->z ^= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(U scalar)
 {
  this->x <<= scalar;
  this->y <<= scalar;
  this->z <<= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  this->z <<= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(vec<3, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  this->z <<= static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  this->y >>= static_cast<T>(scalar);
  this->z >>= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.x);
  this->z >>= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(vec<3, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  this->z >>= static_cast<T>(v.z);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   -v.x,
   -v.y,
   -v.z);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x + scalar,
   v.y + scalar,
   v.z + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x + scalar.x,
   v.y + scalar.x,
   v.z + scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar + v.x,
   scalar + v.y,
   scalar + v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x + v.x,
   scalar.x + v.y,
   scalar.x + v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x + v2.x,
   v1.y + v2.y,
   v1.z + v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x - scalar,
   v.y - scalar,
   v.z - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x - scalar.x,
   v.y - scalar.x,
   v.z - scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar - v.x,
   scalar - v.y,
   scalar - v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x - v.x,
   scalar.x - v.y,
   scalar.x - v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x - v2.x,
   v1.y - v2.y,
   v1.z - v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x * scalar,
   v.y * scalar,
   v.z * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x * scalar.x,
   v.y * scalar.x,
   v.z * scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar * v.x,
   scalar * v.y,
   scalar * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x * v.x,
   scalar.x * v.y,
   scalar.x * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x * v2.x,
   v1.y * v2.y,
   v1.z * v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x / scalar,
   v.y / scalar,
   v.z / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x / scalar.x,
   v.y / scalar.x,
   v.z / scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator/(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar / v.x,
   scalar / v.y,
   scalar / v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator/(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x / v.x,
   scalar.x / v.y,
   scalar.x / v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x / v2.x,
   v1.y / v2.y,
   v1.z / v2.z);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x % scalar,
   v.y % scalar,
   v.z % scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x % scalar.x,
   v.y % scalar.x,
   v.z % scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator%(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar % v.x,
   scalar % v.y,
   scalar % v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator%(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x % v.x,
   scalar.x % v.y,
   scalar.x % v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x % v2.x,
   v1.y % v2.y,
   v1.z % v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x & scalar,
   v.y & scalar,
   v.z & scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x & scalar.x,
   v.y & scalar.x,
   v.z & scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator&(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar & v.x,
   scalar & v.y,
   scalar & v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator&(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x & v.x,
   scalar.x & v.y,
   scalar.x & v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x & v2.x,
   v1.y & v2.y,
   v1.z & v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x | scalar,
   v.y | scalar,
   v.z | scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x | scalar.x,
   v.y | scalar.x,
   v.z | scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator|(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar | v.x,
   scalar | v.y,
   scalar | v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator|(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x | v.x,
   scalar.x | v.y,
   scalar.x | v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x | v2.x,
   v1.y | v2.y,
   v1.z | v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x ^ scalar,
   v.y ^ scalar,
   v.z ^ scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x ^ scalar.x,
   v.y ^ scalar.x,
   v.z ^ scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator^(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar ^ v.x,
   scalar ^ v.y,
   scalar ^ v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator^(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x ^ v.x,
   scalar.x ^ v.y,
   scalar.x ^ v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x ^ v2.x,
   v1.y ^ v2.y,
   v1.z ^ v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x << scalar,
   v.y << scalar,
   v.z << scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x << scalar.x,
   v.y << scalar.x,
   v.z << scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator<<(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar << v.x,
   scalar << v.y,
   scalar << v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator<<(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x << v.x,
   scalar.x << v.y,
   scalar.x << v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x << v2.x,
   v1.y << v2.y,
   v1.z << v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x >> scalar,
   v.y >> scalar,
   v.z >> scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x >> scalar.x,
   v.y >> scalar.x,
   v.z >> scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator>>(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar >> v.x,
   scalar >> v.y,
   scalar >> v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator>>(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x >> v.x,
   scalar.x >> v.y,
   scalar.x >> v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x >> v2.x,
   v1.y >> v2.y,
   v1.z >> v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator~(vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   ~v.x,
   ~v.y,
   ~v.z);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y) &&
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.z, v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return !(v1 == v2);
 }

 template<qualifier Q>
 inline constexpr vec<3, bool, Q> operator&&(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2)
 {
  return vec<3, bool, Q>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z);
 }

 template<qualifier Q>
 inline constexpr vec<3, bool, Q> operator||(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2)
 {
  return vec<3, bool, Q>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z);
 }
}
# 436 "/usr/include/glm/detail/type_vec3.hpp" 2 3 4
# 6 "/usr/include/glm/ext/vector_bool3.hpp" 2 3 4

namespace glm
{






 typedef vec<3, bool, defaultp> bvec3;


}
# 6 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_bool3_precision.hpp" 1 3 4



       


namespace glm
{







 typedef vec<3, bool, highp> highp_bvec3;





 typedef vec<3, bool, mediump> mediump_bvec3;





 typedef vec<3, bool, lowp> lowp_bvec3;


}
# 7 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_float3.hpp" 1 3 4



       


namespace glm
{






 typedef vec<3, float, defaultp> vec3;


}
# 8 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_float3_precision.hpp" 1 3 4



       


namespace glm
{







 typedef vec<3, float, highp> highp_vec3;





 typedef vec<3, float, mediump> mediump_vec3;





 typedef vec<3, float, lowp> lowp_vec3;


}
# 9 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_double3.hpp" 1 3 4



       


namespace glm
{






 typedef vec<3, double, defaultp> dvec3;


}
# 10 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_double3_precision.hpp" 1 3 4



       


namespace glm
{
# 17 "/usr/include/glm/ext/vector_double3_precision.hpp" 3 4
 typedef vec<3, double, highp> highp_dvec3;






 typedef vec<3, double, mediump> mediump_dvec3;






 typedef vec<3, double, lowp> lowp_dvec3;


}
# 11 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_int3.hpp" 1 3 4



       


namespace glm
{






 typedef vec<3, int, defaultp> ivec3;


}
# 12 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_int3_sized.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_int3_sized.hpp" 3 4
       
# 23 "/usr/include/glm/ext/vector_int3_sized.hpp" 3 4
namespace glm
{






 typedef vec<3, int8, defaultp> i8vec3;




 typedef vec<3, int16, defaultp> i16vec3;




 typedef vec<3, int32, defaultp> i32vec3;




 typedef vec<3, int64, defaultp> i64vec3;


}
# 13 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_uint3.hpp" 1 3 4



       


namespace glm
{






 typedef vec<3, unsigned int, defaultp> uvec3;


}
# 14 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_uint3_sized.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_uint3_sized.hpp" 3 4
       
# 23 "/usr/include/glm/ext/vector_uint3_sized.hpp" 3 4
namespace glm
{






 typedef vec<3, uint8, defaultp> u8vec3;




 typedef vec<3, uint16, defaultp> u16vec3;




 typedef vec<3, uint32, defaultp> u32vec3;




 typedef vec<3, uint64, defaultp> u64vec3;


}
# 15 "/usr/include/glm/vec3.hpp" 2 3 4
# 119 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/vec4.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/vector_bool4.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_vec4.hpp" 1 3 4



       
# 14 "/usr/include/glm/detail/type_vec4.hpp" 3 4
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<4, T, Q>
 {


  typedef T value_type;
  typedef vec<4, T, Q> type;
  typedef vec<4, bool, Q> bool_type;





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 68 "/usr/include/glm/detail/type_vec4.hpp" 3 4
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };
   union { T w, a, q; };
# 82 "/usr/include/glm/detail/type_vec4.hpp" 3 4
#pragma GCC diagnostic pop







  typedef length_t length_type;


  [[nodiscard]] static constexpr length_type length(){return 4;}

  [[nodiscard]] constexpr T & operator[](length_type i);
  [[nodiscard]] constexpr T const& operator[](length_type i) const;



  constexpr vec() = default;
  constexpr vec(vec<4, T, Q> const& v) = default;
  template<qualifier P>
  constexpr vec(vec<4, T, P> const& v);



  constexpr explicit vec(T scalar);
  constexpr vec(T x, T y, T z, T w);



  template<typename U, qualifier P>
  constexpr explicit vec(vec<1, U, P> const& v);


  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, Y _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);




  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, B _z, C _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, C _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, B _z, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(A _x, vec<2, B, P> const& _yz, C _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, C _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(A _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(A _x, B _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, B _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(A _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<3, A, P> const& _xyz, B _w);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w);

  template<typename A, typename B, qualifier P>
  constexpr vec(A _x, vec<3, B, P> const& _yzw);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw);


  template<typename U, qualifier P>
  constexpr vec(vec<4, U, P> const& v);
# 252 "/usr/include/glm/detail/type_vec4.hpp" 3 4
  constexpr vec<4, T, Q>& operator=(vec<4, T, Q> const& v) = default;

  template<typename U>
  constexpr vec<4, T, Q>& operator=(vec<4, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator+=(U scalar);
  template<typename U>
  constexpr vec<4, T, Q>& operator+=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator+=(vec<4, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator-=(U scalar);
  template<typename U>
  constexpr vec<4, T, Q>& operator-=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator-=(vec<4, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator*=(U scalar);
  template<typename U>
  constexpr vec<4, T, Q>& operator*=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator*=(vec<4, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator/=(U scalar);
  template<typename U>
  constexpr vec<4, T, Q>& operator/=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator/=(vec<4, U, Q> const& v);



  constexpr vec<4, T, Q> & operator++();
  constexpr vec<4, T, Q> & operator--();
  [[nodiscard]] constexpr vec<4, T, Q> operator++(int);
  [[nodiscard]] constexpr vec<4, T, Q> operator--(int);



  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator%=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator%=(vec<4, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator&=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator&=(vec<4, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator|=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator|=(vec<4, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator^=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator^=(vec<4, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator<<=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator<<=(vec<4, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator>>=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator>>=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator>>=(vec<4, U, Q> const& v);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator&(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator|(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator^(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator<<(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator>>(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator~(vec<4, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);
}


# 1 "/usr/include/glm/detail/type_vec4.inl" 1 3 4




namespace glm{
namespace detail
{
 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_add
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_sub
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_mul
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_div
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_mod
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x % b.x, a.y % b.y, a.z % b.z, a.w % b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_and
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_or
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_xor
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_shift_left
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x << b.x, a.y << b.y, a.z << b.z, a.w << b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_shift_right
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x >> b.x, a.y >> b.y, a.z >> b.z, a.w >> b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_equal
 {
  inline constexpr static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
  {
   return
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.z, v2.z) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.w, v2.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_nequal
 {
  inline constexpr static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
  {
   return !compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_bitwise_not
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& v)
  {
   return vec<4, T, Q>(~v.x, ~v.y, ~v.z, ~v.w);
  }
 };
}
# 148 "/usr/include/glm/detail/type_vec4.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<4, T, P> const& v)
  : x(v.x), y(v.y), z(v.z), w(v.w)
 {}



 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q>::vec(T scalar)
  : x(scalar), y(scalar), z(scalar), w(scalar)
 {}

 template <typename T, qualifier Q>
 inline constexpr vec<4, T, Q>::vec(T _x, T _y, T _z, T _w)
  : x(_x), y(_y), z(_z), w(_w)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.x))
  , z(static_cast<T>(v.x))
  , w(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, Y _y, Z _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}



 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, B _z, C _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, C _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, B _z, vec<1, C, P> const& _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(A _x, vec<2, B, P> const& _yz, C _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, C _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(A _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(A _x, B _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, B _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(A _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, B _w)
  : x(static_cast<T>(_xyz.x))
  , y(static_cast<T>(_xyz.y))
  , z(static_cast<T>(_xyz.z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w)
  : x(static_cast<T>(_xyz.x))
  , y(static_cast<T>(_xyz.y))
  , z(static_cast<T>(_xyz.z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<4, T, Q>::vec(A _x, vec<3, B, P> const& _yzw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yzw.x))
  , z(static_cast<T>(_yzw.y))
  , w(static_cast<T>(_yzw.z))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yzw.x))
  , z(static_cast<T>(_yzw.y))
  , w(static_cast<T>(_yzw.z))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
  , z(static_cast<T>(v.z))
  , w(static_cast<T>(v.w))
 {}



 template<typename T, qualifier Q>
 inline constexpr T& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i)
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  case 2:
   return z;
  case 3:
   return w;
  }
 }

 template<typename T, qualifier Q>
 inline constexpr T const& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i) const
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  case 2:
   return z;
  case 3:
   return w;
  }
 }
# 528 "/usr/include/glm/detail/type_vec4.inl" 3 4
 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q>& vec<4, T, Q>::operator=(vec<4, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  this->w = static_cast<T>(v.w);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(U scalar)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(U scalar)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(U scalar)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(U scalar)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }



 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  ++this->w;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  --this->w;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> vec<4, T, Q>::operator++(int)
 {
  vec<4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> vec<4, T, Q>::operator--(int)
 {
  vec<4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(U scalar)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(U scalar)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(U scalar)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(U scalar)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(U scalar)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(U scalar)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }



 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(0) -= v;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) += scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) += v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(v) += scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v2) += v1;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) += v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) -= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) -= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) -= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) -= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) -= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) *= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) *= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(v) *= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v2) *= v1;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) *= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) /= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) /= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) /= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) /= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) /= v2;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) %= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) %= v2.x;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) %= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar.x) %= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) %= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) &= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<4, T, Q>(v) &= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) &= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator&(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) &= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) &= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) |= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) |= v2.x;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) |= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator|(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) |= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) |= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) ^= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) ^= v2.x;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) ^= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator^(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) ^= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) ^= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) <<= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) <<= v2.x;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) <<= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator<<(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) <<= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) <<= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) >>= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) >>= v2.x;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) >>= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator>>(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) >>= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) >>= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator~(vec<4, T, Q> const& v)
 {
  return detail::compute_vec4_bitwise_not<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return detail::compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return detail::compute_vec4_nequal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
 }

 template<qualifier Q>
 inline constexpr vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
 {
  return vec<4, bool, Q>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z, v1.w && v2.w);
 }

 template<qualifier Q>
 inline constexpr vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
 {
  return vec<4, bool, Q>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z, v1.w || v2.w);
 }
}
# 508 "/usr/include/glm/detail/type_vec4.hpp" 2 3 4
# 6 "/usr/include/glm/ext/vector_bool4.hpp" 2 3 4

namespace glm
{






 typedef vec<4, bool, defaultp> bvec4;


}
# 6 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_bool4_precision.hpp" 1 3 4



       


namespace glm
{







 typedef vec<4, bool, highp> highp_bvec4;





 typedef vec<4, bool, mediump> mediump_bvec4;





 typedef vec<4, bool, lowp> lowp_bvec4;


}
# 7 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_float4.hpp" 1 3 4



       


namespace glm
{






 typedef vec<4, float, defaultp> vec4;


}
# 8 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_float4_precision.hpp" 1 3 4



       


namespace glm
{







 typedef vec<4, float, highp> highp_vec4;





 typedef vec<4, float, mediump> mediump_vec4;





 typedef vec<4, float, lowp> lowp_vec4;


}
# 9 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_double4.hpp" 1 3 4



       


namespace glm
{






 typedef vec<4, double, defaultp> dvec4;


}
# 10 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_double4_precision.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 6 "/usr/include/glm/ext/vector_double4_precision.hpp" 2 3 4


namespace glm
{
# 18 "/usr/include/glm/ext/vector_double4_precision.hpp" 3 4
 typedef vec<4, double, highp> highp_dvec4;






 typedef vec<4, double, mediump> mediump_dvec4;






 typedef vec<4, double, lowp> lowp_dvec4;


}
# 11 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_int4.hpp" 1 3 4



       


namespace glm
{






 typedef vec<4, int, defaultp> ivec4;


}
# 12 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_int4_sized.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_int4_sized.hpp" 3 4
       
# 23 "/usr/include/glm/ext/vector_int4_sized.hpp" 3 4
namespace glm
{






 typedef vec<4, int8, defaultp> i8vec4;




 typedef vec<4, int16, defaultp> i16vec4;




 typedef vec<4, int32, defaultp> i32vec4;




 typedef vec<4, int64, defaultp> i64vec4;


}
# 13 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_uint4.hpp" 1 3 4



       


namespace glm
{






 typedef vec<4, unsigned int, defaultp> uvec4;


}
# 14 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_uint4_sized.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_uint4_sized.hpp" 3 4
       
# 23 "/usr/include/glm/ext/vector_uint4_sized.hpp" 3 4
namespace glm
{






 typedef vec<4, uint8, defaultp> u8vec4;




 typedef vec<4, uint16, defaultp> u16vec4;




 typedef vec<4, uint32, defaultp> u32vec4;




 typedef vec<4, uint64, defaultp> u64vec4;


}
# 15 "/usr/include/glm/vec4.hpp" 2 3 4
# 120 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/mat2x2.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double2x2.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat2x2.hpp" 1 3 4



       





namespace glm
{
 template<typename T, qualifier Q>
 struct mat<2, 2, T, Q>
 {
  typedef vec<2, T, Q> col_type;
  typedef vec<2, T, Q> row_type;
  typedef mat<2, 2, T, Q> type;
  typedef mat<2, 2, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 2; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<2, 2, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T const& x1, T const& y1,
   T const& x2, T const& y2);
  constexpr mat(
   col_type const& v1,
   col_type const& v2);



  template<typename U, typename V, typename M, typename N>
  constexpr mat(
   U const& x1, V const& y1,
   M const& x2, N const& y2);

  template<typename U, typename V>
  constexpr mat(
   vec<2, U, Q> const& v1,
   vec<2, V, Q> const& v2);



  template<typename U, qualifier P>
  constexpr mat(mat<2, 2, U, P> const& m);

  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<2, 2, T, Q> & operator=(mat<2, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator+=(mat<2, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator-=(mat<2, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator*=(mat<2, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator/=(U s);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator/=(mat<2, 2, U, Q> const& m);



  constexpr mat<2, 2, T, Q> & operator++ ();
  constexpr mat<2, 2, T, Q> & operator-- ();
  [[nodiscard]] constexpr mat<2, 2, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<2, 2, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator+(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator-(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator*(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 2, T, Q>::col_type operator*(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 2, T, Q>::row_type operator*(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator/(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 2, T, Q>::col_type operator/(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 2, T, Q>::row_type operator/(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);
}


# 1 "/usr/include/glm/detail/type_mat2x2.inl" 1 3 4
# 1 "/usr/include/glm/matrix.hpp" 1 3 4
# 13 "/usr/include/glm/matrix.hpp" 3 4
       



# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 18 "/usr/include/glm/matrix.hpp" 2 3 4




# 1 "/usr/include/glm/mat2x3.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double2x3.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat2x3.hpp" 1 3 4



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<2, 3, T, Q>
 {
  typedef vec<3, T, Q> col_type;
  typedef vec<2, T, Q> row_type;
  typedef mat<2, 3, T, Q> type;
  typedef mat<3, 2, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 2; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<2, 3, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0, T z0,
   T x1, T y1, T z1);
  constexpr mat(
   col_type const& v0,
   col_type const& v1);



  template<typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
  constexpr mat(
   X1 x1, Y1 y1, Z1 z1,
   X2 x2, Y2 y2, Z2 z2);

  template<typename U, typename V>
  constexpr mat(
   vec<3, U, Q> const& v1,
   vec<3, V, Q> const& v2);



  template<typename U, qualifier P>
  constexpr mat(mat<2, 3, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<2, 3, T, Q> & operator=(mat<2, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator+=(mat<2, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator-=(mat<2, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator/=(U s);



  constexpr mat<2, 3, T, Q> & operator++ ();
  constexpr mat<2, 3, T, Q> & operator-- ();
  [[nodiscard]] constexpr mat<2, 3, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<2, 3, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator*(T scalar, mat<2, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 3, T, Q>::col_type operator*(mat<2, 3, T, Q> const& m, typename mat<2, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 3, T, Q>::row_type operator*(typename mat<2, 3, T, Q>::col_type const& v, mat<2, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator/(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator/(T scalar, mat<2, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);
}


# 1 "/usr/include/glm/detail/type_mat2x3.inl" 1 3 4
namespace glm
{
# 19 "/usr/include/glm/detail/type_mat2x3.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<2, 3, T, Q>::mat(mat<2, 3, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(T scalar)

   : value{col_type(scalar, 0, 0), col_type(0, scalar, 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat
 (
  T x0, T y0, T z0,
  T x1, T y1, T z1
 )

   : value{col_type(x0, y0, z0), col_type(x1, y1, z1)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(col_type const& v0, col_type const& v1)

   : value{col_type(v0), col_type(v1)}

 {




 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2>
 inline constexpr mat<2, 3, T, Q>::mat
 (
  X1 x1, Y1 y1, Z1 z1,
  X2 x2, Y2 y2, Z2 z2
 )

   : value{col_type(x1, y1, z1), col_type(x2, y2, z2)}

 {




 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2>
 inline constexpr mat<2, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2)

   : value{col_type(v1), col_type(v2)}

 {




 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<2, 3, T, Q>::mat(mat<2, 3, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

  : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 3, T, Q>::col_type & mat<2, 3, T, Q>::operator[](typename mat<2, 3, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 3, T, Q>::col_type const& mat<2, 3, T, Q>::operator[](typename mat<2, 3, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator=(mat<2, 3, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator+=(mat<2, 3, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator-=(mat<2, 3, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> mat<2, 3, T, Q>::operator++(int)
 {
  mat<2, 3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> mat<2, 3, T, Q>::operator--(int)
 {
  mat<2, 3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m)
 {
  return mat<2, 3, T, Q>(
   -m[0],
   -m[1]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator*(T scalar, mat<2, 3, T, Q> const& m)
 {
  return mat<2, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 3, T, Q>::col_type operator*
 (
  mat<2, 3, T, Q> const& m,
  typename mat<2, 3, T, Q>::row_type const& v)
 {
  return typename mat<2, 3, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 3, T, Q>::row_type operator*
 (
  typename mat<2, 3, T, Q>::col_type const& v,
  mat<2, 3, T, Q> const& m)
 {
  return typename mat<2, 3, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];

  mat<3, 3, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator/(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator/(T scalar, mat<2, 3, T, Q> const& m)
 {
  return mat<2, 3, T, Q>(
   scalar / m[0],
   scalar / m[1]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 159 "/usr/include/glm/detail/type_mat2x3.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double2x3.hpp" 2 3 4

namespace glm
{






 typedef mat<2, 3, double, defaultp> dmat2x3;


}
# 6 "/usr/include/glm/mat2x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double2x3_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<2, 3, double, lowp> lowp_dmat2x3;





 typedef mat<2, 3, double, mediump> mediump_dmat2x3;





 typedef mat<2, 3, double, highp> highp_dmat2x3;


}
# 7 "/usr/include/glm/mat2x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float2x3.hpp" 1 3 4



       


namespace glm
{






 typedef mat<2, 3, float, defaultp> mat2x3;


}
# 8 "/usr/include/glm/mat2x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float2x3_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<2, 3, float, lowp> lowp_mat2x3;





 typedef mat<2, 3, float, mediump> mediump_mat2x3;





 typedef mat<2, 3, float, highp> highp_mat2x3;


}
# 9 "/usr/include/glm/mat2x3.hpp" 2 3 4
# 23 "/usr/include/glm/matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat2x4.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double2x4.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat2x4.hpp" 1 3 4



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<2, 4, T, Q>
 {
  typedef vec<4, T, Q> col_type;
  typedef vec<2, T, Q> row_type;
  typedef mat<2, 4, T, Q> type;
  typedef mat<4, 2, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 2; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<2, 4, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0, T z0, T w0,
   T x1, T y1, T z1, T w1);
  constexpr mat(
   col_type const& v0,
   col_type const& v1);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2>
  constexpr mat(
   X1 x1, Y1 y1, Z1 z1, W1 w1,
   X2 x2, Y2 y2, Z2 z2, W2 w2);

  template<typename U, typename V>
  constexpr mat(
   vec<4, U, Q> const& v1,
   vec<4, V, Q> const& v2);



  template<typename U, qualifier P>
  constexpr mat(mat<2, 4, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<2, 4, T, Q> & operator=(mat<2, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator+=(mat<2, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator-=(mat<2, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator/=(U s);



  constexpr mat<2, 4, T, Q> & operator++ ();
  constexpr mat<2, 4, T, Q> & operator-- ();
  [[nodiscard]] constexpr mat<2, 4, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<2, 4, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator*(T scalar, mat<2, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 4, T, Q>::col_type operator*(mat<2, 4, T, Q> const& m, typename mat<2, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 4, T, Q>::row_type operator*(typename mat<2, 4, T, Q>::col_type const& v, mat<2, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator/(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator/(T scalar, mat<2, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);
}


# 1 "/usr/include/glm/detail/type_mat2x4.inl" 1 3 4
namespace glm
{
# 19 "/usr/include/glm/detail/type_mat2x4.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<2, 4, T, Q>::mat(mat<2, 4, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(T s)

   : value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat
 (
  T x0, T y0, T z0, T w0,
  T x1, T y1, T z1, T w1
 )

   : value{col_type(x0, y0, z0, w0), col_type(x1, y1, z1, w1)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(col_type const& v0, col_type const& v1)

   : value{col_type(v0), col_type(v1)}

 {




 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2>
 inline constexpr mat<2, 4, T, Q>::mat
 (
  X1 x1, Y1 y1, Z1 z1, W1 w1,
  X2 x2, Y2 y2, Z2 z2, W2 w2
 )

   : value{
    col_type(x1, y1, z1, w1),
    col_type(x2, y2, z2, w2)}

 {




 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2>
 inline constexpr mat<2, 4, T, Q>::mat(vec<4, V1, Q> const& v1, vec<4, V2, Q> const& v2)

   : value{col_type(v1), col_type(v2)}

 {




 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<2, 4, T, Q>::mat(mat<2, 4, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 4, T, Q>::col_type & mat<2, 4, T, Q>::operator[](typename mat<2, 4, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 4, T, Q>::col_type const& mat<2, 4, T, Q>::operator[](typename mat<2, 4, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator=(mat<2, 4, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator+=(mat<2, 4, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator-=(mat<2, 4, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q> & mat<2, 4, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> mat<2, 4, T, Q>::operator++(int)
 {
  mat<2, 4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> mat<2, 4, T, Q>::operator--(int)
 {
  mat<2, 4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m)
 {
  return mat<2, 4, T, Q>(
   -m[0],
   -m[1]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator*(T scalar, mat<2, 4, T, Q> const& m)
 {
  return mat<2, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 4, T, Q>::col_type operator*(mat<2, 4, T, Q> const& m, typename mat<2, 4, T, Q>::row_type const& v)
 {
  return typename mat<2, 4, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y,
   m[0][3] * v.x + m[1][3] * v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 4, T, Q>::row_type operator*(typename mat<2, 4, T, Q>::col_type const& v, mat<2, 4, T, Q> const& m)
 {
  return typename mat<2, 4, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA03 = m1[0][3];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];
  T SrcA13 = m1[1][3];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];
  T SrcB30 = m2[3][0];
  T SrcB31 = m2[3][1];

  mat<4, 4, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator/(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator/(T scalar, mat<2, 4, T, Q> const& m)
 {
  return mat<2, 4, T, Q>(
   scalar / m[0],
   scalar / m[1]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 161 "/usr/include/glm/detail/type_mat2x4.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double2x4.hpp" 2 3 4

namespace glm
{






 typedef mat<2, 4, double, defaultp> dmat2x4;


}
# 6 "/usr/include/glm/mat2x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double2x4_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<2, 4, double, lowp> lowp_dmat2x4;





 typedef mat<2, 4, double, mediump> mediump_dmat2x4;





 typedef mat<2, 4, double, highp> highp_dmat2x4;


}
# 7 "/usr/include/glm/mat2x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float2x4.hpp" 1 3 4



       


namespace glm
{






 typedef mat<2, 4, float, defaultp> mat2x4;


}
# 8 "/usr/include/glm/mat2x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float2x4_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<2, 4, float, lowp> lowp_mat2x4;





 typedef mat<2, 4, float, mediump> mediump_mat2x4;





 typedef mat<2, 4, float, highp> highp_mat2x4;


}
# 9 "/usr/include/glm/mat2x4.hpp" 2 3 4
# 24 "/usr/include/glm/matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat3x2.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double3x2.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat3x2.hpp" 1 3 4



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<3, 2, T, Q>
 {
  typedef vec<2, T, Q> col_type;
  typedef vec<3, T, Q> row_type;
  typedef mat<3, 2, T, Q> type;
  typedef mat<2, 3, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 3; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<3, 2, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0,
   T x1, T y1,
   T x2, T y2);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2);



  template<
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3>
   constexpr mat(
   X1 x1, Y1 y1,
   X2 x2, Y2 y2,
   X3 x3, Y3 y3);

  template<typename V1, typename V2, typename V3>
  constexpr mat(
   vec<2, V1, Q> const& v1,
   vec<2, V2, Q> const& v2,
   vec<2, V3, Q> const& v3);



  template<typename U, qualifier P>
  constexpr mat(mat<3, 2, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<3, 2, T, Q> & operator=(mat<3, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator+=(mat<3, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator-=(mat<3, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator/=(U s);



  constexpr mat<3, 2, T, Q> & operator++ ();
  constexpr mat<3, 2, T, Q> & operator-- ();
  [[nodiscard]] constexpr mat<3, 2, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<3, 2, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator*(T scalar, mat<3, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 2, T, Q>::col_type operator*(mat<3, 2, T, Q> const& m, typename mat<3, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 2, T, Q>::row_type operator*(typename mat<3, 2, T, Q>::col_type const& v, mat<3, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator/(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator/(T scalar, mat<3, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

}


# 1 "/usr/include/glm/detail/type_mat3x2.inl" 1 3 4
namespace glm
{
# 20 "/usr/include/glm/detail/type_mat3x2.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<3, 2, T, Q>::mat(mat<3, 2, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(T s)

   : value{col_type(s, 0), col_type(0, s), col_type(0, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat
 (
  T x0, T y0,
  T x1, T y1,
  T x2, T y2
 )

   : value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0,
  typename X1, typename Y1,
  typename X2, typename Y2>
 inline constexpr mat<3, 2, T, Q>::mat
 (
  X0 x0, Y0 y0,
  X1 x1, Y1 y1,
  X2 x2, Y2 y2
 )

   : value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2)}

 {





 }

 template<typename T, qualifier Q>
 template<typename V0, typename V1, typename V2>
 inline constexpr mat<3, 2, T, Q>::mat(vec<2, V0, Q> const& v0, vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<3, 2, T, Q>::mat(mat<3, 2, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 2, T, Q>::col_type & mat<3, 2, T, Q>::operator[](typename mat<3, 2, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 2, T, Q>::col_type const& mat<3, 2, T, Q>::operator[](typename mat<3, 2, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator=(mat<3, 2, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator+=(mat<3, 2, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator-=(mat<3, 2, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q> & mat<3, 2, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> mat<3, 2, T, Q>::operator++(int)
 {
  mat<3, 2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> mat<3, 2, T, Q>::operator--(int)
 {
  mat<3, 2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m)
 {
  return mat<3, 2, T, Q>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator*(T scalar, mat<3, 2, T, Q> const& m)
 {
  return mat<3, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 2, T, Q>::col_type operator*(mat<3, 2, T, Q> const& m, typename mat<3, 2, T, Q>::row_type const& v)
 {
  return typename mat<3, 2, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 2, T, Q>::row_type operator*(typename mat<3, 2, T, Q>::col_type const& v, mat<3, 2, T, Q> const& m)
 {
  return typename mat<3, 2, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];

  mat<2, 2, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator/(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator/(T scalar, mat<3, 2, T, Q> const& m)
 {
  return mat<3, 2, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 167 "/usr/include/glm/detail/type_mat3x2.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double3x2.hpp" 2 3 4

namespace glm
{






 typedef mat<3, 2, double, defaultp> dmat3x2;


}
# 6 "/usr/include/glm/mat3x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double3x2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<3, 2, double, lowp> lowp_dmat3x2;





 typedef mat<3, 2, double, mediump> mediump_dmat3x2;





 typedef mat<3, 2, double, highp> highp_dmat3x2;


}
# 7 "/usr/include/glm/mat3x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float3x2.hpp" 1 3 4



       


namespace glm
{






 typedef mat<3, 2, float, defaultp> mat3x2;


}
# 8 "/usr/include/glm/mat3x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float3x2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<3, 2, float, lowp> lowp_mat3x2;





 typedef mat<3, 2, float, mediump> mediump_mat3x2;





 typedef mat<3, 2, float, highp> highp_mat3x2;


}
# 9 "/usr/include/glm/mat3x2.hpp" 2 3 4
# 25 "/usr/include/glm/matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat3x3.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double3x3.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat3x3.hpp" 1 3 4



       





namespace glm
{
 template<typename T, qualifier Q>
 struct mat<3, 3, T, Q>
 {
  typedef vec<3, T, Q> col_type;
  typedef vec<3, T, Q> row_type;
  typedef mat<3, 3, T, Q> type;
  typedef mat<3, 3, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 3; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<3, 3, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0, T z0,
   T x1, T y1, T z1,
   T x2, T y2, T z2);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2);



  template<
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3>
  constexpr mat(
   X1 x1, Y1 y1, Z1 z1,
   X2 x2, Y2 y2, Z2 z2,
   X3 x3, Y3 y3, Z3 z3);

  template<typename V1, typename V2, typename V3>
  constexpr mat(
   vec<3, V1, Q> const& v1,
   vec<3, V2, Q> const& v2,
   vec<3, V3, Q> const& v3);



  template<typename U, qualifier P>
  constexpr mat(mat<3, 3, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<3, 3, T, Q> & operator=(mat<3, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator+=(mat<3, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator-=(mat<3, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator*=(mat<3, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator/=(U s);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator/=(mat<3, 3, U, Q> const& m);



  constexpr mat<3, 3, T, Q> & operator++();
  constexpr mat<3, 3, T, Q> & operator--();
  [[nodiscard]] constexpr mat<3, 3, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<3, 3, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator+(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator-(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator*(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 3, T, Q>::col_type operator*(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 3, T, Q>::row_type operator*(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator/(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 3, T, Q>::col_type operator/(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 3, T, Q>::row_type operator/(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);
}


# 1 "/usr/include/glm/detail/type_mat3x3.inl" 1 3 4


namespace glm
{
# 22 "/usr/include/glm/detail/type_mat3x3.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<3, 3, T, Q>::mat(mat<3, 3, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(T s)

   : value{col_type(s, 0, 0), col_type(0, s, 0), col_type(0, 0, s)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat
 (
  T x0, T y0, T z0,
  T x1, T y1, T z1,
  T x2, T y2, T z2
 )

   : value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3>
 inline constexpr mat<3, 3, T, Q>::mat
 (
  X1 x1, Y1 y1, Z1 z1,
  X2 x2, Y2 y2, Z2 z2,
  X3 x3, Y3 y3, Z3 z3
 )

   : value{col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}

 {





 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3>
 inline constexpr mat<3, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2, vec<3, V3, Q> const& v3)

   : value{col_type(v1), col_type(v2), col_type(v3)}

 {





 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<3, 3, T, Q>::mat(mat<3, 3, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::col_type & mat<3, 3, T, Q>::operator[](typename mat<3, 3, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::col_type const& mat<3, 3, T, Q>::operator[](typename mat<3, 3, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator=(mat<3, 3, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator+=(mat<3, 3, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator-=(mat<3, 3, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator*=(mat<3, 3, U, Q> const& m)
 {
  return (*this = *this * m);
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator/=(mat<3, 3, U, Q> const& m)
 {
  return *this *= inverse(m);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> mat<3, 3, T, Q>::operator++(int)
 {
  mat<3, 3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> mat<3, 3, T, Q>::operator--(int)
 {
  mat<3, 3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator+(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 3, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator-(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   scalar - m[0],
   scalar - m[1],
   scalar - m[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 3, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator*(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::col_type operator*(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v)
 {
  return typename mat<3, 3, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::row_type operator*(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m)
 {
  return typename mat<3, 3, T, Q>::row_type(
   m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
   m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
   m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];

  mat<3, 3, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator/(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::col_type operator/(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v)
 {
  return inverse(m) * v;
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::row_type operator/(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m)
 {
  return v * inverse(m);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  mat<3, 3, T, Q> m1_copy(m1);
  return m1_copy /= m2;
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 184 "/usr/include/glm/detail/type_mat3x3.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double3x3.hpp" 2 3 4

namespace glm
{






 typedef mat<3, 3, double, defaultp> dmat3x3;




 typedef mat<3, 3, double, defaultp> dmat3;


}
# 6 "/usr/include/glm/mat3x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double3x3_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<3, 3, double, lowp> lowp_dmat3;





 typedef mat<3, 3, double, mediump> mediump_dmat3;





 typedef mat<3, 3, double, highp> highp_dmat3;





 typedef mat<3, 3, double, lowp> lowp_dmat3x3;





 typedef mat<3, 3, double, mediump> mediump_dmat3x3;





 typedef mat<3, 3, double, highp> highp_dmat3x3;


}
# 7 "/usr/include/glm/mat3x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float3x3.hpp" 1 3 4



       


namespace glm
{






 typedef mat<3, 3, float, defaultp> mat3x3;




 typedef mat<3, 3, float, defaultp> mat3;


}
# 8 "/usr/include/glm/mat3x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float3x3_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<3, 3, float, lowp> lowp_mat3;





 typedef mat<3, 3, float, mediump> mediump_mat3;





 typedef mat<3, 3, float, highp> highp_mat3;





 typedef mat<3, 3, float, lowp> lowp_mat3x3;





 typedef mat<3, 3, float, mediump> mediump_mat3x3;





 typedef mat<3, 3, float, highp> highp_mat3x3;


}
# 9 "/usr/include/glm/mat3x3.hpp" 2 3 4
# 26 "/usr/include/glm/matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat3x4.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double3x4.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat3x4.hpp" 1 3 4



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<3, 4, T, Q>
 {
  typedef vec<4, T, Q> col_type;
  typedef vec<3, T, Q> row_type;
  typedef mat<3, 4, T, Q> type;
  typedef mat<4, 3, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 3; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<3, 4, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0, T z0, T w0,
   T x1, T y1, T z1, T w1,
   T x2, T y2, T z2, T w2);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3>
  constexpr mat(
   X1 x1, Y1 y1, Z1 z1, W1 w1,
   X2 x2, Y2 y2, Z2 z2, W2 w2,
   X3 x3, Y3 y3, Z3 z3, W3 w3);

  template<typename V1, typename V2, typename V3>
  constexpr mat(
   vec<4, V1, Q> const& v1,
   vec<4, V2, Q> const& v2,
   vec<4, V3, Q> const& v3);



  template<typename U, qualifier P>
  constexpr mat(mat<3, 4, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<3, 4, T, Q> & operator=(mat<3, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator+=(mat<3, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator-=(mat<3, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator/=(U s);



  constexpr mat<3, 4, T, Q> & operator++();
  constexpr mat<3, 4, T, Q> & operator--();
  [[nodiscard]] constexpr mat<3, 4, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<3, 4, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator*(T scalar, mat<3, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 4, T, Q>::col_type operator*(mat<3, 4, T, Q> const& m, typename mat<3, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 4, T, Q>::row_type operator*(typename mat<3, 4, T, Q>::col_type const& v, mat<3, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator/(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator/(T scalar, mat<3, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);
}


# 1 "/usr/include/glm/detail/type_mat3x4.inl" 1 3 4
namespace glm
{
# 20 "/usr/include/glm/detail/type_mat3x4.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<3, 4, T, Q>::mat(mat<3, 4, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(T s)

   : value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0), col_type(0, 0, s, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat
 (
  T x0, T y0, T z0, T w0,
  T x1, T y1, T z1, T w1,
  T x2, T y2, T z2, T w2
 )

   : value{
    col_type(x0, y0, z0, w0),
    col_type(x1, y1, z1, w1),
    col_type(x2, y2, z2, w2)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0, typename Z0, typename W0,
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2>
 inline constexpr mat<3, 4, T, Q>::mat
 (
  X0 x0, Y0 y0, Z0 z0, W0 w0,
  X1 x1, Y1 y1, Z1 z1, W1 w1,
  X2 x2, Y2 y2, Z2 z2, W2 w2
 )

   : value{
    col_type(x0, y0, z0, w0),
    col_type(x1, y1, z1, w1),
    col_type(x2, y2, z2, w2)}

 {





 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3>
 inline constexpr mat<3, 4, T, Q>::mat(vec<4, V1, Q> const& v0, vec<4, V2, Q> const& v1, vec<4, V3, Q> const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<3, 4, T, Q>::mat(mat<3, 4, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0)}

 {





 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 4, T, Q>::col_type & mat<3, 4, T, Q>::operator[](typename mat<3, 4, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 4, T, Q>::col_type const& mat<3, 4, T, Q>::operator[](typename mat<3, 4, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator=(mat<3, 4, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator+=(mat<3, 4, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator-=(mat<3, 4, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q> & mat<3, 4, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> mat<3, 4, T, Q>::operator++(int)
 {
  mat<3, 4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> mat<3, 4, T, Q>::operator--(int)
 {
  mat<3, 4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m)
 {
  return mat<3, 4, T, Q>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator*(T scalar, mat<3, 4, T, Q> const& m)
 {
  return mat<3, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 4, T, Q>::col_type operator*
 (
  mat<3, 4, T, Q> const& m,
  typename mat<3, 4, T, Q>::row_type const& v
 )
 {
  return typename mat<3, 4, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
   m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 4, T, Q>::row_type operator*
 (
  typename mat<3, 4, T, Q>::col_type const& v,
  mat<3, 4, T, Q> const& m
 )
 {
  return typename mat<3, 4, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA02 = m1[0][2];
  const T SrcA03 = m1[0][3];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA12 = m1[1][2];
  const T SrcA13 = m1[1][3];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];
  const T SrcA22 = m1[2][2];
  const T SrcA23 = m1[2][3];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];
  const T SrcB20 = m2[2][0];
  const T SrcB21 = m2[2][1];
  const T SrcB22 = m2[2][2];
  const T SrcB30 = m2[3][0];
  const T SrcB31 = m2[3][1];
  const T SrcB32 = m2[3][2];

  mat<4, 4, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator/(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator/(T scalar, mat<3, 4, T, Q> const& m)
 {
  return mat<3, 4, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 166 "/usr/include/glm/detail/type_mat3x4.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double3x4.hpp" 2 3 4

namespace glm
{






 typedef mat<3, 4, double, defaultp> dmat3x4;


}
# 6 "/usr/include/glm/mat3x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double3x4_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<3, 4, double, lowp> lowp_dmat3x4;





 typedef mat<3, 4, double, mediump> mediump_dmat3x4;





 typedef mat<3, 4, double, highp> highp_dmat3x4;


}
# 7 "/usr/include/glm/mat3x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float3x4.hpp" 1 3 4



       


namespace glm
{






 typedef mat<3, 4, float, defaultp> mat3x4;


}
# 8 "/usr/include/glm/mat3x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float3x4_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<3, 4, float, lowp> lowp_mat3x4;





 typedef mat<3, 4, float, mediump> mediump_mat3x4;





 typedef mat<3, 4, float, highp> highp_mat3x4;


}
# 9 "/usr/include/glm/mat3x4.hpp" 2 3 4
# 27 "/usr/include/glm/matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat4x2.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double4x2.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat4x2.hpp" 1 3 4



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<4, 2, T, Q>
 {
  typedef vec<2, T, Q> col_type;
  typedef vec<4, T, Q> row_type;
  typedef mat<4, 2, T, Q> type;
  typedef mat<2, 4, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 4; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<4, 2, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0,
   T x1, T y1,
   T x2, T y2,
   T x3, T y3);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2,
   col_type const& v3);



  template<
   typename X0, typename Y0,
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3>
  constexpr mat(
   X0 x0, Y0 y0,
   X1 x1, Y1 y1,
   X2 x2, Y2 y2,
   X3 x3, Y3 y3);

  template<typename V1, typename V2, typename V3, typename V4>
  constexpr mat(
   vec<2, V1, Q> const& v1,
   vec<2, V2, Q> const& v2,
   vec<2, V3, Q> const& v3,
   vec<2, V4, Q> const& v4);



  template<typename U, qualifier P>
  constexpr mat(mat<4, 2, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);



  template<typename U>
  constexpr mat<4, 2, T, Q> & operator=(mat<4, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator+=(mat<4, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator-=(mat<4, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator/=(U s);



  constexpr mat<4, 2, T, Q> & operator++ ();
  constexpr mat<4, 2, T, Q> & operator-- ();
  [[nodiscard]] constexpr mat<4, 2, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<4, 2, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator*(T scalar, mat<4, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 2, T, Q>::col_type operator*(mat<4, 2, T, Q> const& m, typename mat<4, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 2, T, Q>::row_type operator*(typename mat<4, 2, T, Q>::col_type const& v, mat<4, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator/(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator/(T scalar, mat<4, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);
}


# 1 "/usr/include/glm/detail/type_mat4x2.inl" 1 3 4
namespace glm
{
# 21 "/usr/include/glm/detail/type_mat4x2.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<4, 2, T, Q>::mat(mat<4, 2, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(T s)

   : value{col_type(s, 0), col_type(0, s), col_type(0, 0), col_type(0, 0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat
 (
  T x0, T y0,
  T x1, T y1,
  T x2, T y2,
  T x3, T y3
 )

   : value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2), col_type(x3, y3)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

   : value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}

 {






 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0,
  typename X1, typename Y1,
  typename X2, typename Y2,
  typename X3, typename Y3>
 inline constexpr mat<4, 2, T, Q>::mat
 (
  X0 x0, Y0 y0,
  X1 x1, Y1 y1,
  X2 x2, Y2 y2,
  X3 x3, Y3 y3
 )

   : value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2), col_type(x3, y3)}

 {






 }

 template<typename T, qualifier Q>
 template<typename V0, typename V1, typename V2, typename V3>
 inline constexpr mat<4, 2, T, Q>::mat(vec<2, V0, Q> const& v0, vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2, vec<2, V3, Q> const& v3)

   : value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}

 {






 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<4, 2, T, Q>::mat(mat<4, 2, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 2, T, Q>::col_type & mat<4, 2, T, Q>::operator[](typename mat<4, 2, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 2, T, Q>::col_type const& mat<4, 2, T, Q>::operator[](typename mat<4, 2, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q>& mat<4, 2, T, Q>::operator=(mat<4, 2, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator+=(mat<4, 2, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator-=(mat<4, 2, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> mat<4, 2, T, Q>::operator++(int)
 {
  mat<4, 2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> mat<4, 2, T, Q>::operator--(int)
 {
  mat<4, 2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m)
 {
  return mat<4, 2, T, Q>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar,
   m[3] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator*(T scalar, mat<4, 2, T, Q> const& m)
 {
  return mat<4, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 2, T, Q>::col_type operator*(mat<4, 2, T, Q> const& m, typename mat<4, 2, T, Q>::row_type const& v)
 {
  return typename mat<4, 2, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 2, T, Q>::row_type operator*(typename mat<4, 2, T, Q>::col_type const& v, mat<4, 2, T, Q> const& m)
 {
  return typename mat<4, 2, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1],
   v.x * m[3][0] + v.y * m[3][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];

  mat<2, 2, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator/(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar,
   m[3] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator/(T scalar, mat<4, 2, T, Q> const& m)
 {
  return mat<4, 2, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2],
   scalar / m[3]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 171 "/usr/include/glm/detail/type_mat4x2.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double4x2.hpp" 2 3 4

namespace glm
{






 typedef mat<4, 2, double, defaultp> dmat4x2;


}
# 6 "/usr/include/glm/mat4x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double4x2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<4, 2, double, lowp> lowp_dmat4x2;





 typedef mat<4, 2, double, mediump> mediump_dmat4x2;





 typedef mat<4, 2, double, highp> highp_dmat4x2;


}
# 7 "/usr/include/glm/mat4x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float4x2.hpp" 1 3 4



       


namespace glm
{






 typedef mat<4, 2, float, defaultp> mat4x2;


}
# 8 "/usr/include/glm/mat4x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float4x2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<4, 2, float, lowp> lowp_mat4x2;





 typedef mat<4, 2, float, mediump> mediump_mat4x2;





 typedef mat<4, 2, float, highp> highp_mat4x2;


}
# 9 "/usr/include/glm/mat4x2.hpp" 2 3 4
# 28 "/usr/include/glm/matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat4x3.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double4x3.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat4x3.hpp" 1 3 4



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<4, 3, T, Q>
 {
  typedef vec<3, T, Q> col_type;
  typedef vec<4, T, Q> row_type;
  typedef mat<4, 3, T, Q> type;
  typedef mat<3, 4, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 4; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<4, 3, T, P> const& m);

  constexpr mat(T s);
  constexpr mat(
   T const& x0, T const& y0, T const& z0,
   T const& x1, T const& y1, T const& z1,
   T const& x2, T const& y2, T const& z2,
   T const& x3, T const& y3, T const& z3);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2,
   col_type const& v3);



  template<
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3,
   typename X4, typename Y4, typename Z4>
  constexpr mat(
   X1 const& x1, Y1 const& y1, Z1 const& z1,
   X2 const& x2, Y2 const& y2, Z2 const& z2,
   X3 const& x3, Y3 const& y3, Z3 const& z3,
   X4 const& x4, Y4 const& y4, Z4 const& z4);

  template<typename V1, typename V2, typename V3, typename V4>
  constexpr mat(
   vec<3, V1, Q> const& v1,
   vec<3, V2, Q> const& v2,
   vec<3, V3, Q> const& v3,
   vec<3, V4, Q> const& v4);



  template<typename U, qualifier P>
  constexpr mat(mat<4, 3, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);



  template<typename U>
  constexpr mat<4, 3, T, Q> & operator=(mat<4, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator+=(mat<4, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator-=(mat<4, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator/=(U s);



  constexpr mat<4, 3, T, Q>& operator++();
  constexpr mat<4, 3, T, Q>& operator--();
  [[nodiscard]] constexpr mat<4, 3, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<4, 3, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator*(T scalar, mat<4, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 3, T, Q>::col_type operator*(mat<4, 3, T, Q> const& m, typename mat<4, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 3, T, Q>::row_type operator*(typename mat<4, 3, T, Q>::col_type const& v, mat<4, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator/(mat<4, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator/(T scalar, mat<4, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);
}


# 1 "/usr/include/glm/detail/type_mat4x3.inl" 1 3 4
namespace glm
{
# 21 "/usr/include/glm/detail/type_mat4x3.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<4, 3, T, Q>::mat(mat<4, 3, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(T s)

   : value{col_type(s, 0, 0), col_type(0, s, 0), col_type(0, 0, s), col_type(0, 0, 0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat
 (
  T const& x0, T const& y0, T const& z0,
  T const& x1, T const& y1, T const& z1,
  T const& x2, T const& y2, T const& z2,
  T const& x3, T const& y3, T const& z3
 )

   : value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

   : value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}

 {






 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0, typename Z0,
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3>
 inline constexpr mat<4, 3, T, Q>::mat
 (
  X0 const& x0, Y0 const& y0, Z0 const& z0,
  X1 const& x1, Y1 const& y1, Z1 const& z1,
  X2 const& x2, Y2 const& y2, Z2 const& z2,
  X3 const& x3, Y3 const& y3, Z3 const& z3
 )

   : value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}

 {






 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3, typename V4>
 inline constexpr mat<4, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2, vec<3, V3, Q> const& v3, vec<3, V4, Q> const& v4)

   : value{col_type(v1), col_type(v2), col_type(v3), col_type(v4)}

 {






 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<4, 3, T, Q>::mat(mat<4, 3, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1), col_type(m[3], 0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 3, T, Q>::col_type & mat<4, 3, T, Q>::operator[](typename mat<4, 3, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 3, T, Q>::col_type const& mat<4, 3, T, Q>::operator[](typename mat<4, 3, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q>& mat<4, 3, T, Q>::operator=(mat<4, 3, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator+=(mat<4, 3, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator-=(mat<4, 3, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> mat<4, 3, T, Q>::operator++(int)
 {
  mat<4, 3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> mat<4, 3, T, Q>::operator--(int)
 {
  mat<4, 3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m)
 {
  return mat<4, 3, T, Q>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m, T scalar)
 {
  return mat<4, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m, T scalar)
 {
  return mat<4, 3, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar,
   m[3] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m, T scalar)
 {
  return mat<4, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator*(T scalar, mat<4, 3, T, Q> const& m)
 {
  return mat<4, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 3, T, Q>::col_type operator*
 (
  mat<4, 3, T, Q> const& m,
  typename mat<4, 3, T, Q>::row_type const& v)
 {
  return typename mat<4, 3, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 3, T, Q>::row_type operator*
 (
  typename mat<4, 3, T, Q>::col_type const& v,
  mat<4, 3, T, Q> const& m)
 {
  return typename mat<4, 3, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
   v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];
  T const SrcA32 = m1[3][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];
  T const SrcB23 = m2[2][3];

  mat<3, 3, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator/(mat<4, 3, T, Q> const& m, T scalar)
 {
  return mat<4, 3, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar,
   m[3] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator/(T scalar, mat<4, 3, T, Q> const& m)
 {
  return mat<4, 3, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2],
   scalar / m[3]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 171 "/usr/include/glm/detail/type_mat4x3.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double4x3.hpp" 2 3 4

namespace glm
{






 typedef mat<4, 3, double, defaultp> dmat4x3;


}
# 6 "/usr/include/glm/mat4x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double4x3_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<4, 3, double, lowp> lowp_dmat4x3;





 typedef mat<4, 3, double, mediump> mediump_dmat4x3;





 typedef mat<4, 3, double, highp> highp_dmat4x3;


}
# 7 "/usr/include/glm/mat4x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float4x3.hpp" 1 3 4



       


namespace glm
{






 typedef mat<4, 3, float, defaultp> mat4x3;


}
# 8 "/usr/include/glm/mat4x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float4x3_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<4, 3, float, lowp> lowp_mat4x3;





 typedef mat<4, 3, float, mediump> mediump_mat4x3;





 typedef mat<4, 3, float, highp> highp_mat4x3;


}
# 9 "/usr/include/glm/mat4x3.hpp" 2 3 4
# 29 "/usr/include/glm/matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat4x4.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double4x4.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat4x4.hpp" 1 3 4



       





namespace glm
{
 template<typename T, qualifier Q>
 struct mat<4, 4, T, Q>
 {
  typedef vec<4, T, Q> col_type;
  typedef vec<4, T, Q> row_type;
  typedef mat<4, 4, T, Q> type;
  typedef mat<4, 4, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length(){return 4;}

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<4, 4, T, P> const& m);

  constexpr mat(T s);
  constexpr mat(
   T const& x0, T const& y0, T const& z0, T const& w0,
   T const& x1, T const& y1, T const& z1, T const& w1,
   T const& x2, T const& y2, T const& z2, T const& w2,
   T const& x3, T const& y3, T const& z3, T const& w3);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2,
   col_type const& v3);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3,
   typename X4, typename Y4, typename Z4, typename W4>
  constexpr mat(
   X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
   X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
   X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
   X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4);

  template<typename V1, typename V2, typename V3, typename V4>
  constexpr mat(
   vec<4, V1, Q> const& v1,
   vec<4, V2, Q> const& v2,
   vec<4, V3, Q> const& v3,
   vec<4, V4, Q> const& v4);



  template<typename U, qualifier P>
  constexpr mat(mat<4, 4, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<4, 4, T, Q> & operator=(mat<4, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator+=(mat<4, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator-=(mat<4, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator*=(mat<4, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator/=(U s);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator/=(mat<4, 4, U, Q> const& m);



  constexpr mat<4, 4, T, Q> & operator++();
  constexpr mat<4, 4, T, Q> & operator--();
  [[nodiscard]] constexpr mat<4, 4, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<4, 4, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator+(T scalar, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator-(T scalar, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator*(T scalar, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 4, T, Q>::col_type operator*(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 4, T, Q>::row_type operator*(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator/(T scalar, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 4, T, Q>::col_type operator/(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 4, T, Q>::row_type operator/(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);
}


# 1 "/usr/include/glm/detail/type_mat4x4.inl" 1 3 4


namespace glm
{
# 23 "/usr/include/glm/detail/type_mat4x4.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<4, 4, T, Q>::mat(mat<4, 4, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(T s)

   : value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0), col_type(0, 0, s, 0), col_type(0, 0, 0, s)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat
 (
  T const& x0, T const& y0, T const& z0, T const& w0,
  T const& x1, T const& y1, T const& z1, T const& w1,
  T const& x2, T const& y2, T const& z2, T const& w2,
  T const& x3, T const& y3, T const& z3, T const& w3
 )

   : value{
    col_type(x0, y0, z0, w0),
    col_type(x1, y1, z1, w1),
    col_type(x2, y2, z2, w2),
    col_type(x3, y3, z3, w3)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

   : value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}

 {






 }

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<4, 4, T, Q>::mat(mat<4, 4, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2,
  typename X3, typename Y3, typename Z3, typename W3,
  typename X4, typename Y4, typename Z4, typename W4>
 inline constexpr mat<4, 4, T, Q>::mat
 (
  X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
  X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
  X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
  X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4
 )

   : value{col_type(x1, y1, z1, w1), col_type(x2, y2, z2, w2), col_type(x3, y3, z3, w3), col_type(x4, y4, z4, w4)}

 {
  static_assert(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
  static_assert(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
  static_assert(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
  static_assert(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");

  static_assert(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 5th parameter type invalid.");
  static_assert(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 6th parameter type invalid.");
  static_assert(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 7th parameter type invalid.");
  static_assert(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 8th parameter type invalid.");

  static_assert(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 9th parameter type invalid.");
  static_assert(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 10th parameter type invalid.");
  static_assert(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 11th parameter type invalid.");
  static_assert(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 12th parameter type invalid.");

  static_assert(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 13th parameter type invalid.");
  static_assert(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 14th parameter type invalid.");
  static_assert(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 15th parameter type invalid.");
  static_assert(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 16th parameter type invalid.");







 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3, typename V4>
 inline constexpr mat<4, 4, T, Q>::mat(vec<4, V1, Q> const& v1, vec<4, V2, Q> const& v2, vec<4, V3, Q> const& v3, vec<4, V4, Q> const& v4)

   : value{col_type(v1), col_type(v2), col_type(v3), col_type(v4)}

 {
  static_assert(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
  static_assert(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
  static_assert(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
  static_assert(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");







 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0), col_type(m[3], 1)}

 {






 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::col_type & mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::col_type const& mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator=(mat<4, 4, U, Q> const& m)
 {


  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(mat<4, 4, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(mat<4, 4, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(mat<4, 4, U, Q> const& m)
 {
  return (*this = *this * m);
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(mat<4, 4, U, Q> const& m)
 {
  return *this *= inverse(m);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> mat<4, 4, T, Q>::operator++(int)
 {
  mat<4, 4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> mat<4, 4, T, Q>::operator--(int)
 {
  mat<4, 4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m, T scalar)
 {
  return mat<4, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator+(T scalar, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 4, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m, T scalar)
 {
  return mat<4, 4, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar,
   m[3] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator-(T scalar, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   scalar - m[0],
   scalar - m[1],
   scalar - m[2],
   scalar - m[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 4, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m, T scalar)
 {
  return mat<4, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator*(T scalar, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::col_type operator*
 (
  mat<4, 4, T, Q> const& m,
  typename mat<4, 4, T, Q>::row_type const& v
 )
 {
# 561 "/usr/include/glm/detail/type_mat4x4.inl" 3 4
  typename mat<4, 4, T, Q>::col_type const Mov0(v[0]);
  typename mat<4, 4, T, Q>::col_type const Mov1(v[1]);
  typename mat<4, 4, T, Q>::col_type const Mul0 = m[0] * Mov0;
  typename mat<4, 4, T, Q>::col_type const Mul1 = m[1] * Mov1;
  typename mat<4, 4, T, Q>::col_type const Add0 = Mul0 + Mul1;
  typename mat<4, 4, T, Q>::col_type const Mov2(v[2]);
  typename mat<4, 4, T, Q>::col_type const Mov3(v[3]);
  typename mat<4, 4, T, Q>::col_type const Mul2 = m[2] * Mov2;
  typename mat<4, 4, T, Q>::col_type const Mul3 = m[3] * Mov3;
  typename mat<4, 4, T, Q>::col_type const Add1 = Mul2 + Mul3;
  typename mat<4, 4, T, Q>::col_type const Add2 = Add0 + Add1;
  return Add2;
# 581 "/usr/include/glm/detail/type_mat4x4.inl" 3 4
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::row_type operator*
 (
  typename mat<4, 4, T, Q>::col_type const& v,
  mat<4, 4, T, Q> const& m
 )
 {
  return typename mat<4, 4, T, Q>::row_type(
   m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],
   m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],
   m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],
   m[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  typename mat<4, 4, T, Q>::col_type const SrcA0 = m1[0];
  typename mat<4, 4, T, Q>::col_type const SrcA1 = m1[1];
  typename mat<4, 4, T, Q>::col_type const SrcA2 = m1[2];
  typename mat<4, 4, T, Q>::col_type const SrcA3 = m1[3];

  typename mat<4, 4, T, Q>::col_type const SrcB0 = m2[0];
  typename mat<4, 4, T, Q>::col_type const SrcB1 = m2[1];
  typename mat<4, 4, T, Q>::col_type const SrcB2 = m2[2];
  typename mat<4, 4, T, Q>::col_type const SrcB3 = m2[3];

  mat<4, 4, T, Q> Result;
  Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
  Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
  Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
  Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m, T scalar)
 {
  return mat<4, 4, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar,
   m[3] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator/(T scalar, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2],
   scalar / m[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::col_type operator/(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v)
 {
  return inverse(m) * v;
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::row_type operator/(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m)
 {
  return v * inverse(m);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  mat<4, 4, T, Q> m1_copy(m1);
  return m1_copy /= m2;
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 189 "/usr/include/glm/detail/type_mat4x4.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double4x4.hpp" 2 3 4

namespace glm
{






 typedef mat<4, 4, double, defaultp> dmat4x4;




 typedef mat<4, 4, double, defaultp> dmat4;


}
# 6 "/usr/include/glm/mat4x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double4x4_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<4, 4, double, lowp> lowp_dmat4;





 typedef mat<4, 4, double, mediump> mediump_dmat4;





 typedef mat<4, 4, double, highp> highp_dmat4;





 typedef mat<4, 4, double, lowp> lowp_dmat4x4;





 typedef mat<4, 4, double, mediump> mediump_dmat4x4;





 typedef mat<4, 4, double, highp> highp_dmat4x4;


}
# 7 "/usr/include/glm/mat4x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float4x4.hpp" 1 3 4



       


namespace glm
{






 typedef mat<4, 4, float, defaultp> mat4x4;




 typedef mat<4, 4, float, defaultp> mat4;


}
# 8 "/usr/include/glm/mat4x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float4x4_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<4, 4, float, lowp> lowp_mat4;





 typedef mat<4, 4, float, mediump> mediump_mat4;





 typedef mat<4, 4, float, highp> highp_mat4;





 typedef mat<4, 4, float, lowp> lowp_mat4x4;





 typedef mat<4, 4, float, mediump> mediump_mat4x4;





 typedef mat<4, 4, float, highp> highp_mat4x4;


}
# 9 "/usr/include/glm/mat4x4.hpp" 2 3 4
# 30 "/usr/include/glm/matrix.hpp" 2 3 4

namespace glm {
namespace detail
{
 template<length_t C, length_t R, typename T, qualifier Q>
 struct outerProduct_trait{};

 template<typename T, qualifier Q>
 struct outerProduct_trait<2, 2, T, Q>
 {
  typedef mat<2, 2, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<2, 3, T, Q>
 {
  typedef mat<3, 2, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<2, 4, T, Q>
 {
  typedef mat<4, 2, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<3, 2, T, Q>
 {
  typedef mat<2, 3, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<3, 3, T, Q>
 {
  typedef mat<3, 3, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<3, 4, T, Q>
 {
  typedef mat<4, 3, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<4, 2, T, Q>
 {
  typedef mat<2, 4, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<4, 3, T, Q>
 {
  typedef mat<3, 4, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<4, 4, T, Q>
 {
  typedef mat<4, 4, T, Q> type;
 };
}
# 105 "/usr/include/glm/matrix.hpp" 3 4
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y);
# 119 "/usr/include/glm/matrix.hpp" 3 4
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] typename detail::outerProduct_trait<C, R, T, Q>::type outerProduct(vec<C, T, Q> const& c, vec<R, T, Q> const& r);
# 131 "/usr/include/glm/matrix.hpp" 3 4
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] typename mat<C, R, T, Q>::transpose_type transpose(mat<C, R, T, Q> const& x);
# 143 "/usr/include/glm/matrix.hpp" 3 4
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] T determinant(mat<C, R, T, Q> const& m);
# 155 "/usr/include/glm/matrix.hpp" 3 4
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m);


}

# 1 "/usr/include/glm/detail/func_matrix.inl" 1 3 4
# 1 "/usr/include/glm/geometric.hpp" 1 3 4
# 13 "/usr/include/glm/geometric.hpp" 3 4
       



namespace glm
{
# 29 "/usr/include/glm/geometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] T length(vec<L, T, Q> const& x);
# 39 "/usr/include/glm/geometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] T distance(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1);
# 49 "/usr/include/glm/geometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr T dot(vec<L, T, Q> const& x, vec<L, T, Q> const& y);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> cross(vec<3, T, Q> const& x, vec<3, T, Q> const& y);
# 69 "/usr/include/glm/geometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> normalize(vec<L, T, Q> const& x);
# 79 "/usr/include/glm/geometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> faceforward(
  vec<L, T, Q> const& N,
  vec<L, T, Q> const& I,
  vec<L, T, Q> const& Nref);
# 93 "/usr/include/glm/geometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> reflect(
  vec<L, T, Q> const& I,
  vec<L, T, Q> const& N);
# 107 "/usr/include/glm/geometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> refract(
  vec<L, T, Q> const& I,
  vec<L, T, Q> const& N,
  T eta);


}

# 1 "/usr/include/glm/detail/func_geometric.inl" 1 3 4
# 1 "/usr/include/glm/exponential.hpp" 1 3 4
# 15 "/usr/include/glm/exponential.hpp" 3 4
       

# 1 "/usr/include/glm/detail/type_vec1.hpp" 1 3 4



       
# 14 "/usr/include/glm/detail/type_vec1.hpp" 3 4
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<1, T, Q>
 {


  typedef T value_type;
  typedef vec<1, T, Q> type;
  typedef vec<1, bool, Q> bool_type;





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 66 "/usr/include/glm/detail/type_vec1.hpp" 3 4
   union {T x, r, s;};
# 78 "/usr/include/glm/detail/type_vec1.hpp" 3 4
#pragma GCC diagnostic pop
# 87 "/usr/include/glm/detail/type_vec1.hpp" 3 4
  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length(){return 1;}

  [[nodiscard]] constexpr T & operator[](length_type i);
  [[nodiscard]] constexpr T const& operator[](length_type i) const;



  constexpr vec() = default;
  constexpr vec(vec const& v) = default;
  template<qualifier P>
  constexpr vec(vec<1, T, P> const& v);



  constexpr explicit vec(T scalar);




  template<typename U, qualifier P>
  constexpr vec(vec<2, U, P> const& v);

  template<typename U, qualifier P>
  constexpr vec(vec<3, U, P> const& v);

  template<typename U, qualifier P>
  constexpr vec(vec<4, U, P> const& v);


  template<typename U, qualifier P>
  constexpr vec(vec<1, U, P> const& v);
# 132 "/usr/include/glm/detail/type_vec1.hpp" 3 4
  constexpr vec<1, T, Q> & operator=(vec const& v) = default;

  template<typename U>
  constexpr vec<1, T, Q> & operator=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator+=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator+=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator-=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator-=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator*=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator*=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator/=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator/=(vec<1, U, Q> const& v);



  constexpr vec<1, T, Q> & operator++();
  constexpr vec<1, T, Q> & operator--();
  [[nodiscard]] constexpr vec<1, T, Q> operator++(int);
  [[nodiscard]] constexpr vec<1, T, Q> operator--(int);



  template<typename U>
  constexpr vec<1, T, Q> & operator%=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator&=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator|=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator^=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator<<=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator>>=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator>>=(vec<1, U, Q> const& v);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator+(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator-(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator*(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator/(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator%(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator&(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator|(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator^(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator<<(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator>>(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator~(vec<1, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<1, bool, Q> operator&&(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<1, bool, Q> operator||(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2);
}


# 1 "/usr/include/glm/detail/type_vec1.inl" 1 3 4




namespace glm
{
# 25 "/usr/include/glm/detail/type_vec1.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr vec<1, T, Q>::vec(vec<1, T, P> const& v)
  : x(v.x)
 {}



 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q>::vec(T scalar)
  : x(scalar)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<1, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<1, T, Q>::vec(vec<2, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<1, T, Q>::vec(vec<3, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<1, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}



 template<typename T, qualifier Q>
 inline constexpr T & vec<1, T, Q>::operator[](typename vec<1, T, Q>::length_type)
 {
  return x;
 }

 template<typename T, qualifier Q>
 inline constexpr T const& vec<1, T, Q>::operator[](typename vec<1, T, Q>::length_type) const
 {
  return x;
 }
# 89 "/usr/include/glm/detail/type_vec1.inl" 3 4
 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator=(vec<1, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator/=(U scalar)
 {
  this->x /= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator++()
 {
  ++this->x;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator--()
 {
  --this->x;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> vec<1, T, Q>::operator++(int)
 {
  vec<1, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> vec<1, T, Q>::operator--(int)
 {
  vec<1, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator%=(U scalar)
 {
  this->x %= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  this->x %= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator&=(U scalar)
 {
  this->x &= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  this->x &= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator|=(U scalar)
 {
  this->x |= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  this->x |= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator^=(U scalar)
 {
  this->x ^= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  this->x ^= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator<<=(U scalar)
 {
  this->x <<= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   -v.x);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator+(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar + v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x + v2.x);
 }


 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator-(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar - v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x - v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator*(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar * v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x * v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator/(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar / v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x / v2.x);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x % scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator%(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar % v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x % v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x & scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator&(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar & v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x & v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x | scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator|(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar | v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x | v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x ^ scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator^(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar ^ v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x ^ v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   static_cast<T>(v.x << scalar));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator<<(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   static_cast<T>(scalar << v.x));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   static_cast<T>(v1.x << v2.x));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   static_cast<T>(v.x >> scalar));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator>>(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   static_cast<T>(scalar >> v.x));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   static_cast<T>(v1.x >> v2.x));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator~(vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   ~v.x);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return !(v1 == v2);
 }

 template<qualifier Q>
 inline constexpr vec<1, bool, Q> operator&&(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2)
 {
  return vec<1, bool, Q>(v1.x && v2.x);
 }

 template<qualifier Q>
 inline constexpr vec<1, bool, Q> operator||(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2)
 {
  return vec<1, bool, Q>(v1.x || v2.x);
 }
}
# 308 "/usr/include/glm/detail/type_vec1.hpp" 2 3 4
# 18 "/usr/include/glm/exponential.hpp" 2 3 4



# 1 "/usr/include/c++/14.2.1/cmath" 1 3 4
# 39 "/usr/include/c++/14.2.1/cmath" 3 4
       
# 40 "/usr/include/c++/14.2.1/cmath" 3
# 22 "/usr/include/glm/exponential.hpp" 2 3 4

namespace glm
{
# 35 "/usr/include/glm/exponential.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent);
# 46 "/usr/include/glm/exponential.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> exp(vec<L, T, Q> const& v);
# 59 "/usr/include/glm/exponential.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> log(vec<L, T, Q> const& v);
# 70 "/usr/include/glm/exponential.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> exp2(vec<L, T, Q> const& v);
# 82 "/usr/include/glm/exponential.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> log2(vec<L, T, Q> const& v);
# 93 "/usr/include/glm/exponential.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> sqrt(vec<L, T, Q> const& v);
# 104 "/usr/include/glm/exponential.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> inversesqrt(vec<L, T, Q> const& v);


}

# 1 "/usr/include/glm/detail/func_exponential.inl" 1 3 4



# 1 "/usr/include/glm/vector_relational.hpp" 1 3 4
# 20 "/usr/include/glm/vector_relational.hpp" 3 4
       


# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 24 "/usr/include/glm/vector_relational.hpp" 2 3 4

namespace glm
{
# 37 "/usr/include/glm/vector_relational.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> lessThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 47 "/usr/include/glm/vector_relational.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> lessThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 57 "/usr/include/glm/vector_relational.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> greaterThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 67 "/usr/include/glm/vector_relational.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> greaterThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 77 "/usr/include/glm/vector_relational.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 87 "/usr/include/glm/vector_relational.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);







 template<length_t L, qualifier Q>
 [[nodiscard]] constexpr bool any(vec<L, bool, Q> const& v);







 template<length_t L, qualifier Q>
 [[nodiscard]] constexpr bool all(vec<L, bool, Q> const& v);
# 115 "/usr/include/glm/vector_relational.hpp" 3 4
 template<length_t L, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> not_(vec<L, bool, Q> const& v);


}

# 1 "/usr/include/glm/detail/func_vector_relational.inl" 1 3 4
namespace glm
{
 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> lessThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] < y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> lessThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] <= y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> greaterThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] > y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> greaterThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] >= y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] == y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] != y[i];
  return Result;
 }

 template<length_t L, qualifier Q>
 inline constexpr bool any(vec<L, bool, Q> const& v)
 {
  bool Result = false;
  for(length_t i = 0; i < L; ++i)
   Result = Result || v[i];
  return Result;
 }

 template<length_t L, qualifier Q>
 inline constexpr bool all(vec<L, bool, Q> const& v)
 {
  bool Result = true;
  for(length_t i = 0; i < L; ++i)
   Result = Result && v[i];
  return Result;
 }

 template<length_t L, qualifier Q>
 inline constexpr vec<L, bool, Q> not_(vec<L, bool, Q> const& v)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = !v[i];
  return Result;
 }
}
# 122 "/usr/include/glm/vector_relational.hpp" 2 3 4
# 5 "/usr/include/glm/detail/func_exponential.inl" 2 3 4
# 1 "/usr/include/glm/detail/_vectorize.hpp" 1 3 4
       

namespace glm{
namespace detail
{
 template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename R, typename T, qualifier Q>
 struct functor1{};

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 1, R, T, Q>
 {
  inline constexpr static vec<1, R, Q> call(R (*Func) (T x), vec<1, T, Q> const& v)
  {
   return vec<1, R, Q>(Func(v.x));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 2, R, T, Q>
 {
  inline constexpr static vec<2, R, Q> call(R (*Func) (T x), vec<2, T, Q> const& v)
  {
   return vec<2, R, Q>(Func(v.x), Func(v.y));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 3, R, T, Q>
 {
  inline constexpr static vec<3, R, Q> call(R (*Func) (T x), vec<3, T, Q> const& v)
  {
   return vec<3, R, Q>(Func(v.x), Func(v.y), Func(v.z));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 4, R, T, Q>
 {
  inline constexpr static vec<4, R, Q> call(R (*Func) (T x), vec<4, T, Q> const& v)
  {
   return vec<4, R, Q>(Func(v.x), Func(v.y), Func(v.z), Func(v.w));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename T, qualifier Q>
 struct functor2{};

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 1, T, Q>
 {
  inline static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, vec<1, T, Q> const& b)
  {
   return vec<1, T, Q>(Func(a.x, b.x));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 2, T, Q>
 {
  inline static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, vec<2, T, Q> const& b)
  {
   return vec<2, T, Q>(Func(a.x, b.x), Func(a.y, b.y));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 3, T, Q>
 {
  inline static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, vec<3, T, Q> const& b)
  {
   return vec<3, T, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 4, T, Q>
 {
  inline static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename T, qualifier Q>
 struct functor2_vec_sca{};

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 1, T, Q>
 {
  inline static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, T b)
  {
   return vec<1, T, Q>(Func(a.x, b));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 2, T, Q>
 {
  inline static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, T b)
  {
   return vec<2, T, Q>(Func(a.x, b), Func(a.y, b));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 3, T, Q>
 {
  inline static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, T b)
  {
   return vec<3, T, Q>(Func(a.x, b), Func(a.y, b), Func(a.z, b));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 4, T, Q>
 {
  inline static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, T b)
  {
   return vec<4, T, Q>(Func(a.x, b), Func(a.y, b), Func(a.z, b), Func(a.w, b));
  }
 };

 template<length_t L, typename T, qualifier Q>
 struct functor2_vec_int {};

 template<typename T, qualifier Q>
 struct functor2_vec_int<1, T, Q>
 {
  inline static vec<1, int, Q> call(int (*Func) (T x, int y), vec<1, T, Q> const& a, vec<1, int, Q> const& b)
  {
   return vec<1, int, Q>(Func(a.x, b.x));
  }
 };

 template<typename T, qualifier Q>
 struct functor2_vec_int<2, T, Q>
 {
  inline static vec<2, int, Q> call(int (*Func) (T x, int y), vec<2, T, Q> const& a, vec<2, int, Q> const& b)
  {
   return vec<2, int, Q>(Func(a.x, b.x), Func(a.y, b.y));
  }
 };

 template<typename T, qualifier Q>
 struct functor2_vec_int<3, T, Q>
 {
  inline static vec<3, int, Q> call(int (*Func) (T x, int y), vec<3, T, Q> const& a, vec<3, int, Q> const& b)
  {
   return vec<3, int, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
  }
 };

 template<typename T, qualifier Q>
 struct functor2_vec_int<4, T, Q>
 {
  inline static vec<4, int, Q> call(int (*Func) (T x, int y), vec<4, T, Q> const& a, vec<4, int, Q> const& b)
  {
   return vec<4, int, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
  }
 };
}
}
# 6 "/usr/include/glm/detail/func_exponential.inl" 2 3 4

# 1 "/usr/include/c++/14.2.1/cmath" 1 3 4
# 39 "/usr/include/c++/14.2.1/cmath" 3 4
       
# 40 "/usr/include/c++/14.2.1/cmath" 3
# 8 "/usr/include/glm/detail/func_exponential.inl" 2 3 4
# 1 "/usr/include/c++/14.2.1/cassert" 1 3 4
# 41 "/usr/include/c++/14.2.1/cassert" 3 4
       
# 42 "/usr/include/c++/14.2.1/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 64 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     noexcept (true) __attribute__ ((__noreturn__));


}
# 45 "/usr/include/c++/14.2.1/cassert" 2 3
# 9 "/usr/include/glm/detail/func_exponential.inl" 2 3 4

namespace glm{
namespace detail
{

  using std::log2;
# 23 "/usr/include/glm/detail/func_exponential.inl" 3 4
 template<length_t L, typename T, qualifier Q, bool isFloat, bool Aligned>
 struct compute_log2
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'log2' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.");

   return detail::functor1<vec, L, T, T, Q>::call(log2, v);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_sqrt
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(std::sqrt, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_inversesqrt
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return static_cast<T>(1) / sqrt(x);
  }
 };

 template<length_t L, bool Aligned>
 struct compute_inversesqrt<L, float, lowp, Aligned>
 {
  inline static vec<L, float, lowp> call(vec<L, float, lowp> const& x)
  {
   vec<L, float, lowp> tmp(x);
   vec<L, float, lowp> xhalf(tmp * 0.5f);
   vec<L, uint, lowp>* p = reinterpret_cast<vec<L, uint, lowp>*>(const_cast<vec<L, float, lowp>*>(&x));
   vec<L, uint, lowp> i = vec<L, uint, lowp>(0x5f375a86) - (*p >> vec<L, uint, lowp>(1));
   vec<L, float, lowp>* ptmp = reinterpret_cast<vec<L, float, lowp>*>(&i);
   tmp = *ptmp;
   tmp = tmp * (1.5f - xhalf * tmp * tmp);
   return tmp;
  }
 };
}


 using std::pow;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent)
 {
  return detail::functor2<vec, L, T, Q>::call(pow, base, exponent);
 }


 using std::exp;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> exp(vec<L, T, Q> const& x)
 {
  return detail::functor1<vec, L, T, T, Q>::call(exp, x);
 }


 using std::log;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> log(vec<L, T, Q> const& x)
 {
  return detail::functor1<vec, L, T, T, Q>::call(log, x);
 }


    using std::exp2;
# 106 "/usr/include/glm/detail/func_exponential.inl" 3 4
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> exp2(vec<L, T, Q> const& x)
 {
  return detail::functor1<vec, L, T, T, Q>::call(exp2, x);
 }


 template<typename genType>
 inline genType log2(genType x)
 {
  return log2(vec<1, genType>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> log2(vec<L, T, Q> const& x)
 {
  return detail::compute_log2<L, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x);
 }


 using std::sqrt;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> sqrt(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'sqrt' only accept floating-point inputs");
  return detail::compute_sqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 inline genType inversesqrt(genType x)
 {
  return static_cast<genType>(1) / sqrt(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> inversesqrt(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'inversesqrt' only accept floating-point inputs");
  return detail::compute_inversesqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }
}
# 111 "/usr/include/glm/exponential.hpp" 2 3 4
# 2 "/usr/include/glm/detail/func_geometric.inl" 2 3 4
# 1 "/usr/include/glm/common.hpp" 1 3 4
# 15 "/usr/include/glm/common.hpp" 3 4
       


# 1 "/usr/include/glm/detail/_fixes.hpp" 1 3 4
# 1 "/usr/include/c++/14.2.1/cmath" 1 3 4
# 39 "/usr/include/c++/14.2.1/cmath" 3 4
       
# 40 "/usr/include/c++/14.2.1/cmath" 3
# 2 "/usr/include/glm/detail/_fixes.hpp" 2 3 4
# 19 "/usr/include/glm/common.hpp" 2 3 4

namespace glm
{
# 31 "/usr/include/glm/common.hpp" 3 4
 template<typename genType>
 [[nodiscard]] constexpr genType abs(genType x);
# 42 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> abs(vec<L, T, Q> const& x);
# 53 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> sign(vec<L, T, Q> const& x);
# 64 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> floor(vec<L, T, Q> const& x);
# 76 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> trunc(vec<L, T, Q> const& x);
# 91 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> round(vec<L, T, Q> const& x);
# 105 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> roundEven(vec<L, T, Q> const& x);
# 117 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> ceil(vec<L, T, Q> const& x);







 template<typename genType>
 [[nodiscard]] genType fract(genType x);
# 137 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> fract(vec<L, T, Q> const& x);

 template<typename genType>
 [[nodiscard]] genType mod(genType x, genType y);

 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> mod(vec<L, T, Q> const& x, T y);
# 155 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> mod(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 167 "/usr/include/glm/common.hpp" 3 4
 template<typename genType>
 [[nodiscard]] genType modf(genType x, genType& i);







 template<typename genType>
 [[nodiscard]] constexpr genType min(genType x, genType y);
# 187 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> min(vec<L, T, Q> const& x, T y);
# 198 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> min(vec<L, T, Q> const& x, vec<L, T, Q> const& y);







 template<typename genType>
 [[nodiscard]] constexpr genType max(genType x, genType y);
# 218 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, T y);
# 229 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 239 "/usr/include/glm/common.hpp" 3 4
 template<typename genType>
 [[nodiscard]] constexpr genType clamp(genType x, genType minVal, genType maxVal);
# 251 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, T minVal, T maxVal);
# 263 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal);
# 308 "/usr/include/glm/common.hpp" 3 4
 template<typename genTypeT, typename genTypeU>
 [[nodiscard]] constexpr genTypeT mix(genTypeT x, genTypeT y, genTypeU a);

 template<length_t L, typename T, typename U, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a);

 template<length_t L, typename T, typename U, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U a);





 template<typename genType>
 [[nodiscard]] genType step(genType edge, genType x);
# 332 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> step(T edge, vec<L, T, Q> const& x);
# 343 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> step(vec<L, T, Q> const& edge, vec<L, T, Q> const& x);
# 360 "/usr/include/glm/common.hpp" 3 4
 template<typename genType>
 [[nodiscard]] genType smoothstep(genType edge0, genType edge1, genType x);

 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> smoothstep(T edge0, T edge1, vec<L, T, Q> const& x);

 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> smoothstep(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x);
# 383 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, bool, Q> isnan(vec<L, T, Q> const& x);
# 398 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, bool, Q> isinf(vec<L, T, Q> const& x);







 [[nodiscard]] int floatBitsToInt(float v);
# 418 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, int, Q> floatBitsToInt(vec<L, float, Q> const& v);







 [[nodiscard]] uint floatBitsToUint(float v);
# 438 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, uint, Q> floatBitsToUint(vec<L, float, Q> const& v);
# 449 "/usr/include/glm/common.hpp" 3 4
 [[nodiscard]] float intBitsToFloat(int v);
# 462 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, float, Q> intBitsToFloat(vec<L, int, Q> const& v);
# 473 "/usr/include/glm/common.hpp" 3 4
 [[nodiscard]] float uintBitsToFloat(uint v);
# 486 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, float, Q> uintBitsToFloat(vec<L, uint, Q> const& v);







 template<typename genType>
 [[nodiscard]] genType fma(genType const& a, genType const& b, genType const& c);
# 512 "/usr/include/glm/common.hpp" 3 4
 template<typename genType>
 [[nodiscard]] genType frexp(genType x, int& exp);

 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> frexp(vec<L, T, Q> const& v, vec<L, int, Q>& exp);
# 529 "/usr/include/glm/common.hpp" 3 4
 template<typename genType>
 [[nodiscard]] genType ldexp(genType const& x, int const& exp);

 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> ldexp(vec<L, T, Q> const& v, vec<L, int, Q> const& exp);


}

# 1 "/usr/include/glm/detail/func_common.inl" 1 3 4




# 1 "/usr/include/glm/detail/compute_common.hpp" 1 3 4
       

# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 4 "/usr/include/glm/detail/compute_common.hpp" 2 3 4


namespace glm{
namespace detail
{
 template<typename genFIType, bool >
 struct compute_abs
 {};

 template<typename genFIType>
 struct compute_abs<genFIType, true>
 {
  inline constexpr static genFIType call(genFIType x)
  {
   static_assert(std::numeric_limits<genFIType>::is_iec559 || 0 || std::numeric_limits<genFIType>::is_signed, "'abs' only accept floating-point and integer scalar or vector inputs")

                                                                           ;

   return x >= genFIType(0) ? x : -x;

  }
 };
# 38 "/usr/include/glm/detail/compute_common.hpp" 3 4
 template<typename genFIType>
 struct compute_abs<genFIType, false>
 {
  inline constexpr static genFIType call(genFIType x)
  {
   static_assert((!std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'abs' only accept floating-point and integer scalar or vector inputs")

                                                                           ;
   return x;
  }
 };
}
}
# 6 "/usr/include/glm/detail/func_common.inl" 2 3 4







namespace glm
{

 template<typename genType>
 inline constexpr genType min(genType x, genType y)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer, "'min' only accept floating-point or integer inputs");
  return (y < x) ? y : x;
 }


 template<typename genType>
 inline constexpr genType max(genType x, genType y)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer, "'max' only accept floating-point or integer inputs");

  return (x < y) ? y : x;
 }


 template<>
 inline constexpr int abs(int x)
 {
  int const y = x >> (sizeof(int) * 8 - 1);
  return (x ^ y) - y;
 }



  using ::std::round;
# 55 "/usr/include/glm/detail/func_common.inl" 3 4
  using ::std::trunc;
# 66 "/usr/include/glm/detail/func_common.inl" 3 4
}

namespace glm{
namespace detail
{
 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_abs_vector
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(abs, x);
  }
 };

 template<length_t L, typename T, typename U, qualifier Q, bool Aligned>
 struct compute_mix_vector
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)
  {
   static_assert(std::numeric_limits<U>::is_iec559 || 0 || 0, "'mix' only accept floating-point inputs for the interpolator a");

   return vec<L, T, Q>(vec<L, U, Q>(x) * (static_cast<U>(1) - a) + vec<L, U, Q>(y) * a);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_mix_vector<L, T, bool, Q, Aligned>
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, bool, Q> const& a)
  {
   vec<L, T, Q> Result(0);
   for(length_t i = 0; i < x.length(); ++i)
    Result[i] = a[i] ? y[i] : x[i];
   return Result;
  }
 };

 template<length_t L, typename T, typename U, qualifier Q, bool Aligned>
 struct compute_mix_scalar
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U const& a)
  {
   static_assert(std::numeric_limits<U>::is_iec559 || 0 || 0, "'mix' only accept floating-point inputs for the interpolator a");

   return vec<L, T, Q>(vec<L, U, Q>(x) * (static_cast<U>(1) - a) + vec<L, U, Q>(y) * a);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_mix_scalar<L, T, bool, Q, Aligned>
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, bool const& a)
  {
   return a ? y : x;
  }
 };

 template<typename T, typename U>
 struct compute_mix
 {
  inline constexpr static T call(T const& x, T const& y, U const& a)
  {
   static_assert(std::numeric_limits<U>::is_iec559 || 0 || 0, "'mix' only accept floating-point inputs for the interpolator a");

   return static_cast<T>(static_cast<U>(x) * (static_cast<U>(1) - a) + static_cast<U>(y) * a);
  }
 };

 template<typename T>
 struct compute_mix<T, bool>
 {
  inline constexpr static T call(T const& x, T const& y, bool const& a)
  {
   return a ? y : x;
  }
 };

 template<length_t L, typename T, qualifier Q, bool isFloat, bool Aligned>
 struct compute_sign
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return vec<L, T, Q>(glm::lessThan(vec<L, T, Q>(0), x)) - vec<L, T, Q>(glm::lessThan(x, vec<L, T, Q>(0)));
  }
 };


 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_sign<L, T, Q, false, Aligned>
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   T const Shift(static_cast<T>(sizeof(T) * 8 - 1));
   vec<L, T, Q> const y(vec<L, typename detail::make_unsigned<T>::type, Q>(-x) >> typename detail::make_unsigned<T>::type(Shift));

   return (x >> Shift) | y;
  }
 };


 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_floor
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(std::floor, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_ceil
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(std::ceil, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_fract
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return x - floor(x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_trunc
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(trunc, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_round
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(round, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_mod
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'mod' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.");
   return a - b * floor(a / b);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_min_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
  {
   return detail::functor2<vec, L, T, Q>::call(min, x, y);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_max_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
  {
   return detail::functor2<vec, L, T, Q>::call(max, x, y);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_clamp_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
  {
   return min(max(x, minVal), maxVal);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_step_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)
  {
   return mix(vec<L, T, Q>(1), vec<L, T, Q>(0), glm::lessThan(x, edge));
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_smoothstep_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0 || 0, "'smoothstep' only accept floating-point inputs");
   vec<L, T, Q> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));
   return tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);
  }
 };
}

 template<typename genFIType>
 inline constexpr genFIType abs(genFIType x)
 {
  return detail::compute_abs<genFIType, std::numeric_limits<genFIType>::is_signed>::call(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> abs(vec<L, T, Q> const& x)
 {
  return detail::compute_abs_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }



 template<typename genFIType>
 inline constexpr genFIType sign(genFIType x)
 {
  static_assert(std::numeric_limits<genFIType>::is_iec559 || 0 || (std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'sign' only accept signed inputs")

                                      ;

  return detail::compute_sign<1, genFIType, defaultp,
                                    std::numeric_limits<genFIType>::is_iec559, detail::is_aligned<highp>::value>::call(vec<1, genFIType>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> sign(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0 || (std::numeric_limits<T>::is_signed && std::numeric_limits<T>::is_integer), "'sign' only accept signed inputs")

                                      ;

  return detail::compute_sign<L, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x);
 }


 using ::std::floor;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> floor(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'floor' only accept floating-point inputs.");
  return detail::compute_floor<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> trunc(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'trunc' only accept floating-point inputs");
  return detail::compute_trunc<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> round(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'round' only accept floating-point inputs");
  return detail::compute_round<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }
# 339 "/usr/include/glm/detail/func_common.inl" 3 4
 template<typename genType>
 inline genType roundEven(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'roundEven' only accept floating-point inputs");

  int Integer = static_cast<int>(x);
  genType IntegerPart = static_cast<genType>(Integer);
  genType FractionalPart = fract(x);

  if(FractionalPart > static_cast<genType>(0.5) || FractionalPart < static_cast<genType>(0.5))
  {
   return round(x);
  }
  else if((Integer % 2) == 0)
  {
   return IntegerPart;
  }
  else if(x <= static_cast<genType>(0))
  {
   return IntegerPart - static_cast<genType>(1);
  }
  else
  {
   return IntegerPart + static_cast<genType>(1);
  }




 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> roundEven(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'roundEven' only accept floating-point inputs");
  return detail::functor1<vec, L, T, T, Q>::call(roundEven, x);
 }


 using ::std::ceil;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> ceil(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'ceil' only accept floating-point inputs");
  return detail::compute_ceil<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 inline genType fract(genType x)
 {
  return fract(vec<1, genType>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> fract(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'fract' only accept floating-point inputs");
  return detail::compute_fract<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 inline genType mod(genType x, genType y)
 {





   return mod(vec<1, genType, defaultp>(x), y).x;

 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> mod(vec<L, T, Q> const& x, T y)
 {
  return detail::compute_mod<L, T, Q, detail::is_aligned<Q>::value>::call(x, vec<L, T, Q>(y));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> mod(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  return detail::compute_mod<L, T, Q, detail::is_aligned<Q>::value>::call(x, y);
 }


 template<typename genType>
 inline genType modf(genType x, genType & i)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'modf' only accept floating-point inputs");
  return std::modf(x, &i);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> modf(vec<1, T, Q> const& x, vec<1, T, Q> & i)
 {
  return vec<1, T, Q>(
   modf(x.x, i.x));
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> modf(vec<2, T, Q> const& x, vec<2, T, Q> & i)
 {
  return vec<2, T, Q>(
   modf(x.x, i.x),
   modf(x.y, i.y));
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> modf(vec<3, T, Q> const& x, vec<3, T, Q> & i)
 {
  return vec<3, T, Q>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z));
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> modf(vec<4, T, Q> const& x, vec<4, T, Q> & i)
 {
  return vec<4, T, Q>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z),
   modf(x.w, i.w));
 }
# 476 "/usr/include/glm/detail/func_common.inl" 3 4
 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> min(vec<L, T, Q> const& a, T b)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'min' only accept floating-point or integer inputs");
  return detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> min(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
 {
  return detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);
 }


 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> max(vec<L, T, Q> const& a, T b)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'max' only accept floating-point or integer inputs");
  return detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> max(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
 {
  return detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);
 }


 template<typename genType>
 inline constexpr genType clamp(genType x, genType minVal, genType maxVal)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer, "'clamp' only accept floating-point or integer inputs");
  return min(max(x, minVal), maxVal);
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, T minVal, T maxVal)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs");
  return detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, vec<L, T, Q>(minVal), vec<L, T, Q>(maxVal));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs");
  return detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, minVal, maxVal);
 }

 template<typename genTypeT, typename genTypeU>
 inline constexpr genTypeT mix(genTypeT x, genTypeT y, genTypeU a)
 {
  return detail::compute_mix<genTypeT, genTypeU>::call(x, y, a);
 }

 template<length_t L, typename T, typename U, qualifier Q>
 inline constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U a)
 {
  return detail::compute_mix_scalar<L, T, U, Q, detail::is_aligned<Q>::value>::call(x, y, a);
 }

 template<length_t L, typename T, typename U, qualifier Q>
 inline constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)
 {
  return detail::compute_mix_vector<L, T, U, Q, detail::is_aligned<Q>::value>::call(x, y, a);
 }


 template<typename genType>
 inline genType step(genType edge, genType x)
 {
  return mix(static_cast<genType>(1), static_cast<genType>(0), x < edge);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> step(T edge, vec<L, T, Q> const& x)
 {
  return detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge), x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> step(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)
 {
  return detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge, x);
 }


 template<typename genType>
 inline genType smoothstep(genType edge0, genType edge1, genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0 || 0, "'smoothstep' only accept floating-point inputs");

  genType const tmp(clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1)));
  return tmp * tmp * (genType(3) - genType(2) * tmp);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> smoothstep(T edge0, T edge1, vec<L, T, Q> const& x)
 {
  return detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge0), vec<L, T, Q>(edge1), x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> smoothstep(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)
 {
  return detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge0, edge1, x);
 }


  using std::isnan;
# 612 "/usr/include/glm/detail/func_common.inl" 3 4
 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> isnan(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isnan' only accept floating-point inputs");

  vec<L, bool, Q> Result(0);
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = glm::isnan(v[l]);
  return Result;
 }


  using std::isinf;
# 654 "/usr/include/glm/detail/func_common.inl" 3 4
 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> isinf(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isinf' only accept floating-point inputs");

  vec<L, bool, Q> Result(0);
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = glm::isinf(v[l]);
  return Result;
 }

 inline int floatBitsToInt(float v)
 {
  union
  {
   float in;
   int out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 inline vec<L, int, Q> floatBitsToInt(vec<L, float, Q> const& v)
 {
  return detail::functor1<vec, L, int, float, Q>::call(floatBitsToInt, v);
 }

 inline uint floatBitsToUint(float v)
 {
  union
  {
   float in;
   uint out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 inline vec<L, uint, Q> floatBitsToUint(vec<L, float, Q> const& v)
 {
  return detail::functor1<vec, L, uint, float, Q>::call(floatBitsToUint, v);
 }

 inline float intBitsToFloat(int v)
 {
  union
  {
   int in;
   float out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 inline vec<L, float, Q> intBitsToFloat(vec<L, int, Q> const& v)
 {
  return detail::functor1<vec, L, float, int, Q>::call(intBitsToFloat, v);
 }

 inline float uintBitsToFloat(uint v)
 {
  union
  {
   uint in;
   float out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 inline vec<L, float, Q> uintBitsToFloat(vec<L, uint, Q> const& v)
 {
  return reinterpret_cast<vec<L, float, Q>&>(const_cast<vec<L, uint, Q>&>(v));
 }


  using std::fma;
# 751 "/usr/include/glm/detail/func_common.inl" 3 4
 template<typename genType>
 inline genType frexp(genType x, int& exp)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'frexp' only accept floating-point inputs");

  return std::frexp(x, &exp);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> frexp(vec<L, T, Q> const& v, vec<L, int, Q>& exp)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'frexp' only accept floating-point inputs");

  vec<L, T, Q> Result(0);
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = std::frexp(v[l], &exp[l]);
  return Result;
 }

 template<typename genType>
 inline genType ldexp(genType const& x, int const& exp)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'ldexp' only accept floating-point inputs");

  return std::ldexp(x, exp);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> ldexp(vec<L, T, Q> const& v, vec<L, int, Q> const& exp)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'ldexp' only accept floating-point inputs");

  vec<L, T, Q> Result(0);
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = std::ldexp(v[l], exp[l]);
  return Result;
 }
}
# 539 "/usr/include/glm/common.hpp" 2 3 4
# 3 "/usr/include/glm/detail/func_geometric.inl" 2 3 4

namespace glm{
namespace detail
{
 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_length
 {
  inline static T call(vec<L, T, Q> const& v)
  {
   return sqrt(dot(v, v));
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_distance
 {
  inline static T call(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1)
  {
   return length(p1 - p0);
  }
 };

 template<typename V, typename T, bool Aligned>
 struct compute_dot{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<1, T, Q>, T, Aligned>
 {
  inline constexpr static T call(vec<1, T, Q> const& a, vec<1, T, Q> const& b)
  {
   return a.x * b.x;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<2, T, Q>, T, Aligned>
 {
  inline constexpr static T call(vec<2, T, Q> const& a, vec<2, T, Q> const& b)
  {
   vec<2, T, Q> tmp(a * b);
   return tmp.x + tmp.y;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<3, T, Q>, T, Aligned>
 {
  inline constexpr static T call(vec<3, T, Q> const& a, vec<3, T, Q> const& b)
  {
   vec<3, T, Q> tmp(a * b);
   return tmp.x + tmp.y + tmp.z;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<4, T, Q>, T, Aligned>
 {
  inline constexpr static T call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   vec<4, T, Q> tmp(a * b);
   return (tmp.x + tmp.y) + (tmp.z + tmp.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_cross
 {
  inline constexpr static vec<3, T, Q> call(vec<3, T, Q> const& x, vec<3, T, Q> const& y)
  {
   static_assert(std::numeric_limits<T>::is_iec559, "'cross' accepts only floating-point inputs");

   return vec<3, T, Q>(
    x.y * y.z - y.y * x.z,
    x.z * y.x - y.z * x.x,
    x.x * y.y - y.x * x.y);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_normalize
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
  {
   static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

   return v * inversesqrt(dot(v, v));
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_faceforward
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& N, vec<L, T, Q> const& I, vec<L, T, Q> const& Nref)
  {
   static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

   return dot(Nref, I) < static_cast<T>(0) ? N : -N;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_reflect
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& I, vec<L, T, Q> const& N)
  {
   return I - N * dot(N, I) * static_cast<T>(2);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_refract
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& I, vec<L, T, Q> const& N, T eta)
  {
   T const dotValue(dot(N, I));
   T const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));
   vec<L, T, Q> const Result =
                (k >= static_cast<T>(0)) ? (eta * I - (eta * dotValue + std::sqrt(k)) * N) : vec<L, T, Q>(0);
   return Result;
  }
 };
}


 template<typename genType>
 inline genType length(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'length' accepts only floating-point inputs");

  return abs(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline T length(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'length' accepts only floating-point inputs");

  return detail::compute_length<L, T, Q, detail::is_aligned<Q>::value>::call(v);
 }


 template<typename genType>
 inline genType distance(genType const& p0, genType const& p1)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'distance' accepts only floating-point inputs");

  return length(p1 - p0);
 }

 template<length_t L, typename T, qualifier Q>
 inline T distance(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1)
 {
  return detail::compute_distance<L, T, Q, detail::is_aligned<Q>::value>::call(p0, p1);
 }


 template<typename T>
 inline constexpr T dot(T x, T y)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs");
  return x * y;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr T dot(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs");
  return detail::compute_dot<vec<L, T, Q>, T, detail::is_aligned<Q>::value>::call(x, y);
 }


 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> cross(vec<3, T, Q> const& x, vec<3, T, Q> const& y)
 {
  return detail::compute_cross<T, Q, detail::is_aligned<Q>::value>::call(x, y);
 }
# 189 "/usr/include/glm/detail/func_geometric.inl" 3 4
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> normalize(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

  return detail::compute_normalize<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 inline genType faceforward(genType const& N, genType const& I, genType const& Nref)
 {
  return dot(Nref, I) < static_cast<genType>(0) ? N : -N;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> faceforward(vec<L, T, Q> const& N, vec<L, T, Q> const& I, vec<L, T, Q> const& Nref)
 {
  return detail::compute_faceforward<L, T, Q, detail::is_aligned<Q>::value>::call(N, I, Nref);
 }


 template<typename genType>
 inline genType reflect(genType const& I, genType const& N)
 {
  return I - N * dot(N, I) * genType(2);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> reflect(vec<L, T, Q> const& I, vec<L, T, Q> const& N)
 {
  return detail::compute_reflect<L, T, Q, detail::is_aligned<Q>::value>::call(I, N);
 }


 template<typename genType>
 inline genType refract(genType const& I, genType const& N, genType eta)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'refract' accepts only floating-point inputs");
  genType const dotValue(dot(N, I));
  genType const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));
  return (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> refract(vec<L, T, Q> const& I, vec<L, T, Q> const& N, T eta)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'refract' accepts only floating-point inputs");
  return detail::compute_refract<L, T, Q, detail::is_aligned<Q>::value>::call(I, N, eta);
 }
}
# 117 "/usr/include/glm/geometric.hpp" 2 3 4
# 2 "/usr/include/glm/detail/func_matrix.inl" 2 3 4


namespace glm{
namespace detail
{
 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_matrixCompMult
 {
  inline static mat<C, R, T, Q> call(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
  {
   mat<C, R, T, Q> Result(1);
   for(length_t i = 0; i < Result.length(); ++i)
    Result[i] = x[i] * y[i];
   return Result;
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
 struct compute_matrixCompMult_type {
  inline static mat<C, R, T, Q> call(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'matrixCompMult' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.")
                                                                                                                            ;
   return detail::compute_matrixCompMult<C, R, T, Q, detail::is_aligned<Q>::value>::call(x, y);
  }
 };

 template<length_t DA, length_t DB, typename T, qualifier Q>
 struct compute_outerProduct {
  inline static typename detail::outerProduct_trait<DA, DB, T, Q>::type call(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
  {
   typename detail::outerProduct_trait<DA, DB, T, Q>::type m(0);
   for(length_t i = 0; i < m.length(); ++i)
    m[i] = c * r[i];
   return m;
  }
 };

 template<length_t DA, length_t DB, typename T, qualifier Q, bool IsFloat>
 struct compute_outerProduct_type {
  inline static typename detail::outerProduct_trait<DA, DB, T, Q>::type call(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'outerProduct' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.")
                                                                                                                          ;

   return detail::compute_outerProduct<DA, DB, T, Q>::call(c, r);
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_transpose{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<2, 2, T, Q, Aligned>
 {
  inline static mat<2, 2, T, Q> call(mat<2, 2, T, Q> const& m)
  {
   mat<2, 2, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<2, 3, T, Q, Aligned>
 {
  inline static mat<3, 2, T, Q> call(mat<2, 3, T, Q> const& m)
  {
   mat<3,2, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<2, 4, T, Q, Aligned>
 {
  inline static mat<4, 2, T, Q> call(mat<2, 4, T, Q> const& m)
  {
   mat<4, 2, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[3][0] = m[0][3];
   Result[3][1] = m[1][3];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<3, 2, T, Q, Aligned>
 {
  inline static mat<2, 3, T, Q> call(mat<3, 2, T, Q> const& m)
  {
   mat<2, 3, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<3, 3, T, Q, Aligned>
 {
  inline static mat<3, 3, T, Q> call(mat<3, 3, T, Q> const& m)
  {
   mat<3, 3, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];

   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];

   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<3, 4, T, Q, Aligned>
 {
  inline static mat<4, 3, T, Q> call(mat<3, 4, T, Q> const& m)
  {
   mat<4, 3, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   Result[3][0] = m[0][3];
   Result[3][1] = m[1][3];
   Result[3][2] = m[2][3];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<4, 2, T, Q, Aligned>
 {
  inline static mat<2, 4, T, Q> call(mat<4, 2, T, Q> const& m)
  {
   mat<2, 4, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[0][3] = m[3][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[1][3] = m[3][1];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<4, 3, T, Q, Aligned>
 {
  inline static mat<3, 4, T, Q> call(mat<4, 3, T, Q> const& m)
  {
   mat<3, 4, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[0][3] = m[3][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[1][3] = m[3][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   Result[2][3] = m[3][2];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<4, 4, T, Q, Aligned>
 {
  inline static mat<4, 4, T, Q> call(mat<4, 4, T, Q> const& m)
  {
   mat<4, 4, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[0][3] = m[3][0];

   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[1][3] = m[3][1];

   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   Result[2][3] = m[3][2];

   Result[3][0] = m[0][3];
   Result[3][1] = m[1][3];
   Result[3][2] = m[2][3];
   Result[3][3] = m[3][3];
   return Result;
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
 struct compute_transpose_type {
  inline static mat<R, C, T, Q> call(mat<C, R, T, Q> const& m)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'transpose' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.")
                                                                                                                       ;
   return detail::compute_transpose<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_determinant{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_determinant<2, 2, T, Q, Aligned>
 {
  inline static T call(mat<2, 2, T, Q> const& m)
  {
   return m[0][0] * m[1][1] - m[1][0] * m[0][1];
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_determinant<3, 3, T, Q, Aligned>
 {
  inline static T call(mat<3, 3, T, Q> const& m)
  {
   return
    + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_determinant<4, 4, T, Q, Aligned>
 {
  inline static T call(mat<4, 4, T, Q> const& m)
  {
   T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
   T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
   T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
   T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
   T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
   T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

   vec<4, T, Q> DetCof(
    + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
    - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
    + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
    - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

   return
    m[0][0] * DetCof[0] + m[0][1] * DetCof[1] +
    m[0][2] * DetCof[2] + m[0][3] * DetCof[3];
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
 struct compute_determinant_type{

  inline static T call(mat<C, R, T, Q> const& m)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'determinant' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.")
                                                                                                                         ;
   return detail::compute_determinant<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_inverse{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_inverse<2, 2, T, Q, Aligned>
 {
  inline static mat<2, 2, T, Q> call(mat<2, 2, T, Q> const& m)
  {
   T OneOverDeterminant = static_cast<T>(1) / (
    + m[0][0] * m[1][1]
    - m[1][0] * m[0][1]);

   mat<2, 2, T, Q> Inverse(
    + m[1][1] * OneOverDeterminant,
    - m[0][1] * OneOverDeterminant,
    - m[1][0] * OneOverDeterminant,
    + m[0][0] * OneOverDeterminant);

   return Inverse;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_inverse<3, 3, T, Q, Aligned>
 {
  inline static mat<3, 3, T, Q> call(mat<3, 3, T, Q> const& m)
  {
   T OneOverDeterminant = static_cast<T>(1) / (
    + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]));

   mat<3, 3, T, Q> Inverse;
   Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * OneOverDeterminant;
   Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]) * OneOverDeterminant;
   Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * OneOverDeterminant;
   Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]) * OneOverDeterminant;
   Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]) * OneOverDeterminant;
   Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]) * OneOverDeterminant;
   Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]) * OneOverDeterminant;
   Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]) * OneOverDeterminant;
   Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * OneOverDeterminant;

   return Inverse;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_inverse<4, 4, T, Q, Aligned>
 {
  inline static mat<4, 4, T, Q> call(mat<4, 4, T, Q> const& m)
  {
   T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
   T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
   T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

   T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
   T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
   T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

   T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
   T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
   T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

   T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
   T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
   T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

   T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
   T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
   T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

   T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
   T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
   T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

   vec<4, T, Q> Fac0(Coef00, Coef00, Coef02, Coef03);
   vec<4, T, Q> Fac1(Coef04, Coef04, Coef06, Coef07);
   vec<4, T, Q> Fac2(Coef08, Coef08, Coef10, Coef11);
   vec<4, T, Q> Fac3(Coef12, Coef12, Coef14, Coef15);
   vec<4, T, Q> Fac4(Coef16, Coef16, Coef18, Coef19);
   vec<4, T, Q> Fac5(Coef20, Coef20, Coef22, Coef23);

   vec<4, T, Q> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
   vec<4, T, Q> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
   vec<4, T, Q> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
   vec<4, T, Q> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

   vec<4, T, Q> Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
   vec<4, T, Q> Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
   vec<4, T, Q> Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
   vec<4, T, Q> Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

   vec<4, T, Q> SignA(+1, -1, +1, -1);
   vec<4, T, Q> SignB(-1, +1, -1, +1);
   mat<4, 4, T, Q> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA, Inv3 * SignB);

   vec<4, T, Q> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

   vec<4, T, Q> Dot0(m[0] * Row0);
   T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);

   T OneOverDeterminant = static_cast<T>(1) / Dot1;

   return Inverse * OneOverDeterminant;
  }
 };
}

 template<length_t C, length_t R, typename T, qualifier Q>
 inline mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
 {
  return detail::compute_matrixCompMult_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x, y);
 }

 template<length_t DA, length_t DB, typename T, qualifier Q>
 inline typename detail::outerProduct_trait<DA, DB, T, Q>::type outerProduct(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
 {
  return detail::compute_outerProduct_type<DA, DB, T, Q, std::numeric_limits<T>::is_iec559>::call(c, r);
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline typename mat<C, R, T, Q>::transpose_type transpose(mat<C, R, T, Q> const& m)
 {
  return detail::compute_transpose_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(m);
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline T determinant(mat<C, R, T, Q> const& m)
 {
  return detail::compute_determinant_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(m);
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'inverse' only accept floating-point inputs");
  return detail::compute_inverse<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
 }
}
# 162 "/usr/include/glm/matrix.hpp" 2 3 4
# 2 "/usr/include/glm/detail/type_mat2x2.inl" 2 3 4

namespace glm
{
# 21 "/usr/include/glm/detail/type_mat2x2.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<2, 2, T, Q>::mat(mat<2, 2, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(T scalar)

   : value{col_type(scalar, 0), col_type(0, scalar)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat
 (
  T const& x0, T const& y0,
  T const& x1, T const& y1
 )

   : value{col_type(x0, y0), col_type(x1, y1)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(col_type const& v0, col_type const& v1)

   : value{v0, v1}

 {




 }



 template<typename T, qualifier Q>
 template<typename X1, typename Y1, typename X2, typename Y2>
 inline constexpr mat<2, 2, T, Q>::mat
 (
  X1 const& x1, Y1 const& y1,
  X2 const& x2, Y2 const& y2
 )

   : value{col_type(static_cast<T>(x1), value_type(y1)), col_type(static_cast<T>(x2), value_type(y2)) }

 {




 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2>
 inline constexpr mat<2, 2, T, Q>::mat(vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2)

   : value{col_type(v1), col_type(v2)}

 {




 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<2, 2, T, Q>::mat(mat<2, 2, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::col_type& mat<2, 2, T, Q>::operator[](typename mat<2, 2, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::col_type const& mat<2, 2, T, Q>::operator[](typename mat<2, 2, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator=(mat<2, 2, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator+=(U scalar)
 {
  this->value[0] += scalar;
  this->value[1] += scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator+=(mat<2, 2, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator-=(U scalar)
 {
  this->value[0] -= scalar;
  this->value[1] -= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator-=(mat<2, 2, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator*=(U scalar)
 {
  this->value[0] *= scalar;
  this->value[1] *= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator*=(mat<2, 2, U, Q> const& m)
 {
  return (*this = *this * m);
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator/=(U scalar)
 {
  this->value[0] /= scalar;
  this->value[1] /= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator/=(mat<2, 2, U, Q> const& m)
 {
  return *this *= inverse(m);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> mat<2, 2, T, Q>::operator++(int)
 {
  mat<2, 2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> mat<2, 2, T, Q>::operator--(int)
 {
  mat<2, 2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   -m[0],
   -m[1]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator+(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 2, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator-(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   scalar - m[0],
   scalar - m[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 2, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator*(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::col_type operator*
 (
  mat<2, 2, T, Q> const& m,
  typename mat<2, 2, T, Q>::row_type const& v
 )
 {
  return vec<2, T, Q>(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::row_type operator*
 (
  typename mat<2, 2, T, Q>::col_type const& v,
  mat<2, 2, T, Q> const& m
 )
 {
  return vec<2, T, Q>(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator/(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   scalar / m[0],
   scalar / m[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::col_type operator/(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v)
 {
  return inverse(m) * v;
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::row_type operator/(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m)
 {
  return v * inverse(m);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  mat<2, 2, T, Q> m1_copy(m1);
  return m1_copy /= m2;
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 177 "/usr/include/glm/detail/type_mat2x2.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double2x2.hpp" 2 3 4

namespace glm
{






 typedef mat<2, 2, double, defaultp> dmat2x2;




 typedef mat<2, 2, double, defaultp> dmat2;


}
# 6 "/usr/include/glm/mat2x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double2x2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<2, 2, double, lowp> lowp_dmat2;





 typedef mat<2, 2, double, mediump> mediump_dmat2;





 typedef mat<2, 2, double, highp> highp_dmat2;





 typedef mat<2, 2, double, lowp> lowp_dmat2x2;





 typedef mat<2, 2, double, mediump> mediump_dmat2x2;





 typedef mat<2, 2, double, highp> highp_dmat2x2;


}
# 7 "/usr/include/glm/mat2x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float2x2.hpp" 1 3 4



       


namespace glm
{






 typedef mat<2, 2, float, defaultp> mat2x2;




 typedef mat<2, 2, float, defaultp> mat2;


}
# 8 "/usr/include/glm/mat2x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float2x2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<2, 2, float, lowp> lowp_mat2;





 typedef mat<2, 2, float, mediump> mediump_mat2;





 typedef mat<2, 2, float, highp> highp_mat2;





 typedef mat<2, 2, float, lowp> lowp_mat2x2;





 typedef mat<2, 2, float, mediump> mediump_mat2x2;





 typedef mat<2, 2, float, highp> highp_mat2x2;


}
# 9 "/usr/include/glm/mat2x2.hpp" 2 3 4
# 121 "/usr/include/glm/glm.hpp" 2 3 4
# 130 "/usr/include/glm/glm.hpp" 3 4
# 1 "/usr/include/glm/trigonometric.hpp" 1 3 4
# 19 "/usr/include/glm/trigonometric.hpp" 3 4
       

# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 22 "/usr/include/glm/trigonometric.hpp" 2 3 4


namespace glm
{
# 37 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> radians(vec<L, T, Q> const& degrees);
# 48 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> degrees(vec<L, T, Q> const& radians);
# 60 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> sin(vec<L, T, Q> const& angle);
# 72 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> cos(vec<L, T, Q> const& angle);
# 83 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> tan(vec<L, T, Q> const& angle);
# 96 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> asin(vec<L, T, Q> const& x);
# 109 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> acos(vec<L, T, Q> const& x);
# 124 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> atan(vec<L, T, Q> const& y, vec<L, T, Q> const& x);
# 136 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> atan(vec<L, T, Q> const& y_over_x);
# 147 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> sinh(vec<L, T, Q> const& angle);
# 158 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> cosh(vec<L, T, Q> const& angle);
# 169 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> tanh(vec<L, T, Q> const& angle);
# 180 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> asinh(vec<L, T, Q> const& x);
# 192 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> acosh(vec<L, T, Q> const& x);
# 204 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> atanh(vec<L, T, Q> const& x);


}

# 1 "/usr/include/glm/detail/func_trigonometric.inl" 1 3 4

# 1 "/usr/include/c++/14.2.1/cmath" 1 3 4
# 39 "/usr/include/c++/14.2.1/cmath" 3 4
       
# 40 "/usr/include/c++/14.2.1/cmath" 3
# 3 "/usr/include/glm/detail/func_trigonometric.inl" 2 3 4


namespace glm
{

 template<typename genType>
 inline constexpr genType radians(genType degrees)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'radians' only accept floating-point input");

  return degrees * static_cast<genType>(0.01745329251994329576923690768489);
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> radians(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(radians, v);
 }


 template<typename genType>
 inline constexpr genType degrees(genType radians)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'degrees' only accept floating-point input");

  return radians * static_cast<genType>(57.295779513082320876798154814105);
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> degrees(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(degrees, v);
 }


 using ::std::sin;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> sin(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(sin, v);
 }


 using std::cos;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> cos(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(cos, v);
 }


 using std::tan;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> tan(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(tan, v);
 }


 using std::asin;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> asin(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(asin, v);
 }


 using std::acos;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> acos(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(acos, v);
 }


 template<typename genType>
 inline genType atan(genType y, genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'atan' only accept floating-point input");

  return ::std::atan2(y, x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> atan(vec<L, T, Q> const& y, vec<L, T, Q> const& x)
 {
  return detail::functor2<vec, L, T, Q>::call(::std::atan2, y, x);
 }

 using std::atan;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> atan(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(atan, v);
 }


 using std::sinh;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> sinh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(sinh, v);
 }


 using std::cosh;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> cosh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(cosh, v);
 }


 using std::tanh;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> tanh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(tanh, v);
 }



  using std::asinh;
# 145 "/usr/include/glm/detail/func_trigonometric.inl" 3 4
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> asinh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(asinh, v);
 }



  using std::acosh;
# 166 "/usr/include/glm/detail/func_trigonometric.inl" 3 4
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> acosh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(acosh, v);
 }



  using std::atanh;
# 187 "/usr/include/glm/detail/func_trigonometric.inl" 3 4
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> atanh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(atanh, v);
 }
}
# 211 "/usr/include/glm/trigonometric.hpp" 2 3 4
# 131 "/usr/include/glm/glm.hpp" 2 3 4


# 1 "/usr/include/glm/packing.hpp" 1 3 4
# 16 "/usr/include/glm/packing.hpp" 3 4
       





namespace glm
{
# 38 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] uint packUnorm2x16(vec2 const& v);
# 51 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] uint packSnorm2x16(vec2 const& v);
# 64 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] uint packUnorm4x8(vec4 const& v);
# 77 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] uint packSnorm4x8(vec4 const& v);
# 90 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] vec2 unpackUnorm2x16(uint p);
# 103 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] vec2 unpackSnorm2x16(uint p);
# 116 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] vec4 unpackUnorm4x8(uint p);
# 129 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] vec4 unpackSnorm4x8(uint p);
# 139 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] double packDouble2x32(uvec2 const& v);
# 148 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] uvec2 unpackDouble2x32(double v);
# 158 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] uint packHalf2x16(vec2 const& v);
# 168 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] vec2 unpackHalf2x16(uint v);


}

# 1 "/usr/include/glm/detail/func_packing.inl" 1 3 4




# 1 "/usr/include/glm/detail/type_half.hpp" 1 3 4
       

# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 4 "/usr/include/glm/detail/type_half.hpp" 2 3 4

namespace glm{
namespace detail
{
 typedef short hdata;

 [[nodiscard]] float toFloat32(hdata value);
 [[nodiscard]] hdata toFloat16(float const& value);

}
}

# 1 "/usr/include/glm/detail/type_half.inl" 1 3 4
namespace glm{
namespace detail
{
 inline float overflow()
 {
  volatile float f = 1e10;

  for(int i = 0; i < 10; ++i)
   f = f * f;
  return f;
 }

 union uif32
 {
  inline uif32() :
   i(0)
  {}

  inline uif32(float f_) :
   f(f_)
  {}

  inline uif32(unsigned int i_) :
   i(i_)
  {}

  float f;
  unsigned int i;
 };

 inline float toFloat32(hdata value)
 {
  int s = (value >> 15) & 0x00000001;
  int e = (value >> 10) & 0x0000001f;
  int m = value & 0x000003ff;

  if(e == 0)
  {
   if(m == 0)
   {




    detail::uif32 result;
    result.i = static_cast<unsigned int>(s << 31);
    return result.f;
   }
   else
   {




    while(!(m & 0x00000400))
    {
     m <<= 1;
     e -= 1;
    }

    e += 1;
    m &= ~0x00000400;
   }
  }
  else if(e == 31)
  {
   if(m == 0)
   {




    uif32 result;
    result.i = static_cast<unsigned int>((s << 31) | 0x7f800000);
    return result.f;
   }
   else
   {




    uif32 result;
    result.i = static_cast<unsigned int>((s << 31) | 0x7f800000 | (m << 13));
    return result.f;
   }
  }





  e = e + (127 - 15);
  m = m << 13;





  uif32 Result;
  Result.i = static_cast<unsigned int>((s << 31) | (e << 23) | m);
  return Result.f;
 }

 inline hdata toFloat16(float const& f)
 {
  uif32 Entry;
  Entry.f = f;
  int i = static_cast<int>(Entry.i);
# 121 "/usr/include/glm/detail/type_half.inl" 3 4
  int s = (i >> 16) & 0x00008000;
  int e = ((i >> 23) & 0x000000ff) - (127 - 15);
  int m = i & 0x007fffff;





  if(e <= 0)
  {
   if(e < -10)
   {
# 141 "/usr/include/glm/detail/type_half.inl" 3 4
    return hdata(s);
   }
# 151 "/usr/include/glm/detail/type_half.inl" 3 4
   m = (m | 0x00800000) >> (1 - e);
# 162 "/usr/include/glm/detail/type_half.inl" 3 4
   if(m & 0x00001000)
    m += 0x00002000;





   return hdata(s | (m >> 13));
  }
  else if(e == 0xff - (127 - 15))
  {
   if(m == 0)
   {





    return hdata(s | 0x7c00);
   }
   else
   {
# 193 "/usr/include/glm/detail/type_half.inl" 3 4
    m >>= 13;

    return hdata(s | 0x7c00 | m | (m == 0));
   }
  }
  else
  {
# 209 "/usr/include/glm/detail/type_half.inl" 3 4
   if(m & 0x00001000)
   {
    m += 0x00002000;

    if(m & 0x00800000)
    {
     m = 0;
     e += 1;
    }
   }





   if (e > 30)
   {
    overflow();

    return hdata(s | 0x7c00);

   }





   return hdata(s | (e << 10) | (m >> 13));
  }
 }

}
}
# 17 "/usr/include/glm/detail/type_half.hpp" 2 3 4
# 6 "/usr/include/glm/detail/func_packing.inl" 2 3 4

namespace glm
{
 inline uint packUnorm2x16(vec2 const& v)
 {
  union
  {
   unsigned short in[2];
   uint out;
  } u;

  vec<2, unsigned short, defaultp> result(round(clamp(v, 0.0f, 1.0f) * 65535.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];

  return u.out;
 }

 inline vec2 unpackUnorm2x16(uint p)
 {
  union
  {
   uint in;
   unsigned short out[2];
  } u;

  u.in = p;

  return vec2(u.out[0], u.out[1]) * 1.5259021896696421759365224689097e-5f;
 }

 inline uint packSnorm2x16(vec2 const& v)
 {
  union
  {
   signed short in[2];
   uint out;
  } u;

  vec<2, short, defaultp> result(round(clamp(v, -1.0f, 1.0f) * 32767.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];

  return u.out;
 }

 inline vec2 unpackSnorm2x16(uint p)
 {
  union
  {
   uint in;
   signed short out[2];
  } u;

  u.in = p;

  return clamp(vec2(u.out[0], u.out[1]) * 3.0518509475997192297128208258309e-5f, -1.0f, 1.0f);
 }

 inline uint packUnorm4x8(vec4 const& v)
 {
  union
  {
   unsigned char in[4];
   uint out;
  } u;

  vec<4, unsigned char, defaultp> result(round(clamp(v, 0.0f, 1.0f) * 255.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];
  u.in[2] = result[2];
  u.in[3] = result[3];

  return u.out;
 }

 inline vec4 unpackUnorm4x8(uint p)
 {
  union
  {
   uint in;
   unsigned char out[4];
  } u;

  u.in = p;

  return vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0039215686274509803921568627451f;
 }

 inline uint packSnorm4x8(vec4 const& v)
 {
  union
  {
   signed char in[4];
   uint out;
  } u;

  vec<4, signed char, defaultp> result(round(clamp(v, -1.0f, 1.0f) * 127.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];
  u.in[2] = result[2];
  u.in[3] = result[3];

  return u.out;
 }

 inline glm::vec4 unpackSnorm4x8(uint p)
 {
  union
  {
   uint in;
   signed char out[4];
  } u;

  u.in = p;

  return clamp(vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0078740157480315f, -1.0f, 1.0f);
 }

 inline double packDouble2x32(uvec2 const& v)
 {
  union
  {
   uint in[2];
   double out;
  } u;

  u.in[0] = v[0];
  u.in[1] = v[1];

  return u.out;
 }

 inline uvec2 unpackDouble2x32(double v)
 {
  union
  {
   double in;
   uint out[2];
  } u;

  u.in = v;

  return uvec2(u.out[0], u.out[1]);
 }

 inline uint packHalf2x16(vec2 const& v)
 {
  union
  {
   signed short in[2];
   uint out;
  } u;

  u.in[0] = detail::toFloat16(v.x);
  u.in[1] = detail::toFloat16(v.y);

  return u.out;
 }

 inline vec2 unpackHalf2x16(uint v)
 {
  union
  {
   uint in;
   signed short out[2];
  } u;

  u.in = v;

  return vec2(
   detail::toFloat32(u.out[0]),
   detail::toFloat32(u.out[1]));
 }
}
# 174 "/usr/include/glm/packing.hpp" 2 3 4
# 134 "/usr/include/glm/glm.hpp" 2 3 4



# 1 "/usr/include/glm/integer.hpp" 1 3 4
# 17 "/usr/include/glm/integer.hpp" 3 4
       





namespace glm
{
# 36 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, uint, Q> uaddCarry(
  vec<L, uint, Q> const& x,
  vec<L, uint, Q> const& y,
  vec<L, uint, Q> & carry);
# 50 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, uint, Q> usubBorrow(
  vec<L, uint, Q> const& x,
  vec<L, uint, Q> const& y,
  vec<L, uint, Q> & borrow);
# 64 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, qualifier Q>
 void umulExtended(
  vec<L, uint, Q> const& x,
  vec<L, uint, Q> const& y,
  vec<L, uint, Q> & msb,
  vec<L, uint, Q> & lsb);
# 79 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, qualifier Q>
 void imulExtended(
  vec<L, int, Q> const& x,
  vec<L, int, Q> const& y,
  vec<L, int, Q> & msb,
  vec<L, int, Q> & lsb);
# 102 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> bitfieldExtract(
  vec<L, T, Q> const& Value,
  int Offset,
  int Bits);
# 123 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> bitfieldInsert(
  vec<L, T, Q> const& Base,
  vec<L, T, Q> const& Insert,
  int Offset,
  int Bits);
# 139 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> bitfieldReverse(vec<L, T, Q> const& v);







 template<typename genType>
 [[nodiscard]] int bitCount(genType v);
# 158 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, int, Q> bitCount(vec<L, T, Q> const& v);
# 169 "/usr/include/glm/integer.hpp" 3 4
 template<typename genIUType>
 [[nodiscard]] int findLSB(genIUType x);
# 181 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, int, Q> findLSB(vec<L, T, Q> const& v);
# 193 "/usr/include/glm/integer.hpp" 3 4
 template<typename genIUType>
 [[nodiscard]] int findMSB(genIUType x);
# 206 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, int, Q> findMSB(vec<L, T, Q> const& v);


}

# 1 "/usr/include/glm/detail/func_integer.inl" 1 3 4
# 21 "/usr/include/glm/detail/func_integer.inl" 3 4
namespace glm{
namespace detail
{
 template<typename T>
 inline T mask(T Bits)
 {
  return Bits >= static_cast<T>(sizeof(T) * 8) ? ~static_cast<T>(0) : (static_cast<T>(1) << Bits) - static_cast<T>(1);
 }

 template<length_t L, typename T, qualifier Q, bool Aligned, bool EXEC>
 struct compute_bitfieldReverseStep
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T, T)
  {
   return v;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_bitfieldReverseStep<L, T, Q, Aligned, true>
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Mask, T Shift)
  {
   return (v & Mask) << Shift | (v & (~Mask)) >> Shift;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned, bool EXEC>
 struct compute_bitfieldBitCountStep
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T, T)
  {
   return v;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_bitfieldBitCountStep<L, T, Q, Aligned, true>
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Mask, T Shift)
  {
   return (v & Mask) + ((v >> Shift) & Mask);
  }
 };

 template<typename genIUType, size_t Bits>
 struct compute_findLSB
 {
  inline static int call(genIUType Value)
  {
   if(Value == 0)
    return -1;

   return glm::bitCount(~Value & (Value - static_cast<genIUType>(1)));
  }
 };
# 104 "/usr/include/glm/detail/func_integer.inl" 3 4
 template<length_t L, typename T, qualifier Q, bool EXEC = true>
 struct compute_findMSB_step_vec
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, T Shift)
  {
   return x | (x >> Shift);
  }
 };

 template<length_t L, typename T, qualifier Q>
 struct compute_findMSB_step_vec<L, T, Q, false>
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, T)
  {
   return x;
  }
 };

 template<length_t L, typename T, qualifier Q, int>
 struct compute_findMSB_vec
 {
  inline static vec<L, int, Q> call(vec<L, T, Q> const& v)
  {
   vec<L, T, Q> x(v);
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 1));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 2));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 4));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 16>::call(x, static_cast<T>( 8));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 32>::call(x, static_cast<T>(16));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 64>::call(x, static_cast<T>(32));
   return vec<L, int, Q>(sizeof(T) * 8 - 1) - glm::bitCount(~x);
  }
 };
# 175 "/usr/include/glm/detail/func_integer.inl" 3 4
}


 inline uint uaddCarry(uint const& x, uint const& y, uint & Carry)
 {
  detail::uint64 const Value64(static_cast<detail::uint64>(x) + static_cast<detail::uint64>(y));
  detail::uint64 const Max32((static_cast<detail::uint64>(1) << static_cast<detail::uint64>(32)) - static_cast<detail::uint64>(1));
  Carry = Value64 > Max32 ? 1u : 0u;
  return static_cast<uint>(Value64 % (Max32 + static_cast<detail::uint64>(1)));
 }

 template<length_t L, qualifier Q>
 inline vec<L, uint, Q> uaddCarry(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& Carry)
 {
  vec<L, detail::uint64, Q> Value64(vec<L, detail::uint64, Q>(x) + vec<L, detail::uint64, Q>(y));
  vec<L, detail::uint64, Q> Max32((static_cast<detail::uint64>(1) << static_cast<detail::uint64>(32)) - static_cast<detail::uint64>(1));
  Carry = mix(vec<L, uint, Q>(0), vec<L, uint, Q>(1), greaterThan(Value64, Max32));
  return vec<L, uint, Q>(Value64 % (Max32 + static_cast<detail::uint64>(1)));
 }


 inline uint usubBorrow(uint const& x, uint const& y, uint & Borrow)
 {
  Borrow = x >= y ? static_cast<uint>(0) : static_cast<uint>(1);
  if(y >= x)
   return y - x;
  else
   return static_cast<uint>((static_cast<detail::int64>(1) << static_cast<detail::int64>(32)) + (static_cast<detail::int64>(y) - static_cast<detail::int64>(x)));
 }

 template<length_t L, qualifier Q>
 inline vec<L, uint, Q> usubBorrow(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& Borrow)
 {
  Borrow = mix(vec<L, uint, Q>(1), vec<L, uint, Q>(0), greaterThanEqual(x, y));
  vec<L, uint, Q> const YgeX(y - x);
  vec<L, uint, Q> const XgeY(vec<L, uint, Q>((static_cast<detail::int64>(1) << static_cast<detail::int64>(32)) + (vec<L, detail::int64, Q>(y) - vec<L, detail::int64, Q>(x))));
  return mix(XgeY, YgeX, greaterThanEqual(y, x));
 }


 inline void umulExtended(uint const& x, uint const& y, uint & msb, uint & lsb)
 {
  detail::uint64 Value64 = static_cast<detail::uint64>(x) * static_cast<detail::uint64>(y);
  msb = static_cast<uint>(Value64 >> static_cast<detail::uint64>(32));
  lsb = static_cast<uint>(Value64);
 }

 template<length_t L, qualifier Q>
 inline void umulExtended(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& msb, vec<L, uint, Q>& lsb)
 {
  vec<L, detail::uint64, Q> Value64(vec<L, detail::uint64, Q>(x) * vec<L, detail::uint64, Q>(y));
  msb = vec<L, uint, Q>(Value64 >> static_cast<detail::uint64>(32));
  lsb = vec<L, uint, Q>(Value64);
 }


 inline void imulExtended(int x, int y, int& msb, int& lsb)
 {
  detail::int64 Value64 = static_cast<detail::int64>(x) * static_cast<detail::int64>(y);
  msb = static_cast<int>(Value64 >> static_cast<detail::int64>(32));
  lsb = static_cast<int>(Value64);
 }

 template<length_t L, qualifier Q>
 inline void imulExtended(vec<L, int, Q> const& x, vec<L, int, Q> const& y, vec<L, int, Q>& msb, vec<L, int, Q>& lsb)
 {
  vec<L, detail::int64, Q> Value64(vec<L, detail::int64, Q>(x) * vec<L, detail::int64, Q>(y));
  lsb = vec<L, int, Q>(Value64 & static_cast<detail::int64>(0xFFFFFFFF));
  msb = vec<L, int, Q>((Value64 >> static_cast<detail::int64>(32)) & static_cast<detail::int64>(0xFFFFFFFF));
 }


 template<typename genIUType>
 inline genIUType bitfieldExtract(genIUType Value, int Offset, int Bits)
 {
  return bitfieldExtract(vec<1, genIUType>(Value), Offset, Bits).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> bitfieldExtract(vec<L, T, Q> const& Value, int Offset, int Bits)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitfieldExtract' only accept integer inputs");

  return (Value >> static_cast<T>(Offset)) & static_cast<T>(detail::mask(Bits));
 }


 template<typename genIUType>
 inline genIUType bitfieldInsert(genIUType const& Base, genIUType const& Insert, int Offset, int Bits)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'bitfieldInsert' only accept integer values");

  return bitfieldInsert(vec<1, genIUType>(Base), vec<1, genIUType>(Insert), Offset, Bits).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> bitfieldInsert(vec<L, T, Q> const& Base, vec<L, T, Q> const& Insert, int Offset, int Bits)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitfieldInsert' only accept integer values");

  T const Mask = detail::mask(static_cast<T>(Bits)) << Offset;
  return (Base & ~Mask) | ((Insert << static_cast<T>(Offset)) & Mask);
 }







 template<typename genIUType>
 inline genIUType bitfieldReverse(genIUType x)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'bitfieldReverse' only accept integer values");

  return bitfieldReverse(glm::vec<1, genIUType, glm::defaultp>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> bitfieldReverse(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitfieldReverse' only accept integer values");

  vec<L, T, Q> x(v);
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 2>::call(x, static_cast<T>(0x5555555555555555ull), static_cast<T>( 1));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 4>::call(x, static_cast<T>(0x3333333333333333ull), static_cast<T>( 2));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 8>::call(x, static_cast<T>(0x0F0F0F0F0F0F0F0Full), static_cast<T>( 4));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 16>::call(x, static_cast<T>(0x00FF00FF00FF00FFull), static_cast<T>( 8));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 32>::call(x, static_cast<T>(0x0000FFFF0000FFFFull), static_cast<T>(16));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 64>::call(x, static_cast<T>(0x00000000FFFFFFFFull), static_cast<T>(32));
  return x;
 }






 template<typename genIUType>
 inline int bitCount(genIUType x)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'bitCount' only accept integer values");

  return bitCount(glm::vec<1, genIUType, glm::defaultp>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, int, Q> bitCount(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitCount' only accept integer values");






  vec<L, typename detail::make_unsigned<T>::type, Q> x(v);
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 2>::call(x, typename detail::make_unsigned<T>::type(0x5555555555555555ull), typename detail::make_unsigned<T>::type( 1));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 4>::call(x, typename detail::make_unsigned<T>::type(0x3333333333333333ull), typename detail::make_unsigned<T>::type( 2));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 8>::call(x, typename detail::make_unsigned<T>::type(0x0F0F0F0F0F0F0F0Full), typename detail::make_unsigned<T>::type( 4));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 16>::call(x, typename detail::make_unsigned<T>::type(0x00FF00FF00FF00FFull), typename detail::make_unsigned<T>::type( 8));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 32>::call(x, typename detail::make_unsigned<T>::type(0x0000FFFF0000FFFFull), typename detail::make_unsigned<T>::type(16));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 64>::call(x, typename detail::make_unsigned<T>::type(0x00000000FFFFFFFFull), typename detail::make_unsigned<T>::type(32));
  return vec<L, int, Q>(x);




 }


 template<typename genIUType>
 inline int findLSB(genIUType Value)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'findLSB' only accept integer values");

  return detail::compute_findLSB<genIUType, sizeof(genIUType) * 8>::call(Value);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, int, Q> findLSB(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'findLSB' only accept integer values");

  return detail::functor1<vec, L, int, T, Q>::call(findLSB, x);
 }


 template<typename genIUType>
 inline int findMSB(genIUType v)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'findMSB' only accept integer values");

  return findMSB(vec<1, genIUType>(v)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, int, Q> findMSB(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'findMSB' only accept integer values");

  return detail::compute_findMSB_vec<L, T, Q, static_cast<int>(sizeof(T) * 8)>::call(v);
 }
}
# 213 "/usr/include/glm/integer.hpp" 2 3 4
# 138 "/usr/include/glm/glm.hpp" 2 3 4
# 7 "/home/tayler/projects/marmalade/src/graphics/../../include/graphics/shader.h" 2


# 8 "/home/tayler/projects/marmalade/src/graphics/../../include/graphics/shader.h"
class Shader {
public:
    unsigned int ID;

    Shader(const char* vPath, const char* fPath);

    void Use();

    void SetBool(const std::string &name, bool value) const;
    void SetInt(const std::string &name, int value) const;
    void SetFloat(const std::string &name, float value) const;
    void SetMat4(const std::string &name, const glm::mat4 &mat) const;

private:
    void GetError(unsigned int shader, std::string type);
};
# 6 "/home/tayler/projects/marmalade/src/graphics/shader.cpp" 2
# 1 "/home/tayler/projects/marmalade/vendor/glad/include/glad/glad.h" 1
# 665 "/home/tayler/projects/marmalade/vendor/glad/include/glad/glad.h"
extern "C" {


struct gladGLversionStruct {
    int major;
    int minor;
};

typedef void* (* GLADloadproc)(const char *name);
# 701 "/home/tayler/projects/marmalade/vendor/glad/include/glad/glad.h"
extern struct gladGLversionStruct GLVersion;

extern int gladLoadGL(void);

extern int gladLoadGLLoader(GLADloadproc);

# 1 "/home/tayler/projects/marmalade/vendor/glad/include/KHR/khrplatform.h" 1
# 150 "/home/tayler/projects/marmalade/vendor/glad/include/KHR/khrplatform.h"
typedef int32_t khronos_int32_t;
typedef uint32_t khronos_uint32_t;
typedef int64_t khronos_int64_t;
typedef uint64_t khronos_uint64_t;
# 242 "/home/tayler/projects/marmalade/vendor/glad/include/KHR/khrplatform.h"
typedef signed char khronos_int8_t;
typedef unsigned char khronos_uint8_t;
typedef signed short int khronos_int16_t;
typedef unsigned short int khronos_uint16_t;
# 259 "/home/tayler/projects/marmalade/vendor/glad/include/KHR/khrplatform.h"
typedef signed long int khronos_intptr_t;
typedef unsigned long int khronos_uintptr_t;






typedef signed long int khronos_ssize_t;
typedef unsigned long int khronos_usize_t;






typedef float khronos_float_t;
# 288 "/home/tayler/projects/marmalade/vendor/glad/include/KHR/khrplatform.h"
typedef khronos_uint64_t khronos_utime_nanoseconds_t;
typedef khronos_int64_t khronos_stime_nanoseconds_t;
# 305 "/home/tayler/projects/marmalade/vendor/glad/include/KHR/khrplatform.h"
typedef enum {
    KHRONOS_FALSE = 0,
    KHRONOS_TRUE = 1,
    KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = 0x7FFFFFFF
} khronos_boolean_enum_t;
# 708 "/home/tayler/projects/marmalade/vendor/glad/include/glad/glad.h" 2
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef void GLvoid;
typedef khronos_int8_t GLbyte;
typedef khronos_uint8_t GLubyte;
typedef khronos_int16_t GLshort;
typedef khronos_uint16_t GLushort;
typedef int GLint;
typedef unsigned int GLuint;
typedef khronos_int32_t GLclampx;
typedef int GLsizei;
typedef khronos_float_t GLfloat;
typedef khronos_float_t GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void *GLeglClientBufferEXT;
typedef void *GLeglImageOES;
typedef char GLchar;
typedef char GLcharARB;



typedef unsigned int GLhandleARB;

typedef khronos_uint16_t GLhalf;
typedef khronos_uint16_t GLhalfARB;
typedef khronos_int32_t GLfixed;
typedef khronos_intptr_t GLintptr;
typedef khronos_intptr_t GLintptrARB;
typedef khronos_ssize_t GLsizeiptr;
typedef khronos_ssize_t GLsizeiptrARB;
typedef khronos_int64_t GLint64;
typedef khronos_int64_t GLint64EXT;
typedef khronos_uint64_t GLuint64;
typedef khronos_uint64_t GLuint64EXT;
typedef struct __GLsync *GLsync;
struct _cl_context;
struct _cl_event;
typedef void ( *GLDEBUGPROC)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void ( *GLDEBUGPROCARB)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void ( *GLDEBUGPROCKHR)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void ( *GLDEBUGPROCAMD)(GLuint id,GLenum category,GLenum severity,GLsizei length,const GLchar *message,void *userParam);
typedef unsigned short GLhalfNV;
typedef GLintptr GLvdpauSurfaceNV;
typedef void ( *GLVULKANPROCNV)(void);
# 2136 "/home/tayler/projects/marmalade/vendor/glad/include/glad/glad.h"
extern int GLAD_GL_VERSION_1_0;
typedef void ( * PFNGLCULLFACEPROC)(GLenum mode);
extern PFNGLCULLFACEPROC glad_glCullFace;

typedef void ( * PFNGLFRONTFACEPROC)(GLenum mode);
extern PFNGLFRONTFACEPROC glad_glFrontFace;

typedef void ( * PFNGLHINTPROC)(GLenum target, GLenum mode);
extern PFNGLHINTPROC glad_glHint;

typedef void ( * PFNGLLINEWIDTHPROC)(GLfloat width);
extern PFNGLLINEWIDTHPROC glad_glLineWidth;

typedef void ( * PFNGLPOINTSIZEPROC)(GLfloat size);
extern PFNGLPOINTSIZEPROC glad_glPointSize;

typedef void ( * PFNGLPOLYGONMODEPROC)(GLenum face, GLenum mode);
extern PFNGLPOLYGONMODEPROC glad_glPolygonMode;

typedef void ( * PFNGLSCISSORPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLSCISSORPROC glad_glScissor;

typedef void ( * PFNGLTEXPARAMETERFPROC)(GLenum target, GLenum pname, GLfloat param);
extern PFNGLTEXPARAMETERFPROC glad_glTexParameterf;

typedef void ( * PFNGLTEXPARAMETERFVPROC)(GLenum target, GLenum pname, const GLfloat *params);
extern PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv;

typedef void ( * PFNGLTEXPARAMETERIPROC)(GLenum target, GLenum pname, GLint param);
extern PFNGLTEXPARAMETERIPROC glad_glTexParameteri;

typedef void ( * PFNGLTEXPARAMETERIVPROC)(GLenum target, GLenum pname, const GLint *params);
extern PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv;

typedef void ( * PFNGLTEXIMAGE1DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXIMAGE1DPROC glad_glTexImage1D;

typedef void ( * PFNGLTEXIMAGE2DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXIMAGE2DPROC glad_glTexImage2D;

typedef void ( * PFNGLDRAWBUFFERPROC)(GLenum buf);
extern PFNGLDRAWBUFFERPROC glad_glDrawBuffer;

typedef void ( * PFNGLCLEARPROC)(GLbitfield mask);
extern PFNGLCLEARPROC glad_glClear;

typedef void ( * PFNGLCLEARCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern PFNGLCLEARCOLORPROC glad_glClearColor;

typedef void ( * PFNGLCLEARSTENCILPROC)(GLint s);
extern PFNGLCLEARSTENCILPROC glad_glClearStencil;

typedef void ( * PFNGLCLEARDEPTHPROC)(GLdouble depth);
extern PFNGLCLEARDEPTHPROC glad_glClearDepth;

typedef void ( * PFNGLSTENCILMASKPROC)(GLuint mask);
extern PFNGLSTENCILMASKPROC glad_glStencilMask;

typedef void ( * PFNGLCOLORMASKPROC)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern PFNGLCOLORMASKPROC glad_glColorMask;

typedef void ( * PFNGLDEPTHMASKPROC)(GLboolean flag);
extern PFNGLDEPTHMASKPROC glad_glDepthMask;

typedef void ( * PFNGLDISABLEPROC)(GLenum cap);
extern PFNGLDISABLEPROC glad_glDisable;

typedef void ( * PFNGLENABLEPROC)(GLenum cap);
extern PFNGLENABLEPROC glad_glEnable;

typedef void ( * PFNGLFINISHPROC)(void);
extern PFNGLFINISHPROC glad_glFinish;

typedef void ( * PFNGLFLUSHPROC)(void);
extern PFNGLFLUSHPROC glad_glFlush;

typedef void ( * PFNGLBLENDFUNCPROC)(GLenum sfactor, GLenum dfactor);
extern PFNGLBLENDFUNCPROC glad_glBlendFunc;

typedef void ( * PFNGLLOGICOPPROC)(GLenum opcode);
extern PFNGLLOGICOPPROC glad_glLogicOp;

typedef void ( * PFNGLSTENCILFUNCPROC)(GLenum func, GLint ref, GLuint mask);
extern PFNGLSTENCILFUNCPROC glad_glStencilFunc;

typedef void ( * PFNGLSTENCILOPPROC)(GLenum fail, GLenum zfail, GLenum zpass);
extern PFNGLSTENCILOPPROC glad_glStencilOp;

typedef void ( * PFNGLDEPTHFUNCPROC)(GLenum func);
extern PFNGLDEPTHFUNCPROC glad_glDepthFunc;

typedef void ( * PFNGLPIXELSTOREFPROC)(GLenum pname, GLfloat param);
extern PFNGLPIXELSTOREFPROC glad_glPixelStoref;

typedef void ( * PFNGLPIXELSTOREIPROC)(GLenum pname, GLint param);
extern PFNGLPIXELSTOREIPROC glad_glPixelStorei;

typedef void ( * PFNGLREADBUFFERPROC)(GLenum src);
extern PFNGLREADBUFFERPROC glad_glReadBuffer;

typedef void ( * PFNGLREADPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels);
extern PFNGLREADPIXELSPROC glad_glReadPixels;

typedef void ( * PFNGLGETBOOLEANVPROC)(GLenum pname, GLboolean *data);
extern PFNGLGETBOOLEANVPROC glad_glGetBooleanv;

typedef void ( * PFNGLGETDOUBLEVPROC)(GLenum pname, GLdouble *data);
extern PFNGLGETDOUBLEVPROC glad_glGetDoublev;

typedef GLenum ( * PFNGLGETERRORPROC)(void);
extern PFNGLGETERRORPROC glad_glGetError;

typedef void ( * PFNGLGETFLOATVPROC)(GLenum pname, GLfloat *data);
extern PFNGLGETFLOATVPROC glad_glGetFloatv;

typedef void ( * PFNGLGETINTEGERVPROC)(GLenum pname, GLint *data);
extern PFNGLGETINTEGERVPROC glad_glGetIntegerv;

typedef const GLubyte * ( * PFNGLGETSTRINGPROC)(GLenum name);
extern PFNGLGETSTRINGPROC glad_glGetString;

typedef void ( * PFNGLGETTEXIMAGEPROC)(GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
extern PFNGLGETTEXIMAGEPROC glad_glGetTexImage;

typedef void ( * PFNGLGETTEXPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv;

typedef void ( * PFNGLGETTEXPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv;

typedef void ( * PFNGLGETTEXLEVELPARAMETERFVPROC)(GLenum target, GLint level, GLenum pname, GLfloat *params);
extern PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv;

typedef void ( * PFNGLGETTEXLEVELPARAMETERIVPROC)(GLenum target, GLint level, GLenum pname, GLint *params);
extern PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv;

typedef GLboolean ( * PFNGLISENABLEDPROC)(GLenum cap);
extern PFNGLISENABLEDPROC glad_glIsEnabled;

typedef void ( * PFNGLDEPTHRANGEPROC)(GLdouble n, GLdouble f);
extern PFNGLDEPTHRANGEPROC glad_glDepthRange;

typedef void ( * PFNGLVIEWPORTPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLVIEWPORTPROC glad_glViewport;




extern int GLAD_GL_VERSION_1_1;
typedef void ( * PFNGLDRAWARRAYSPROC)(GLenum mode, GLint first, GLsizei count);
extern PFNGLDRAWARRAYSPROC glad_glDrawArrays;

typedef void ( * PFNGLDRAWELEMENTSPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices);
extern PFNGLDRAWELEMENTSPROC glad_glDrawElements;

typedef void ( * PFNGLPOLYGONOFFSETPROC)(GLfloat factor, GLfloat units);
extern PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset;

typedef void ( * PFNGLCOPYTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
extern PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D;

typedef void ( * PFNGLCOPYTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D;

typedef void ( * PFNGLCOPYTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D;

typedef void ( * PFNGLCOPYTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D;

typedef void ( * PFNGLTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D;

typedef void ( * PFNGLTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D;

typedef void ( * PFNGLBINDTEXTUREPROC)(GLenum target, GLuint texture);
extern PFNGLBINDTEXTUREPROC glad_glBindTexture;

typedef void ( * PFNGLDELETETEXTURESPROC)(GLsizei n, const GLuint *textures);
extern PFNGLDELETETEXTURESPROC glad_glDeleteTextures;

typedef void ( * PFNGLGENTEXTURESPROC)(GLsizei n, GLuint *textures);
extern PFNGLGENTEXTURESPROC glad_glGenTextures;

typedef GLboolean ( * PFNGLISTEXTUREPROC)(GLuint texture);
extern PFNGLISTEXTUREPROC glad_glIsTexture;




extern int GLAD_GL_VERSION_1_2;
typedef void ( * PFNGLDRAWRANGEELEMENTSPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
extern PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements;

typedef void ( * PFNGLTEXIMAGE3DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXIMAGE3DPROC glad_glTexImage3D;

typedef void ( * PFNGLTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D;

typedef void ( * PFNGLCOPYTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D;




extern int GLAD_GL_VERSION_1_3;
typedef void ( * PFNGLACTIVETEXTUREPROC)(GLenum texture);
extern PFNGLACTIVETEXTUREPROC glad_glActiveTexture;

typedef void ( * PFNGLSAMPLECOVERAGEPROC)(GLfloat value, GLboolean invert);
extern PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage;

typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D;

typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D;

typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D;

typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D;

typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D;

typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D;

typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint level, void *img);
extern PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage;




extern int GLAD_GL_VERSION_1_4;
typedef void ( * PFNGLBLENDFUNCSEPARATEPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
extern PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate;

typedef void ( * PFNGLMULTIDRAWARRAYSPROC)(GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
extern PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays;

typedef void ( * PFNGLMULTIDRAWELEMENTSPROC)(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount);
extern PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements;

typedef void ( * PFNGLPOINTPARAMETERFPROC)(GLenum pname, GLfloat param);
extern PFNGLPOINTPARAMETERFPROC glad_glPointParameterf;

typedef void ( * PFNGLPOINTPARAMETERFVPROC)(GLenum pname, const GLfloat *params);
extern PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv;

typedef void ( * PFNGLPOINTPARAMETERIPROC)(GLenum pname, GLint param);
extern PFNGLPOINTPARAMETERIPROC glad_glPointParameteri;

typedef void ( * PFNGLPOINTPARAMETERIVPROC)(GLenum pname, const GLint *params);
extern PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv;

typedef void ( * PFNGLBLENDCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern PFNGLBLENDCOLORPROC glad_glBlendColor;

typedef void ( * PFNGLBLENDEQUATIONPROC)(GLenum mode);
extern PFNGLBLENDEQUATIONPROC glad_glBlendEquation;




extern int GLAD_GL_VERSION_1_5;
typedef void ( * PFNGLGENQUERIESPROC)(GLsizei n, GLuint *ids);
extern PFNGLGENQUERIESPROC glad_glGenQueries;

typedef void ( * PFNGLDELETEQUERIESPROC)(GLsizei n, const GLuint *ids);
extern PFNGLDELETEQUERIESPROC glad_glDeleteQueries;

typedef GLboolean ( * PFNGLISQUERYPROC)(GLuint id);
extern PFNGLISQUERYPROC glad_glIsQuery;

typedef void ( * PFNGLBEGINQUERYPROC)(GLenum target, GLuint id);
extern PFNGLBEGINQUERYPROC glad_glBeginQuery;

typedef void ( * PFNGLENDQUERYPROC)(GLenum target);
extern PFNGLENDQUERYPROC glad_glEndQuery;

typedef void ( * PFNGLGETQUERYIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETQUERYIVPROC glad_glGetQueryiv;

typedef void ( * PFNGLGETQUERYOBJECTIVPROC)(GLuint id, GLenum pname, GLint *params);
extern PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv;

typedef void ( * PFNGLGETQUERYOBJECTUIVPROC)(GLuint id, GLenum pname, GLuint *params);
extern PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv;

typedef void ( * PFNGLBINDBUFFERPROC)(GLenum target, GLuint buffer);
extern PFNGLBINDBUFFERPROC glad_glBindBuffer;

typedef void ( * PFNGLDELETEBUFFERSPROC)(GLsizei n, const GLuint *buffers);
extern PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers;

typedef void ( * PFNGLGENBUFFERSPROC)(GLsizei n, GLuint *buffers);
extern PFNGLGENBUFFERSPROC glad_glGenBuffers;

typedef GLboolean ( * PFNGLISBUFFERPROC)(GLuint buffer);
extern PFNGLISBUFFERPROC glad_glIsBuffer;

typedef void ( * PFNGLBUFFERDATAPROC)(GLenum target, GLsizeiptr size, const void *data, GLenum usage);
extern PFNGLBUFFERDATAPROC glad_glBufferData;

typedef void ( * PFNGLBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, const void *data);
extern PFNGLBUFFERSUBDATAPROC glad_glBufferSubData;

typedef void ( * PFNGLGETBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, void *data);
extern PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData;

typedef void * ( * PFNGLMAPBUFFERPROC)(GLenum target, GLenum access);
extern PFNGLMAPBUFFERPROC glad_glMapBuffer;

typedef GLboolean ( * PFNGLUNMAPBUFFERPROC)(GLenum target);
extern PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer;

typedef void ( * PFNGLGETBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv;

typedef void ( * PFNGLGETBUFFERPOINTERVPROC)(GLenum target, GLenum pname, void **params);
extern PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv;




extern int GLAD_GL_VERSION_2_0;
typedef void ( * PFNGLBLENDEQUATIONSEPARATEPROC)(GLenum modeRGB, GLenum modeAlpha);
extern PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate;

typedef void ( * PFNGLDRAWBUFFERSPROC)(GLsizei n, const GLenum *bufs);
extern PFNGLDRAWBUFFERSPROC glad_glDrawBuffers;

typedef void ( * PFNGLSTENCILOPSEPARATEPROC)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
extern PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate;

typedef void ( * PFNGLSTENCILFUNCSEPARATEPROC)(GLenum face, GLenum func, GLint ref, GLuint mask);
extern PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate;

typedef void ( * PFNGLSTENCILMASKSEPARATEPROC)(GLenum face, GLuint mask);
extern PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate;

typedef void ( * PFNGLATTACHSHADERPROC)(GLuint program, GLuint shader);
extern PFNGLATTACHSHADERPROC glad_glAttachShader;

typedef void ( * PFNGLBINDATTRIBLOCATIONPROC)(GLuint program, GLuint index, const GLchar *name);
extern PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation;

typedef void ( * PFNGLCOMPILESHADERPROC)(GLuint shader);
extern PFNGLCOMPILESHADERPROC glad_glCompileShader;

typedef GLuint ( * PFNGLCREATEPROGRAMPROC)(void);
extern PFNGLCREATEPROGRAMPROC glad_glCreateProgram;

typedef GLuint ( * PFNGLCREATESHADERPROC)(GLenum type);
extern PFNGLCREATESHADERPROC glad_glCreateShader;

typedef void ( * PFNGLDELETEPROGRAMPROC)(GLuint program);
extern PFNGLDELETEPROGRAMPROC glad_glDeleteProgram;

typedef void ( * PFNGLDELETESHADERPROC)(GLuint shader);
extern PFNGLDELETESHADERPROC glad_glDeleteShader;

typedef void ( * PFNGLDETACHSHADERPROC)(GLuint program, GLuint shader);
extern PFNGLDETACHSHADERPROC glad_glDetachShader;

typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYPROC)(GLuint index);
extern PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray;

typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYPROC)(GLuint index);
extern PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray;

typedef void ( * PFNGLGETACTIVEATTRIBPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
extern PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib;

typedef void ( * PFNGLGETACTIVEUNIFORMPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
extern PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform;

typedef void ( * PFNGLGETATTACHEDSHADERSPROC)(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
extern PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders;

typedef GLint ( * PFNGLGETATTRIBLOCATIONPROC)(GLuint program, const GLchar *name);
extern PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation;

typedef void ( * PFNGLGETPROGRAMIVPROC)(GLuint program, GLenum pname, GLint *params);
extern PFNGLGETPROGRAMIVPROC glad_glGetProgramiv;

typedef void ( * PFNGLGETPROGRAMINFOLOGPROC)(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog;

typedef void ( * PFNGLGETSHADERIVPROC)(GLuint shader, GLenum pname, GLint *params);
extern PFNGLGETSHADERIVPROC glad_glGetShaderiv;

typedef void ( * PFNGLGETSHADERINFOLOGPROC)(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog;

typedef void ( * PFNGLGETSHADERSOURCEPROC)(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
extern PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource;

typedef GLint ( * PFNGLGETUNIFORMLOCATIONPROC)(GLuint program, const GLchar *name);
extern PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation;

typedef void ( * PFNGLGETUNIFORMFVPROC)(GLuint program, GLint location, GLfloat *params);
extern PFNGLGETUNIFORMFVPROC glad_glGetUniformfv;

typedef void ( * PFNGLGETUNIFORMIVPROC)(GLuint program, GLint location, GLint *params);
extern PFNGLGETUNIFORMIVPROC glad_glGetUniformiv;

typedef void ( * PFNGLGETVERTEXATTRIBDVPROC)(GLuint index, GLenum pname, GLdouble *params);
extern PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv;

typedef void ( * PFNGLGETVERTEXATTRIBFVPROC)(GLuint index, GLenum pname, GLfloat *params);
extern PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv;

typedef void ( * PFNGLGETVERTEXATTRIBIVPROC)(GLuint index, GLenum pname, GLint *params);
extern PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv;

typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVPROC)(GLuint index, GLenum pname, void **pointer);
extern PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv;

typedef GLboolean ( * PFNGLISPROGRAMPROC)(GLuint program);
extern PFNGLISPROGRAMPROC glad_glIsProgram;

typedef GLboolean ( * PFNGLISSHADERPROC)(GLuint shader);
extern PFNGLISSHADERPROC glad_glIsShader;

typedef void ( * PFNGLLINKPROGRAMPROC)(GLuint program);
extern PFNGLLINKPROGRAMPROC glad_glLinkProgram;

typedef void ( * PFNGLSHADERSOURCEPROC)(GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length);
extern PFNGLSHADERSOURCEPROC glad_glShaderSource;

typedef void ( * PFNGLUSEPROGRAMPROC)(GLuint program);
extern PFNGLUSEPROGRAMPROC glad_glUseProgram;

typedef void ( * PFNGLUNIFORM1FPROC)(GLint location, GLfloat v0);
extern PFNGLUNIFORM1FPROC glad_glUniform1f;

typedef void ( * PFNGLUNIFORM2FPROC)(GLint location, GLfloat v0, GLfloat v1);
extern PFNGLUNIFORM2FPROC glad_glUniform2f;

typedef void ( * PFNGLUNIFORM3FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern PFNGLUNIFORM3FPROC glad_glUniform3f;

typedef void ( * PFNGLUNIFORM4FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern PFNGLUNIFORM4FPROC glad_glUniform4f;

typedef void ( * PFNGLUNIFORM1IPROC)(GLint location, GLint v0);
extern PFNGLUNIFORM1IPROC glad_glUniform1i;

typedef void ( * PFNGLUNIFORM2IPROC)(GLint location, GLint v0, GLint v1);
extern PFNGLUNIFORM2IPROC glad_glUniform2i;

typedef void ( * PFNGLUNIFORM3IPROC)(GLint location, GLint v0, GLint v1, GLint v2);
extern PFNGLUNIFORM3IPROC glad_glUniform3i;

typedef void ( * PFNGLUNIFORM4IPROC)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern PFNGLUNIFORM4IPROC glad_glUniform4i;

typedef void ( * PFNGLUNIFORM1FVPROC)(GLint location, GLsizei count, const GLfloat *value);
extern PFNGLUNIFORM1FVPROC glad_glUniform1fv;

typedef void ( * PFNGLUNIFORM2FVPROC)(GLint location, GLsizei count, const GLfloat *value);
extern PFNGLUNIFORM2FVPROC glad_glUniform2fv;

typedef void ( * PFNGLUNIFORM3FVPROC)(GLint location, GLsizei count, const GLfloat *value);
extern PFNGLUNIFORM3FVPROC glad_glUniform3fv;

typedef void ( * PFNGLUNIFORM4FVPROC)(GLint location, GLsizei count, const GLfloat *value);
extern PFNGLUNIFORM4FVPROC glad_glUniform4fv;

typedef void ( * PFNGLUNIFORM1IVPROC)(GLint location, GLsizei count, const GLint *value);
extern PFNGLUNIFORM1IVPROC glad_glUniform1iv;

typedef void ( * PFNGLUNIFORM2IVPROC)(GLint location, GLsizei count, const GLint *value);
extern PFNGLUNIFORM2IVPROC glad_glUniform2iv;

typedef void ( * PFNGLUNIFORM3IVPROC)(GLint location, GLsizei count, const GLint *value);
extern PFNGLUNIFORM3IVPROC glad_glUniform3iv;

typedef void ( * PFNGLUNIFORM4IVPROC)(GLint location, GLsizei count, const GLint *value);
extern PFNGLUNIFORM4IVPROC glad_glUniform4iv;

typedef void ( * PFNGLUNIFORMMATRIX2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv;

typedef void ( * PFNGLUNIFORMMATRIX3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv;

typedef void ( * PFNGLUNIFORMMATRIX4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv;

typedef void ( * PFNGLVALIDATEPROGRAMPROC)(GLuint program);
extern PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram;

typedef void ( * PFNGLVERTEXATTRIB1DPROC)(GLuint index, GLdouble x);
extern PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d;

typedef void ( * PFNGLVERTEXATTRIB1DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv;

typedef void ( * PFNGLVERTEXATTRIB1FPROC)(GLuint index, GLfloat x);
extern PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f;

typedef void ( * PFNGLVERTEXATTRIB1FVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv;

typedef void ( * PFNGLVERTEXATTRIB1SPROC)(GLuint index, GLshort x);
extern PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s;

typedef void ( * PFNGLVERTEXATTRIB1SVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv;

typedef void ( * PFNGLVERTEXATTRIB2DPROC)(GLuint index, GLdouble x, GLdouble y);
extern PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d;

typedef void ( * PFNGLVERTEXATTRIB2DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv;

typedef void ( * PFNGLVERTEXATTRIB2FPROC)(GLuint index, GLfloat x, GLfloat y);
extern PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f;

typedef void ( * PFNGLVERTEXATTRIB2FVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv;

typedef void ( * PFNGLVERTEXATTRIB2SPROC)(GLuint index, GLshort x, GLshort y);
extern PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s;

typedef void ( * PFNGLVERTEXATTRIB2SVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv;

typedef void ( * PFNGLVERTEXATTRIB3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d;

typedef void ( * PFNGLVERTEXATTRIB3DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv;

typedef void ( * PFNGLVERTEXATTRIB3FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f;

typedef void ( * PFNGLVERTEXATTRIB3FVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv;

typedef void ( * PFNGLVERTEXATTRIB3SPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
extern PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s;

typedef void ( * PFNGLVERTEXATTRIB3SVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv;

typedef void ( * PFNGLVERTEXATTRIB4NBVPROC)(GLuint index, const GLbyte *v);
extern PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv;

typedef void ( * PFNGLVERTEXATTRIB4NIVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv;

typedef void ( * PFNGLVERTEXATTRIB4NSVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv;

typedef void ( * PFNGLVERTEXATTRIB4NUBPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub;

typedef void ( * PFNGLVERTEXATTRIB4NUBVPROC)(GLuint index, const GLubyte *v);
extern PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv;

typedef void ( * PFNGLVERTEXATTRIB4NUIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv;

typedef void ( * PFNGLVERTEXATTRIB4NUSVPROC)(GLuint index, const GLushort *v);
extern PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv;

typedef void ( * PFNGLVERTEXATTRIB4BVPROC)(GLuint index, const GLbyte *v);
extern PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv;

typedef void ( * PFNGLVERTEXATTRIB4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d;

typedef void ( * PFNGLVERTEXATTRIB4DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv;

typedef void ( * PFNGLVERTEXATTRIB4FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f;

typedef void ( * PFNGLVERTEXATTRIB4FVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv;

typedef void ( * PFNGLVERTEXATTRIB4IVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv;

typedef void ( * PFNGLVERTEXATTRIB4SPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s;

typedef void ( * PFNGLVERTEXATTRIB4SVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv;

typedef void ( * PFNGLVERTEXATTRIB4UBVPROC)(GLuint index, const GLubyte *v);
extern PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv;

typedef void ( * PFNGLVERTEXATTRIB4UIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv;

typedef void ( * PFNGLVERTEXATTRIB4USVPROC)(GLuint index, const GLushort *v);
extern PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv;

typedef void ( * PFNGLVERTEXATTRIBPOINTERPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
extern PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer;




extern int GLAD_GL_VERSION_2_1;
typedef void ( * PFNGLUNIFORMMATRIX2X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv;

typedef void ( * PFNGLUNIFORMMATRIX3X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv;

typedef void ( * PFNGLUNIFORMMATRIX2X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv;

typedef void ( * PFNGLUNIFORMMATRIX4X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv;

typedef void ( * PFNGLUNIFORMMATRIX3X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv;

typedef void ( * PFNGLUNIFORMMATRIX4X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv;




extern int GLAD_GL_VERSION_3_0;
typedef void ( * PFNGLCOLORMASKIPROC)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
extern PFNGLCOLORMASKIPROC glad_glColorMaski;

typedef void ( * PFNGLGETBOOLEANI_VPROC)(GLenum target, GLuint index, GLboolean *data);
extern PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v;

typedef void ( * PFNGLGETINTEGERI_VPROC)(GLenum target, GLuint index, GLint *data);
extern PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v;

typedef void ( * PFNGLENABLEIPROC)(GLenum target, GLuint index);
extern PFNGLENABLEIPROC glad_glEnablei;

typedef void ( * PFNGLDISABLEIPROC)(GLenum target, GLuint index);
extern PFNGLDISABLEIPROC glad_glDisablei;

typedef GLboolean ( * PFNGLISENABLEDIPROC)(GLenum target, GLuint index);
extern PFNGLISENABLEDIPROC glad_glIsEnabledi;

typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKPROC)(GLenum primitiveMode);
extern PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback;

typedef void ( * PFNGLENDTRANSFORMFEEDBACKPROC)(void);
extern PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback;

typedef void ( * PFNGLBINDBUFFERRANGEPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange;

typedef void ( * PFNGLBINDBUFFERBASEPROC)(GLenum target, GLuint index, GLuint buffer);
extern PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase;

typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSPROC)(GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode);
extern PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings;

typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
extern PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying;

typedef void ( * PFNGLCLAMPCOLORPROC)(GLenum target, GLenum clamp);
extern PFNGLCLAMPCOLORPROC glad_glClampColor;

typedef void ( * PFNGLBEGINCONDITIONALRENDERPROC)(GLuint id, GLenum mode);
extern PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender;

typedef void ( * PFNGLENDCONDITIONALRENDERPROC)(void);
extern PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender;

typedef void ( * PFNGLVERTEXATTRIBIPOINTERPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
extern PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer;

typedef void ( * PFNGLGETVERTEXATTRIBIIVPROC)(GLuint index, GLenum pname, GLint *params);
extern PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv;

typedef void ( * PFNGLGETVERTEXATTRIBIUIVPROC)(GLuint index, GLenum pname, GLuint *params);
extern PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv;

typedef void ( * PFNGLVERTEXATTRIBI1IPROC)(GLuint index, GLint x);
extern PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i;

typedef void ( * PFNGLVERTEXATTRIBI2IPROC)(GLuint index, GLint x, GLint y);
extern PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i;

typedef void ( * PFNGLVERTEXATTRIBI3IPROC)(GLuint index, GLint x, GLint y, GLint z);
extern PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i;

typedef void ( * PFNGLVERTEXATTRIBI4IPROC)(GLuint index, GLint x, GLint y, GLint z, GLint w);
extern PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i;

typedef void ( * PFNGLVERTEXATTRIBI1UIPROC)(GLuint index, GLuint x);
extern PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui;

typedef void ( * PFNGLVERTEXATTRIBI2UIPROC)(GLuint index, GLuint x, GLuint y);
extern PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui;

typedef void ( * PFNGLVERTEXATTRIBI3UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z);
extern PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui;

typedef void ( * PFNGLVERTEXATTRIBI4UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
extern PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui;

typedef void ( * PFNGLVERTEXATTRIBI1IVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv;

typedef void ( * PFNGLVERTEXATTRIBI2IVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv;

typedef void ( * PFNGLVERTEXATTRIBI3IVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv;

typedef void ( * PFNGLVERTEXATTRIBI4IVPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv;

typedef void ( * PFNGLVERTEXATTRIBI1UIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv;

typedef void ( * PFNGLVERTEXATTRIBI2UIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv;

typedef void ( * PFNGLVERTEXATTRIBI3UIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv;

typedef void ( * PFNGLVERTEXATTRIBI4UIVPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv;

typedef void ( * PFNGLVERTEXATTRIBI4BVPROC)(GLuint index, const GLbyte *v);
extern PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv;

typedef void ( * PFNGLVERTEXATTRIBI4SVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv;

typedef void ( * PFNGLVERTEXATTRIBI4UBVPROC)(GLuint index, const GLubyte *v);
extern PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv;

typedef void ( * PFNGLVERTEXATTRIBI4USVPROC)(GLuint index, const GLushort *v);
extern PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv;

typedef void ( * PFNGLGETUNIFORMUIVPROC)(GLuint program, GLint location, GLuint *params);
extern PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv;

typedef void ( * PFNGLBINDFRAGDATALOCATIONPROC)(GLuint program, GLuint color, const GLchar *name);
extern PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation;

typedef GLint ( * PFNGLGETFRAGDATALOCATIONPROC)(GLuint program, const GLchar *name);
extern PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation;

typedef void ( * PFNGLUNIFORM1UIPROC)(GLint location, GLuint v0);
extern PFNGLUNIFORM1UIPROC glad_glUniform1ui;

typedef void ( * PFNGLUNIFORM2UIPROC)(GLint location, GLuint v0, GLuint v1);
extern PFNGLUNIFORM2UIPROC glad_glUniform2ui;

typedef void ( * PFNGLUNIFORM3UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2);
extern PFNGLUNIFORM3UIPROC glad_glUniform3ui;

typedef void ( * PFNGLUNIFORM4UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
extern PFNGLUNIFORM4UIPROC glad_glUniform4ui;

typedef void ( * PFNGLUNIFORM1UIVPROC)(GLint location, GLsizei count, const GLuint *value);
extern PFNGLUNIFORM1UIVPROC glad_glUniform1uiv;

typedef void ( * PFNGLUNIFORM2UIVPROC)(GLint location, GLsizei count, const GLuint *value);
extern PFNGLUNIFORM2UIVPROC glad_glUniform2uiv;

typedef void ( * PFNGLUNIFORM3UIVPROC)(GLint location, GLsizei count, const GLuint *value);
extern PFNGLUNIFORM3UIVPROC glad_glUniform3uiv;

typedef void ( * PFNGLUNIFORM4UIVPROC)(GLint location, GLsizei count, const GLuint *value);
extern PFNGLUNIFORM4UIVPROC glad_glUniform4uiv;

typedef void ( * PFNGLTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, const GLint *params);
extern PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv;

typedef void ( * PFNGLTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, const GLuint *params);
extern PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv;

typedef void ( * PFNGLGETTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv;

typedef void ( * PFNGLGETTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, GLuint *params);
extern PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv;

typedef void ( * PFNGLCLEARBUFFERIVPROC)(GLenum buffer, GLint drawbuffer, const GLint *value);
extern PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv;

typedef void ( * PFNGLCLEARBUFFERUIVPROC)(GLenum buffer, GLint drawbuffer, const GLuint *value);
extern PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv;

typedef void ( * PFNGLCLEARBUFFERFVPROC)(GLenum buffer, GLint drawbuffer, const GLfloat *value);
extern PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv;

typedef void ( * PFNGLCLEARBUFFERFIPROC)(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
extern PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi;

typedef const GLubyte * ( * PFNGLGETSTRINGIPROC)(GLenum name, GLuint index);
extern PFNGLGETSTRINGIPROC glad_glGetStringi;

typedef GLboolean ( * PFNGLISRENDERBUFFERPROC)(GLuint renderbuffer);
extern PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer;

typedef void ( * PFNGLBINDRENDERBUFFERPROC)(GLenum target, GLuint renderbuffer);
extern PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer;

typedef void ( * PFNGLDELETERENDERBUFFERSPROC)(GLsizei n, const GLuint *renderbuffers);
extern PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers;

typedef void ( * PFNGLGENRENDERBUFFERSPROC)(GLsizei n, GLuint *renderbuffers);
extern PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers;

typedef void ( * PFNGLRENDERBUFFERSTORAGEPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage;

typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv;

typedef GLboolean ( * PFNGLISFRAMEBUFFERPROC)(GLuint framebuffer);
extern PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer;

typedef void ( * PFNGLBINDFRAMEBUFFERPROC)(GLenum target, GLuint framebuffer);
extern PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer;

typedef void ( * PFNGLDELETEFRAMEBUFFERSPROC)(GLsizei n, const GLuint *framebuffers);
extern PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers;

typedef void ( * PFNGLGENFRAMEBUFFERSPROC)(GLsizei n, GLuint *framebuffers);
extern PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers;

typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSPROC)(GLenum target);
extern PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus;

typedef void ( * PFNGLFRAMEBUFFERTEXTURE1DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D;

typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D;

typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
extern PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D;

typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFERPROC)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer;

typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLenum target, GLenum attachment, GLenum pname, GLint *params);
extern PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv;

typedef void ( * PFNGLGENERATEMIPMAPPROC)(GLenum target);
extern PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap;

typedef void ( * PFNGLBLITFRAMEBUFFERPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
extern PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer;

typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample;

typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
extern PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer;

typedef void * ( * PFNGLMAPBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
extern PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange;

typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length);
extern PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange;

typedef void ( * PFNGLBINDVERTEXARRAYPROC)(GLuint array);
extern PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray;

typedef void ( * PFNGLDELETEVERTEXARRAYSPROC)(GLsizei n, const GLuint *arrays);
extern PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays;

typedef void ( * PFNGLGENVERTEXARRAYSPROC)(GLsizei n, GLuint *arrays);
extern PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays;

typedef GLboolean ( * PFNGLISVERTEXARRAYPROC)(GLuint array);
extern PFNGLISVERTEXARRAYPROC glad_glIsVertexArray;




extern int GLAD_GL_VERSION_3_1;
typedef void ( * PFNGLDRAWARRAYSINSTANCEDPROC)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
extern PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced;

typedef void ( * PFNGLDRAWELEMENTSINSTANCEDPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount);
extern PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced;

typedef void ( * PFNGLTEXBUFFERPROC)(GLenum target, GLenum internalformat, GLuint buffer);
extern PFNGLTEXBUFFERPROC glad_glTexBuffer;

typedef void ( * PFNGLPRIMITIVERESTARTINDEXPROC)(GLuint index);
extern PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex;

typedef void ( * PFNGLCOPYBUFFERSUBDATAPROC)(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
extern PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData;

typedef void ( * PFNGLGETUNIFORMINDICESPROC)(GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices);
extern PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices;

typedef void ( * PFNGLGETACTIVEUNIFORMSIVPROC)(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
extern PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv;

typedef void ( * PFNGLGETACTIVEUNIFORMNAMEPROC)(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName);
extern PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName;

typedef GLuint ( * PFNGLGETUNIFORMBLOCKINDEXPROC)(GLuint program, const GLchar *uniformBlockName);
extern PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex;

typedef void ( * PFNGLGETACTIVEUNIFORMBLOCKIVPROC)(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
extern PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv;

typedef void ( * PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
extern PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName;

typedef void ( * PFNGLUNIFORMBLOCKBINDINGPROC)(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
extern PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding;




extern int GLAD_GL_VERSION_3_2;
typedef void ( * PFNGLDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex);
extern PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex;

typedef void ( * PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex);
extern PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex;

typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex);
extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex;

typedef void ( * PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount, const GLint *basevertex);
extern PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex;

typedef void ( * PFNGLPROVOKINGVERTEXPROC)(GLenum mode);
extern PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex;

typedef GLsync ( * PFNGLFENCESYNCPROC)(GLenum condition, GLbitfield flags);
extern PFNGLFENCESYNCPROC glad_glFenceSync;

typedef GLboolean ( * PFNGLISSYNCPROC)(GLsync sync);
extern PFNGLISSYNCPROC glad_glIsSync;

typedef void ( * PFNGLDELETESYNCPROC)(GLsync sync);
extern PFNGLDELETESYNCPROC glad_glDeleteSync;

typedef GLenum ( * PFNGLCLIENTWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
extern PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync;

typedef void ( * PFNGLWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
extern PFNGLWAITSYNCPROC glad_glWaitSync;

typedef void ( * PFNGLGETINTEGER64VPROC)(GLenum pname, GLint64 *data);
extern PFNGLGETINTEGER64VPROC glad_glGetInteger64v;

typedef void ( * PFNGLGETSYNCIVPROC)(GLsync sync, GLenum pname, GLsizei count, GLsizei *length, GLint *values);
extern PFNGLGETSYNCIVPROC glad_glGetSynciv;

typedef void ( * PFNGLGETINTEGER64I_VPROC)(GLenum target, GLuint index, GLint64 *data);
extern PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v;

typedef void ( * PFNGLGETBUFFERPARAMETERI64VPROC)(GLenum target, GLenum pname, GLint64 *params);
extern PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v;

typedef void ( * PFNGLFRAMEBUFFERTEXTUREPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
extern PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture;

typedef void ( * PFNGLTEXIMAGE2DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
extern PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample;

typedef void ( * PFNGLTEXIMAGE3DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
extern PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample;

typedef void ( * PFNGLGETMULTISAMPLEFVPROC)(GLenum pname, GLuint index, GLfloat *val);
extern PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv;

typedef void ( * PFNGLSAMPLEMASKIPROC)(GLuint maskNumber, GLbitfield mask);
extern PFNGLSAMPLEMASKIPROC glad_glSampleMaski;




extern int GLAD_GL_VERSION_3_3;
typedef void ( * PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name);
extern PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed;

typedef GLint ( * PFNGLGETFRAGDATAINDEXPROC)(GLuint program, const GLchar *name);
extern PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex;

typedef void ( * PFNGLGENSAMPLERSPROC)(GLsizei count, GLuint *samplers);
extern PFNGLGENSAMPLERSPROC glad_glGenSamplers;

typedef void ( * PFNGLDELETESAMPLERSPROC)(GLsizei count, const GLuint *samplers);
extern PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers;

typedef GLboolean ( * PFNGLISSAMPLERPROC)(GLuint sampler);
extern PFNGLISSAMPLERPROC glad_glIsSampler;

typedef void ( * PFNGLBINDSAMPLERPROC)(GLuint unit, GLuint sampler);
extern PFNGLBINDSAMPLERPROC glad_glBindSampler;

typedef void ( * PFNGLSAMPLERPARAMETERIPROC)(GLuint sampler, GLenum pname, GLint param);
extern PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri;

typedef void ( * PFNGLSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, const GLint *param);
extern PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv;

typedef void ( * PFNGLSAMPLERPARAMETERFPROC)(GLuint sampler, GLenum pname, GLfloat param);
extern PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf;

typedef void ( * PFNGLSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, const GLfloat *param);
extern PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv;

typedef void ( * PFNGLSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, const GLint *param);
extern PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv;

typedef void ( * PFNGLSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, const GLuint *param);
extern PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv;

typedef void ( * PFNGLGETSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, GLint *params);
extern PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv;

typedef void ( * PFNGLGETSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, GLint *params);
extern PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv;

typedef void ( * PFNGLGETSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, GLfloat *params);
extern PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv;

typedef void ( * PFNGLGETSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, GLuint *params);
extern PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv;

typedef void ( * PFNGLQUERYCOUNTERPROC)(GLuint id, GLenum target);
extern PFNGLQUERYCOUNTERPROC glad_glQueryCounter;

typedef void ( * PFNGLGETQUERYOBJECTI64VPROC)(GLuint id, GLenum pname, GLint64 *params);
extern PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v;

typedef void ( * PFNGLGETQUERYOBJECTUI64VPROC)(GLuint id, GLenum pname, GLuint64 *params);
extern PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v;

typedef void ( * PFNGLVERTEXATTRIBDIVISORPROC)(GLuint index, GLuint divisor);
extern PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor;

typedef void ( * PFNGLVERTEXATTRIBP1UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui;

typedef void ( * PFNGLVERTEXATTRIBP1UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
extern PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv;

typedef void ( * PFNGLVERTEXATTRIBP2UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui;

typedef void ( * PFNGLVERTEXATTRIBP2UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
extern PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv;

typedef void ( * PFNGLVERTEXATTRIBP3UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui;

typedef void ( * PFNGLVERTEXATTRIBP3UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
extern PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv;

typedef void ( * PFNGLVERTEXATTRIBP4UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui;

typedef void ( * PFNGLVERTEXATTRIBP4UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
extern PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv;

typedef void ( * PFNGLVERTEXP2UIPROC)(GLenum type, GLuint value);
extern PFNGLVERTEXP2UIPROC glad_glVertexP2ui;

typedef void ( * PFNGLVERTEXP2UIVPROC)(GLenum type, const GLuint *value);
extern PFNGLVERTEXP2UIVPROC glad_glVertexP2uiv;

typedef void ( * PFNGLVERTEXP3UIPROC)(GLenum type, GLuint value);
extern PFNGLVERTEXP3UIPROC glad_glVertexP3ui;

typedef void ( * PFNGLVERTEXP3UIVPROC)(GLenum type, const GLuint *value);
extern PFNGLVERTEXP3UIVPROC glad_glVertexP3uiv;

typedef void ( * PFNGLVERTEXP4UIPROC)(GLenum type, GLuint value);
extern PFNGLVERTEXP4UIPROC glad_glVertexP4ui;

typedef void ( * PFNGLVERTEXP4UIVPROC)(GLenum type, const GLuint *value);
extern PFNGLVERTEXP4UIVPROC glad_glVertexP4uiv;

typedef void ( * PFNGLTEXCOORDP1UIPROC)(GLenum type, GLuint coords);
extern PFNGLTEXCOORDP1UIPROC glad_glTexCoordP1ui;

typedef void ( * PFNGLTEXCOORDP1UIVPROC)(GLenum type, const GLuint *coords);
extern PFNGLTEXCOORDP1UIVPROC glad_glTexCoordP1uiv;

typedef void ( * PFNGLTEXCOORDP2UIPROC)(GLenum type, GLuint coords);
extern PFNGLTEXCOORDP2UIPROC glad_glTexCoordP2ui;

typedef void ( * PFNGLTEXCOORDP2UIVPROC)(GLenum type, const GLuint *coords);
extern PFNGLTEXCOORDP2UIVPROC glad_glTexCoordP2uiv;

typedef void ( * PFNGLTEXCOORDP3UIPROC)(GLenum type, GLuint coords);
extern PFNGLTEXCOORDP3UIPROC glad_glTexCoordP3ui;

typedef void ( * PFNGLTEXCOORDP3UIVPROC)(GLenum type, const GLuint *coords);
extern PFNGLTEXCOORDP3UIVPROC glad_glTexCoordP3uiv;

typedef void ( * PFNGLTEXCOORDP4UIPROC)(GLenum type, GLuint coords);
extern PFNGLTEXCOORDP4UIPROC glad_glTexCoordP4ui;

typedef void ( * PFNGLTEXCOORDP4UIVPROC)(GLenum type, const GLuint *coords);
extern PFNGLTEXCOORDP4UIVPROC glad_glTexCoordP4uiv;

typedef void ( * PFNGLMULTITEXCOORDP1UIPROC)(GLenum texture, GLenum type, GLuint coords);
extern PFNGLMULTITEXCOORDP1UIPROC glad_glMultiTexCoordP1ui;

typedef void ( * PFNGLMULTITEXCOORDP1UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
extern PFNGLMULTITEXCOORDP1UIVPROC glad_glMultiTexCoordP1uiv;

typedef void ( * PFNGLMULTITEXCOORDP2UIPROC)(GLenum texture, GLenum type, GLuint coords);
extern PFNGLMULTITEXCOORDP2UIPROC glad_glMultiTexCoordP2ui;

typedef void ( * PFNGLMULTITEXCOORDP2UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
extern PFNGLMULTITEXCOORDP2UIVPROC glad_glMultiTexCoordP2uiv;

typedef void ( * PFNGLMULTITEXCOORDP3UIPROC)(GLenum texture, GLenum type, GLuint coords);
extern PFNGLMULTITEXCOORDP3UIPROC glad_glMultiTexCoordP3ui;

typedef void ( * PFNGLMULTITEXCOORDP3UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
extern PFNGLMULTITEXCOORDP3UIVPROC glad_glMultiTexCoordP3uiv;

typedef void ( * PFNGLMULTITEXCOORDP4UIPROC)(GLenum texture, GLenum type, GLuint coords);
extern PFNGLMULTITEXCOORDP4UIPROC glad_glMultiTexCoordP4ui;

typedef void ( * PFNGLMULTITEXCOORDP4UIVPROC)(GLenum texture, GLenum type, const GLuint *coords);
extern PFNGLMULTITEXCOORDP4UIVPROC glad_glMultiTexCoordP4uiv;

typedef void ( * PFNGLNORMALP3UIPROC)(GLenum type, GLuint coords);
extern PFNGLNORMALP3UIPROC glad_glNormalP3ui;

typedef void ( * PFNGLNORMALP3UIVPROC)(GLenum type, const GLuint *coords);
extern PFNGLNORMALP3UIVPROC glad_glNormalP3uiv;

typedef void ( * PFNGLCOLORP3UIPROC)(GLenum type, GLuint color);
extern PFNGLCOLORP3UIPROC glad_glColorP3ui;

typedef void ( * PFNGLCOLORP3UIVPROC)(GLenum type, const GLuint *color);
extern PFNGLCOLORP3UIVPROC glad_glColorP3uiv;

typedef void ( * PFNGLCOLORP4UIPROC)(GLenum type, GLuint color);
extern PFNGLCOLORP4UIPROC glad_glColorP4ui;

typedef void ( * PFNGLCOLORP4UIVPROC)(GLenum type, const GLuint *color);
extern PFNGLCOLORP4UIVPROC glad_glColorP4uiv;

typedef void ( * PFNGLSECONDARYCOLORP3UIPROC)(GLenum type, GLuint color);
extern PFNGLSECONDARYCOLORP3UIPROC glad_glSecondaryColorP3ui;

typedef void ( * PFNGLSECONDARYCOLORP3UIVPROC)(GLenum type, const GLuint *color);
extern PFNGLSECONDARYCOLORP3UIVPROC glad_glSecondaryColorP3uiv;




extern int GLAD_GL_VERSION_4_0;
typedef void ( * PFNGLMINSAMPLESHADINGPROC)(GLfloat value);
extern PFNGLMINSAMPLESHADINGPROC glad_glMinSampleShading;

typedef void ( * PFNGLBLENDEQUATIONIPROC)(GLuint buf, GLenum mode);
extern PFNGLBLENDEQUATIONIPROC glad_glBlendEquationi;

typedef void ( * PFNGLBLENDEQUATIONSEPARATEIPROC)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
extern PFNGLBLENDEQUATIONSEPARATEIPROC glad_glBlendEquationSeparatei;

typedef void ( * PFNGLBLENDFUNCIPROC)(GLuint buf, GLenum src, GLenum dst);
extern PFNGLBLENDFUNCIPROC glad_glBlendFunci;

typedef void ( * PFNGLBLENDFUNCSEPARATEIPROC)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
extern PFNGLBLENDFUNCSEPARATEIPROC glad_glBlendFuncSeparatei;

typedef void ( * PFNGLDRAWARRAYSINDIRECTPROC)(GLenum mode, const void *indirect);
extern PFNGLDRAWARRAYSINDIRECTPROC glad_glDrawArraysIndirect;

typedef void ( * PFNGLDRAWELEMENTSINDIRECTPROC)(GLenum mode, GLenum type, const void *indirect);
extern PFNGLDRAWELEMENTSINDIRECTPROC glad_glDrawElementsIndirect;

typedef void ( * PFNGLUNIFORM1DPROC)(GLint location, GLdouble x);
extern PFNGLUNIFORM1DPROC glad_glUniform1d;

typedef void ( * PFNGLUNIFORM2DPROC)(GLint location, GLdouble x, GLdouble y);
extern PFNGLUNIFORM2DPROC glad_glUniform2d;

typedef void ( * PFNGLUNIFORM3DPROC)(GLint location, GLdouble x, GLdouble y, GLdouble z);
extern PFNGLUNIFORM3DPROC glad_glUniform3d;

typedef void ( * PFNGLUNIFORM4DPROC)(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLUNIFORM4DPROC glad_glUniform4d;

typedef void ( * PFNGLUNIFORM1DVPROC)(GLint location, GLsizei count, const GLdouble *value);
extern PFNGLUNIFORM1DVPROC glad_glUniform1dv;

typedef void ( * PFNGLUNIFORM2DVPROC)(GLint location, GLsizei count, const GLdouble *value);
extern PFNGLUNIFORM2DVPROC glad_glUniform2dv;

typedef void ( * PFNGLUNIFORM3DVPROC)(GLint location, GLsizei count, const GLdouble *value);
extern PFNGLUNIFORM3DVPROC glad_glUniform3dv;

typedef void ( * PFNGLUNIFORM4DVPROC)(GLint location, GLsizei count, const GLdouble *value);
extern PFNGLUNIFORM4DVPROC glad_glUniform4dv;

typedef void ( * PFNGLUNIFORMMATRIX2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX2DVPROC glad_glUniformMatrix2dv;

typedef void ( * PFNGLUNIFORMMATRIX3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX3DVPROC glad_glUniformMatrix3dv;

typedef void ( * PFNGLUNIFORMMATRIX4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX4DVPROC glad_glUniformMatrix4dv;

typedef void ( * PFNGLUNIFORMMATRIX2X3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX2X3DVPROC glad_glUniformMatrix2x3dv;

typedef void ( * PFNGLUNIFORMMATRIX2X4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX2X4DVPROC glad_glUniformMatrix2x4dv;

typedef void ( * PFNGLUNIFORMMATRIX3X2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX3X2DVPROC glad_glUniformMatrix3x2dv;

typedef void ( * PFNGLUNIFORMMATRIX3X4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX3X4DVPROC glad_glUniformMatrix3x4dv;

typedef void ( * PFNGLUNIFORMMATRIX4X2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX4X2DVPROC glad_glUniformMatrix4x2dv;

typedef void ( * PFNGLUNIFORMMATRIX4X3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLUNIFORMMATRIX4X3DVPROC glad_glUniformMatrix4x3dv;

typedef void ( * PFNGLGETUNIFORMDVPROC)(GLuint program, GLint location, GLdouble *params);
extern PFNGLGETUNIFORMDVPROC glad_glGetUniformdv;

typedef GLint ( * PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC)(GLuint program, GLenum shadertype, const GLchar *name);
extern PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glad_glGetSubroutineUniformLocation;

typedef GLuint ( * PFNGLGETSUBROUTINEINDEXPROC)(GLuint program, GLenum shadertype, const GLchar *name);
extern PFNGLGETSUBROUTINEINDEXPROC glad_glGetSubroutineIndex;

typedef void ( * PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC)(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values);
extern PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glad_glGetActiveSubroutineUniformiv;

typedef void ( * PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
extern PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glad_glGetActiveSubroutineUniformName;

typedef void ( * PFNGLGETACTIVESUBROUTINENAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
extern PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName;

typedef void ( * PFNGLUNIFORMSUBROUTINESUIVPROC)(GLenum shadertype, GLsizei count, const GLuint *indices);
extern PFNGLUNIFORMSUBROUTINESUIVPROC glad_glUniformSubroutinesuiv;

typedef void ( * PFNGLGETUNIFORMSUBROUTINEUIVPROC)(GLenum shadertype, GLint location, GLuint *params);
extern PFNGLGETUNIFORMSUBROUTINEUIVPROC glad_glGetUniformSubroutineuiv;

typedef void ( * PFNGLGETPROGRAMSTAGEIVPROC)(GLuint program, GLenum shadertype, GLenum pname, GLint *values);
extern PFNGLGETPROGRAMSTAGEIVPROC glad_glGetProgramStageiv;

typedef void ( * PFNGLPATCHPARAMETERIPROC)(GLenum pname, GLint value);
extern PFNGLPATCHPARAMETERIPROC glad_glPatchParameteri;

typedef void ( * PFNGLPATCHPARAMETERFVPROC)(GLenum pname, const GLfloat *values);
extern PFNGLPATCHPARAMETERFVPROC glad_glPatchParameterfv;

typedef void ( * PFNGLBINDTRANSFORMFEEDBACKPROC)(GLenum target, GLuint id);
extern PFNGLBINDTRANSFORMFEEDBACKPROC glad_glBindTransformFeedback;

typedef void ( * PFNGLDELETETRANSFORMFEEDBACKSPROC)(GLsizei n, const GLuint *ids);
extern PFNGLDELETETRANSFORMFEEDBACKSPROC glad_glDeleteTransformFeedbacks;

typedef void ( * PFNGLGENTRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint *ids);
extern PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks;

typedef GLboolean ( * PFNGLISTRANSFORMFEEDBACKPROC)(GLuint id);
extern PFNGLISTRANSFORMFEEDBACKPROC glad_glIsTransformFeedback;

typedef void ( * PFNGLPAUSETRANSFORMFEEDBACKPROC)(void);
extern PFNGLPAUSETRANSFORMFEEDBACKPROC glad_glPauseTransformFeedback;

typedef void ( * PFNGLRESUMETRANSFORMFEEDBACKPROC)(void);
extern PFNGLRESUMETRANSFORMFEEDBACKPROC glad_glResumeTransformFeedback;

typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKPROC)(GLenum mode, GLuint id);
extern PFNGLDRAWTRANSFORMFEEDBACKPROC glad_glDrawTransformFeedback;

typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC)(GLenum mode, GLuint id, GLuint stream);
extern PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glad_glDrawTransformFeedbackStream;

typedef void ( * PFNGLBEGINQUERYINDEXEDPROC)(GLenum target, GLuint index, GLuint id);
extern PFNGLBEGINQUERYINDEXEDPROC glad_glBeginQueryIndexed;

typedef void ( * PFNGLENDQUERYINDEXEDPROC)(GLenum target, GLuint index);
extern PFNGLENDQUERYINDEXEDPROC glad_glEndQueryIndexed;

typedef void ( * PFNGLGETQUERYINDEXEDIVPROC)(GLenum target, GLuint index, GLenum pname, GLint *params);
extern PFNGLGETQUERYINDEXEDIVPROC glad_glGetQueryIndexediv;




extern int GLAD_GL_VERSION_4_1;
typedef void ( * PFNGLRELEASESHADERCOMPILERPROC)(void);
extern PFNGLRELEASESHADERCOMPILERPROC glad_glReleaseShaderCompiler;

typedef void ( * PFNGLSHADERBINARYPROC)(GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length);
extern PFNGLSHADERBINARYPROC glad_glShaderBinary;

typedef void ( * PFNGLGETSHADERPRECISIONFORMATPROC)(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
extern PFNGLGETSHADERPRECISIONFORMATPROC glad_glGetShaderPrecisionFormat;

typedef void ( * PFNGLDEPTHRANGEFPROC)(GLfloat n, GLfloat f);
extern PFNGLDEPTHRANGEFPROC glad_glDepthRangef;

typedef void ( * PFNGLCLEARDEPTHFPROC)(GLfloat d);
extern PFNGLCLEARDEPTHFPROC glad_glClearDepthf;

typedef void ( * PFNGLGETPROGRAMBINARYPROC)(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary);
extern PFNGLGETPROGRAMBINARYPROC glad_glGetProgramBinary;

typedef void ( * PFNGLPROGRAMBINARYPROC)(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
extern PFNGLPROGRAMBINARYPROC glad_glProgramBinary;

typedef void ( * PFNGLPROGRAMPARAMETERIPROC)(GLuint program, GLenum pname, GLint value);
extern PFNGLPROGRAMPARAMETERIPROC glad_glProgramParameteri;

typedef void ( * PFNGLUSEPROGRAMSTAGESPROC)(GLuint pipeline, GLbitfield stages, GLuint program);
extern PFNGLUSEPROGRAMSTAGESPROC glad_glUseProgramStages;

typedef void ( * PFNGLACTIVESHADERPROGRAMPROC)(GLuint pipeline, GLuint program);
extern PFNGLACTIVESHADERPROGRAMPROC glad_glActiveShaderProgram;

typedef GLuint ( * PFNGLCREATESHADERPROGRAMVPROC)(GLenum type, GLsizei count, const GLchar *const*strings);
extern PFNGLCREATESHADERPROGRAMVPROC glad_glCreateShaderProgramv;

typedef void ( * PFNGLBINDPROGRAMPIPELINEPROC)(GLuint pipeline);
extern PFNGLBINDPROGRAMPIPELINEPROC glad_glBindProgramPipeline;

typedef void ( * PFNGLDELETEPROGRAMPIPELINESPROC)(GLsizei n, const GLuint *pipelines);
extern PFNGLDELETEPROGRAMPIPELINESPROC glad_glDeleteProgramPipelines;

typedef void ( * PFNGLGENPROGRAMPIPELINESPROC)(GLsizei n, GLuint *pipelines);
extern PFNGLGENPROGRAMPIPELINESPROC glad_glGenProgramPipelines;

typedef GLboolean ( * PFNGLISPROGRAMPIPELINEPROC)(GLuint pipeline);
extern PFNGLISPROGRAMPIPELINEPROC glad_glIsProgramPipeline;

typedef void ( * PFNGLGETPROGRAMPIPELINEIVPROC)(GLuint pipeline, GLenum pname, GLint *params);
extern PFNGLGETPROGRAMPIPELINEIVPROC glad_glGetProgramPipelineiv;

typedef void ( * PFNGLPROGRAMUNIFORM1IPROC)(GLuint program, GLint location, GLint v0);
extern PFNGLPROGRAMUNIFORM1IPROC glad_glProgramUniform1i;

typedef void ( * PFNGLPROGRAMUNIFORM1IVPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
extern PFNGLPROGRAMUNIFORM1IVPROC glad_glProgramUniform1iv;

typedef void ( * PFNGLPROGRAMUNIFORM1FPROC)(GLuint program, GLint location, GLfloat v0);
extern PFNGLPROGRAMUNIFORM1FPROC glad_glProgramUniform1f;

typedef void ( * PFNGLPROGRAMUNIFORM1FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
extern PFNGLPROGRAMUNIFORM1FVPROC glad_glProgramUniform1fv;

typedef void ( * PFNGLPROGRAMUNIFORM1DPROC)(GLuint program, GLint location, GLdouble v0);
extern PFNGLPROGRAMUNIFORM1DPROC glad_glProgramUniform1d;

typedef void ( * PFNGLPROGRAMUNIFORM1DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
extern PFNGLPROGRAMUNIFORM1DVPROC glad_glProgramUniform1dv;

typedef void ( * PFNGLPROGRAMUNIFORM1UIPROC)(GLuint program, GLint location, GLuint v0);
extern PFNGLPROGRAMUNIFORM1UIPROC glad_glProgramUniform1ui;

typedef void ( * PFNGLPROGRAMUNIFORM1UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
extern PFNGLPROGRAMUNIFORM1UIVPROC glad_glProgramUniform1uiv;

typedef void ( * PFNGLPROGRAMUNIFORM2IPROC)(GLuint program, GLint location, GLint v0, GLint v1);
extern PFNGLPROGRAMUNIFORM2IPROC glad_glProgramUniform2i;

typedef void ( * PFNGLPROGRAMUNIFORM2IVPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
extern PFNGLPROGRAMUNIFORM2IVPROC glad_glProgramUniform2iv;

typedef void ( * PFNGLPROGRAMUNIFORM2FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1);
extern PFNGLPROGRAMUNIFORM2FPROC glad_glProgramUniform2f;

typedef void ( * PFNGLPROGRAMUNIFORM2FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
extern PFNGLPROGRAMUNIFORM2FVPROC glad_glProgramUniform2fv;

typedef void ( * PFNGLPROGRAMUNIFORM2DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1);
extern PFNGLPROGRAMUNIFORM2DPROC glad_glProgramUniform2d;

typedef void ( * PFNGLPROGRAMUNIFORM2DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
extern PFNGLPROGRAMUNIFORM2DVPROC glad_glProgramUniform2dv;

typedef void ( * PFNGLPROGRAMUNIFORM2UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1);
extern PFNGLPROGRAMUNIFORM2UIPROC glad_glProgramUniform2ui;

typedef void ( * PFNGLPROGRAMUNIFORM2UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
extern PFNGLPROGRAMUNIFORM2UIVPROC glad_glProgramUniform2uiv;

typedef void ( * PFNGLPROGRAMUNIFORM3IPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
extern PFNGLPROGRAMUNIFORM3IPROC glad_glProgramUniform3i;

typedef void ( * PFNGLPROGRAMUNIFORM3IVPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
extern PFNGLPROGRAMUNIFORM3IVPROC glad_glProgramUniform3iv;

typedef void ( * PFNGLPROGRAMUNIFORM3FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern PFNGLPROGRAMUNIFORM3FPROC glad_glProgramUniform3f;

typedef void ( * PFNGLPROGRAMUNIFORM3FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
extern PFNGLPROGRAMUNIFORM3FVPROC glad_glProgramUniform3fv;

typedef void ( * PFNGLPROGRAMUNIFORM3DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
extern PFNGLPROGRAMUNIFORM3DPROC glad_glProgramUniform3d;

typedef void ( * PFNGLPROGRAMUNIFORM3DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
extern PFNGLPROGRAMUNIFORM3DVPROC glad_glProgramUniform3dv;

typedef void ( * PFNGLPROGRAMUNIFORM3UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
extern PFNGLPROGRAMUNIFORM3UIPROC glad_glProgramUniform3ui;

typedef void ( * PFNGLPROGRAMUNIFORM3UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
extern PFNGLPROGRAMUNIFORM3UIVPROC glad_glProgramUniform3uiv;

typedef void ( * PFNGLPROGRAMUNIFORM4IPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern PFNGLPROGRAMUNIFORM4IPROC glad_glProgramUniform4i;

typedef void ( * PFNGLPROGRAMUNIFORM4IVPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
extern PFNGLPROGRAMUNIFORM4IVPROC glad_glProgramUniform4iv;

typedef void ( * PFNGLPROGRAMUNIFORM4FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern PFNGLPROGRAMUNIFORM4FPROC glad_glProgramUniform4f;

typedef void ( * PFNGLPROGRAMUNIFORM4FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
extern PFNGLPROGRAMUNIFORM4FVPROC glad_glProgramUniform4fv;

typedef void ( * PFNGLPROGRAMUNIFORM4DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
extern PFNGLPROGRAMUNIFORM4DPROC glad_glProgramUniform4d;

typedef void ( * PFNGLPROGRAMUNIFORM4DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
extern PFNGLPROGRAMUNIFORM4DVPROC glad_glProgramUniform4dv;

typedef void ( * PFNGLPROGRAMUNIFORM4UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
extern PFNGLPROGRAMUNIFORM4UIPROC glad_glProgramUniform4ui;

typedef void ( * PFNGLPROGRAMUNIFORM4UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
extern PFNGLPROGRAMUNIFORM4UIVPROC glad_glProgramUniform4uiv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX2FVPROC glad_glProgramUniformMatrix2fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX3FVPROC glad_glProgramUniformMatrix3fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX4FVPROC glad_glProgramUniformMatrix4fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX2DVPROC glad_glProgramUniformMatrix2dv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX3DVPROC glad_glProgramUniformMatrix3dv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX4DVPROC glad_glProgramUniformMatrix4dv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC glad_glProgramUniformMatrix2x3fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC glad_glProgramUniformMatrix3x2fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC glad_glProgramUniformMatrix2x4fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC glad_glProgramUniformMatrix4x2fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC glad_glProgramUniformMatrix3x4fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC glad_glProgramUniformMatrix4x3fv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC glad_glProgramUniformMatrix2x3dv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC glad_glProgramUniformMatrix3x2dv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC glad_glProgramUniformMatrix2x4dv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC glad_glProgramUniformMatrix4x2dv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC glad_glProgramUniformMatrix3x4dv;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC glad_glProgramUniformMatrix4x3dv;

typedef void ( * PFNGLVALIDATEPROGRAMPIPELINEPROC)(GLuint pipeline);
extern PFNGLVALIDATEPROGRAMPIPELINEPROC glad_glValidateProgramPipeline;

typedef void ( * PFNGLGETPROGRAMPIPELINEINFOLOGPROC)(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern PFNGLGETPROGRAMPIPELINEINFOLOGPROC glad_glGetProgramPipelineInfoLog;

typedef void ( * PFNGLVERTEXATTRIBL1DPROC)(GLuint index, GLdouble x);
extern PFNGLVERTEXATTRIBL1DPROC glad_glVertexAttribL1d;

typedef void ( * PFNGLVERTEXATTRIBL2DPROC)(GLuint index, GLdouble x, GLdouble y);
extern PFNGLVERTEXATTRIBL2DPROC glad_glVertexAttribL2d;

typedef void ( * PFNGLVERTEXATTRIBL3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern PFNGLVERTEXATTRIBL3DPROC glad_glVertexAttribL3d;

typedef void ( * PFNGLVERTEXATTRIBL4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLVERTEXATTRIBL4DPROC glad_glVertexAttribL4d;

typedef void ( * PFNGLVERTEXATTRIBL1DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIBL1DVPROC glad_glVertexAttribL1dv;

typedef void ( * PFNGLVERTEXATTRIBL2DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIBL2DVPROC glad_glVertexAttribL2dv;

typedef void ( * PFNGLVERTEXATTRIBL3DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIBL3DVPROC glad_glVertexAttribL3dv;

typedef void ( * PFNGLVERTEXATTRIBL4DVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIBL4DVPROC glad_glVertexAttribL4dv;

typedef void ( * PFNGLVERTEXATTRIBLPOINTERPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
extern PFNGLVERTEXATTRIBLPOINTERPROC glad_glVertexAttribLPointer;

typedef void ( * PFNGLGETVERTEXATTRIBLDVPROC)(GLuint index, GLenum pname, GLdouble *params);
extern PFNGLGETVERTEXATTRIBLDVPROC glad_glGetVertexAttribLdv;

typedef void ( * PFNGLVIEWPORTARRAYVPROC)(GLuint first, GLsizei count, const GLfloat *v);
extern PFNGLVIEWPORTARRAYVPROC glad_glViewportArrayv;

typedef void ( * PFNGLVIEWPORTINDEXEDFPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
extern PFNGLVIEWPORTINDEXEDFPROC glad_glViewportIndexedf;

typedef void ( * PFNGLVIEWPORTINDEXEDFVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVIEWPORTINDEXEDFVPROC glad_glViewportIndexedfv;

typedef void ( * PFNGLSCISSORARRAYVPROC)(GLuint first, GLsizei count, const GLint *v);
extern PFNGLSCISSORARRAYVPROC glad_glScissorArrayv;

typedef void ( * PFNGLSCISSORINDEXEDPROC)(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
extern PFNGLSCISSORINDEXEDPROC glad_glScissorIndexed;

typedef void ( * PFNGLSCISSORINDEXEDVPROC)(GLuint index, const GLint *v);
extern PFNGLSCISSORINDEXEDVPROC glad_glScissorIndexedv;

typedef void ( * PFNGLDEPTHRANGEARRAYVPROC)(GLuint first, GLsizei count, const GLdouble *v);
extern PFNGLDEPTHRANGEARRAYVPROC glad_glDepthRangeArrayv;

typedef void ( * PFNGLDEPTHRANGEINDEXEDPROC)(GLuint index, GLdouble n, GLdouble f);
extern PFNGLDEPTHRANGEINDEXEDPROC glad_glDepthRangeIndexed;

typedef void ( * PFNGLGETFLOATI_VPROC)(GLenum target, GLuint index, GLfloat *data);
extern PFNGLGETFLOATI_VPROC glad_glGetFloati_v;

typedef void ( * PFNGLGETDOUBLEI_VPROC)(GLenum target, GLuint index, GLdouble *data);
extern PFNGLGETDOUBLEI_VPROC glad_glGetDoublei_v;




extern int GLAD_GL_VERSION_4_2;
typedef void ( * PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
extern PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC glad_glDrawArraysInstancedBaseInstance;

typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance);
extern PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC glad_glDrawElementsInstancedBaseInstance;

typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC glad_glDrawElementsInstancedBaseVertexBaseInstance;

typedef void ( * PFNGLGETINTERNALFORMATIVPROC)(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint *params);
extern PFNGLGETINTERNALFORMATIVPROC glad_glGetInternalformativ;

typedef void ( * PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC)(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params);
extern PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glad_glGetActiveAtomicCounterBufferiv;

typedef void ( * PFNGLBINDIMAGETEXTUREPROC)(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
extern PFNGLBINDIMAGETEXTUREPROC glad_glBindImageTexture;

typedef void ( * PFNGLMEMORYBARRIERPROC)(GLbitfield barriers);
extern PFNGLMEMORYBARRIERPROC glad_glMemoryBarrier;

typedef void ( * PFNGLTEXSTORAGE1DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
extern PFNGLTEXSTORAGE1DPROC glad_glTexStorage1D;

typedef void ( * PFNGLTEXSTORAGE2DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLTEXSTORAGE2DPROC glad_glTexStorage2D;

typedef void ( * PFNGLTEXSTORAGE3DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
extern PFNGLTEXSTORAGE3DPROC glad_glTexStorage3D;

typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC)(GLenum mode, GLuint id, GLsizei instancecount);
extern PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC glad_glDrawTransformFeedbackInstanced;

typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC)(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);
extern PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC glad_glDrawTransformFeedbackStreamInstanced;




extern int GLAD_GL_VERSION_4_3;
typedef void ( * PFNGLCLEARBUFFERDATAPROC)(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data);
extern PFNGLCLEARBUFFERDATAPROC glad_glClearBufferData;

typedef void ( * PFNGLCLEARBUFFERSUBDATAPROC)(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
extern PFNGLCLEARBUFFERSUBDATAPROC glad_glClearBufferSubData;

typedef void ( * PFNGLDISPATCHCOMPUTEPROC)(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
extern PFNGLDISPATCHCOMPUTEPROC glad_glDispatchCompute;

typedef void ( * PFNGLDISPATCHCOMPUTEINDIRECTPROC)(GLintptr indirect);
extern PFNGLDISPATCHCOMPUTEINDIRECTPROC glad_glDispatchComputeIndirect;

typedef void ( * PFNGLCOPYIMAGESUBDATAPROC)(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
extern PFNGLCOPYIMAGESUBDATAPROC glad_glCopyImageSubData;

typedef void ( * PFNGLFRAMEBUFFERPARAMETERIPROC)(GLenum target, GLenum pname, GLint param);
extern PFNGLFRAMEBUFFERPARAMETERIPROC glad_glFramebufferParameteri;

typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETFRAMEBUFFERPARAMETERIVPROC glad_glGetFramebufferParameteriv;

typedef void ( * PFNGLGETINTERNALFORMATI64VPROC)(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64 *params);
extern PFNGLGETINTERNALFORMATI64VPROC glad_glGetInternalformati64v;

typedef void ( * PFNGLINVALIDATETEXSUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
extern PFNGLINVALIDATETEXSUBIMAGEPROC glad_glInvalidateTexSubImage;

typedef void ( * PFNGLINVALIDATETEXIMAGEPROC)(GLuint texture, GLint level);
extern PFNGLINVALIDATETEXIMAGEPROC glad_glInvalidateTexImage;

typedef void ( * PFNGLINVALIDATEBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
extern PFNGLINVALIDATEBUFFERSUBDATAPROC glad_glInvalidateBufferSubData;

typedef void ( * PFNGLINVALIDATEBUFFERDATAPROC)(GLuint buffer);
extern PFNGLINVALIDATEBUFFERDATAPROC glad_glInvalidateBufferData;

typedef void ( * PFNGLINVALIDATEFRAMEBUFFERPROC)(GLenum target, GLsizei numAttachments, const GLenum *attachments);
extern PFNGLINVALIDATEFRAMEBUFFERPROC glad_glInvalidateFramebuffer;

typedef void ( * PFNGLINVALIDATESUBFRAMEBUFFERPROC)(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLINVALIDATESUBFRAMEBUFFERPROC glad_glInvalidateSubFramebuffer;

typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTPROC)(GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride);
extern PFNGLMULTIDRAWARRAYSINDIRECTPROC glad_glMultiDrawArraysIndirect;

typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTPROC)(GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride);
extern PFNGLMULTIDRAWELEMENTSINDIRECTPROC glad_glMultiDrawElementsIndirect;

typedef void ( * PFNGLGETPROGRAMINTERFACEIVPROC)(GLuint program, GLenum programInterface, GLenum pname, GLint *params);
extern PFNGLGETPROGRAMINTERFACEIVPROC glad_glGetProgramInterfaceiv;

typedef GLuint ( * PFNGLGETPROGRAMRESOURCEINDEXPROC)(GLuint program, GLenum programInterface, const GLchar *name);
extern PFNGLGETPROGRAMRESOURCEINDEXPROC glad_glGetProgramResourceIndex;

typedef void ( * PFNGLGETPROGRAMRESOURCENAMEPROC)(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
extern PFNGLGETPROGRAMRESOURCENAMEPROC glad_glGetProgramResourceName;

typedef void ( * PFNGLGETPROGRAMRESOURCEIVPROC)(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei count, GLsizei *length, GLint *params);
extern PFNGLGETPROGRAMRESOURCEIVPROC glad_glGetProgramResourceiv;

typedef GLint ( * PFNGLGETPROGRAMRESOURCELOCATIONPROC)(GLuint program, GLenum programInterface, const GLchar *name);
extern PFNGLGETPROGRAMRESOURCELOCATIONPROC glad_glGetProgramResourceLocation;

typedef GLint ( * PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC)(GLuint program, GLenum programInterface, const GLchar *name);
extern PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC glad_glGetProgramResourceLocationIndex;

typedef void ( * PFNGLSHADERSTORAGEBLOCKBINDINGPROC)(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
extern PFNGLSHADERSTORAGEBLOCKBINDINGPROC glad_glShaderStorageBlockBinding;

typedef void ( * PFNGLTEXBUFFERRANGEPROC)(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern PFNGLTEXBUFFERRANGEPROC glad_glTexBufferRange;

typedef void ( * PFNGLTEXSTORAGE2DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
extern PFNGLTEXSTORAGE2DMULTISAMPLEPROC glad_glTexStorage2DMultisample;

typedef void ( * PFNGLTEXSTORAGE3DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
extern PFNGLTEXSTORAGE3DMULTISAMPLEPROC glad_glTexStorage3DMultisample;

typedef void ( * PFNGLTEXTUREVIEWPROC)(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
extern PFNGLTEXTUREVIEWPROC glad_glTextureView;

typedef void ( * PFNGLBINDVERTEXBUFFERPROC)(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
extern PFNGLBINDVERTEXBUFFERPROC glad_glBindVertexBuffer;

typedef void ( * PFNGLVERTEXATTRIBFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
extern PFNGLVERTEXATTRIBFORMATPROC glad_glVertexAttribFormat;

typedef void ( * PFNGLVERTEXATTRIBIFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
extern PFNGLVERTEXATTRIBIFORMATPROC glad_glVertexAttribIFormat;

typedef void ( * PFNGLVERTEXATTRIBLFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
extern PFNGLVERTEXATTRIBLFORMATPROC glad_glVertexAttribLFormat;

typedef void ( * PFNGLVERTEXATTRIBBINDINGPROC)(GLuint attribindex, GLuint bindingindex);
extern PFNGLVERTEXATTRIBBINDINGPROC glad_glVertexAttribBinding;

typedef void ( * PFNGLVERTEXBINDINGDIVISORPROC)(GLuint bindingindex, GLuint divisor);
extern PFNGLVERTEXBINDINGDIVISORPROC glad_glVertexBindingDivisor;

typedef void ( * PFNGLDEBUGMESSAGECONTROLPROC)(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
extern PFNGLDEBUGMESSAGECONTROLPROC glad_glDebugMessageControl;

typedef void ( * PFNGLDEBUGMESSAGEINSERTPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
extern PFNGLDEBUGMESSAGEINSERTPROC glad_glDebugMessageInsert;

typedef void ( * PFNGLDEBUGMESSAGECALLBACKPROC)(GLDEBUGPROC callback, const void *userParam);
extern PFNGLDEBUGMESSAGECALLBACKPROC glad_glDebugMessageCallback;

typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGPROC)(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
extern PFNGLGETDEBUGMESSAGELOGPROC glad_glGetDebugMessageLog;

typedef void ( * PFNGLPUSHDEBUGGROUPPROC)(GLenum source, GLuint id, GLsizei length, const GLchar *message);
extern PFNGLPUSHDEBUGGROUPPROC glad_glPushDebugGroup;

typedef void ( * PFNGLPOPDEBUGGROUPPROC)(void);
extern PFNGLPOPDEBUGGROUPPROC glad_glPopDebugGroup;

typedef void ( * PFNGLOBJECTLABELPROC)(GLenum identifier, GLuint name, GLsizei length, const GLchar *label);
extern PFNGLOBJECTLABELPROC glad_glObjectLabel;

typedef void ( * PFNGLGETOBJECTLABELPROC)(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label);
extern PFNGLGETOBJECTLABELPROC glad_glGetObjectLabel;

typedef void ( * PFNGLOBJECTPTRLABELPROC)(const void *ptr, GLsizei length, const GLchar *label);
extern PFNGLOBJECTPTRLABELPROC glad_glObjectPtrLabel;

typedef void ( * PFNGLGETOBJECTPTRLABELPROC)(const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label);
extern PFNGLGETOBJECTPTRLABELPROC glad_glGetObjectPtrLabel;

typedef void ( * PFNGLGETPOINTERVPROC)(GLenum pname, void **params);
extern PFNGLGETPOINTERVPROC glad_glGetPointerv;




extern int GLAD_GL_VERSION_4_4;
typedef void ( * PFNGLBUFFERSTORAGEPROC)(GLenum target, GLsizeiptr size, const void *data, GLbitfield flags);
extern PFNGLBUFFERSTORAGEPROC glad_glBufferStorage;

typedef void ( * PFNGLCLEARTEXIMAGEPROC)(GLuint texture, GLint level, GLenum format, GLenum type, const void *data);
extern PFNGLCLEARTEXIMAGEPROC glad_glClearTexImage;

typedef void ( * PFNGLCLEARTEXSUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
extern PFNGLCLEARTEXSUBIMAGEPROC glad_glClearTexSubImage;

typedef void ( * PFNGLBINDBUFFERSBASEPROC)(GLenum target, GLuint first, GLsizei count, const GLuint *buffers);
extern PFNGLBINDBUFFERSBASEPROC glad_glBindBuffersBase;

typedef void ( * PFNGLBINDBUFFERSRANGEPROC)(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizeiptr *sizes);
extern PFNGLBINDBUFFERSRANGEPROC glad_glBindBuffersRange;

typedef void ( * PFNGLBINDTEXTURESPROC)(GLuint first, GLsizei count, const GLuint *textures);
extern PFNGLBINDTEXTURESPROC glad_glBindTextures;

typedef void ( * PFNGLBINDSAMPLERSPROC)(GLuint first, GLsizei count, const GLuint *samplers);
extern PFNGLBINDSAMPLERSPROC glad_glBindSamplers;

typedef void ( * PFNGLBINDIMAGETEXTURESPROC)(GLuint first, GLsizei count, const GLuint *textures);
extern PFNGLBINDIMAGETEXTURESPROC glad_glBindImageTextures;

typedef void ( * PFNGLBINDVERTEXBUFFERSPROC)(GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides);
extern PFNGLBINDVERTEXBUFFERSPROC glad_glBindVertexBuffers;




extern int GLAD_GL_VERSION_4_5;
typedef void ( * PFNGLCLIPCONTROLPROC)(GLenum origin, GLenum depth);
extern PFNGLCLIPCONTROLPROC glad_glClipControl;

typedef void ( * PFNGLCREATETRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint *ids);
extern PFNGLCREATETRANSFORMFEEDBACKSPROC glad_glCreateTransformFeedbacks;

typedef void ( * PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC)(GLuint xfb, GLuint index, GLuint buffer);
extern PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC glad_glTransformFeedbackBufferBase;

typedef void ( * PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC)(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC glad_glTransformFeedbackBufferRange;

typedef void ( * PFNGLGETTRANSFORMFEEDBACKIVPROC)(GLuint xfb, GLenum pname, GLint *param);
extern PFNGLGETTRANSFORMFEEDBACKIVPROC glad_glGetTransformFeedbackiv;

typedef void ( * PFNGLGETTRANSFORMFEEDBACKI_VPROC)(GLuint xfb, GLenum pname, GLuint index, GLint *param);
extern PFNGLGETTRANSFORMFEEDBACKI_VPROC glad_glGetTransformFeedbacki_v;

typedef void ( * PFNGLGETTRANSFORMFEEDBACKI64_VPROC)(GLuint xfb, GLenum pname, GLuint index, GLint64 *param);
extern PFNGLGETTRANSFORMFEEDBACKI64_VPROC glad_glGetTransformFeedbacki64_v;

typedef void ( * PFNGLCREATEBUFFERSPROC)(GLsizei n, GLuint *buffers);
extern PFNGLCREATEBUFFERSPROC glad_glCreateBuffers;

typedef void ( * PFNGLNAMEDBUFFERSTORAGEPROC)(GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);
extern PFNGLNAMEDBUFFERSTORAGEPROC glad_glNamedBufferStorage;

typedef void ( * PFNGLNAMEDBUFFERDATAPROC)(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
extern PFNGLNAMEDBUFFERDATAPROC glad_glNamedBufferData;

typedef void ( * PFNGLNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
extern PFNGLNAMEDBUFFERSUBDATAPROC glad_glNamedBufferSubData;

typedef void ( * PFNGLCOPYNAMEDBUFFERSUBDATAPROC)(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
extern PFNGLCOPYNAMEDBUFFERSUBDATAPROC glad_glCopyNamedBufferSubData;

typedef void ( * PFNGLCLEARNAMEDBUFFERDATAPROC)(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
extern PFNGLCLEARNAMEDBUFFERDATAPROC glad_glClearNamedBufferData;

typedef void ( * PFNGLCLEARNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
extern PFNGLCLEARNAMEDBUFFERSUBDATAPROC glad_glClearNamedBufferSubData;

typedef void * ( * PFNGLMAPNAMEDBUFFERPROC)(GLuint buffer, GLenum access);
extern PFNGLMAPNAMEDBUFFERPROC glad_glMapNamedBuffer;

typedef void * ( * PFNGLMAPNAMEDBUFFERRANGEPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
extern PFNGLMAPNAMEDBUFFERRANGEPROC glad_glMapNamedBufferRange;

typedef GLboolean ( * PFNGLUNMAPNAMEDBUFFERPROC)(GLuint buffer);
extern PFNGLUNMAPNAMEDBUFFERPROC glad_glUnmapNamedBuffer;

typedef void ( * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
extern PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC glad_glFlushMappedNamedBufferRange;

typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERIVPROC)(GLuint buffer, GLenum pname, GLint *params);
extern PFNGLGETNAMEDBUFFERPARAMETERIVPROC glad_glGetNamedBufferParameteriv;

typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERI64VPROC)(GLuint buffer, GLenum pname, GLint64 *params);
extern PFNGLGETNAMEDBUFFERPARAMETERI64VPROC glad_glGetNamedBufferParameteri64v;

typedef void ( * PFNGLGETNAMEDBUFFERPOINTERVPROC)(GLuint buffer, GLenum pname, void **params);
extern PFNGLGETNAMEDBUFFERPOINTERVPROC glad_glGetNamedBufferPointerv;

typedef void ( * PFNGLGETNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
extern PFNGLGETNAMEDBUFFERSUBDATAPROC glad_glGetNamedBufferSubData;

typedef void ( * PFNGLCREATEFRAMEBUFFERSPROC)(GLsizei n, GLuint *framebuffers);
extern PFNGLCREATEFRAMEBUFFERSPROC glad_glCreateFramebuffers;

typedef void ( * PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC)(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC glad_glNamedFramebufferRenderbuffer;

typedef void ( * PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC)(GLuint framebuffer, GLenum pname, GLint param);
extern PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC glad_glNamedFramebufferParameteri;

typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
extern PFNGLNAMEDFRAMEBUFFERTEXTUREPROC glad_glNamedFramebufferTexture;

typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
extern PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC glad_glNamedFramebufferTextureLayer;

typedef void ( * PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC)(GLuint framebuffer, GLenum buf);
extern PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC glad_glNamedFramebufferDrawBuffer;

typedef void ( * PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC)(GLuint framebuffer, GLsizei n, const GLenum *bufs);
extern PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC glad_glNamedFramebufferDrawBuffers;

typedef void ( * PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC)(GLuint framebuffer, GLenum src);
extern PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC glad_glNamedFramebufferReadBuffer;

typedef void ( * PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC)(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments);
extern PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC glad_glInvalidateNamedFramebufferData;

typedef void ( * PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC)(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC glad_glInvalidateNamedFramebufferSubData;

typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERIVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *value);
extern PFNGLCLEARNAMEDFRAMEBUFFERIVPROC glad_glClearNamedFramebufferiv;

typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *value);
extern PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC glad_glClearNamedFramebufferuiv;

typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERFVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *value);
extern PFNGLCLEARNAMEDFRAMEBUFFERFVPROC glad_glClearNamedFramebufferfv;

typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERFIPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
extern PFNGLCLEARNAMEDFRAMEBUFFERFIPROC glad_glClearNamedFramebufferfi;

typedef void ( * PFNGLBLITNAMEDFRAMEBUFFERPROC)(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
extern PFNGLBLITNAMEDFRAMEBUFFERPROC glad_glBlitNamedFramebuffer;

typedef GLenum ( * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC)(GLuint framebuffer, GLenum target);
extern PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC glad_glCheckNamedFramebufferStatus;

typedef void ( * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC)(GLuint framebuffer, GLenum pname, GLint *param);
extern PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC glad_glGetNamedFramebufferParameteriv;

typedef void ( * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params);
extern PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetNamedFramebufferAttachmentParameteriv;

typedef void ( * PFNGLCREATERENDERBUFFERSPROC)(GLsizei n, GLuint *renderbuffers);
extern PFNGLCREATERENDERBUFFERSPROC glad_glCreateRenderbuffers;

typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEPROC)(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLNAMEDRENDERBUFFERSTORAGEPROC glad_glNamedRenderbufferStorage;

typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glNamedRenderbufferStorageMultisample;

typedef void ( * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC)(GLuint renderbuffer, GLenum pname, GLint *params);
extern PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC glad_glGetNamedRenderbufferParameteriv;

typedef void ( * PFNGLCREATETEXTURESPROC)(GLenum target, GLsizei n, GLuint *textures);
extern PFNGLCREATETEXTURESPROC glad_glCreateTextures;

typedef void ( * PFNGLTEXTUREBUFFERPROC)(GLuint texture, GLenum internalformat, GLuint buffer);
extern PFNGLTEXTUREBUFFERPROC glad_glTextureBuffer;

typedef void ( * PFNGLTEXTUREBUFFERRANGEPROC)(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern PFNGLTEXTUREBUFFERRANGEPROC glad_glTextureBufferRange;

typedef void ( * PFNGLTEXTURESTORAGE1DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);
extern PFNGLTEXTURESTORAGE1DPROC glad_glTextureStorage1D;

typedef void ( * PFNGLTEXTURESTORAGE2DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLTEXTURESTORAGE2DPROC glad_glTextureStorage2D;

typedef void ( * PFNGLTEXTURESTORAGE3DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
extern PFNGLTEXTURESTORAGE3DPROC glad_glTextureStorage3D;

typedef void ( * PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC)(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
extern PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC glad_glTextureStorage2DMultisample;

typedef void ( * PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC)(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
extern PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC glad_glTextureStorage3DMultisample;

typedef void ( * PFNGLTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXTURESUBIMAGE1DPROC glad_glTextureSubImage1D;

typedef void ( * PFNGLTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXTURESUBIMAGE2DPROC glad_glTextureSubImage2D;

typedef void ( * PFNGLTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXTURESUBIMAGE3DPROC glad_glTextureSubImage3D;

typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC glad_glCompressedTextureSubImage1D;

typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC glad_glCompressedTextureSubImage2D;

typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC glad_glCompressedTextureSubImage3D;

typedef void ( * PFNGLCOPYTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern PFNGLCOPYTEXTURESUBIMAGE1DPROC glad_glCopyTextureSubImage1D;

typedef void ( * PFNGLCOPYTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYTEXTURESUBIMAGE2DPROC glad_glCopyTextureSubImage2D;

typedef void ( * PFNGLCOPYTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYTEXTURESUBIMAGE3DPROC glad_glCopyTextureSubImage3D;

typedef void ( * PFNGLTEXTUREPARAMETERFPROC)(GLuint texture, GLenum pname, GLfloat param);
extern PFNGLTEXTUREPARAMETERFPROC glad_glTextureParameterf;

typedef void ( * PFNGLTEXTUREPARAMETERFVPROC)(GLuint texture, GLenum pname, const GLfloat *param);
extern PFNGLTEXTUREPARAMETERFVPROC glad_glTextureParameterfv;

typedef void ( * PFNGLTEXTUREPARAMETERIPROC)(GLuint texture, GLenum pname, GLint param);
extern PFNGLTEXTUREPARAMETERIPROC glad_glTextureParameteri;

typedef void ( * PFNGLTEXTUREPARAMETERIIVPROC)(GLuint texture, GLenum pname, const GLint *params);
extern PFNGLTEXTUREPARAMETERIIVPROC glad_glTextureParameterIiv;

typedef void ( * PFNGLTEXTUREPARAMETERIUIVPROC)(GLuint texture, GLenum pname, const GLuint *params);
extern PFNGLTEXTUREPARAMETERIUIVPROC glad_glTextureParameterIuiv;

typedef void ( * PFNGLTEXTUREPARAMETERIVPROC)(GLuint texture, GLenum pname, const GLint *param);
extern PFNGLTEXTUREPARAMETERIVPROC glad_glTextureParameteriv;

typedef void ( * PFNGLGENERATETEXTUREMIPMAPPROC)(GLuint texture);
extern PFNGLGENERATETEXTUREMIPMAPPROC glad_glGenerateTextureMipmap;

typedef void ( * PFNGLBINDTEXTUREUNITPROC)(GLuint unit, GLuint texture);
extern PFNGLBINDTEXTUREUNITPROC glad_glBindTextureUnit;

typedef void ( * PFNGLGETTEXTUREIMAGEPROC)(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
extern PFNGLGETTEXTUREIMAGEPROC glad_glGetTextureImage;

typedef void ( * PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC)(GLuint texture, GLint level, GLsizei bufSize, void *pixels);
extern PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC glad_glGetCompressedTextureImage;

typedef void ( * PFNGLGETTEXTURELEVELPARAMETERFVPROC)(GLuint texture, GLint level, GLenum pname, GLfloat *params);
extern PFNGLGETTEXTURELEVELPARAMETERFVPROC glad_glGetTextureLevelParameterfv;

typedef void ( * PFNGLGETTEXTURELEVELPARAMETERIVPROC)(GLuint texture, GLint level, GLenum pname, GLint *params);
extern PFNGLGETTEXTURELEVELPARAMETERIVPROC glad_glGetTextureLevelParameteriv;

typedef void ( * PFNGLGETTEXTUREPARAMETERFVPROC)(GLuint texture, GLenum pname, GLfloat *params);
extern PFNGLGETTEXTUREPARAMETERFVPROC glad_glGetTextureParameterfv;

typedef void ( * PFNGLGETTEXTUREPARAMETERIIVPROC)(GLuint texture, GLenum pname, GLint *params);
extern PFNGLGETTEXTUREPARAMETERIIVPROC glad_glGetTextureParameterIiv;

typedef void ( * PFNGLGETTEXTUREPARAMETERIUIVPROC)(GLuint texture, GLenum pname, GLuint *params);
extern PFNGLGETTEXTUREPARAMETERIUIVPROC glad_glGetTextureParameterIuiv;

typedef void ( * PFNGLGETTEXTUREPARAMETERIVPROC)(GLuint texture, GLenum pname, GLint *params);
extern PFNGLGETTEXTUREPARAMETERIVPROC glad_glGetTextureParameteriv;

typedef void ( * PFNGLCREATEVERTEXARRAYSPROC)(GLsizei n, GLuint *arrays);
extern PFNGLCREATEVERTEXARRAYSPROC glad_glCreateVertexArrays;

typedef void ( * PFNGLDISABLEVERTEXARRAYATTRIBPROC)(GLuint vaobj, GLuint index);
extern PFNGLDISABLEVERTEXARRAYATTRIBPROC glad_glDisableVertexArrayAttrib;

typedef void ( * PFNGLENABLEVERTEXARRAYATTRIBPROC)(GLuint vaobj, GLuint index);
extern PFNGLENABLEVERTEXARRAYATTRIBPROC glad_glEnableVertexArrayAttrib;

typedef void ( * PFNGLVERTEXARRAYELEMENTBUFFERPROC)(GLuint vaobj, GLuint buffer);
extern PFNGLVERTEXARRAYELEMENTBUFFERPROC glad_glVertexArrayElementBuffer;

typedef void ( * PFNGLVERTEXARRAYVERTEXBUFFERPROC)(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
extern PFNGLVERTEXARRAYVERTEXBUFFERPROC glad_glVertexArrayVertexBuffer;

typedef void ( * PFNGLVERTEXARRAYVERTEXBUFFERSPROC)(GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides);
extern PFNGLVERTEXARRAYVERTEXBUFFERSPROC glad_glVertexArrayVertexBuffers;

typedef void ( * PFNGLVERTEXARRAYATTRIBBINDINGPROC)(GLuint vaobj, GLuint attribindex, GLuint bindingindex);
extern PFNGLVERTEXARRAYATTRIBBINDINGPROC glad_glVertexArrayAttribBinding;

typedef void ( * PFNGLVERTEXARRAYATTRIBFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
extern PFNGLVERTEXARRAYATTRIBFORMATPROC glad_glVertexArrayAttribFormat;

typedef void ( * PFNGLVERTEXARRAYATTRIBIFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
extern PFNGLVERTEXARRAYATTRIBIFORMATPROC glad_glVertexArrayAttribIFormat;

typedef void ( * PFNGLVERTEXARRAYATTRIBLFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
extern PFNGLVERTEXARRAYATTRIBLFORMATPROC glad_glVertexArrayAttribLFormat;

typedef void ( * PFNGLVERTEXARRAYBINDINGDIVISORPROC)(GLuint vaobj, GLuint bindingindex, GLuint divisor);
extern PFNGLVERTEXARRAYBINDINGDIVISORPROC glad_glVertexArrayBindingDivisor;

typedef void ( * PFNGLGETVERTEXARRAYIVPROC)(GLuint vaobj, GLenum pname, GLint *param);
extern PFNGLGETVERTEXARRAYIVPROC glad_glGetVertexArrayiv;

typedef void ( * PFNGLGETVERTEXARRAYINDEXEDIVPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint *param);
extern PFNGLGETVERTEXARRAYINDEXEDIVPROC glad_glGetVertexArrayIndexediv;

typedef void ( * PFNGLGETVERTEXARRAYINDEXED64IVPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint64 *param);
extern PFNGLGETVERTEXARRAYINDEXED64IVPROC glad_glGetVertexArrayIndexed64iv;

typedef void ( * PFNGLCREATESAMPLERSPROC)(GLsizei n, GLuint *samplers);
extern PFNGLCREATESAMPLERSPROC glad_glCreateSamplers;

typedef void ( * PFNGLCREATEPROGRAMPIPELINESPROC)(GLsizei n, GLuint *pipelines);
extern PFNGLCREATEPROGRAMPIPELINESPROC glad_glCreateProgramPipelines;

typedef void ( * PFNGLCREATEQUERIESPROC)(GLenum target, GLsizei n, GLuint *ids);
extern PFNGLCREATEQUERIESPROC glad_glCreateQueries;

typedef void ( * PFNGLGETQUERYBUFFEROBJECTI64VPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
extern PFNGLGETQUERYBUFFEROBJECTI64VPROC glad_glGetQueryBufferObjecti64v;

typedef void ( * PFNGLGETQUERYBUFFEROBJECTIVPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
extern PFNGLGETQUERYBUFFEROBJECTIVPROC glad_glGetQueryBufferObjectiv;

typedef void ( * PFNGLGETQUERYBUFFEROBJECTUI64VPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
extern PFNGLGETQUERYBUFFEROBJECTUI64VPROC glad_glGetQueryBufferObjectui64v;

typedef void ( * PFNGLGETQUERYBUFFEROBJECTUIVPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
extern PFNGLGETQUERYBUFFEROBJECTUIVPROC glad_glGetQueryBufferObjectuiv;

typedef void ( * PFNGLMEMORYBARRIERBYREGIONPROC)(GLbitfield barriers);
extern PFNGLMEMORYBARRIERBYREGIONPROC glad_glMemoryBarrierByRegion;

typedef void ( * PFNGLGETTEXTURESUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
extern PFNGLGETTEXTURESUBIMAGEPROC glad_glGetTextureSubImage;

typedef void ( * PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels);
extern PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC glad_glGetCompressedTextureSubImage;

typedef GLenum ( * PFNGLGETGRAPHICSRESETSTATUSPROC)(void);
extern PFNGLGETGRAPHICSRESETSTATUSPROC glad_glGetGraphicsResetStatus;

typedef void ( * PFNGLGETNCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint lod, GLsizei bufSize, void *pixels);
extern PFNGLGETNCOMPRESSEDTEXIMAGEPROC glad_glGetnCompressedTexImage;

typedef void ( * PFNGLGETNTEXIMAGEPROC)(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
extern PFNGLGETNTEXIMAGEPROC glad_glGetnTexImage;

typedef void ( * PFNGLGETNUNIFORMDVPROC)(GLuint program, GLint location, GLsizei bufSize, GLdouble *params);
extern PFNGLGETNUNIFORMDVPROC glad_glGetnUniformdv;

typedef void ( * PFNGLGETNUNIFORMFVPROC)(GLuint program, GLint location, GLsizei bufSize, GLfloat *params);
extern PFNGLGETNUNIFORMFVPROC glad_glGetnUniformfv;

typedef void ( * PFNGLGETNUNIFORMIVPROC)(GLuint program, GLint location, GLsizei bufSize, GLint *params);
extern PFNGLGETNUNIFORMIVPROC glad_glGetnUniformiv;

typedef void ( * PFNGLGETNUNIFORMUIVPROC)(GLuint program, GLint location, GLsizei bufSize, GLuint *params);
extern PFNGLGETNUNIFORMUIVPROC glad_glGetnUniformuiv;

typedef void ( * PFNGLREADNPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);
extern PFNGLREADNPIXELSPROC glad_glReadnPixels;

typedef void ( * PFNGLGETNMAPDVPROC)(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v);
extern PFNGLGETNMAPDVPROC glad_glGetnMapdv;

typedef void ( * PFNGLGETNMAPFVPROC)(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v);
extern PFNGLGETNMAPFVPROC glad_glGetnMapfv;

typedef void ( * PFNGLGETNMAPIVPROC)(GLenum target, GLenum query, GLsizei bufSize, GLint *v);
extern PFNGLGETNMAPIVPROC glad_glGetnMapiv;

typedef void ( * PFNGLGETNPIXELMAPFVPROC)(GLenum map, GLsizei bufSize, GLfloat *values);
extern PFNGLGETNPIXELMAPFVPROC glad_glGetnPixelMapfv;

typedef void ( * PFNGLGETNPIXELMAPUIVPROC)(GLenum map, GLsizei bufSize, GLuint *values);
extern PFNGLGETNPIXELMAPUIVPROC glad_glGetnPixelMapuiv;

typedef void ( * PFNGLGETNPIXELMAPUSVPROC)(GLenum map, GLsizei bufSize, GLushort *values);
extern PFNGLGETNPIXELMAPUSVPROC glad_glGetnPixelMapusv;

typedef void ( * PFNGLGETNPOLYGONSTIPPLEPROC)(GLsizei bufSize, GLubyte *pattern);
extern PFNGLGETNPOLYGONSTIPPLEPROC glad_glGetnPolygonStipple;

typedef void ( * PFNGLGETNCOLORTABLEPROC)(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table);
extern PFNGLGETNCOLORTABLEPROC glad_glGetnColorTable;

typedef void ( * PFNGLGETNCONVOLUTIONFILTERPROC)(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image);
extern PFNGLGETNCONVOLUTIONFILTERPROC glad_glGetnConvolutionFilter;

typedef void ( * PFNGLGETNSEPARABLEFILTERPROC)(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span);
extern PFNGLGETNSEPARABLEFILTERPROC glad_glGetnSeparableFilter;

typedef void ( * PFNGLGETNHISTOGRAMPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values);
extern PFNGLGETNHISTOGRAMPROC glad_glGetnHistogram;

typedef void ( * PFNGLGETNMINMAXPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values);
extern PFNGLGETNMINMAXPROC glad_glGetnMinmax;

typedef void ( * PFNGLTEXTUREBARRIERPROC)(void);
extern PFNGLTEXTUREBARRIERPROC glad_glTextureBarrier;




extern int GLAD_GL_VERSION_4_6;
typedef void ( * PFNGLSPECIALIZESHADERPROC)(GLuint shader, const GLchar *pEntryPoint, GLuint numSpecializationConstants, const GLuint *pConstantIndex, const GLuint *pConstantValue);
extern PFNGLSPECIALIZESHADERPROC glad_glSpecializeShader;

typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC)(GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
extern PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC glad_glMultiDrawArraysIndirectCount;

typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC)(GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
extern PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC glad_glMultiDrawElementsIndirectCount;

typedef void ( * PFNGLPOLYGONOFFSETCLAMPPROC)(GLfloat factor, GLfloat units, GLfloat clamp);
extern PFNGLPOLYGONOFFSETCLAMPPROC glad_glPolygonOffsetClamp;
# 7558 "/home/tayler/projects/marmalade/vendor/glad/include/glad/glad.h"
extern int GLAD_GL_3DFX_multisample;



extern int GLAD_GL_3DFX_tbuffer;
typedef void ( * PFNGLTBUFFERMASK3DFXPROC)(GLuint mask);
extern PFNGLTBUFFERMASK3DFXPROC glad_glTbufferMask3DFX;




extern int GLAD_GL_3DFX_texture_compression_FXT1;



extern int GLAD_GL_AMD_blend_minmax_factor;



extern int GLAD_GL_AMD_conservative_depth;



extern int GLAD_GL_AMD_debug_output;
typedef void ( * PFNGLDEBUGMESSAGEENABLEAMDPROC)(GLenum category, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
extern PFNGLDEBUGMESSAGEENABLEAMDPROC glad_glDebugMessageEnableAMD;

typedef void ( * PFNGLDEBUGMESSAGEINSERTAMDPROC)(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *buf);
extern PFNGLDEBUGMESSAGEINSERTAMDPROC glad_glDebugMessageInsertAMD;

typedef void ( * PFNGLDEBUGMESSAGECALLBACKAMDPROC)(GLDEBUGPROCAMD callback, void *userParam);
extern PFNGLDEBUGMESSAGECALLBACKAMDPROC glad_glDebugMessageCallbackAMD;

typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGAMDPROC)(GLuint count, GLsizei bufSize, GLenum *categories, GLenum *severities, GLuint *ids, GLsizei *lengths, GLchar *message);
extern PFNGLGETDEBUGMESSAGELOGAMDPROC glad_glGetDebugMessageLogAMD;




extern int GLAD_GL_AMD_depth_clamp_separate;



extern int GLAD_GL_AMD_draw_buffers_blend;
typedef void ( * PFNGLBLENDFUNCINDEXEDAMDPROC)(GLuint buf, GLenum src, GLenum dst);
extern PFNGLBLENDFUNCINDEXEDAMDPROC glad_glBlendFuncIndexedAMD;

typedef void ( * PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
extern PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC glad_glBlendFuncSeparateIndexedAMD;

typedef void ( * PFNGLBLENDEQUATIONINDEXEDAMDPROC)(GLuint buf, GLenum mode);
extern PFNGLBLENDEQUATIONINDEXEDAMDPROC glad_glBlendEquationIndexedAMD;

typedef void ( * PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
extern PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC glad_glBlendEquationSeparateIndexedAMD;




extern int GLAD_GL_AMD_framebuffer_multisample_advanced;
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC)(GLenum target, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC glad_glRenderbufferStorageMultisampleAdvancedAMD;

typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC)(GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC glad_glNamedRenderbufferStorageMultisampleAdvancedAMD;




extern int GLAD_GL_AMD_framebuffer_sample_positions;
typedef void ( * PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC)(GLenum target, GLuint numsamples, GLuint pixelindex, const GLfloat *values);
extern PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC glad_glFramebufferSamplePositionsfvAMD;

typedef void ( * PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC)(GLuint framebuffer, GLuint numsamples, GLuint pixelindex, const GLfloat *values);
extern PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC glad_glNamedFramebufferSamplePositionsfvAMD;

typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC)(GLenum target, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat *values);
extern PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC glad_glGetFramebufferParameterfvAMD;

typedef void ( * PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC)(GLuint framebuffer, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat *values);
extern PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC glad_glGetNamedFramebufferParameterfvAMD;




extern int GLAD_GL_AMD_gcn_shader;



extern int GLAD_GL_AMD_gpu_shader_half_float;



extern int GLAD_GL_AMD_gpu_shader_int16;



extern int GLAD_GL_AMD_gpu_shader_int64;
typedef void ( * PFNGLUNIFORM1I64NVPROC)(GLint location, GLint64EXT x);
extern PFNGLUNIFORM1I64NVPROC glad_glUniform1i64NV;

typedef void ( * PFNGLUNIFORM2I64NVPROC)(GLint location, GLint64EXT x, GLint64EXT y);
extern PFNGLUNIFORM2I64NVPROC glad_glUniform2i64NV;

typedef void ( * PFNGLUNIFORM3I64NVPROC)(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
extern PFNGLUNIFORM3I64NVPROC glad_glUniform3i64NV;

typedef void ( * PFNGLUNIFORM4I64NVPROC)(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
extern PFNGLUNIFORM4I64NVPROC glad_glUniform4i64NV;

typedef void ( * PFNGLUNIFORM1I64VNVPROC)(GLint location, GLsizei count, const GLint64EXT *value);
extern PFNGLUNIFORM1I64VNVPROC glad_glUniform1i64vNV;

typedef void ( * PFNGLUNIFORM2I64VNVPROC)(GLint location, GLsizei count, const GLint64EXT *value);
extern PFNGLUNIFORM2I64VNVPROC glad_glUniform2i64vNV;

typedef void ( * PFNGLUNIFORM3I64VNVPROC)(GLint location, GLsizei count, const GLint64EXT *value);
extern PFNGLUNIFORM3I64VNVPROC glad_glUniform3i64vNV;

typedef void ( * PFNGLUNIFORM4I64VNVPROC)(GLint location, GLsizei count, const GLint64EXT *value);
extern PFNGLUNIFORM4I64VNVPROC glad_glUniform4i64vNV;

typedef void ( * PFNGLUNIFORM1UI64NVPROC)(GLint location, GLuint64EXT x);
extern PFNGLUNIFORM1UI64NVPROC glad_glUniform1ui64NV;

typedef void ( * PFNGLUNIFORM2UI64NVPROC)(GLint location, GLuint64EXT x, GLuint64EXT y);
extern PFNGLUNIFORM2UI64NVPROC glad_glUniform2ui64NV;

typedef void ( * PFNGLUNIFORM3UI64NVPROC)(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
extern PFNGLUNIFORM3UI64NVPROC glad_glUniform3ui64NV;

typedef void ( * PFNGLUNIFORM4UI64NVPROC)(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
extern PFNGLUNIFORM4UI64NVPROC glad_glUniform4ui64NV;

typedef void ( * PFNGLUNIFORM1UI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT *value);
extern PFNGLUNIFORM1UI64VNVPROC glad_glUniform1ui64vNV;

typedef void ( * PFNGLUNIFORM2UI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT *value);
extern PFNGLUNIFORM2UI64VNVPROC glad_glUniform2ui64vNV;

typedef void ( * PFNGLUNIFORM3UI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT *value);
extern PFNGLUNIFORM3UI64VNVPROC glad_glUniform3ui64vNV;

typedef void ( * PFNGLUNIFORM4UI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT *value);
extern PFNGLUNIFORM4UI64VNVPROC glad_glUniform4ui64vNV;

typedef void ( * PFNGLGETUNIFORMI64VNVPROC)(GLuint program, GLint location, GLint64EXT *params);
extern PFNGLGETUNIFORMI64VNVPROC glad_glGetUniformi64vNV;

typedef void ( * PFNGLGETUNIFORMUI64VNVPROC)(GLuint program, GLint location, GLuint64EXT *params);
extern PFNGLGETUNIFORMUI64VNVPROC glad_glGetUniformui64vNV;

typedef void ( * PFNGLPROGRAMUNIFORM1I64NVPROC)(GLuint program, GLint location, GLint64EXT x);
extern PFNGLPROGRAMUNIFORM1I64NVPROC glad_glProgramUniform1i64NV;

typedef void ( * PFNGLPROGRAMUNIFORM2I64NVPROC)(GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
extern PFNGLPROGRAMUNIFORM2I64NVPROC glad_glProgramUniform2i64NV;

typedef void ( * PFNGLPROGRAMUNIFORM3I64NVPROC)(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
extern PFNGLPROGRAMUNIFORM3I64NVPROC glad_glProgramUniform3i64NV;

typedef void ( * PFNGLPROGRAMUNIFORM4I64NVPROC)(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
extern PFNGLPROGRAMUNIFORM4I64NVPROC glad_glProgramUniform4i64NV;

typedef void ( * PFNGLPROGRAMUNIFORM1I64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
extern PFNGLPROGRAMUNIFORM1I64VNVPROC glad_glProgramUniform1i64vNV;

typedef void ( * PFNGLPROGRAMUNIFORM2I64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
extern PFNGLPROGRAMUNIFORM2I64VNVPROC glad_glProgramUniform2i64vNV;

typedef void ( * PFNGLPROGRAMUNIFORM3I64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
extern PFNGLPROGRAMUNIFORM3I64VNVPROC glad_glProgramUniform3i64vNV;

typedef void ( * PFNGLPROGRAMUNIFORM4I64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
extern PFNGLPROGRAMUNIFORM4I64VNVPROC glad_glProgramUniform4i64vNV;

typedef void ( * PFNGLPROGRAMUNIFORM1UI64NVPROC)(GLuint program, GLint location, GLuint64EXT x);
extern PFNGLPROGRAMUNIFORM1UI64NVPROC glad_glProgramUniform1ui64NV;

typedef void ( * PFNGLPROGRAMUNIFORM2UI64NVPROC)(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
extern PFNGLPROGRAMUNIFORM2UI64NVPROC glad_glProgramUniform2ui64NV;

typedef void ( * PFNGLPROGRAMUNIFORM3UI64NVPROC)(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
extern PFNGLPROGRAMUNIFORM3UI64NVPROC glad_glProgramUniform3ui64NV;

typedef void ( * PFNGLPROGRAMUNIFORM4UI64NVPROC)(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
extern PFNGLPROGRAMUNIFORM4UI64NVPROC glad_glProgramUniform4ui64NV;

typedef void ( * PFNGLPROGRAMUNIFORM1UI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
extern PFNGLPROGRAMUNIFORM1UI64VNVPROC glad_glProgramUniform1ui64vNV;

typedef void ( * PFNGLPROGRAMUNIFORM2UI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
extern PFNGLPROGRAMUNIFORM2UI64VNVPROC glad_glProgramUniform2ui64vNV;

typedef void ( * PFNGLPROGRAMUNIFORM3UI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
extern PFNGLPROGRAMUNIFORM3UI64VNVPROC glad_glProgramUniform3ui64vNV;

typedef void ( * PFNGLPROGRAMUNIFORM4UI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
extern PFNGLPROGRAMUNIFORM4UI64VNVPROC glad_glProgramUniform4ui64vNV;




extern int GLAD_GL_AMD_interleaved_elements;
typedef void ( * PFNGLVERTEXATTRIBPARAMETERIAMDPROC)(GLuint index, GLenum pname, GLint param);
extern PFNGLVERTEXATTRIBPARAMETERIAMDPROC glad_glVertexAttribParameteriAMD;




extern int GLAD_GL_AMD_multi_draw_indirect;
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC)(GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride);
extern PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC glad_glMultiDrawArraysIndirectAMD;

typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC)(GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride);
extern PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC glad_glMultiDrawElementsIndirectAMD;




extern int GLAD_GL_AMD_name_gen_delete;
typedef void ( * PFNGLGENNAMESAMDPROC)(GLenum identifier, GLuint num, GLuint *names);
extern PFNGLGENNAMESAMDPROC glad_glGenNamesAMD;

typedef void ( * PFNGLDELETENAMESAMDPROC)(GLenum identifier, GLuint num, const GLuint *names);
extern PFNGLDELETENAMESAMDPROC glad_glDeleteNamesAMD;

typedef GLboolean ( * PFNGLISNAMEAMDPROC)(GLenum identifier, GLuint name);
extern PFNGLISNAMEAMDPROC glad_glIsNameAMD;




extern int GLAD_GL_AMD_occlusion_query_event;
typedef void ( * PFNGLQUERYOBJECTPARAMETERUIAMDPROC)(GLenum target, GLuint id, GLenum pname, GLuint param);
extern PFNGLQUERYOBJECTPARAMETERUIAMDPROC glad_glQueryObjectParameteruiAMD;




extern int GLAD_GL_AMD_performance_monitor;
typedef void ( * PFNGLGETPERFMONITORGROUPSAMDPROC)(GLint *numGroups, GLsizei groupsSize, GLuint *groups);
extern PFNGLGETPERFMONITORGROUPSAMDPROC glad_glGetPerfMonitorGroupsAMD;

typedef void ( * PFNGLGETPERFMONITORCOUNTERSAMDPROC)(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei counterSize, GLuint *counters);
extern PFNGLGETPERFMONITORCOUNTERSAMDPROC glad_glGetPerfMonitorCountersAMD;

typedef void ( * PFNGLGETPERFMONITORGROUPSTRINGAMDPROC)(GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString);
extern PFNGLGETPERFMONITORGROUPSTRINGAMDPROC glad_glGetPerfMonitorGroupStringAMD;

typedef void ( * PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC)(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString);
extern PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC glad_glGetPerfMonitorCounterStringAMD;

typedef void ( * PFNGLGETPERFMONITORCOUNTERINFOAMDPROC)(GLuint group, GLuint counter, GLenum pname, void *data);
extern PFNGLGETPERFMONITORCOUNTERINFOAMDPROC glad_glGetPerfMonitorCounterInfoAMD;

typedef void ( * PFNGLGENPERFMONITORSAMDPROC)(GLsizei n, GLuint *monitors);
extern PFNGLGENPERFMONITORSAMDPROC glad_glGenPerfMonitorsAMD;

typedef void ( * PFNGLDELETEPERFMONITORSAMDPROC)(GLsizei n, GLuint *monitors);
extern PFNGLDELETEPERFMONITORSAMDPROC glad_glDeletePerfMonitorsAMD;

typedef void ( * PFNGLSELECTPERFMONITORCOUNTERSAMDPROC)(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList);
extern PFNGLSELECTPERFMONITORCOUNTERSAMDPROC glad_glSelectPerfMonitorCountersAMD;

typedef void ( * PFNGLBEGINPERFMONITORAMDPROC)(GLuint monitor);
extern PFNGLBEGINPERFMONITORAMDPROC glad_glBeginPerfMonitorAMD;

typedef void ( * PFNGLENDPERFMONITORAMDPROC)(GLuint monitor);
extern PFNGLENDPERFMONITORAMDPROC glad_glEndPerfMonitorAMD;

typedef void ( * PFNGLGETPERFMONITORCOUNTERDATAAMDPROC)(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten);
extern PFNGLGETPERFMONITORCOUNTERDATAAMDPROC glad_glGetPerfMonitorCounterDataAMD;




extern int GLAD_GL_AMD_pinned_memory;



extern int GLAD_GL_AMD_query_buffer_object;



extern int GLAD_GL_AMD_sample_positions;
typedef void ( * PFNGLSETMULTISAMPLEFVAMDPROC)(GLenum pname, GLuint index, const GLfloat *val);
extern PFNGLSETMULTISAMPLEFVAMDPROC glad_glSetMultisamplefvAMD;




extern int GLAD_GL_AMD_seamless_cubemap_per_texture;



extern int GLAD_GL_AMD_shader_atomic_counter_ops;



extern int GLAD_GL_AMD_shader_ballot;



extern int GLAD_GL_AMD_shader_explicit_vertex_parameter;



extern int GLAD_GL_AMD_shader_gpu_shader_half_float_fetch;



extern int GLAD_GL_AMD_shader_image_load_store_lod;



extern int GLAD_GL_AMD_shader_stencil_export;



extern int GLAD_GL_AMD_shader_trinary_minmax;



extern int GLAD_GL_AMD_sparse_texture;
typedef void ( * PFNGLTEXSTORAGESPARSEAMDPROC)(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
extern PFNGLTEXSTORAGESPARSEAMDPROC glad_glTexStorageSparseAMD;

typedef void ( * PFNGLTEXTURESTORAGESPARSEAMDPROC)(GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
extern PFNGLTEXTURESTORAGESPARSEAMDPROC glad_glTextureStorageSparseAMD;




extern int GLAD_GL_AMD_stencil_operation_extended;
typedef void ( * PFNGLSTENCILOPVALUEAMDPROC)(GLenum face, GLuint value);
extern PFNGLSTENCILOPVALUEAMDPROC glad_glStencilOpValueAMD;




extern int GLAD_GL_AMD_texture_gather_bias_lod;



extern int GLAD_GL_AMD_texture_texture4;



extern int GLAD_GL_AMD_transform_feedback3_lines_triangles;



extern int GLAD_GL_AMD_transform_feedback4;



extern int GLAD_GL_AMD_vertex_shader_layer;



extern int GLAD_GL_AMD_vertex_shader_tessellator;
typedef void ( * PFNGLTESSELLATIONFACTORAMDPROC)(GLfloat factor);
extern PFNGLTESSELLATIONFACTORAMDPROC glad_glTessellationFactorAMD;

typedef void ( * PFNGLTESSELLATIONMODEAMDPROC)(GLenum mode);
extern PFNGLTESSELLATIONMODEAMDPROC glad_glTessellationModeAMD;




extern int GLAD_GL_AMD_vertex_shader_viewport_index;



extern int GLAD_GL_APPLE_aux_depth_stencil;



extern int GLAD_GL_APPLE_client_storage;



extern int GLAD_GL_APPLE_element_array;
typedef void ( * PFNGLELEMENTPOINTERAPPLEPROC)(GLenum type, const void *pointer);
extern PFNGLELEMENTPOINTERAPPLEPROC glad_glElementPointerAPPLE;

typedef void ( * PFNGLDRAWELEMENTARRAYAPPLEPROC)(GLenum mode, GLint first, GLsizei count);
extern PFNGLDRAWELEMENTARRAYAPPLEPROC glad_glDrawElementArrayAPPLE;

typedef void ( * PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC)(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
extern PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC glad_glDrawRangeElementArrayAPPLE;

typedef void ( * PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC)(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
extern PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC glad_glMultiDrawElementArrayAPPLE;

typedef void ( * PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC)(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount);
extern PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC glad_glMultiDrawRangeElementArrayAPPLE;




extern int GLAD_GL_APPLE_fence;
typedef void ( * PFNGLGENFENCESAPPLEPROC)(GLsizei n, GLuint *fences);
extern PFNGLGENFENCESAPPLEPROC glad_glGenFencesAPPLE;

typedef void ( * PFNGLDELETEFENCESAPPLEPROC)(GLsizei n, const GLuint *fences);
extern PFNGLDELETEFENCESAPPLEPROC glad_glDeleteFencesAPPLE;

typedef void ( * PFNGLSETFENCEAPPLEPROC)(GLuint fence);
extern PFNGLSETFENCEAPPLEPROC glad_glSetFenceAPPLE;

typedef GLboolean ( * PFNGLISFENCEAPPLEPROC)(GLuint fence);
extern PFNGLISFENCEAPPLEPROC glad_glIsFenceAPPLE;

typedef GLboolean ( * PFNGLTESTFENCEAPPLEPROC)(GLuint fence);
extern PFNGLTESTFENCEAPPLEPROC glad_glTestFenceAPPLE;

typedef void ( * PFNGLFINISHFENCEAPPLEPROC)(GLuint fence);
extern PFNGLFINISHFENCEAPPLEPROC glad_glFinishFenceAPPLE;

typedef GLboolean ( * PFNGLTESTOBJECTAPPLEPROC)(GLenum object, GLuint name);
extern PFNGLTESTOBJECTAPPLEPROC glad_glTestObjectAPPLE;

typedef void ( * PFNGLFINISHOBJECTAPPLEPROC)(GLenum object, GLint name);
extern PFNGLFINISHOBJECTAPPLEPROC glad_glFinishObjectAPPLE;




extern int GLAD_GL_APPLE_float_pixels;



extern int GLAD_GL_APPLE_flush_buffer_range;
typedef void ( * PFNGLBUFFERPARAMETERIAPPLEPROC)(GLenum target, GLenum pname, GLint param);
extern PFNGLBUFFERPARAMETERIAPPLEPROC glad_glBufferParameteriAPPLE;

typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC)(GLenum target, GLintptr offset, GLsizeiptr size);
extern PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC glad_glFlushMappedBufferRangeAPPLE;




extern int GLAD_GL_APPLE_object_purgeable;
typedef GLenum ( * PFNGLOBJECTPURGEABLEAPPLEPROC)(GLenum objectType, GLuint name, GLenum option);
extern PFNGLOBJECTPURGEABLEAPPLEPROC glad_glObjectPurgeableAPPLE;

typedef GLenum ( * PFNGLOBJECTUNPURGEABLEAPPLEPROC)(GLenum objectType, GLuint name, GLenum option);
extern PFNGLOBJECTUNPURGEABLEAPPLEPROC glad_glObjectUnpurgeableAPPLE;

typedef void ( * PFNGLGETOBJECTPARAMETERIVAPPLEPROC)(GLenum objectType, GLuint name, GLenum pname, GLint *params);
extern PFNGLGETOBJECTPARAMETERIVAPPLEPROC glad_glGetObjectParameterivAPPLE;




extern int GLAD_GL_APPLE_rgb_422;



extern int GLAD_GL_APPLE_row_bytes;



extern int GLAD_GL_APPLE_specular_vector;



extern int GLAD_GL_APPLE_texture_range;
typedef void ( * PFNGLTEXTURERANGEAPPLEPROC)(GLenum target, GLsizei length, const void *pointer);
extern PFNGLTEXTURERANGEAPPLEPROC glad_glTextureRangeAPPLE;

typedef void ( * PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC)(GLenum target, GLenum pname, void **params);
extern PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC glad_glGetTexParameterPointervAPPLE;




extern int GLAD_GL_APPLE_transform_hint;



extern int GLAD_GL_APPLE_vertex_array_object;
typedef void ( * PFNGLBINDVERTEXARRAYAPPLEPROC)(GLuint array);
extern PFNGLBINDVERTEXARRAYAPPLEPROC glad_glBindVertexArrayAPPLE;

typedef void ( * PFNGLDELETEVERTEXARRAYSAPPLEPROC)(GLsizei n, const GLuint *arrays);
extern PFNGLDELETEVERTEXARRAYSAPPLEPROC glad_glDeleteVertexArraysAPPLE;

typedef void ( * PFNGLGENVERTEXARRAYSAPPLEPROC)(GLsizei n, GLuint *arrays);
extern PFNGLGENVERTEXARRAYSAPPLEPROC glad_glGenVertexArraysAPPLE;

typedef GLboolean ( * PFNGLISVERTEXARRAYAPPLEPROC)(GLuint array);
extern PFNGLISVERTEXARRAYAPPLEPROC glad_glIsVertexArrayAPPLE;




extern int GLAD_GL_APPLE_vertex_array_range;
typedef void ( * PFNGLVERTEXARRAYRANGEAPPLEPROC)(GLsizei length, void *pointer);
extern PFNGLVERTEXARRAYRANGEAPPLEPROC glad_glVertexArrayRangeAPPLE;

typedef void ( * PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC)(GLsizei length, void *pointer);
extern PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC glad_glFlushVertexArrayRangeAPPLE;

typedef void ( * PFNGLVERTEXARRAYPARAMETERIAPPLEPROC)(GLenum pname, GLint param);
extern PFNGLVERTEXARRAYPARAMETERIAPPLEPROC glad_glVertexArrayParameteriAPPLE;




extern int GLAD_GL_APPLE_vertex_program_evaluators;
typedef void ( * PFNGLENABLEVERTEXATTRIBAPPLEPROC)(GLuint index, GLenum pname);
extern PFNGLENABLEVERTEXATTRIBAPPLEPROC glad_glEnableVertexAttribAPPLE;

typedef void ( * PFNGLDISABLEVERTEXATTRIBAPPLEPROC)(GLuint index, GLenum pname);
extern PFNGLDISABLEVERTEXATTRIBAPPLEPROC glad_glDisableVertexAttribAPPLE;

typedef GLboolean ( * PFNGLISVERTEXATTRIBENABLEDAPPLEPROC)(GLuint index, GLenum pname);
extern PFNGLISVERTEXATTRIBENABLEDAPPLEPROC glad_glIsVertexAttribEnabledAPPLE;

typedef void ( * PFNGLMAPVERTEXATTRIB1DAPPLEPROC)(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern PFNGLMAPVERTEXATTRIB1DAPPLEPROC glad_glMapVertexAttrib1dAPPLE;

typedef void ( * PFNGLMAPVERTEXATTRIB1FAPPLEPROC)(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern PFNGLMAPVERTEXATTRIB1FAPPLEPROC glad_glMapVertexAttrib1fAPPLE;

typedef void ( * PFNGLMAPVERTEXATTRIB2DAPPLEPROC)(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern PFNGLMAPVERTEXATTRIB2DAPPLEPROC glad_glMapVertexAttrib2dAPPLE;

typedef void ( * PFNGLMAPVERTEXATTRIB2FAPPLEPROC)(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
extern PFNGLMAPVERTEXATTRIB2FAPPLEPROC glad_glMapVertexAttrib2fAPPLE;




extern int GLAD_GL_APPLE_ycbcr_422;



extern int GLAD_GL_ARB_ES2_compatibility;



extern int GLAD_GL_ARB_ES3_1_compatibility;



extern int GLAD_GL_ARB_ES3_2_compatibility;
typedef void ( * PFNGLPRIMITIVEBOUNDINGBOXARBPROC)(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW);
extern PFNGLPRIMITIVEBOUNDINGBOXARBPROC glad_glPrimitiveBoundingBoxARB;




extern int GLAD_GL_ARB_ES3_compatibility;



extern int GLAD_GL_ARB_arrays_of_arrays;



extern int GLAD_GL_ARB_base_instance;



extern int GLAD_GL_ARB_bindless_texture;
typedef GLuint64 ( * PFNGLGETTEXTUREHANDLEARBPROC)(GLuint texture);
extern PFNGLGETTEXTUREHANDLEARBPROC glad_glGetTextureHandleARB;

typedef GLuint64 ( * PFNGLGETTEXTURESAMPLERHANDLEARBPROC)(GLuint texture, GLuint sampler);
extern PFNGLGETTEXTURESAMPLERHANDLEARBPROC glad_glGetTextureSamplerHandleARB;

typedef void ( * PFNGLMAKETEXTUREHANDLERESIDENTARBPROC)(GLuint64 handle);
extern PFNGLMAKETEXTUREHANDLERESIDENTARBPROC glad_glMakeTextureHandleResidentARB;

typedef void ( * PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC)(GLuint64 handle);
extern PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC glad_glMakeTextureHandleNonResidentARB;

typedef GLuint64 ( * PFNGLGETIMAGEHANDLEARBPROC)(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
extern PFNGLGETIMAGEHANDLEARBPROC glad_glGetImageHandleARB;

typedef void ( * PFNGLMAKEIMAGEHANDLERESIDENTARBPROC)(GLuint64 handle, GLenum access);
extern PFNGLMAKEIMAGEHANDLERESIDENTARBPROC glad_glMakeImageHandleResidentARB;

typedef void ( * PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC)(GLuint64 handle);
extern PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC glad_glMakeImageHandleNonResidentARB;

typedef void ( * PFNGLUNIFORMHANDLEUI64ARBPROC)(GLint location, GLuint64 value);
extern PFNGLUNIFORMHANDLEUI64ARBPROC glad_glUniformHandleui64ARB;

typedef void ( * PFNGLUNIFORMHANDLEUI64VARBPROC)(GLint location, GLsizei count, const GLuint64 *value);
extern PFNGLUNIFORMHANDLEUI64VARBPROC glad_glUniformHandleui64vARB;

typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC)(GLuint program, GLint location, GLuint64 value);
extern PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC glad_glProgramUniformHandleui64ARB;

typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 *values);
extern PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC glad_glProgramUniformHandleui64vARB;

typedef GLboolean ( * PFNGLISTEXTUREHANDLERESIDENTARBPROC)(GLuint64 handle);
extern PFNGLISTEXTUREHANDLERESIDENTARBPROC glad_glIsTextureHandleResidentARB;

typedef GLboolean ( * PFNGLISIMAGEHANDLERESIDENTARBPROC)(GLuint64 handle);
extern PFNGLISIMAGEHANDLERESIDENTARBPROC glad_glIsImageHandleResidentARB;

typedef void ( * PFNGLVERTEXATTRIBL1UI64ARBPROC)(GLuint index, GLuint64EXT x);
extern PFNGLVERTEXATTRIBL1UI64ARBPROC glad_glVertexAttribL1ui64ARB;

typedef void ( * PFNGLVERTEXATTRIBL1UI64VARBPROC)(GLuint index, const GLuint64EXT *v);
extern PFNGLVERTEXATTRIBL1UI64VARBPROC glad_glVertexAttribL1ui64vARB;

typedef void ( * PFNGLGETVERTEXATTRIBLUI64VARBPROC)(GLuint index, GLenum pname, GLuint64EXT *params);
extern PFNGLGETVERTEXATTRIBLUI64VARBPROC glad_glGetVertexAttribLui64vARB;




extern int GLAD_GL_ARB_blend_func_extended;



extern int GLAD_GL_ARB_buffer_storage;



extern int GLAD_GL_ARB_cl_event;
typedef GLsync ( * PFNGLCREATESYNCFROMCLEVENTARBPROC)(struct _cl_context *context, struct _cl_event *event, GLbitfield flags);
extern PFNGLCREATESYNCFROMCLEVENTARBPROC glad_glCreateSyncFromCLeventARB;




extern int GLAD_GL_ARB_clear_buffer_object;



extern int GLAD_GL_ARB_clear_texture;



extern int GLAD_GL_ARB_clip_control;



extern int GLAD_GL_ARB_color_buffer_float;
typedef void ( * PFNGLCLAMPCOLORARBPROC)(GLenum target, GLenum clamp);
extern PFNGLCLAMPCOLORARBPROC glad_glClampColorARB;




extern int GLAD_GL_ARB_compatibility;



extern int GLAD_GL_ARB_compressed_texture_pixel_storage;



extern int GLAD_GL_ARB_compute_shader;



extern int GLAD_GL_ARB_compute_variable_group_size;
typedef void ( * PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC)(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z);
extern PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC glad_glDispatchComputeGroupSizeARB;




extern int GLAD_GL_ARB_conditional_render_inverted;



extern int GLAD_GL_ARB_conservative_depth;



extern int GLAD_GL_ARB_copy_buffer;



extern int GLAD_GL_ARB_copy_image;



extern int GLAD_GL_ARB_cull_distance;



extern int GLAD_GL_ARB_debug_output;
typedef void ( * PFNGLDEBUGMESSAGECONTROLARBPROC)(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
extern PFNGLDEBUGMESSAGECONTROLARBPROC glad_glDebugMessageControlARB;

typedef void ( * PFNGLDEBUGMESSAGEINSERTARBPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
extern PFNGLDEBUGMESSAGEINSERTARBPROC glad_glDebugMessageInsertARB;

typedef void ( * PFNGLDEBUGMESSAGECALLBACKARBPROC)(GLDEBUGPROCARB callback, const void *userParam);
extern PFNGLDEBUGMESSAGECALLBACKARBPROC glad_glDebugMessageCallbackARB;

typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGARBPROC)(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
extern PFNGLGETDEBUGMESSAGELOGARBPROC glad_glGetDebugMessageLogARB;




extern int GLAD_GL_ARB_depth_buffer_float;



extern int GLAD_GL_ARB_depth_clamp;



extern int GLAD_GL_ARB_depth_texture;



extern int GLAD_GL_ARB_derivative_control;



extern int GLAD_GL_ARB_direct_state_access;



extern int GLAD_GL_ARB_draw_buffers;
typedef void ( * PFNGLDRAWBUFFERSARBPROC)(GLsizei n, const GLenum *bufs);
extern PFNGLDRAWBUFFERSARBPROC glad_glDrawBuffersARB;




extern int GLAD_GL_ARB_draw_buffers_blend;
typedef void ( * PFNGLBLENDEQUATIONIARBPROC)(GLuint buf, GLenum mode);
extern PFNGLBLENDEQUATIONIARBPROC glad_glBlendEquationiARB;

typedef void ( * PFNGLBLENDEQUATIONSEPARATEIARBPROC)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
extern PFNGLBLENDEQUATIONSEPARATEIARBPROC glad_glBlendEquationSeparateiARB;

typedef void ( * PFNGLBLENDFUNCIARBPROC)(GLuint buf, GLenum src, GLenum dst);
extern PFNGLBLENDFUNCIARBPROC glad_glBlendFunciARB;

typedef void ( * PFNGLBLENDFUNCSEPARATEIARBPROC)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
extern PFNGLBLENDFUNCSEPARATEIARBPROC glad_glBlendFuncSeparateiARB;




extern int GLAD_GL_ARB_draw_elements_base_vertex;



extern int GLAD_GL_ARB_draw_indirect;



extern int GLAD_GL_ARB_draw_instanced;
typedef void ( * PFNGLDRAWARRAYSINSTANCEDARBPROC)(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
extern PFNGLDRAWARRAYSINSTANCEDARBPROC glad_glDrawArraysInstancedARB;

typedef void ( * PFNGLDRAWELEMENTSINSTANCEDARBPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
extern PFNGLDRAWELEMENTSINSTANCEDARBPROC glad_glDrawElementsInstancedARB;




extern int GLAD_GL_ARB_enhanced_layouts;



extern int GLAD_GL_ARB_explicit_attrib_location;



extern int GLAD_GL_ARB_explicit_uniform_location;



extern int GLAD_GL_ARB_fragment_coord_conventions;



extern int GLAD_GL_ARB_fragment_layer_viewport;



extern int GLAD_GL_ARB_fragment_program;
typedef void ( * PFNGLPROGRAMSTRINGARBPROC)(GLenum target, GLenum format, GLsizei len, const void *string);
extern PFNGLPROGRAMSTRINGARBPROC glad_glProgramStringARB;

typedef void ( * PFNGLBINDPROGRAMARBPROC)(GLenum target, GLuint program);
extern PFNGLBINDPROGRAMARBPROC glad_glBindProgramARB;

typedef void ( * PFNGLDELETEPROGRAMSARBPROC)(GLsizei n, const GLuint *programs);
extern PFNGLDELETEPROGRAMSARBPROC glad_glDeleteProgramsARB;

typedef void ( * PFNGLGENPROGRAMSARBPROC)(GLsizei n, GLuint *programs);
extern PFNGLGENPROGRAMSARBPROC glad_glGenProgramsARB;

typedef void ( * PFNGLPROGRAMENVPARAMETER4DARBPROC)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLPROGRAMENVPARAMETER4DARBPROC glad_glProgramEnvParameter4dARB;

typedef void ( * PFNGLPROGRAMENVPARAMETER4DVARBPROC)(GLenum target, GLuint index, const GLdouble *params);
extern PFNGLPROGRAMENVPARAMETER4DVARBPROC glad_glProgramEnvParameter4dvARB;

typedef void ( * PFNGLPROGRAMENVPARAMETER4FARBPROC)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern PFNGLPROGRAMENVPARAMETER4FARBPROC glad_glProgramEnvParameter4fARB;

typedef void ( * PFNGLPROGRAMENVPARAMETER4FVARBPROC)(GLenum target, GLuint index, const GLfloat *params);
extern PFNGLPROGRAMENVPARAMETER4FVARBPROC glad_glProgramEnvParameter4fvARB;

typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DARBPROC)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLPROGRAMLOCALPARAMETER4DARBPROC glad_glProgramLocalParameter4dARB;

typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DVARBPROC)(GLenum target, GLuint index, const GLdouble *params);
extern PFNGLPROGRAMLOCALPARAMETER4DVARBPROC glad_glProgramLocalParameter4dvARB;

typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FARBPROC)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern PFNGLPROGRAMLOCALPARAMETER4FARBPROC glad_glProgramLocalParameter4fARB;

typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FVARBPROC)(GLenum target, GLuint index, const GLfloat *params);
extern PFNGLPROGRAMLOCALPARAMETER4FVARBPROC glad_glProgramLocalParameter4fvARB;

typedef void ( * PFNGLGETPROGRAMENVPARAMETERDVARBPROC)(GLenum target, GLuint index, GLdouble *params);
extern PFNGLGETPROGRAMENVPARAMETERDVARBPROC glad_glGetProgramEnvParameterdvARB;

typedef void ( * PFNGLGETPROGRAMENVPARAMETERFVARBPROC)(GLenum target, GLuint index, GLfloat *params);
extern PFNGLGETPROGRAMENVPARAMETERFVARBPROC glad_glGetProgramEnvParameterfvARB;

typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC)(GLenum target, GLuint index, GLdouble *params);
extern PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC glad_glGetProgramLocalParameterdvARB;

typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC)(GLenum target, GLuint index, GLfloat *params);
extern PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC glad_glGetProgramLocalParameterfvARB;

typedef void ( * PFNGLGETPROGRAMIVARBPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETPROGRAMIVARBPROC glad_glGetProgramivARB;

typedef void ( * PFNGLGETPROGRAMSTRINGARBPROC)(GLenum target, GLenum pname, void *string);
extern PFNGLGETPROGRAMSTRINGARBPROC glad_glGetProgramStringARB;

typedef GLboolean ( * PFNGLISPROGRAMARBPROC)(GLuint program);
extern PFNGLISPROGRAMARBPROC glad_glIsProgramARB;




extern int GLAD_GL_ARB_fragment_program_shadow;



extern int GLAD_GL_ARB_fragment_shader;



extern int GLAD_GL_ARB_fragment_shader_interlock;



extern int GLAD_GL_ARB_framebuffer_no_attachments;



extern int GLAD_GL_ARB_framebuffer_object;



extern int GLAD_GL_ARB_framebuffer_sRGB;



extern int GLAD_GL_ARB_geometry_shader4;
typedef void ( * PFNGLPROGRAMPARAMETERIARBPROC)(GLuint program, GLenum pname, GLint value);
extern PFNGLPROGRAMPARAMETERIARBPROC glad_glProgramParameteriARB;

typedef void ( * PFNGLFRAMEBUFFERTEXTUREARBPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
extern PFNGLFRAMEBUFFERTEXTUREARBPROC glad_glFramebufferTextureARB;

typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERARBPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
extern PFNGLFRAMEBUFFERTEXTURELAYERARBPROC glad_glFramebufferTextureLayerARB;

typedef void ( * PFNGLFRAMEBUFFERTEXTUREFACEARBPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
extern PFNGLFRAMEBUFFERTEXTUREFACEARBPROC glad_glFramebufferTextureFaceARB;




extern int GLAD_GL_ARB_get_program_binary;



extern int GLAD_GL_ARB_get_texture_sub_image;



extern int GLAD_GL_ARB_gl_spirv;
typedef void ( * PFNGLSPECIALIZESHADERARBPROC)(GLuint shader, const GLchar *pEntryPoint, GLuint numSpecializationConstants, const GLuint *pConstantIndex, const GLuint *pConstantValue);
extern PFNGLSPECIALIZESHADERARBPROC glad_glSpecializeShaderARB;




extern int GLAD_GL_ARB_gpu_shader5;



extern int GLAD_GL_ARB_gpu_shader_fp64;



extern int GLAD_GL_ARB_gpu_shader_int64;
typedef void ( * PFNGLUNIFORM1I64ARBPROC)(GLint location, GLint64 x);
extern PFNGLUNIFORM1I64ARBPROC glad_glUniform1i64ARB;

typedef void ( * PFNGLUNIFORM2I64ARBPROC)(GLint location, GLint64 x, GLint64 y);
extern PFNGLUNIFORM2I64ARBPROC glad_glUniform2i64ARB;

typedef void ( * PFNGLUNIFORM3I64ARBPROC)(GLint location, GLint64 x, GLint64 y, GLint64 z);
extern PFNGLUNIFORM3I64ARBPROC glad_glUniform3i64ARB;

typedef void ( * PFNGLUNIFORM4I64ARBPROC)(GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
extern PFNGLUNIFORM4I64ARBPROC glad_glUniform4i64ARB;

typedef void ( * PFNGLUNIFORM1I64VARBPROC)(GLint location, GLsizei count, const GLint64 *value);
extern PFNGLUNIFORM1I64VARBPROC glad_glUniform1i64vARB;

typedef void ( * PFNGLUNIFORM2I64VARBPROC)(GLint location, GLsizei count, const GLint64 *value);
extern PFNGLUNIFORM2I64VARBPROC glad_glUniform2i64vARB;

typedef void ( * PFNGLUNIFORM3I64VARBPROC)(GLint location, GLsizei count, const GLint64 *value);
extern PFNGLUNIFORM3I64VARBPROC glad_glUniform3i64vARB;

typedef void ( * PFNGLUNIFORM4I64VARBPROC)(GLint location, GLsizei count, const GLint64 *value);
extern PFNGLUNIFORM4I64VARBPROC glad_glUniform4i64vARB;

typedef void ( * PFNGLUNIFORM1UI64ARBPROC)(GLint location, GLuint64 x);
extern PFNGLUNIFORM1UI64ARBPROC glad_glUniform1ui64ARB;

typedef void ( * PFNGLUNIFORM2UI64ARBPROC)(GLint location, GLuint64 x, GLuint64 y);
extern PFNGLUNIFORM2UI64ARBPROC glad_glUniform2ui64ARB;

typedef void ( * PFNGLUNIFORM3UI64ARBPROC)(GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
extern PFNGLUNIFORM3UI64ARBPROC glad_glUniform3ui64ARB;

typedef void ( * PFNGLUNIFORM4UI64ARBPROC)(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
extern PFNGLUNIFORM4UI64ARBPROC glad_glUniform4ui64ARB;

typedef void ( * PFNGLUNIFORM1UI64VARBPROC)(GLint location, GLsizei count, const GLuint64 *value);
extern PFNGLUNIFORM1UI64VARBPROC glad_glUniform1ui64vARB;

typedef void ( * PFNGLUNIFORM2UI64VARBPROC)(GLint location, GLsizei count, const GLuint64 *value);
extern PFNGLUNIFORM2UI64VARBPROC glad_glUniform2ui64vARB;

typedef void ( * PFNGLUNIFORM3UI64VARBPROC)(GLint location, GLsizei count, const GLuint64 *value);
extern PFNGLUNIFORM3UI64VARBPROC glad_glUniform3ui64vARB;

typedef void ( * PFNGLUNIFORM4UI64VARBPROC)(GLint location, GLsizei count, const GLuint64 *value);
extern PFNGLUNIFORM4UI64VARBPROC glad_glUniform4ui64vARB;

typedef void ( * PFNGLGETUNIFORMI64VARBPROC)(GLuint program, GLint location, GLint64 *params);
extern PFNGLGETUNIFORMI64VARBPROC glad_glGetUniformi64vARB;

typedef void ( * PFNGLGETUNIFORMUI64VARBPROC)(GLuint program, GLint location, GLuint64 *params);
extern PFNGLGETUNIFORMUI64VARBPROC glad_glGetUniformui64vARB;

typedef void ( * PFNGLGETNUNIFORMI64VARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLint64 *params);
extern PFNGLGETNUNIFORMI64VARBPROC glad_glGetnUniformi64vARB;

typedef void ( * PFNGLGETNUNIFORMUI64VARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLuint64 *params);
extern PFNGLGETNUNIFORMUI64VARBPROC glad_glGetnUniformui64vARB;

typedef void ( * PFNGLPROGRAMUNIFORM1I64ARBPROC)(GLuint program, GLint location, GLint64 x);
extern PFNGLPROGRAMUNIFORM1I64ARBPROC glad_glProgramUniform1i64ARB;

typedef void ( * PFNGLPROGRAMUNIFORM2I64ARBPROC)(GLuint program, GLint location, GLint64 x, GLint64 y);
extern PFNGLPROGRAMUNIFORM2I64ARBPROC glad_glProgramUniform2i64ARB;

typedef void ( * PFNGLPROGRAMUNIFORM3I64ARBPROC)(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z);
extern PFNGLPROGRAMUNIFORM3I64ARBPROC glad_glProgramUniform3i64ARB;

typedef void ( * PFNGLPROGRAMUNIFORM4I64ARBPROC)(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
extern PFNGLPROGRAMUNIFORM4I64ARBPROC glad_glProgramUniform4i64ARB;

typedef void ( * PFNGLPROGRAMUNIFORM1I64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLint64 *value);
extern PFNGLPROGRAMUNIFORM1I64VARBPROC glad_glProgramUniform1i64vARB;

typedef void ( * PFNGLPROGRAMUNIFORM2I64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLint64 *value);
extern PFNGLPROGRAMUNIFORM2I64VARBPROC glad_glProgramUniform2i64vARB;

typedef void ( * PFNGLPROGRAMUNIFORM3I64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLint64 *value);
extern PFNGLPROGRAMUNIFORM3I64VARBPROC glad_glProgramUniform3i64vARB;

typedef void ( * PFNGLPROGRAMUNIFORM4I64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLint64 *value);
extern PFNGLPROGRAMUNIFORM4I64VARBPROC glad_glProgramUniform4i64vARB;

typedef void ( * PFNGLPROGRAMUNIFORM1UI64ARBPROC)(GLuint program, GLint location, GLuint64 x);
extern PFNGLPROGRAMUNIFORM1UI64ARBPROC glad_glProgramUniform1ui64ARB;

typedef void ( * PFNGLPROGRAMUNIFORM2UI64ARBPROC)(GLuint program, GLint location, GLuint64 x, GLuint64 y);
extern PFNGLPROGRAMUNIFORM2UI64ARBPROC glad_glProgramUniform2ui64ARB;

typedef void ( * PFNGLPROGRAMUNIFORM3UI64ARBPROC)(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
extern PFNGLPROGRAMUNIFORM3UI64ARBPROC glad_glProgramUniform3ui64ARB;

typedef void ( * PFNGLPROGRAMUNIFORM4UI64ARBPROC)(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
extern PFNGLPROGRAMUNIFORM4UI64ARBPROC glad_glProgramUniform4ui64ARB;

typedef void ( * PFNGLPROGRAMUNIFORM1UI64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 *value);
extern PFNGLPROGRAMUNIFORM1UI64VARBPROC glad_glProgramUniform1ui64vARB;

typedef void ( * PFNGLPROGRAMUNIFORM2UI64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 *value);
extern PFNGLPROGRAMUNIFORM2UI64VARBPROC glad_glProgramUniform2ui64vARB;

typedef void ( * PFNGLPROGRAMUNIFORM3UI64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 *value);
extern PFNGLPROGRAMUNIFORM3UI64VARBPROC glad_glProgramUniform3ui64vARB;

typedef void ( * PFNGLPROGRAMUNIFORM4UI64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 *value);
extern PFNGLPROGRAMUNIFORM4UI64VARBPROC glad_glProgramUniform4ui64vARB;




extern int GLAD_GL_ARB_half_float_pixel;



extern int GLAD_GL_ARB_half_float_vertex;



extern int GLAD_GL_ARB_imaging;
typedef void ( * PFNGLCOLORTABLEPROC)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
extern PFNGLCOLORTABLEPROC glad_glColorTable;

typedef void ( * PFNGLCOLORTABLEPARAMETERFVPROC)(GLenum target, GLenum pname, const GLfloat *params);
extern PFNGLCOLORTABLEPARAMETERFVPROC glad_glColorTableParameterfv;

typedef void ( * PFNGLCOLORTABLEPARAMETERIVPROC)(GLenum target, GLenum pname, const GLint *params);
extern PFNGLCOLORTABLEPARAMETERIVPROC glad_glColorTableParameteriv;

typedef void ( * PFNGLCOPYCOLORTABLEPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern PFNGLCOPYCOLORTABLEPROC glad_glCopyColorTable;

typedef void ( * PFNGLGETCOLORTABLEPROC)(GLenum target, GLenum format, GLenum type, void *table);
extern PFNGLGETCOLORTABLEPROC glad_glGetColorTable;

typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETCOLORTABLEPARAMETERFVPROC glad_glGetColorTableParameterfv;

typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETCOLORTABLEPARAMETERIVPROC glad_glGetColorTableParameteriv;

typedef void ( * PFNGLCOLORSUBTABLEPROC)(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
extern PFNGLCOLORSUBTABLEPROC glad_glColorSubTable;

typedef void ( * PFNGLCOPYCOLORSUBTABLEPROC)(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
extern PFNGLCOPYCOLORSUBTABLEPROC glad_glCopyColorSubTable;

typedef void ( * PFNGLCONVOLUTIONFILTER1DPROC)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
extern PFNGLCONVOLUTIONFILTER1DPROC glad_glConvolutionFilter1D;

typedef void ( * PFNGLCONVOLUTIONFILTER2DPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
extern PFNGLCONVOLUTIONFILTER2DPROC glad_glConvolutionFilter2D;

typedef void ( * PFNGLCONVOLUTIONPARAMETERFPROC)(GLenum target, GLenum pname, GLfloat params);
extern PFNGLCONVOLUTIONPARAMETERFPROC glad_glConvolutionParameterf;

typedef void ( * PFNGLCONVOLUTIONPARAMETERFVPROC)(GLenum target, GLenum pname, const GLfloat *params);
extern PFNGLCONVOLUTIONPARAMETERFVPROC glad_glConvolutionParameterfv;

typedef void ( * PFNGLCONVOLUTIONPARAMETERIPROC)(GLenum target, GLenum pname, GLint params);
extern PFNGLCONVOLUTIONPARAMETERIPROC glad_glConvolutionParameteri;

typedef void ( * PFNGLCONVOLUTIONPARAMETERIVPROC)(GLenum target, GLenum pname, const GLint *params);
extern PFNGLCONVOLUTIONPARAMETERIVPROC glad_glConvolutionParameteriv;

typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern PFNGLCOPYCONVOLUTIONFILTER1DPROC glad_glCopyConvolutionFilter1D;

typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYCONVOLUTIONFILTER2DPROC glad_glCopyConvolutionFilter2D;

typedef void ( * PFNGLGETCONVOLUTIONFILTERPROC)(GLenum target, GLenum format, GLenum type, void *image);
extern PFNGLGETCONVOLUTIONFILTERPROC glad_glGetConvolutionFilter;

typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETCONVOLUTIONPARAMETERFVPROC glad_glGetConvolutionParameterfv;

typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETCONVOLUTIONPARAMETERIVPROC glad_glGetConvolutionParameteriv;

typedef void ( * PFNGLGETSEPARABLEFILTERPROC)(GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
extern PFNGLGETSEPARABLEFILTERPROC glad_glGetSeparableFilter;

typedef void ( * PFNGLSEPARABLEFILTER2DPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);
extern PFNGLSEPARABLEFILTER2DPROC glad_glSeparableFilter2D;

typedef void ( * PFNGLGETHISTOGRAMPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
extern PFNGLGETHISTOGRAMPROC glad_glGetHistogram;

typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETHISTOGRAMPARAMETERFVPROC glad_glGetHistogramParameterfv;

typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETHISTOGRAMPARAMETERIVPROC glad_glGetHistogramParameteriv;

typedef void ( * PFNGLGETMINMAXPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
extern PFNGLGETMINMAXPROC glad_glGetMinmax;

typedef void ( * PFNGLGETMINMAXPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETMINMAXPARAMETERFVPROC glad_glGetMinmaxParameterfv;

typedef void ( * PFNGLGETMINMAXPARAMETERIVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETMINMAXPARAMETERIVPROC glad_glGetMinmaxParameteriv;

typedef void ( * PFNGLHISTOGRAMPROC)(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
extern PFNGLHISTOGRAMPROC glad_glHistogram;

typedef void ( * PFNGLMINMAXPROC)(GLenum target, GLenum internalformat, GLboolean sink);
extern PFNGLMINMAXPROC glad_glMinmax;

typedef void ( * PFNGLRESETHISTOGRAMPROC)(GLenum target);
extern PFNGLRESETHISTOGRAMPROC glad_glResetHistogram;

typedef void ( * PFNGLRESETMINMAXPROC)(GLenum target);
extern PFNGLRESETMINMAXPROC glad_glResetMinmax;




extern int GLAD_GL_ARB_indirect_parameters;
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC)(GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
extern PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC glad_glMultiDrawArraysIndirectCountARB;

typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC)(GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
extern PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC glad_glMultiDrawElementsIndirectCountARB;




extern int GLAD_GL_ARB_instanced_arrays;
typedef void ( * PFNGLVERTEXATTRIBDIVISORARBPROC)(GLuint index, GLuint divisor);
extern PFNGLVERTEXATTRIBDIVISORARBPROC glad_glVertexAttribDivisorARB;




extern int GLAD_GL_ARB_internalformat_query;



extern int GLAD_GL_ARB_internalformat_query2;



extern int GLAD_GL_ARB_invalidate_subdata;



extern int GLAD_GL_ARB_map_buffer_alignment;



extern int GLAD_GL_ARB_map_buffer_range;



extern int GLAD_GL_ARB_matrix_palette;
typedef void ( * PFNGLCURRENTPALETTEMATRIXARBPROC)(GLint index);
extern PFNGLCURRENTPALETTEMATRIXARBPROC glad_glCurrentPaletteMatrixARB;

typedef void ( * PFNGLMATRIXINDEXUBVARBPROC)(GLint size, const GLubyte *indices);
extern PFNGLMATRIXINDEXUBVARBPROC glad_glMatrixIndexubvARB;

typedef void ( * PFNGLMATRIXINDEXUSVARBPROC)(GLint size, const GLushort *indices);
extern PFNGLMATRIXINDEXUSVARBPROC glad_glMatrixIndexusvARB;

typedef void ( * PFNGLMATRIXINDEXUIVARBPROC)(GLint size, const GLuint *indices);
extern PFNGLMATRIXINDEXUIVARBPROC glad_glMatrixIndexuivARB;

typedef void ( * PFNGLMATRIXINDEXPOINTERARBPROC)(GLint size, GLenum type, GLsizei stride, const void *pointer);
extern PFNGLMATRIXINDEXPOINTERARBPROC glad_glMatrixIndexPointerARB;




extern int GLAD_GL_ARB_multi_bind;



extern int GLAD_GL_ARB_multi_draw_indirect;



extern int GLAD_GL_ARB_multisample;
typedef void ( * PFNGLSAMPLECOVERAGEARBPROC)(GLfloat value, GLboolean invert);
extern PFNGLSAMPLECOVERAGEARBPROC glad_glSampleCoverageARB;




extern int GLAD_GL_ARB_multitexture;
typedef void ( * PFNGLACTIVETEXTUREARBPROC)(GLenum texture);
extern PFNGLACTIVETEXTUREARBPROC glad_glActiveTextureARB;

typedef void ( * PFNGLCLIENTACTIVETEXTUREARBPROC)(GLenum texture);
extern PFNGLCLIENTACTIVETEXTUREARBPROC glad_glClientActiveTextureARB;

typedef void ( * PFNGLMULTITEXCOORD1DARBPROC)(GLenum target, GLdouble s);
extern PFNGLMULTITEXCOORD1DARBPROC glad_glMultiTexCoord1dARB;

typedef void ( * PFNGLMULTITEXCOORD1DVARBPROC)(GLenum target, const GLdouble *v);
extern PFNGLMULTITEXCOORD1DVARBPROC glad_glMultiTexCoord1dvARB;

typedef void ( * PFNGLMULTITEXCOORD1FARBPROC)(GLenum target, GLfloat s);
extern PFNGLMULTITEXCOORD1FARBPROC glad_glMultiTexCoord1fARB;

typedef void ( * PFNGLMULTITEXCOORD1FVARBPROC)(GLenum target, const GLfloat *v);
extern PFNGLMULTITEXCOORD1FVARBPROC glad_glMultiTexCoord1fvARB;

typedef void ( * PFNGLMULTITEXCOORD1IARBPROC)(GLenum target, GLint s);
extern PFNGLMULTITEXCOORD1IARBPROC glad_glMultiTexCoord1iARB;

typedef void ( * PFNGLMULTITEXCOORD1IVARBPROC)(GLenum target, const GLint *v);
extern PFNGLMULTITEXCOORD1IVARBPROC glad_glMultiTexCoord1ivARB;

typedef void ( * PFNGLMULTITEXCOORD1SARBPROC)(GLenum target, GLshort s);
extern PFNGLMULTITEXCOORD1SARBPROC glad_glMultiTexCoord1sARB;

typedef void ( * PFNGLMULTITEXCOORD1SVARBPROC)(GLenum target, const GLshort *v);
extern PFNGLMULTITEXCOORD1SVARBPROC glad_glMultiTexCoord1svARB;

typedef void ( * PFNGLMULTITEXCOORD2DARBPROC)(GLenum target, GLdouble s, GLdouble t);
extern PFNGLMULTITEXCOORD2DARBPROC glad_glMultiTexCoord2dARB;

typedef void ( * PFNGLMULTITEXCOORD2DVARBPROC)(GLenum target, const GLdouble *v);
extern PFNGLMULTITEXCOORD2DVARBPROC glad_glMultiTexCoord2dvARB;

typedef void ( * PFNGLMULTITEXCOORD2FARBPROC)(GLenum target, GLfloat s, GLfloat t);
extern PFNGLMULTITEXCOORD2FARBPROC glad_glMultiTexCoord2fARB;

typedef void ( * PFNGLMULTITEXCOORD2FVARBPROC)(GLenum target, const GLfloat *v);
extern PFNGLMULTITEXCOORD2FVARBPROC glad_glMultiTexCoord2fvARB;

typedef void ( * PFNGLMULTITEXCOORD2IARBPROC)(GLenum target, GLint s, GLint t);
extern PFNGLMULTITEXCOORD2IARBPROC glad_glMultiTexCoord2iARB;

typedef void ( * PFNGLMULTITEXCOORD2IVARBPROC)(GLenum target, const GLint *v);
extern PFNGLMULTITEXCOORD2IVARBPROC glad_glMultiTexCoord2ivARB;

typedef void ( * PFNGLMULTITEXCOORD2SARBPROC)(GLenum target, GLshort s, GLshort t);
extern PFNGLMULTITEXCOORD2SARBPROC glad_glMultiTexCoord2sARB;

typedef void ( * PFNGLMULTITEXCOORD2SVARBPROC)(GLenum target, const GLshort *v);
extern PFNGLMULTITEXCOORD2SVARBPROC glad_glMultiTexCoord2svARB;

typedef void ( * PFNGLMULTITEXCOORD3DARBPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r);
extern PFNGLMULTITEXCOORD3DARBPROC glad_glMultiTexCoord3dARB;

typedef void ( * PFNGLMULTITEXCOORD3DVARBPROC)(GLenum target, const GLdouble *v);
extern PFNGLMULTITEXCOORD3DVARBPROC glad_glMultiTexCoord3dvARB;

typedef void ( * PFNGLMULTITEXCOORD3FARBPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r);
extern PFNGLMULTITEXCOORD3FARBPROC glad_glMultiTexCoord3fARB;

typedef void ( * PFNGLMULTITEXCOORD3FVARBPROC)(GLenum target, const GLfloat *v);
extern PFNGLMULTITEXCOORD3FVARBPROC glad_glMultiTexCoord3fvARB;

typedef void ( * PFNGLMULTITEXCOORD3IARBPROC)(GLenum target, GLint s, GLint t, GLint r);
extern PFNGLMULTITEXCOORD3IARBPROC glad_glMultiTexCoord3iARB;

typedef void ( * PFNGLMULTITEXCOORD3IVARBPROC)(GLenum target, const GLint *v);
extern PFNGLMULTITEXCOORD3IVARBPROC glad_glMultiTexCoord3ivARB;

typedef void ( * PFNGLMULTITEXCOORD3SARBPROC)(GLenum target, GLshort s, GLshort t, GLshort r);
extern PFNGLMULTITEXCOORD3SARBPROC glad_glMultiTexCoord3sARB;

typedef void ( * PFNGLMULTITEXCOORD3SVARBPROC)(GLenum target, const GLshort *v);
extern PFNGLMULTITEXCOORD3SVARBPROC glad_glMultiTexCoord3svARB;

typedef void ( * PFNGLMULTITEXCOORD4DARBPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern PFNGLMULTITEXCOORD4DARBPROC glad_glMultiTexCoord4dARB;

typedef void ( * PFNGLMULTITEXCOORD4DVARBPROC)(GLenum target, const GLdouble *v);
extern PFNGLMULTITEXCOORD4DVARBPROC glad_glMultiTexCoord4dvARB;

typedef void ( * PFNGLMULTITEXCOORD4FARBPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern PFNGLMULTITEXCOORD4FARBPROC glad_glMultiTexCoord4fARB;

typedef void ( * PFNGLMULTITEXCOORD4FVARBPROC)(GLenum target, const GLfloat *v);
extern PFNGLMULTITEXCOORD4FVARBPROC glad_glMultiTexCoord4fvARB;

typedef void ( * PFNGLMULTITEXCOORD4IARBPROC)(GLenum target, GLint s, GLint t, GLint r, GLint q);
extern PFNGLMULTITEXCOORD4IARBPROC glad_glMultiTexCoord4iARB;

typedef void ( * PFNGLMULTITEXCOORD4IVARBPROC)(GLenum target, const GLint *v);
extern PFNGLMULTITEXCOORD4IVARBPROC glad_glMultiTexCoord4ivARB;

typedef void ( * PFNGLMULTITEXCOORD4SARBPROC)(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
extern PFNGLMULTITEXCOORD4SARBPROC glad_glMultiTexCoord4sARB;

typedef void ( * PFNGLMULTITEXCOORD4SVARBPROC)(GLenum target, const GLshort *v);
extern PFNGLMULTITEXCOORD4SVARBPROC glad_glMultiTexCoord4svARB;




extern int GLAD_GL_ARB_occlusion_query;
typedef void ( * PFNGLGENQUERIESARBPROC)(GLsizei n, GLuint *ids);
extern PFNGLGENQUERIESARBPROC glad_glGenQueriesARB;

typedef void ( * PFNGLDELETEQUERIESARBPROC)(GLsizei n, const GLuint *ids);
extern PFNGLDELETEQUERIESARBPROC glad_glDeleteQueriesARB;

typedef GLboolean ( * PFNGLISQUERYARBPROC)(GLuint id);
extern PFNGLISQUERYARBPROC glad_glIsQueryARB;

typedef void ( * PFNGLBEGINQUERYARBPROC)(GLenum target, GLuint id);
extern PFNGLBEGINQUERYARBPROC glad_glBeginQueryARB;

typedef void ( * PFNGLENDQUERYARBPROC)(GLenum target);
extern PFNGLENDQUERYARBPROC glad_glEndQueryARB;

typedef void ( * PFNGLGETQUERYIVARBPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETQUERYIVARBPROC glad_glGetQueryivARB;

typedef void ( * PFNGLGETQUERYOBJECTIVARBPROC)(GLuint id, GLenum pname, GLint *params);
extern PFNGLGETQUERYOBJECTIVARBPROC glad_glGetQueryObjectivARB;

typedef void ( * PFNGLGETQUERYOBJECTUIVARBPROC)(GLuint id, GLenum pname, GLuint *params);
extern PFNGLGETQUERYOBJECTUIVARBPROC glad_glGetQueryObjectuivARB;




extern int GLAD_GL_ARB_occlusion_query2;



extern int GLAD_GL_ARB_parallel_shader_compile;
typedef void ( * PFNGLMAXSHADERCOMPILERTHREADSARBPROC)(GLuint count);
extern PFNGLMAXSHADERCOMPILERTHREADSARBPROC glad_glMaxShaderCompilerThreadsARB;




extern int GLAD_GL_ARB_pipeline_statistics_query;



extern int GLAD_GL_ARB_pixel_buffer_object;



extern int GLAD_GL_ARB_point_parameters;
typedef void ( * PFNGLPOINTPARAMETERFARBPROC)(GLenum pname, GLfloat param);
extern PFNGLPOINTPARAMETERFARBPROC glad_glPointParameterfARB;

typedef void ( * PFNGLPOINTPARAMETERFVARBPROC)(GLenum pname, const GLfloat *params);
extern PFNGLPOINTPARAMETERFVARBPROC glad_glPointParameterfvARB;




extern int GLAD_GL_ARB_point_sprite;



extern int GLAD_GL_ARB_polygon_offset_clamp;



extern int GLAD_GL_ARB_post_depth_coverage;



extern int GLAD_GL_ARB_program_interface_query;



extern int GLAD_GL_ARB_provoking_vertex;



extern int GLAD_GL_ARB_query_buffer_object;



extern int GLAD_GL_ARB_robust_buffer_access_behavior;



extern int GLAD_GL_ARB_robustness;
typedef GLenum ( * PFNGLGETGRAPHICSRESETSTATUSARBPROC)(void);
extern PFNGLGETGRAPHICSRESETSTATUSARBPROC glad_glGetGraphicsResetStatusARB;

typedef void ( * PFNGLGETNTEXIMAGEARBPROC)(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *img);
extern PFNGLGETNTEXIMAGEARBPROC glad_glGetnTexImageARB;

typedef void ( * PFNGLREADNPIXELSARBPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);
extern PFNGLREADNPIXELSARBPROC glad_glReadnPixelsARB;

typedef void ( * PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC)(GLenum target, GLint lod, GLsizei bufSize, void *img);
extern PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC glad_glGetnCompressedTexImageARB;

typedef void ( * PFNGLGETNUNIFORMFVARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLfloat *params);
extern PFNGLGETNUNIFORMFVARBPROC glad_glGetnUniformfvARB;

typedef void ( * PFNGLGETNUNIFORMIVARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLint *params);
extern PFNGLGETNUNIFORMIVARBPROC glad_glGetnUniformivARB;

typedef void ( * PFNGLGETNUNIFORMUIVARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLuint *params);
extern PFNGLGETNUNIFORMUIVARBPROC glad_glGetnUniformuivARB;

typedef void ( * PFNGLGETNUNIFORMDVARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLdouble *params);
extern PFNGLGETNUNIFORMDVARBPROC glad_glGetnUniformdvARB;

typedef void ( * PFNGLGETNMAPDVARBPROC)(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v);
extern PFNGLGETNMAPDVARBPROC glad_glGetnMapdvARB;

typedef void ( * PFNGLGETNMAPFVARBPROC)(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v);
extern PFNGLGETNMAPFVARBPROC glad_glGetnMapfvARB;

typedef void ( * PFNGLGETNMAPIVARBPROC)(GLenum target, GLenum query, GLsizei bufSize, GLint *v);
extern PFNGLGETNMAPIVARBPROC glad_glGetnMapivARB;

typedef void ( * PFNGLGETNPIXELMAPFVARBPROC)(GLenum map, GLsizei bufSize, GLfloat *values);
extern PFNGLGETNPIXELMAPFVARBPROC glad_glGetnPixelMapfvARB;

typedef void ( * PFNGLGETNPIXELMAPUIVARBPROC)(GLenum map, GLsizei bufSize, GLuint *values);
extern PFNGLGETNPIXELMAPUIVARBPROC glad_glGetnPixelMapuivARB;

typedef void ( * PFNGLGETNPIXELMAPUSVARBPROC)(GLenum map, GLsizei bufSize, GLushort *values);
extern PFNGLGETNPIXELMAPUSVARBPROC glad_glGetnPixelMapusvARB;

typedef void ( * PFNGLGETNPOLYGONSTIPPLEARBPROC)(GLsizei bufSize, GLubyte *pattern);
extern PFNGLGETNPOLYGONSTIPPLEARBPROC glad_glGetnPolygonStippleARB;

typedef void ( * PFNGLGETNCOLORTABLEARBPROC)(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table);
extern PFNGLGETNCOLORTABLEARBPROC glad_glGetnColorTableARB;

typedef void ( * PFNGLGETNCONVOLUTIONFILTERARBPROC)(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image);
extern PFNGLGETNCONVOLUTIONFILTERARBPROC glad_glGetnConvolutionFilterARB;

typedef void ( * PFNGLGETNSEPARABLEFILTERARBPROC)(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span);
extern PFNGLGETNSEPARABLEFILTERARBPROC glad_glGetnSeparableFilterARB;

typedef void ( * PFNGLGETNHISTOGRAMARBPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values);
extern PFNGLGETNHISTOGRAMARBPROC glad_glGetnHistogramARB;

typedef void ( * PFNGLGETNMINMAXARBPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values);
extern PFNGLGETNMINMAXARBPROC glad_glGetnMinmaxARB;




extern int GLAD_GL_ARB_robustness_isolation;



extern int GLAD_GL_ARB_sample_locations;
typedef void ( * PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC)(GLenum target, GLuint start, GLsizei count, const GLfloat *v);
extern PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC glad_glFramebufferSampleLocationsfvARB;

typedef void ( * PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC)(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v);
extern PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC glad_glNamedFramebufferSampleLocationsfvARB;

typedef void ( * PFNGLEVALUATEDEPTHVALUESARBPROC)(void);
extern PFNGLEVALUATEDEPTHVALUESARBPROC glad_glEvaluateDepthValuesARB;




extern int GLAD_GL_ARB_sample_shading;
typedef void ( * PFNGLMINSAMPLESHADINGARBPROC)(GLfloat value);
extern PFNGLMINSAMPLESHADINGARBPROC glad_glMinSampleShadingARB;




extern int GLAD_GL_ARB_sampler_objects;



extern int GLAD_GL_ARB_seamless_cube_map;



extern int GLAD_GL_ARB_seamless_cubemap_per_texture;



extern int GLAD_GL_ARB_separate_shader_objects;



extern int GLAD_GL_ARB_shader_atomic_counter_ops;



extern int GLAD_GL_ARB_shader_atomic_counters;



extern int GLAD_GL_ARB_shader_ballot;



extern int GLAD_GL_ARB_shader_bit_encoding;



extern int GLAD_GL_ARB_shader_clock;



extern int GLAD_GL_ARB_shader_draw_parameters;



extern int GLAD_GL_ARB_shader_group_vote;



extern int GLAD_GL_ARB_shader_image_load_store;



extern int GLAD_GL_ARB_shader_image_size;



extern int GLAD_GL_ARB_shader_objects;
typedef void ( * PFNGLDELETEOBJECTARBPROC)(GLhandleARB obj);
extern PFNGLDELETEOBJECTARBPROC glad_glDeleteObjectARB;

typedef GLhandleARB ( * PFNGLGETHANDLEARBPROC)(GLenum pname);
extern PFNGLGETHANDLEARBPROC glad_glGetHandleARB;

typedef void ( * PFNGLDETACHOBJECTARBPROC)(GLhandleARB containerObj, GLhandleARB attachedObj);
extern PFNGLDETACHOBJECTARBPROC glad_glDetachObjectARB;

typedef GLhandleARB ( * PFNGLCREATESHADEROBJECTARBPROC)(GLenum shaderType);
extern PFNGLCREATESHADEROBJECTARBPROC glad_glCreateShaderObjectARB;

typedef void ( * PFNGLSHADERSOURCEARBPROC)(GLhandleARB shaderObj, GLsizei count, const GLcharARB **string, const GLint *length);
extern PFNGLSHADERSOURCEARBPROC glad_glShaderSourceARB;

typedef void ( * PFNGLCOMPILESHADERARBPROC)(GLhandleARB shaderObj);
extern PFNGLCOMPILESHADERARBPROC glad_glCompileShaderARB;

typedef GLhandleARB ( * PFNGLCREATEPROGRAMOBJECTARBPROC)(void);
extern PFNGLCREATEPROGRAMOBJECTARBPROC glad_glCreateProgramObjectARB;

typedef void ( * PFNGLATTACHOBJECTARBPROC)(GLhandleARB containerObj, GLhandleARB obj);
extern PFNGLATTACHOBJECTARBPROC glad_glAttachObjectARB;

typedef void ( * PFNGLLINKPROGRAMARBPROC)(GLhandleARB programObj);
extern PFNGLLINKPROGRAMARBPROC glad_glLinkProgramARB;

typedef void ( * PFNGLUSEPROGRAMOBJECTARBPROC)(GLhandleARB programObj);
extern PFNGLUSEPROGRAMOBJECTARBPROC glad_glUseProgramObjectARB;

typedef void ( * PFNGLVALIDATEPROGRAMARBPROC)(GLhandleARB programObj);
extern PFNGLVALIDATEPROGRAMARBPROC glad_glValidateProgramARB;

typedef void ( * PFNGLUNIFORM1FARBPROC)(GLint location, GLfloat v0);
extern PFNGLUNIFORM1FARBPROC glad_glUniform1fARB;

typedef void ( * PFNGLUNIFORM2FARBPROC)(GLint location, GLfloat v0, GLfloat v1);
extern PFNGLUNIFORM2FARBPROC glad_glUniform2fARB;

typedef void ( * PFNGLUNIFORM3FARBPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern PFNGLUNIFORM3FARBPROC glad_glUniform3fARB;

typedef void ( * PFNGLUNIFORM4FARBPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern PFNGLUNIFORM4FARBPROC glad_glUniform4fARB;

typedef void ( * PFNGLUNIFORM1IARBPROC)(GLint location, GLint v0);
extern PFNGLUNIFORM1IARBPROC glad_glUniform1iARB;

typedef void ( * PFNGLUNIFORM2IARBPROC)(GLint location, GLint v0, GLint v1);
extern PFNGLUNIFORM2IARBPROC glad_glUniform2iARB;

typedef void ( * PFNGLUNIFORM3IARBPROC)(GLint location, GLint v0, GLint v1, GLint v2);
extern PFNGLUNIFORM3IARBPROC glad_glUniform3iARB;

typedef void ( * PFNGLUNIFORM4IARBPROC)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern PFNGLUNIFORM4IARBPROC glad_glUniform4iARB;

typedef void ( * PFNGLUNIFORM1FVARBPROC)(GLint location, GLsizei count, const GLfloat *value);
extern PFNGLUNIFORM1FVARBPROC glad_glUniform1fvARB;

typedef void ( * PFNGLUNIFORM2FVARBPROC)(GLint location, GLsizei count, const GLfloat *value);
extern PFNGLUNIFORM2FVARBPROC glad_glUniform2fvARB;

typedef void ( * PFNGLUNIFORM3FVARBPROC)(GLint location, GLsizei count, const GLfloat *value);
extern PFNGLUNIFORM3FVARBPROC glad_glUniform3fvARB;

typedef void ( * PFNGLUNIFORM4FVARBPROC)(GLint location, GLsizei count, const GLfloat *value);
extern PFNGLUNIFORM4FVARBPROC glad_glUniform4fvARB;

typedef void ( * PFNGLUNIFORM1IVARBPROC)(GLint location, GLsizei count, const GLint *value);
extern PFNGLUNIFORM1IVARBPROC glad_glUniform1ivARB;

typedef void ( * PFNGLUNIFORM2IVARBPROC)(GLint location, GLsizei count, const GLint *value);
extern PFNGLUNIFORM2IVARBPROC glad_glUniform2ivARB;

typedef void ( * PFNGLUNIFORM3IVARBPROC)(GLint location, GLsizei count, const GLint *value);
extern PFNGLUNIFORM3IVARBPROC glad_glUniform3ivARB;

typedef void ( * PFNGLUNIFORM4IVARBPROC)(GLint location, GLsizei count, const GLint *value);
extern PFNGLUNIFORM4IVARBPROC glad_glUniform4ivARB;

typedef void ( * PFNGLUNIFORMMATRIX2FVARBPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX2FVARBPROC glad_glUniformMatrix2fvARB;

typedef void ( * PFNGLUNIFORMMATRIX3FVARBPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX3FVARBPROC glad_glUniformMatrix3fvARB;

typedef void ( * PFNGLUNIFORMMATRIX4FVARBPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLUNIFORMMATRIX4FVARBPROC glad_glUniformMatrix4fvARB;

typedef void ( * PFNGLGETOBJECTPARAMETERFVARBPROC)(GLhandleARB obj, GLenum pname, GLfloat *params);
extern PFNGLGETOBJECTPARAMETERFVARBPROC glad_glGetObjectParameterfvARB;

typedef void ( * PFNGLGETOBJECTPARAMETERIVARBPROC)(GLhandleARB obj, GLenum pname, GLint *params);
extern PFNGLGETOBJECTPARAMETERIVARBPROC glad_glGetObjectParameterivARB;

typedef void ( * PFNGLGETINFOLOGARBPROC)(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
extern PFNGLGETINFOLOGARBPROC glad_glGetInfoLogARB;

typedef void ( * PFNGLGETATTACHEDOBJECTSARBPROC)(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj);
extern PFNGLGETATTACHEDOBJECTSARBPROC glad_glGetAttachedObjectsARB;

typedef GLint ( * PFNGLGETUNIFORMLOCATIONARBPROC)(GLhandleARB programObj, const GLcharARB *name);
extern PFNGLGETUNIFORMLOCATIONARBPROC glad_glGetUniformLocationARB;

typedef void ( * PFNGLGETACTIVEUNIFORMARBPROC)(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
extern PFNGLGETACTIVEUNIFORMARBPROC glad_glGetActiveUniformARB;

typedef void ( * PFNGLGETUNIFORMFVARBPROC)(GLhandleARB programObj, GLint location, GLfloat *params);
extern PFNGLGETUNIFORMFVARBPROC glad_glGetUniformfvARB;

typedef void ( * PFNGLGETUNIFORMIVARBPROC)(GLhandleARB programObj, GLint location, GLint *params);
extern PFNGLGETUNIFORMIVARBPROC glad_glGetUniformivARB;

typedef void ( * PFNGLGETSHADERSOURCEARBPROC)(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source);
extern PFNGLGETSHADERSOURCEARBPROC glad_glGetShaderSourceARB;




extern int GLAD_GL_ARB_shader_precision;



extern int GLAD_GL_ARB_shader_stencil_export;



extern int GLAD_GL_ARB_shader_storage_buffer_object;



extern int GLAD_GL_ARB_shader_subroutine;



extern int GLAD_GL_ARB_shader_texture_image_samples;



extern int GLAD_GL_ARB_shader_texture_lod;



extern int GLAD_GL_ARB_shader_viewport_layer_array;



extern int GLAD_GL_ARB_shading_language_100;



extern int GLAD_GL_ARB_shading_language_420pack;



extern int GLAD_GL_ARB_shading_language_include;
typedef void ( * PFNGLNAMEDSTRINGARBPROC)(GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string);
extern PFNGLNAMEDSTRINGARBPROC glad_glNamedStringARB;

typedef void ( * PFNGLDELETENAMEDSTRINGARBPROC)(GLint namelen, const GLchar *name);
extern PFNGLDELETENAMEDSTRINGARBPROC glad_glDeleteNamedStringARB;

typedef void ( * PFNGLCOMPILESHADERINCLUDEARBPROC)(GLuint shader, GLsizei count, const GLchar *const*path, const GLint *length);
extern PFNGLCOMPILESHADERINCLUDEARBPROC glad_glCompileShaderIncludeARB;

typedef GLboolean ( * PFNGLISNAMEDSTRINGARBPROC)(GLint namelen, const GLchar *name);
extern PFNGLISNAMEDSTRINGARBPROC glad_glIsNamedStringARB;

typedef void ( * PFNGLGETNAMEDSTRINGARBPROC)(GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string);
extern PFNGLGETNAMEDSTRINGARBPROC glad_glGetNamedStringARB;

typedef void ( * PFNGLGETNAMEDSTRINGIVARBPROC)(GLint namelen, const GLchar *name, GLenum pname, GLint *params);
extern PFNGLGETNAMEDSTRINGIVARBPROC glad_glGetNamedStringivARB;




extern int GLAD_GL_ARB_shading_language_packing;



extern int GLAD_GL_ARB_shadow;



extern int GLAD_GL_ARB_shadow_ambient;



extern int GLAD_GL_ARB_sparse_buffer;
typedef void ( * PFNGLBUFFERPAGECOMMITMENTARBPROC)(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit);
extern PFNGLBUFFERPAGECOMMITMENTARBPROC glad_glBufferPageCommitmentARB;

typedef void ( * PFNGLNAMEDBUFFERPAGECOMMITMENTEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit);
extern PFNGLNAMEDBUFFERPAGECOMMITMENTEXTPROC glad_glNamedBufferPageCommitmentEXT;

typedef void ( * PFNGLNAMEDBUFFERPAGECOMMITMENTARBPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit);
extern PFNGLNAMEDBUFFERPAGECOMMITMENTARBPROC glad_glNamedBufferPageCommitmentARB;




extern int GLAD_GL_ARB_sparse_texture;
typedef void ( * PFNGLTEXPAGECOMMITMENTARBPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
extern PFNGLTEXPAGECOMMITMENTARBPROC glad_glTexPageCommitmentARB;




extern int GLAD_GL_ARB_sparse_texture2;



extern int GLAD_GL_ARB_sparse_texture_clamp;



extern int GLAD_GL_ARB_spirv_extensions;



extern int GLAD_GL_ARB_stencil_texturing;



extern int GLAD_GL_ARB_sync;



extern int GLAD_GL_ARB_tessellation_shader;



extern int GLAD_GL_ARB_texture_barrier;



extern int GLAD_GL_ARB_texture_border_clamp;



extern int GLAD_GL_ARB_texture_buffer_object;
typedef void ( * PFNGLTEXBUFFERARBPROC)(GLenum target, GLenum internalformat, GLuint buffer);
extern PFNGLTEXBUFFERARBPROC glad_glTexBufferARB;




extern int GLAD_GL_ARB_texture_buffer_object_rgb32;



extern int GLAD_GL_ARB_texture_buffer_range;



extern int GLAD_GL_ARB_texture_compression;
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DARBPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXIMAGE3DARBPROC glad_glCompressedTexImage3DARB;

typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DARBPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXIMAGE2DARBPROC glad_glCompressedTexImage2DARB;

typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DARBPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXIMAGE1DARBPROC glad_glCompressedTexImage1DARB;

typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC glad_glCompressedTexSubImage3DARB;

typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC glad_glCompressedTexSubImage2DARB;

typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
extern PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC glad_glCompressedTexSubImage1DARB;

typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEARBPROC)(GLenum target, GLint level, void *img);
extern PFNGLGETCOMPRESSEDTEXIMAGEARBPROC glad_glGetCompressedTexImageARB;




extern int GLAD_GL_ARB_texture_compression_bptc;



extern int GLAD_GL_ARB_texture_compression_rgtc;



extern int GLAD_GL_ARB_texture_cube_map;



extern int GLAD_GL_ARB_texture_cube_map_array;



extern int GLAD_GL_ARB_texture_env_add;



extern int GLAD_GL_ARB_texture_env_combine;



extern int GLAD_GL_ARB_texture_env_crossbar;



extern int GLAD_GL_ARB_texture_env_dot3;



extern int GLAD_GL_ARB_texture_filter_anisotropic;



extern int GLAD_GL_ARB_texture_filter_minmax;



extern int GLAD_GL_ARB_texture_float;



extern int GLAD_GL_ARB_texture_gather;



extern int GLAD_GL_ARB_texture_mirror_clamp_to_edge;



extern int GLAD_GL_ARB_texture_mirrored_repeat;



extern int GLAD_GL_ARB_texture_multisample;



extern int GLAD_GL_ARB_texture_non_power_of_two;



extern int GLAD_GL_ARB_texture_query_levels;



extern int GLAD_GL_ARB_texture_query_lod;



extern int GLAD_GL_ARB_texture_rectangle;



extern int GLAD_GL_ARB_texture_rg;



extern int GLAD_GL_ARB_texture_rgb10_a2ui;



extern int GLAD_GL_ARB_texture_stencil8;



extern int GLAD_GL_ARB_texture_storage;



extern int GLAD_GL_ARB_texture_storage_multisample;



extern int GLAD_GL_ARB_texture_swizzle;



extern int GLAD_GL_ARB_texture_view;



extern int GLAD_GL_ARB_timer_query;



extern int GLAD_GL_ARB_transform_feedback2;



extern int GLAD_GL_ARB_transform_feedback3;



extern int GLAD_GL_ARB_transform_feedback_instanced;



extern int GLAD_GL_ARB_transform_feedback_overflow_query;



extern int GLAD_GL_ARB_transpose_matrix;
typedef void ( * PFNGLLOADTRANSPOSEMATRIXFARBPROC)(const GLfloat *m);
extern PFNGLLOADTRANSPOSEMATRIXFARBPROC glad_glLoadTransposeMatrixfARB;

typedef void ( * PFNGLLOADTRANSPOSEMATRIXDARBPROC)(const GLdouble *m);
extern PFNGLLOADTRANSPOSEMATRIXDARBPROC glad_glLoadTransposeMatrixdARB;

typedef void ( * PFNGLMULTTRANSPOSEMATRIXFARBPROC)(const GLfloat *m);
extern PFNGLMULTTRANSPOSEMATRIXFARBPROC glad_glMultTransposeMatrixfARB;

typedef void ( * PFNGLMULTTRANSPOSEMATRIXDARBPROC)(const GLdouble *m);
extern PFNGLMULTTRANSPOSEMATRIXDARBPROC glad_glMultTransposeMatrixdARB;




extern int GLAD_GL_ARB_uniform_buffer_object;



extern int GLAD_GL_ARB_vertex_array_bgra;



extern int GLAD_GL_ARB_vertex_array_object;



extern int GLAD_GL_ARB_vertex_attrib_64bit;



extern int GLAD_GL_ARB_vertex_attrib_binding;



extern int GLAD_GL_ARB_vertex_blend;
typedef void ( * PFNGLWEIGHTBVARBPROC)(GLint size, const GLbyte *weights);
extern PFNGLWEIGHTBVARBPROC glad_glWeightbvARB;

typedef void ( * PFNGLWEIGHTSVARBPROC)(GLint size, const GLshort *weights);
extern PFNGLWEIGHTSVARBPROC glad_glWeightsvARB;

typedef void ( * PFNGLWEIGHTIVARBPROC)(GLint size, const GLint *weights);
extern PFNGLWEIGHTIVARBPROC glad_glWeightivARB;

typedef void ( * PFNGLWEIGHTFVARBPROC)(GLint size, const GLfloat *weights);
extern PFNGLWEIGHTFVARBPROC glad_glWeightfvARB;

typedef void ( * PFNGLWEIGHTDVARBPROC)(GLint size, const GLdouble *weights);
extern PFNGLWEIGHTDVARBPROC glad_glWeightdvARB;

typedef void ( * PFNGLWEIGHTUBVARBPROC)(GLint size, const GLubyte *weights);
extern PFNGLWEIGHTUBVARBPROC glad_glWeightubvARB;

typedef void ( * PFNGLWEIGHTUSVARBPROC)(GLint size, const GLushort *weights);
extern PFNGLWEIGHTUSVARBPROC glad_glWeightusvARB;

typedef void ( * PFNGLWEIGHTUIVARBPROC)(GLint size, const GLuint *weights);
extern PFNGLWEIGHTUIVARBPROC glad_glWeightuivARB;

typedef void ( * PFNGLWEIGHTPOINTERARBPROC)(GLint size, GLenum type, GLsizei stride, const void *pointer);
extern PFNGLWEIGHTPOINTERARBPROC glad_glWeightPointerARB;

typedef void ( * PFNGLVERTEXBLENDARBPROC)(GLint count);
extern PFNGLVERTEXBLENDARBPROC glad_glVertexBlendARB;




extern int GLAD_GL_ARB_vertex_buffer_object;
typedef void ( * PFNGLBINDBUFFERARBPROC)(GLenum target, GLuint buffer);
extern PFNGLBINDBUFFERARBPROC glad_glBindBufferARB;

typedef void ( * PFNGLDELETEBUFFERSARBPROC)(GLsizei n, const GLuint *buffers);
extern PFNGLDELETEBUFFERSARBPROC glad_glDeleteBuffersARB;

typedef void ( * PFNGLGENBUFFERSARBPROC)(GLsizei n, GLuint *buffers);
extern PFNGLGENBUFFERSARBPROC glad_glGenBuffersARB;

typedef GLboolean ( * PFNGLISBUFFERARBPROC)(GLuint buffer);
extern PFNGLISBUFFERARBPROC glad_glIsBufferARB;

typedef void ( * PFNGLBUFFERDATAARBPROC)(GLenum target, GLsizeiptrARB size, const void *data, GLenum usage);
extern PFNGLBUFFERDATAARBPROC glad_glBufferDataARB;

typedef void ( * PFNGLBUFFERSUBDATAARBPROC)(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void *data);
extern PFNGLBUFFERSUBDATAARBPROC glad_glBufferSubDataARB;

typedef void ( * PFNGLGETBUFFERSUBDATAARBPROC)(GLenum target, GLintptrARB offset, GLsizeiptrARB size, void *data);
extern PFNGLGETBUFFERSUBDATAARBPROC glad_glGetBufferSubDataARB;

typedef void * ( * PFNGLMAPBUFFERARBPROC)(GLenum target, GLenum access);
extern PFNGLMAPBUFFERARBPROC glad_glMapBufferARB;

typedef GLboolean ( * PFNGLUNMAPBUFFERARBPROC)(GLenum target);
extern PFNGLUNMAPBUFFERARBPROC glad_glUnmapBufferARB;

typedef void ( * PFNGLGETBUFFERPARAMETERIVARBPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETBUFFERPARAMETERIVARBPROC glad_glGetBufferParameterivARB;

typedef void ( * PFNGLGETBUFFERPOINTERVARBPROC)(GLenum target, GLenum pname, void **params);
extern PFNGLGETBUFFERPOINTERVARBPROC glad_glGetBufferPointervARB;




extern int GLAD_GL_ARB_vertex_program;
typedef void ( * PFNGLVERTEXATTRIB1DARBPROC)(GLuint index, GLdouble x);
extern PFNGLVERTEXATTRIB1DARBPROC glad_glVertexAttrib1dARB;

typedef void ( * PFNGLVERTEXATTRIB1DVARBPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB1DVARBPROC glad_glVertexAttrib1dvARB;

typedef void ( * PFNGLVERTEXATTRIB1FARBPROC)(GLuint index, GLfloat x);
extern PFNGLVERTEXATTRIB1FARBPROC glad_glVertexAttrib1fARB;

typedef void ( * PFNGLVERTEXATTRIB1FVARBPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB1FVARBPROC glad_glVertexAttrib1fvARB;

typedef void ( * PFNGLVERTEXATTRIB1SARBPROC)(GLuint index, GLshort x);
extern PFNGLVERTEXATTRIB1SARBPROC glad_glVertexAttrib1sARB;

typedef void ( * PFNGLVERTEXATTRIB1SVARBPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB1SVARBPROC glad_glVertexAttrib1svARB;

typedef void ( * PFNGLVERTEXATTRIB2DARBPROC)(GLuint index, GLdouble x, GLdouble y);
extern PFNGLVERTEXATTRIB2DARBPROC glad_glVertexAttrib2dARB;

typedef void ( * PFNGLVERTEXATTRIB2DVARBPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB2DVARBPROC glad_glVertexAttrib2dvARB;

typedef void ( * PFNGLVERTEXATTRIB2FARBPROC)(GLuint index, GLfloat x, GLfloat y);
extern PFNGLVERTEXATTRIB2FARBPROC glad_glVertexAttrib2fARB;

typedef void ( * PFNGLVERTEXATTRIB2FVARBPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB2FVARBPROC glad_glVertexAttrib2fvARB;

typedef void ( * PFNGLVERTEXATTRIB2SARBPROC)(GLuint index, GLshort x, GLshort y);
extern PFNGLVERTEXATTRIB2SARBPROC glad_glVertexAttrib2sARB;

typedef void ( * PFNGLVERTEXATTRIB2SVARBPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB2SVARBPROC glad_glVertexAttrib2svARB;

typedef void ( * PFNGLVERTEXATTRIB3DARBPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern PFNGLVERTEXATTRIB3DARBPROC glad_glVertexAttrib3dARB;

typedef void ( * PFNGLVERTEXATTRIB3DVARBPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB3DVARBPROC glad_glVertexAttrib3dvARB;

typedef void ( * PFNGLVERTEXATTRIB3FARBPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLVERTEXATTRIB3FARBPROC glad_glVertexAttrib3fARB;

typedef void ( * PFNGLVERTEXATTRIB3FVARBPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB3FVARBPROC glad_glVertexAttrib3fvARB;

typedef void ( * PFNGLVERTEXATTRIB3SARBPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
extern PFNGLVERTEXATTRIB3SARBPROC glad_glVertexAttrib3sARB;

typedef void ( * PFNGLVERTEXATTRIB3SVARBPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB3SVARBPROC glad_glVertexAttrib3svARB;

typedef void ( * PFNGLVERTEXATTRIB4NBVARBPROC)(GLuint index, const GLbyte *v);
extern PFNGLVERTEXATTRIB4NBVARBPROC glad_glVertexAttrib4NbvARB;

typedef void ( * PFNGLVERTEXATTRIB4NIVARBPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIB4NIVARBPROC glad_glVertexAttrib4NivARB;

typedef void ( * PFNGLVERTEXATTRIB4NSVARBPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB4NSVARBPROC glad_glVertexAttrib4NsvARB;

typedef void ( * PFNGLVERTEXATTRIB4NUBARBPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern PFNGLVERTEXATTRIB4NUBARBPROC glad_glVertexAttrib4NubARB;

typedef void ( * PFNGLVERTEXATTRIB4NUBVARBPROC)(GLuint index, const GLubyte *v);
extern PFNGLVERTEXATTRIB4NUBVARBPROC glad_glVertexAttrib4NubvARB;

typedef void ( * PFNGLVERTEXATTRIB4NUIVARBPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIB4NUIVARBPROC glad_glVertexAttrib4NuivARB;

typedef void ( * PFNGLVERTEXATTRIB4NUSVARBPROC)(GLuint index, const GLushort *v);
extern PFNGLVERTEXATTRIB4NUSVARBPROC glad_glVertexAttrib4NusvARB;

typedef void ( * PFNGLVERTEXATTRIB4BVARBPROC)(GLuint index, const GLbyte *v);
extern PFNGLVERTEXATTRIB4BVARBPROC glad_glVertexAttrib4bvARB;

typedef void ( * PFNGLVERTEXATTRIB4DARBPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLVERTEXATTRIB4DARBPROC glad_glVertexAttrib4dARB;

typedef void ( * PFNGLVERTEXATTRIB4DVARBPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB4DVARBPROC glad_glVertexAttrib4dvARB;

typedef void ( * PFNGLVERTEXATTRIB4FARBPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern PFNGLVERTEXATTRIB4FARBPROC glad_glVertexAttrib4fARB;

typedef void ( * PFNGLVERTEXATTRIB4FVARBPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB4FVARBPROC glad_glVertexAttrib4fvARB;

typedef void ( * PFNGLVERTEXATTRIB4IVARBPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIB4IVARBPROC glad_glVertexAttrib4ivARB;

typedef void ( * PFNGLVERTEXATTRIB4SARBPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern PFNGLVERTEXATTRIB4SARBPROC glad_glVertexAttrib4sARB;

typedef void ( * PFNGLVERTEXATTRIB4SVARBPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB4SVARBPROC glad_glVertexAttrib4svARB;

typedef void ( * PFNGLVERTEXATTRIB4UBVARBPROC)(GLuint index, const GLubyte *v);
extern PFNGLVERTEXATTRIB4UBVARBPROC glad_glVertexAttrib4ubvARB;

typedef void ( * PFNGLVERTEXATTRIB4UIVARBPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIB4UIVARBPROC glad_glVertexAttrib4uivARB;

typedef void ( * PFNGLVERTEXATTRIB4USVARBPROC)(GLuint index, const GLushort *v);
extern PFNGLVERTEXATTRIB4USVARBPROC glad_glVertexAttrib4usvARB;

typedef void ( * PFNGLVERTEXATTRIBPOINTERARBPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
extern PFNGLVERTEXATTRIBPOINTERARBPROC glad_glVertexAttribPointerARB;

typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYARBPROC)(GLuint index);
extern PFNGLENABLEVERTEXATTRIBARRAYARBPROC glad_glEnableVertexAttribArrayARB;

typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYARBPROC)(GLuint index);
extern PFNGLDISABLEVERTEXATTRIBARRAYARBPROC glad_glDisableVertexAttribArrayARB;

typedef void ( * PFNGLGETVERTEXATTRIBDVARBPROC)(GLuint index, GLenum pname, GLdouble *params);
extern PFNGLGETVERTEXATTRIBDVARBPROC glad_glGetVertexAttribdvARB;

typedef void ( * PFNGLGETVERTEXATTRIBFVARBPROC)(GLuint index, GLenum pname, GLfloat *params);
extern PFNGLGETVERTEXATTRIBFVARBPROC glad_glGetVertexAttribfvARB;

typedef void ( * PFNGLGETVERTEXATTRIBIVARBPROC)(GLuint index, GLenum pname, GLint *params);
extern PFNGLGETVERTEXATTRIBIVARBPROC glad_glGetVertexAttribivARB;

typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVARBPROC)(GLuint index, GLenum pname, void **pointer);
extern PFNGLGETVERTEXATTRIBPOINTERVARBPROC glad_glGetVertexAttribPointervARB;




extern int GLAD_GL_ARB_vertex_shader;
typedef void ( * PFNGLBINDATTRIBLOCATIONARBPROC)(GLhandleARB programObj, GLuint index, const GLcharARB *name);
extern PFNGLBINDATTRIBLOCATIONARBPROC glad_glBindAttribLocationARB;

typedef void ( * PFNGLGETACTIVEATTRIBARBPROC)(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
extern PFNGLGETACTIVEATTRIBARBPROC glad_glGetActiveAttribARB;

typedef GLint ( * PFNGLGETATTRIBLOCATIONARBPROC)(GLhandleARB programObj, const GLcharARB *name);
extern PFNGLGETATTRIBLOCATIONARBPROC glad_glGetAttribLocationARB;




extern int GLAD_GL_ARB_vertex_type_10f_11f_11f_rev;



extern int GLAD_GL_ARB_vertex_type_2_10_10_10_rev;



extern int GLAD_GL_ARB_viewport_array;
typedef void ( * PFNGLDEPTHRANGEARRAYDVNVPROC)(GLuint first, GLsizei count, const GLdouble *v);
extern PFNGLDEPTHRANGEARRAYDVNVPROC glad_glDepthRangeArraydvNV;

typedef void ( * PFNGLDEPTHRANGEINDEXEDDNVPROC)(GLuint index, GLdouble n, GLdouble f);
extern PFNGLDEPTHRANGEINDEXEDDNVPROC glad_glDepthRangeIndexeddNV;




extern int GLAD_GL_ARB_window_pos;
typedef void ( * PFNGLWINDOWPOS2DARBPROC)(GLdouble x, GLdouble y);
extern PFNGLWINDOWPOS2DARBPROC glad_glWindowPos2dARB;

typedef void ( * PFNGLWINDOWPOS2DVARBPROC)(const GLdouble *v);
extern PFNGLWINDOWPOS2DVARBPROC glad_glWindowPos2dvARB;

typedef void ( * PFNGLWINDOWPOS2FARBPROC)(GLfloat x, GLfloat y);
extern PFNGLWINDOWPOS2FARBPROC glad_glWindowPos2fARB;

typedef void ( * PFNGLWINDOWPOS2FVARBPROC)(const GLfloat *v);
extern PFNGLWINDOWPOS2FVARBPROC glad_glWindowPos2fvARB;

typedef void ( * PFNGLWINDOWPOS2IARBPROC)(GLint x, GLint y);
extern PFNGLWINDOWPOS2IARBPROC glad_glWindowPos2iARB;

typedef void ( * PFNGLWINDOWPOS2IVARBPROC)(const GLint *v);
extern PFNGLWINDOWPOS2IVARBPROC glad_glWindowPos2ivARB;

typedef void ( * PFNGLWINDOWPOS2SARBPROC)(GLshort x, GLshort y);
extern PFNGLWINDOWPOS2SARBPROC glad_glWindowPos2sARB;

typedef void ( * PFNGLWINDOWPOS2SVARBPROC)(const GLshort *v);
extern PFNGLWINDOWPOS2SVARBPROC glad_glWindowPos2svARB;

typedef void ( * PFNGLWINDOWPOS3DARBPROC)(GLdouble x, GLdouble y, GLdouble z);
extern PFNGLWINDOWPOS3DARBPROC glad_glWindowPos3dARB;

typedef void ( * PFNGLWINDOWPOS3DVARBPROC)(const GLdouble *v);
extern PFNGLWINDOWPOS3DVARBPROC glad_glWindowPos3dvARB;

typedef void ( * PFNGLWINDOWPOS3FARBPROC)(GLfloat x, GLfloat y, GLfloat z);
extern PFNGLWINDOWPOS3FARBPROC glad_glWindowPos3fARB;

typedef void ( * PFNGLWINDOWPOS3FVARBPROC)(const GLfloat *v);
extern PFNGLWINDOWPOS3FVARBPROC glad_glWindowPos3fvARB;

typedef void ( * PFNGLWINDOWPOS3IARBPROC)(GLint x, GLint y, GLint z);
extern PFNGLWINDOWPOS3IARBPROC glad_glWindowPos3iARB;

typedef void ( * PFNGLWINDOWPOS3IVARBPROC)(const GLint *v);
extern PFNGLWINDOWPOS3IVARBPROC glad_glWindowPos3ivARB;

typedef void ( * PFNGLWINDOWPOS3SARBPROC)(GLshort x, GLshort y, GLshort z);
extern PFNGLWINDOWPOS3SARBPROC glad_glWindowPos3sARB;

typedef void ( * PFNGLWINDOWPOS3SVARBPROC)(const GLshort *v);
extern PFNGLWINDOWPOS3SVARBPROC glad_glWindowPos3svARB;




extern int GLAD_GL_ATI_draw_buffers;
typedef void ( * PFNGLDRAWBUFFERSATIPROC)(GLsizei n, const GLenum *bufs);
extern PFNGLDRAWBUFFERSATIPROC glad_glDrawBuffersATI;




extern int GLAD_GL_ATI_element_array;
typedef void ( * PFNGLELEMENTPOINTERATIPROC)(GLenum type, const void *pointer);
extern PFNGLELEMENTPOINTERATIPROC glad_glElementPointerATI;

typedef void ( * PFNGLDRAWELEMENTARRAYATIPROC)(GLenum mode, GLsizei count);
extern PFNGLDRAWELEMENTARRAYATIPROC glad_glDrawElementArrayATI;

typedef void ( * PFNGLDRAWRANGEELEMENTARRAYATIPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count);
extern PFNGLDRAWRANGEELEMENTARRAYATIPROC glad_glDrawRangeElementArrayATI;




extern int GLAD_GL_ATI_envmap_bumpmap;
typedef void ( * PFNGLTEXBUMPPARAMETERIVATIPROC)(GLenum pname, const GLint *param);
extern PFNGLTEXBUMPPARAMETERIVATIPROC glad_glTexBumpParameterivATI;

typedef void ( * PFNGLTEXBUMPPARAMETERFVATIPROC)(GLenum pname, const GLfloat *param);
extern PFNGLTEXBUMPPARAMETERFVATIPROC glad_glTexBumpParameterfvATI;

typedef void ( * PFNGLGETTEXBUMPPARAMETERIVATIPROC)(GLenum pname, GLint *param);
extern PFNGLGETTEXBUMPPARAMETERIVATIPROC glad_glGetTexBumpParameterivATI;

typedef void ( * PFNGLGETTEXBUMPPARAMETERFVATIPROC)(GLenum pname, GLfloat *param);
extern PFNGLGETTEXBUMPPARAMETERFVATIPROC glad_glGetTexBumpParameterfvATI;




extern int GLAD_GL_ATI_fragment_shader;
typedef GLuint ( * PFNGLGENFRAGMENTSHADERSATIPROC)(GLuint range);
extern PFNGLGENFRAGMENTSHADERSATIPROC glad_glGenFragmentShadersATI;

typedef void ( * PFNGLBINDFRAGMENTSHADERATIPROC)(GLuint id);
extern PFNGLBINDFRAGMENTSHADERATIPROC glad_glBindFragmentShaderATI;

typedef void ( * PFNGLDELETEFRAGMENTSHADERATIPROC)(GLuint id);
extern PFNGLDELETEFRAGMENTSHADERATIPROC glad_glDeleteFragmentShaderATI;

typedef void ( * PFNGLBEGINFRAGMENTSHADERATIPROC)(void);
extern PFNGLBEGINFRAGMENTSHADERATIPROC glad_glBeginFragmentShaderATI;

typedef void ( * PFNGLENDFRAGMENTSHADERATIPROC)(void);
extern PFNGLENDFRAGMENTSHADERATIPROC glad_glEndFragmentShaderATI;

typedef void ( * PFNGLPASSTEXCOORDATIPROC)(GLuint dst, GLuint coord, GLenum swizzle);
extern PFNGLPASSTEXCOORDATIPROC glad_glPassTexCoordATI;

typedef void ( * PFNGLSAMPLEMAPATIPROC)(GLuint dst, GLuint interp, GLenum swizzle);
extern PFNGLSAMPLEMAPATIPROC glad_glSampleMapATI;

typedef void ( * PFNGLCOLORFRAGMENTOP1ATIPROC)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
extern PFNGLCOLORFRAGMENTOP1ATIPROC glad_glColorFragmentOp1ATI;

typedef void ( * PFNGLCOLORFRAGMENTOP2ATIPROC)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
extern PFNGLCOLORFRAGMENTOP2ATIPROC glad_glColorFragmentOp2ATI;

typedef void ( * PFNGLCOLORFRAGMENTOP3ATIPROC)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
extern PFNGLCOLORFRAGMENTOP3ATIPROC glad_glColorFragmentOp3ATI;

typedef void ( * PFNGLALPHAFRAGMENTOP1ATIPROC)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
extern PFNGLALPHAFRAGMENTOP1ATIPROC glad_glAlphaFragmentOp1ATI;

typedef void ( * PFNGLALPHAFRAGMENTOP2ATIPROC)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
extern PFNGLALPHAFRAGMENTOP2ATIPROC glad_glAlphaFragmentOp2ATI;

typedef void ( * PFNGLALPHAFRAGMENTOP3ATIPROC)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
extern PFNGLALPHAFRAGMENTOP3ATIPROC glad_glAlphaFragmentOp3ATI;

typedef void ( * PFNGLSETFRAGMENTSHADERCONSTANTATIPROC)(GLuint dst, const GLfloat *value);
extern PFNGLSETFRAGMENTSHADERCONSTANTATIPROC glad_glSetFragmentShaderConstantATI;




extern int GLAD_GL_ATI_map_object_buffer;
typedef void * ( * PFNGLMAPOBJECTBUFFERATIPROC)(GLuint buffer);
extern PFNGLMAPOBJECTBUFFERATIPROC glad_glMapObjectBufferATI;

typedef void ( * PFNGLUNMAPOBJECTBUFFERATIPROC)(GLuint buffer);
extern PFNGLUNMAPOBJECTBUFFERATIPROC glad_glUnmapObjectBufferATI;




extern int GLAD_GL_ATI_meminfo;



extern int GLAD_GL_ATI_pixel_format_float;



extern int GLAD_GL_ATI_pn_triangles;
typedef void ( * PFNGLPNTRIANGLESIATIPROC)(GLenum pname, GLint param);
extern PFNGLPNTRIANGLESIATIPROC glad_glPNTrianglesiATI;

typedef void ( * PFNGLPNTRIANGLESFATIPROC)(GLenum pname, GLfloat param);
extern PFNGLPNTRIANGLESFATIPROC glad_glPNTrianglesfATI;




extern int GLAD_GL_ATI_separate_stencil;
typedef void ( * PFNGLSTENCILOPSEPARATEATIPROC)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
extern PFNGLSTENCILOPSEPARATEATIPROC glad_glStencilOpSeparateATI;

typedef void ( * PFNGLSTENCILFUNCSEPARATEATIPROC)(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
extern PFNGLSTENCILFUNCSEPARATEATIPROC glad_glStencilFuncSeparateATI;




extern int GLAD_GL_ATI_text_fragment_shader;



extern int GLAD_GL_ATI_texture_env_combine3;



extern int GLAD_GL_ATI_texture_float;



extern int GLAD_GL_ATI_texture_mirror_once;



extern int GLAD_GL_ATI_vertex_array_object;
typedef GLuint ( * PFNGLNEWOBJECTBUFFERATIPROC)(GLsizei size, const void *pointer, GLenum usage);
extern PFNGLNEWOBJECTBUFFERATIPROC glad_glNewObjectBufferATI;

typedef GLboolean ( * PFNGLISOBJECTBUFFERATIPROC)(GLuint buffer);
extern PFNGLISOBJECTBUFFERATIPROC glad_glIsObjectBufferATI;

typedef void ( * PFNGLUPDATEOBJECTBUFFERATIPROC)(GLuint buffer, GLuint offset, GLsizei size, const void *pointer, GLenum preserve);
extern PFNGLUPDATEOBJECTBUFFERATIPROC glad_glUpdateObjectBufferATI;

typedef void ( * PFNGLGETOBJECTBUFFERFVATIPROC)(GLuint buffer, GLenum pname, GLfloat *params);
extern PFNGLGETOBJECTBUFFERFVATIPROC glad_glGetObjectBufferfvATI;

typedef void ( * PFNGLGETOBJECTBUFFERIVATIPROC)(GLuint buffer, GLenum pname, GLint *params);
extern PFNGLGETOBJECTBUFFERIVATIPROC glad_glGetObjectBufferivATI;

typedef void ( * PFNGLFREEOBJECTBUFFERATIPROC)(GLuint buffer);
extern PFNGLFREEOBJECTBUFFERATIPROC glad_glFreeObjectBufferATI;

typedef void ( * PFNGLARRAYOBJECTATIPROC)(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
extern PFNGLARRAYOBJECTATIPROC glad_glArrayObjectATI;

typedef void ( * PFNGLGETARRAYOBJECTFVATIPROC)(GLenum array, GLenum pname, GLfloat *params);
extern PFNGLGETARRAYOBJECTFVATIPROC glad_glGetArrayObjectfvATI;

typedef void ( * PFNGLGETARRAYOBJECTIVATIPROC)(GLenum array, GLenum pname, GLint *params);
extern PFNGLGETARRAYOBJECTIVATIPROC glad_glGetArrayObjectivATI;

typedef void ( * PFNGLVARIANTARRAYOBJECTATIPROC)(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
extern PFNGLVARIANTARRAYOBJECTATIPROC glad_glVariantArrayObjectATI;

typedef void ( * PFNGLGETVARIANTARRAYOBJECTFVATIPROC)(GLuint id, GLenum pname, GLfloat *params);
extern PFNGLGETVARIANTARRAYOBJECTFVATIPROC glad_glGetVariantArrayObjectfvATI;

typedef void ( * PFNGLGETVARIANTARRAYOBJECTIVATIPROC)(GLuint id, GLenum pname, GLint *params);
extern PFNGLGETVARIANTARRAYOBJECTIVATIPROC glad_glGetVariantArrayObjectivATI;




extern int GLAD_GL_ATI_vertex_attrib_array_object;
typedef void ( * PFNGLVERTEXATTRIBARRAYOBJECTATIPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);
extern PFNGLVERTEXATTRIBARRAYOBJECTATIPROC glad_glVertexAttribArrayObjectATI;

typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC)(GLuint index, GLenum pname, GLfloat *params);
extern PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC glad_glGetVertexAttribArrayObjectfvATI;

typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC)(GLuint index, GLenum pname, GLint *params);
extern PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC glad_glGetVertexAttribArrayObjectivATI;




extern int GLAD_GL_ATI_vertex_streams;
typedef void ( * PFNGLVERTEXSTREAM1SATIPROC)(GLenum stream, GLshort x);
extern PFNGLVERTEXSTREAM1SATIPROC glad_glVertexStream1sATI;

typedef void ( * PFNGLVERTEXSTREAM1SVATIPROC)(GLenum stream, const GLshort *coords);
extern PFNGLVERTEXSTREAM1SVATIPROC glad_glVertexStream1svATI;

typedef void ( * PFNGLVERTEXSTREAM1IATIPROC)(GLenum stream, GLint x);
extern PFNGLVERTEXSTREAM1IATIPROC glad_glVertexStream1iATI;

typedef void ( * PFNGLVERTEXSTREAM1IVATIPROC)(GLenum stream, const GLint *coords);
extern PFNGLVERTEXSTREAM1IVATIPROC glad_glVertexStream1ivATI;

typedef void ( * PFNGLVERTEXSTREAM1FATIPROC)(GLenum stream, GLfloat x);
extern PFNGLVERTEXSTREAM1FATIPROC glad_glVertexStream1fATI;

typedef void ( * PFNGLVERTEXSTREAM1FVATIPROC)(GLenum stream, const GLfloat *coords);
extern PFNGLVERTEXSTREAM1FVATIPROC glad_glVertexStream1fvATI;

typedef void ( * PFNGLVERTEXSTREAM1DATIPROC)(GLenum stream, GLdouble x);
extern PFNGLVERTEXSTREAM1DATIPROC glad_glVertexStream1dATI;

typedef void ( * PFNGLVERTEXSTREAM1DVATIPROC)(GLenum stream, const GLdouble *coords);
extern PFNGLVERTEXSTREAM1DVATIPROC glad_glVertexStream1dvATI;

typedef void ( * PFNGLVERTEXSTREAM2SATIPROC)(GLenum stream, GLshort x, GLshort y);
extern PFNGLVERTEXSTREAM2SATIPROC glad_glVertexStream2sATI;

typedef void ( * PFNGLVERTEXSTREAM2SVATIPROC)(GLenum stream, const GLshort *coords);
extern PFNGLVERTEXSTREAM2SVATIPROC glad_glVertexStream2svATI;

typedef void ( * PFNGLVERTEXSTREAM2IATIPROC)(GLenum stream, GLint x, GLint y);
extern PFNGLVERTEXSTREAM2IATIPROC glad_glVertexStream2iATI;

typedef void ( * PFNGLVERTEXSTREAM2IVATIPROC)(GLenum stream, const GLint *coords);
extern PFNGLVERTEXSTREAM2IVATIPROC glad_glVertexStream2ivATI;

typedef void ( * PFNGLVERTEXSTREAM2FATIPROC)(GLenum stream, GLfloat x, GLfloat y);
extern PFNGLVERTEXSTREAM2FATIPROC glad_glVertexStream2fATI;

typedef void ( * PFNGLVERTEXSTREAM2FVATIPROC)(GLenum stream, const GLfloat *coords);
extern PFNGLVERTEXSTREAM2FVATIPROC glad_glVertexStream2fvATI;

typedef void ( * PFNGLVERTEXSTREAM2DATIPROC)(GLenum stream, GLdouble x, GLdouble y);
extern PFNGLVERTEXSTREAM2DATIPROC glad_glVertexStream2dATI;

typedef void ( * PFNGLVERTEXSTREAM2DVATIPROC)(GLenum stream, const GLdouble *coords);
extern PFNGLVERTEXSTREAM2DVATIPROC glad_glVertexStream2dvATI;

typedef void ( * PFNGLVERTEXSTREAM3SATIPROC)(GLenum stream, GLshort x, GLshort y, GLshort z);
extern PFNGLVERTEXSTREAM3SATIPROC glad_glVertexStream3sATI;

typedef void ( * PFNGLVERTEXSTREAM3SVATIPROC)(GLenum stream, const GLshort *coords);
extern PFNGLVERTEXSTREAM3SVATIPROC glad_glVertexStream3svATI;

typedef void ( * PFNGLVERTEXSTREAM3IATIPROC)(GLenum stream, GLint x, GLint y, GLint z);
extern PFNGLVERTEXSTREAM3IATIPROC glad_glVertexStream3iATI;

typedef void ( * PFNGLVERTEXSTREAM3IVATIPROC)(GLenum stream, const GLint *coords);
extern PFNGLVERTEXSTREAM3IVATIPROC glad_glVertexStream3ivATI;

typedef void ( * PFNGLVERTEXSTREAM3FATIPROC)(GLenum stream, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLVERTEXSTREAM3FATIPROC glad_glVertexStream3fATI;

typedef void ( * PFNGLVERTEXSTREAM3FVATIPROC)(GLenum stream, const GLfloat *coords);
extern PFNGLVERTEXSTREAM3FVATIPROC glad_glVertexStream3fvATI;

typedef void ( * PFNGLVERTEXSTREAM3DATIPROC)(GLenum stream, GLdouble x, GLdouble y, GLdouble z);
extern PFNGLVERTEXSTREAM3DATIPROC glad_glVertexStream3dATI;

typedef void ( * PFNGLVERTEXSTREAM3DVATIPROC)(GLenum stream, const GLdouble *coords);
extern PFNGLVERTEXSTREAM3DVATIPROC glad_glVertexStream3dvATI;

typedef void ( * PFNGLVERTEXSTREAM4SATIPROC)(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
extern PFNGLVERTEXSTREAM4SATIPROC glad_glVertexStream4sATI;

typedef void ( * PFNGLVERTEXSTREAM4SVATIPROC)(GLenum stream, const GLshort *coords);
extern PFNGLVERTEXSTREAM4SVATIPROC glad_glVertexStream4svATI;

typedef void ( * PFNGLVERTEXSTREAM4IATIPROC)(GLenum stream, GLint x, GLint y, GLint z, GLint w);
extern PFNGLVERTEXSTREAM4IATIPROC glad_glVertexStream4iATI;

typedef void ( * PFNGLVERTEXSTREAM4IVATIPROC)(GLenum stream, const GLint *coords);
extern PFNGLVERTEXSTREAM4IVATIPROC glad_glVertexStream4ivATI;

typedef void ( * PFNGLVERTEXSTREAM4FATIPROC)(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern PFNGLVERTEXSTREAM4FATIPROC glad_glVertexStream4fATI;

typedef void ( * PFNGLVERTEXSTREAM4FVATIPROC)(GLenum stream, const GLfloat *coords);
extern PFNGLVERTEXSTREAM4FVATIPROC glad_glVertexStream4fvATI;

typedef void ( * PFNGLVERTEXSTREAM4DATIPROC)(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLVERTEXSTREAM4DATIPROC glad_glVertexStream4dATI;

typedef void ( * PFNGLVERTEXSTREAM4DVATIPROC)(GLenum stream, const GLdouble *coords);
extern PFNGLVERTEXSTREAM4DVATIPROC glad_glVertexStream4dvATI;

typedef void ( * PFNGLNORMALSTREAM3BATIPROC)(GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz);
extern PFNGLNORMALSTREAM3BATIPROC glad_glNormalStream3bATI;

typedef void ( * PFNGLNORMALSTREAM3BVATIPROC)(GLenum stream, const GLbyte *coords);
extern PFNGLNORMALSTREAM3BVATIPROC glad_glNormalStream3bvATI;

typedef void ( * PFNGLNORMALSTREAM3SATIPROC)(GLenum stream, GLshort nx, GLshort ny, GLshort nz);
extern PFNGLNORMALSTREAM3SATIPROC glad_glNormalStream3sATI;

typedef void ( * PFNGLNORMALSTREAM3SVATIPROC)(GLenum stream, const GLshort *coords);
extern PFNGLNORMALSTREAM3SVATIPROC glad_glNormalStream3svATI;

typedef void ( * PFNGLNORMALSTREAM3IATIPROC)(GLenum stream, GLint nx, GLint ny, GLint nz);
extern PFNGLNORMALSTREAM3IATIPROC glad_glNormalStream3iATI;

typedef void ( * PFNGLNORMALSTREAM3IVATIPROC)(GLenum stream, const GLint *coords);
extern PFNGLNORMALSTREAM3IVATIPROC glad_glNormalStream3ivATI;

typedef void ( * PFNGLNORMALSTREAM3FATIPROC)(GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz);
extern PFNGLNORMALSTREAM3FATIPROC glad_glNormalStream3fATI;

typedef void ( * PFNGLNORMALSTREAM3FVATIPROC)(GLenum stream, const GLfloat *coords);
extern PFNGLNORMALSTREAM3FVATIPROC glad_glNormalStream3fvATI;

typedef void ( * PFNGLNORMALSTREAM3DATIPROC)(GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz);
extern PFNGLNORMALSTREAM3DATIPROC glad_glNormalStream3dATI;

typedef void ( * PFNGLNORMALSTREAM3DVATIPROC)(GLenum stream, const GLdouble *coords);
extern PFNGLNORMALSTREAM3DVATIPROC glad_glNormalStream3dvATI;

typedef void ( * PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC)(GLenum stream);
extern PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC glad_glClientActiveVertexStreamATI;

typedef void ( * PFNGLVERTEXBLENDENVIATIPROC)(GLenum pname, GLint param);
extern PFNGLVERTEXBLENDENVIATIPROC glad_glVertexBlendEnviATI;

typedef void ( * PFNGLVERTEXBLENDENVFATIPROC)(GLenum pname, GLfloat param);
extern PFNGLVERTEXBLENDENVFATIPROC glad_glVertexBlendEnvfATI;




extern int GLAD_GL_EXT_422_pixels;



extern int GLAD_GL_EXT_EGL_image_storage;
typedef void ( * PFNGLEGLIMAGETARGETTEXSTORAGEEXTPROC)(GLenum target, GLeglImageOES image, const GLint* attrib_list);
extern PFNGLEGLIMAGETARGETTEXSTORAGEEXTPROC glad_glEGLImageTargetTexStorageEXT;

typedef void ( * PFNGLEGLIMAGETARGETTEXTURESTORAGEEXTPROC)(GLuint texture, GLeglImageOES image, const GLint* attrib_list);
extern PFNGLEGLIMAGETARGETTEXTURESTORAGEEXTPROC glad_glEGLImageTargetTextureStorageEXT;




extern int GLAD_GL_EXT_EGL_sync;



extern int GLAD_GL_EXT_abgr;



extern int GLAD_GL_EXT_bgra;



extern int GLAD_GL_EXT_bindable_uniform;
typedef void ( * PFNGLUNIFORMBUFFEREXTPROC)(GLuint program, GLint location, GLuint buffer);
extern PFNGLUNIFORMBUFFEREXTPROC glad_glUniformBufferEXT;

typedef GLint ( * PFNGLGETUNIFORMBUFFERSIZEEXTPROC)(GLuint program, GLint location);
extern PFNGLGETUNIFORMBUFFERSIZEEXTPROC glad_glGetUniformBufferSizeEXT;

typedef GLintptr ( * PFNGLGETUNIFORMOFFSETEXTPROC)(GLuint program, GLint location);
extern PFNGLGETUNIFORMOFFSETEXTPROC glad_glGetUniformOffsetEXT;




extern int GLAD_GL_EXT_blend_color;
typedef void ( * PFNGLBLENDCOLOREXTPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern PFNGLBLENDCOLOREXTPROC glad_glBlendColorEXT;




extern int GLAD_GL_EXT_blend_equation_separate;
typedef void ( * PFNGLBLENDEQUATIONSEPARATEEXTPROC)(GLenum modeRGB, GLenum modeAlpha);
extern PFNGLBLENDEQUATIONSEPARATEEXTPROC glad_glBlendEquationSeparateEXT;




extern int GLAD_GL_EXT_blend_func_separate;
typedef void ( * PFNGLBLENDFUNCSEPARATEEXTPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
extern PFNGLBLENDFUNCSEPARATEEXTPROC glad_glBlendFuncSeparateEXT;




extern int GLAD_GL_EXT_blend_logic_op;



extern int GLAD_GL_EXT_blend_minmax;
typedef void ( * PFNGLBLENDEQUATIONEXTPROC)(GLenum mode);
extern PFNGLBLENDEQUATIONEXTPROC glad_glBlendEquationEXT;




extern int GLAD_GL_EXT_blend_subtract;



extern int GLAD_GL_EXT_clip_volume_hint;



extern int GLAD_GL_EXT_cmyka;



extern int GLAD_GL_EXT_color_subtable;
typedef void ( * PFNGLCOLORSUBTABLEEXTPROC)(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
extern PFNGLCOLORSUBTABLEEXTPROC glad_glColorSubTableEXT;

typedef void ( * PFNGLCOPYCOLORSUBTABLEEXTPROC)(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
extern PFNGLCOPYCOLORSUBTABLEEXTPROC glad_glCopyColorSubTableEXT;




extern int GLAD_GL_EXT_compiled_vertex_array;
typedef void ( * PFNGLLOCKARRAYSEXTPROC)(GLint first, GLsizei count);
extern PFNGLLOCKARRAYSEXTPROC glad_glLockArraysEXT;

typedef void ( * PFNGLUNLOCKARRAYSEXTPROC)(void);
extern PFNGLUNLOCKARRAYSEXTPROC glad_glUnlockArraysEXT;




extern int GLAD_GL_EXT_convolution;
typedef void ( * PFNGLCONVOLUTIONFILTER1DEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
extern PFNGLCONVOLUTIONFILTER1DEXTPROC glad_glConvolutionFilter1DEXT;

typedef void ( * PFNGLCONVOLUTIONFILTER2DEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
extern PFNGLCONVOLUTIONFILTER2DEXTPROC glad_glConvolutionFilter2DEXT;

typedef void ( * PFNGLCONVOLUTIONPARAMETERFEXTPROC)(GLenum target, GLenum pname, GLfloat params);
extern PFNGLCONVOLUTIONPARAMETERFEXTPROC glad_glConvolutionParameterfEXT;

typedef void ( * PFNGLCONVOLUTIONPARAMETERFVEXTPROC)(GLenum target, GLenum pname, const GLfloat *params);
extern PFNGLCONVOLUTIONPARAMETERFVEXTPROC glad_glConvolutionParameterfvEXT;

typedef void ( * PFNGLCONVOLUTIONPARAMETERIEXTPROC)(GLenum target, GLenum pname, GLint params);
extern PFNGLCONVOLUTIONPARAMETERIEXTPROC glad_glConvolutionParameteriEXT;

typedef void ( * PFNGLCONVOLUTIONPARAMETERIVEXTPROC)(GLenum target, GLenum pname, const GLint *params);
extern PFNGLCONVOLUTIONPARAMETERIVEXTPROC glad_glConvolutionParameterivEXT;

typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC glad_glCopyConvolutionFilter1DEXT;

typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC glad_glCopyConvolutionFilter2DEXT;

typedef void ( * PFNGLGETCONVOLUTIONFILTEREXTPROC)(GLenum target, GLenum format, GLenum type, void *image);
extern PFNGLGETCONVOLUTIONFILTEREXTPROC glad_glGetConvolutionFilterEXT;

typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC glad_glGetConvolutionParameterfvEXT;

typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC glad_glGetConvolutionParameterivEXT;

typedef void ( * PFNGLGETSEPARABLEFILTEREXTPROC)(GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
extern PFNGLGETSEPARABLEFILTEREXTPROC glad_glGetSeparableFilterEXT;

typedef void ( * PFNGLSEPARABLEFILTER2DEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);
extern PFNGLSEPARABLEFILTER2DEXTPROC glad_glSeparableFilter2DEXT;




extern int GLAD_GL_EXT_coordinate_frame;
typedef void ( * PFNGLTANGENT3BEXTPROC)(GLbyte tx, GLbyte ty, GLbyte tz);
extern PFNGLTANGENT3BEXTPROC glad_glTangent3bEXT;

typedef void ( * PFNGLTANGENT3BVEXTPROC)(const GLbyte *v);
extern PFNGLTANGENT3BVEXTPROC glad_glTangent3bvEXT;

typedef void ( * PFNGLTANGENT3DEXTPROC)(GLdouble tx, GLdouble ty, GLdouble tz);
extern PFNGLTANGENT3DEXTPROC glad_glTangent3dEXT;

typedef void ( * PFNGLTANGENT3DVEXTPROC)(const GLdouble *v);
extern PFNGLTANGENT3DVEXTPROC glad_glTangent3dvEXT;

typedef void ( * PFNGLTANGENT3FEXTPROC)(GLfloat tx, GLfloat ty, GLfloat tz);
extern PFNGLTANGENT3FEXTPROC glad_glTangent3fEXT;

typedef void ( * PFNGLTANGENT3FVEXTPROC)(const GLfloat *v);
extern PFNGLTANGENT3FVEXTPROC glad_glTangent3fvEXT;

typedef void ( * PFNGLTANGENT3IEXTPROC)(GLint tx, GLint ty, GLint tz);
extern PFNGLTANGENT3IEXTPROC glad_glTangent3iEXT;

typedef void ( * PFNGLTANGENT3IVEXTPROC)(const GLint *v);
extern PFNGLTANGENT3IVEXTPROC glad_glTangent3ivEXT;

typedef void ( * PFNGLTANGENT3SEXTPROC)(GLshort tx, GLshort ty, GLshort tz);
extern PFNGLTANGENT3SEXTPROC glad_glTangent3sEXT;

typedef void ( * PFNGLTANGENT3SVEXTPROC)(const GLshort *v);
extern PFNGLTANGENT3SVEXTPROC glad_glTangent3svEXT;

typedef void ( * PFNGLBINORMAL3BEXTPROC)(GLbyte bx, GLbyte by, GLbyte bz);
extern PFNGLBINORMAL3BEXTPROC glad_glBinormal3bEXT;

typedef void ( * PFNGLBINORMAL3BVEXTPROC)(const GLbyte *v);
extern PFNGLBINORMAL3BVEXTPROC glad_glBinormal3bvEXT;

typedef void ( * PFNGLBINORMAL3DEXTPROC)(GLdouble bx, GLdouble by, GLdouble bz);
extern PFNGLBINORMAL3DEXTPROC glad_glBinormal3dEXT;

typedef void ( * PFNGLBINORMAL3DVEXTPROC)(const GLdouble *v);
extern PFNGLBINORMAL3DVEXTPROC glad_glBinormal3dvEXT;

typedef void ( * PFNGLBINORMAL3FEXTPROC)(GLfloat bx, GLfloat by, GLfloat bz);
extern PFNGLBINORMAL3FEXTPROC glad_glBinormal3fEXT;

typedef void ( * PFNGLBINORMAL3FVEXTPROC)(const GLfloat *v);
extern PFNGLBINORMAL3FVEXTPROC glad_glBinormal3fvEXT;

typedef void ( * PFNGLBINORMAL3IEXTPROC)(GLint bx, GLint by, GLint bz);
extern PFNGLBINORMAL3IEXTPROC glad_glBinormal3iEXT;

typedef void ( * PFNGLBINORMAL3IVEXTPROC)(const GLint *v);
extern PFNGLBINORMAL3IVEXTPROC glad_glBinormal3ivEXT;

typedef void ( * PFNGLBINORMAL3SEXTPROC)(GLshort bx, GLshort by, GLshort bz);
extern PFNGLBINORMAL3SEXTPROC glad_glBinormal3sEXT;

typedef void ( * PFNGLBINORMAL3SVEXTPROC)(const GLshort *v);
extern PFNGLBINORMAL3SVEXTPROC glad_glBinormal3svEXT;

typedef void ( * PFNGLTANGENTPOINTEREXTPROC)(GLenum type, GLsizei stride, const void *pointer);
extern PFNGLTANGENTPOINTEREXTPROC glad_glTangentPointerEXT;

typedef void ( * PFNGLBINORMALPOINTEREXTPROC)(GLenum type, GLsizei stride, const void *pointer);
extern PFNGLBINORMALPOINTEREXTPROC glad_glBinormalPointerEXT;




extern int GLAD_GL_EXT_copy_texture;
typedef void ( * PFNGLCOPYTEXIMAGE1DEXTPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
extern PFNGLCOPYTEXIMAGE1DEXTPROC glad_glCopyTexImage1DEXT;

typedef void ( * PFNGLCOPYTEXIMAGE2DEXTPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern PFNGLCOPYTEXIMAGE2DEXTPROC glad_glCopyTexImage2DEXT;

typedef void ( * PFNGLCOPYTEXSUBIMAGE1DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern PFNGLCOPYTEXSUBIMAGE1DEXTPROC glad_glCopyTexSubImage1DEXT;

typedef void ( * PFNGLCOPYTEXSUBIMAGE2DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYTEXSUBIMAGE2DEXTPROC glad_glCopyTexSubImage2DEXT;

typedef void ( * PFNGLCOPYTEXSUBIMAGE3DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYTEXSUBIMAGE3DEXTPROC glad_glCopyTexSubImage3DEXT;




extern int GLAD_GL_EXT_cull_vertex;
typedef void ( * PFNGLCULLPARAMETERDVEXTPROC)(GLenum pname, GLdouble *params);
extern PFNGLCULLPARAMETERDVEXTPROC glad_glCullParameterdvEXT;

typedef void ( * PFNGLCULLPARAMETERFVEXTPROC)(GLenum pname, GLfloat *params);
extern PFNGLCULLPARAMETERFVEXTPROC glad_glCullParameterfvEXT;




extern int GLAD_GL_EXT_debug_label;
typedef void ( * PFNGLLABELOBJECTEXTPROC)(GLenum type, GLuint object, GLsizei length, const GLchar *label);
extern PFNGLLABELOBJECTEXTPROC glad_glLabelObjectEXT;

typedef void ( * PFNGLGETOBJECTLABELEXTPROC)(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label);
extern PFNGLGETOBJECTLABELEXTPROC glad_glGetObjectLabelEXT;




extern int GLAD_GL_EXT_debug_marker;
typedef void ( * PFNGLINSERTEVENTMARKEREXTPROC)(GLsizei length, const GLchar *marker);
extern PFNGLINSERTEVENTMARKEREXTPROC glad_glInsertEventMarkerEXT;

typedef void ( * PFNGLPUSHGROUPMARKEREXTPROC)(GLsizei length, const GLchar *marker);
extern PFNGLPUSHGROUPMARKEREXTPROC glad_glPushGroupMarkerEXT;

typedef void ( * PFNGLPOPGROUPMARKEREXTPROC)(void);
extern PFNGLPOPGROUPMARKEREXTPROC glad_glPopGroupMarkerEXT;




extern int GLAD_GL_EXT_depth_bounds_test;
typedef void ( * PFNGLDEPTHBOUNDSEXTPROC)(GLclampd zmin, GLclampd zmax);
extern PFNGLDEPTHBOUNDSEXTPROC glad_glDepthBoundsEXT;




extern int GLAD_GL_EXT_direct_state_access;
typedef void ( * PFNGLMATRIXLOADFEXTPROC)(GLenum mode, const GLfloat *m);
extern PFNGLMATRIXLOADFEXTPROC glad_glMatrixLoadfEXT;

typedef void ( * PFNGLMATRIXLOADDEXTPROC)(GLenum mode, const GLdouble *m);
extern PFNGLMATRIXLOADDEXTPROC glad_glMatrixLoaddEXT;

typedef void ( * PFNGLMATRIXMULTFEXTPROC)(GLenum mode, const GLfloat *m);
extern PFNGLMATRIXMULTFEXTPROC glad_glMatrixMultfEXT;

typedef void ( * PFNGLMATRIXMULTDEXTPROC)(GLenum mode, const GLdouble *m);
extern PFNGLMATRIXMULTDEXTPROC glad_glMatrixMultdEXT;

typedef void ( * PFNGLMATRIXLOADIDENTITYEXTPROC)(GLenum mode);
extern PFNGLMATRIXLOADIDENTITYEXTPROC glad_glMatrixLoadIdentityEXT;

typedef void ( * PFNGLMATRIXROTATEFEXTPROC)(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLMATRIXROTATEFEXTPROC glad_glMatrixRotatefEXT;

typedef void ( * PFNGLMATRIXROTATEDEXTPROC)(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
extern PFNGLMATRIXROTATEDEXTPROC glad_glMatrixRotatedEXT;

typedef void ( * PFNGLMATRIXSCALEFEXTPROC)(GLenum mode, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLMATRIXSCALEFEXTPROC glad_glMatrixScalefEXT;

typedef void ( * PFNGLMATRIXSCALEDEXTPROC)(GLenum mode, GLdouble x, GLdouble y, GLdouble z);
extern PFNGLMATRIXSCALEDEXTPROC glad_glMatrixScaledEXT;

typedef void ( * PFNGLMATRIXTRANSLATEFEXTPROC)(GLenum mode, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLMATRIXTRANSLATEFEXTPROC glad_glMatrixTranslatefEXT;

typedef void ( * PFNGLMATRIXTRANSLATEDEXTPROC)(GLenum mode, GLdouble x, GLdouble y, GLdouble z);
extern PFNGLMATRIXTRANSLATEDEXTPROC glad_glMatrixTranslatedEXT;

typedef void ( * PFNGLMATRIXFRUSTUMEXTPROC)(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern PFNGLMATRIXFRUSTUMEXTPROC glad_glMatrixFrustumEXT;

typedef void ( * PFNGLMATRIXORTHOEXTPROC)(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern PFNGLMATRIXORTHOEXTPROC glad_glMatrixOrthoEXT;

typedef void ( * PFNGLMATRIXPOPEXTPROC)(GLenum mode);
extern PFNGLMATRIXPOPEXTPROC glad_glMatrixPopEXT;

typedef void ( * PFNGLMATRIXPUSHEXTPROC)(GLenum mode);
extern PFNGLMATRIXPUSHEXTPROC glad_glMatrixPushEXT;

typedef void ( * PFNGLCLIENTATTRIBDEFAULTEXTPROC)(GLbitfield mask);
extern PFNGLCLIENTATTRIBDEFAULTEXTPROC glad_glClientAttribDefaultEXT;

typedef void ( * PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC)(GLbitfield mask);
extern PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC glad_glPushClientAttribDefaultEXT;

typedef void ( * PFNGLTEXTUREPARAMETERFEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLfloat param);
extern PFNGLTEXTUREPARAMETERFEXTPROC glad_glTextureParameterfEXT;

typedef void ( * PFNGLTEXTUREPARAMETERFVEXTPROC)(GLuint texture, GLenum target, GLenum pname, const GLfloat *params);
extern PFNGLTEXTUREPARAMETERFVEXTPROC glad_glTextureParameterfvEXT;

typedef void ( * PFNGLTEXTUREPARAMETERIEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLint param);
extern PFNGLTEXTUREPARAMETERIEXTPROC glad_glTextureParameteriEXT;

typedef void ( * PFNGLTEXTUREPARAMETERIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, const GLint *params);
extern PFNGLTEXTUREPARAMETERIVEXTPROC glad_glTextureParameterivEXT;

typedef void ( * PFNGLTEXTUREIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXTUREIMAGE1DEXTPROC glad_glTextureImage1DEXT;

typedef void ( * PFNGLTEXTUREIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXTUREIMAGE2DEXTPROC glad_glTextureImage2DEXT;

typedef void ( * PFNGLTEXTURESUBIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXTURESUBIMAGE1DEXTPROC glad_glTextureSubImage1DEXT;

typedef void ( * PFNGLTEXTURESUBIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXTURESUBIMAGE2DEXTPROC glad_glTextureSubImage2DEXT;

typedef void ( * PFNGLCOPYTEXTUREIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
extern PFNGLCOPYTEXTUREIMAGE1DEXTPROC glad_glCopyTextureImage1DEXT;

typedef void ( * PFNGLCOPYTEXTUREIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern PFNGLCOPYTEXTUREIMAGE2DEXTPROC glad_glCopyTextureImage2DEXT;

typedef void ( * PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC glad_glCopyTextureSubImage1DEXT;

typedef void ( * PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC glad_glCopyTextureSubImage2DEXT;

typedef void ( * PFNGLGETTEXTUREIMAGEEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
extern PFNGLGETTEXTUREIMAGEEXTPROC glad_glGetTextureImageEXT;

typedef void ( * PFNGLGETTEXTUREPARAMETERFVEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETTEXTUREPARAMETERFVEXTPROC glad_glGetTextureParameterfvEXT;

typedef void ( * PFNGLGETTEXTUREPARAMETERIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLint *params);
extern PFNGLGETTEXTUREPARAMETERIVEXTPROC glad_glGetTextureParameterivEXT;

typedef void ( * PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params);
extern PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC glad_glGetTextureLevelParameterfvEXT;

typedef void ( * PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params);
extern PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC glad_glGetTextureLevelParameterivEXT;

typedef void ( * PFNGLTEXTUREIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXTUREIMAGE3DEXTPROC glad_glTextureImage3DEXT;

typedef void ( * PFNGLTEXTURESUBIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXTURESUBIMAGE3DEXTPROC glad_glTextureSubImage3DEXT;

typedef void ( * PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC glad_glCopyTextureSubImage3DEXT;

typedef void ( * PFNGLBINDMULTITEXTUREEXTPROC)(GLenum texunit, GLenum target, GLuint texture);
extern PFNGLBINDMULTITEXTUREEXTPROC glad_glBindMultiTextureEXT;

typedef void ( * PFNGLMULTITEXCOORDPOINTEREXTPROC)(GLenum texunit, GLint size, GLenum type, GLsizei stride, const void *pointer);
extern PFNGLMULTITEXCOORDPOINTEREXTPROC glad_glMultiTexCoordPointerEXT;

typedef void ( * PFNGLMULTITEXENVFEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLfloat param);
extern PFNGLMULTITEXENVFEXTPROC glad_glMultiTexEnvfEXT;

typedef void ( * PFNGLMULTITEXENVFVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLfloat *params);
extern PFNGLMULTITEXENVFVEXTPROC glad_glMultiTexEnvfvEXT;

typedef void ( * PFNGLMULTITEXENVIEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint param);
extern PFNGLMULTITEXENVIEXTPROC glad_glMultiTexEnviEXT;

typedef void ( * PFNGLMULTITEXENVIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLint *params);
extern PFNGLMULTITEXENVIVEXTPROC glad_glMultiTexEnvivEXT;

typedef void ( * PFNGLMULTITEXGENDEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
extern PFNGLMULTITEXGENDEXTPROC glad_glMultiTexGendEXT;

typedef void ( * PFNGLMULTITEXGENDVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params);
extern PFNGLMULTITEXGENDVEXTPROC glad_glMultiTexGendvEXT;

typedef void ( * PFNGLMULTITEXGENFEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
extern PFNGLMULTITEXGENFEXTPROC glad_glMultiTexGenfEXT;

typedef void ( * PFNGLMULTITEXGENFVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params);
extern PFNGLMULTITEXGENFVEXTPROC glad_glMultiTexGenfvEXT;

typedef void ( * PFNGLMULTITEXGENIEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLint param);
extern PFNGLMULTITEXGENIEXTPROC glad_glMultiTexGeniEXT;

typedef void ( * PFNGLMULTITEXGENIVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, const GLint *params);
extern PFNGLMULTITEXGENIVEXTPROC glad_glMultiTexGenivEXT;

typedef void ( * PFNGLGETMULTITEXENVFVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETMULTITEXENVFVEXTPROC glad_glGetMultiTexEnvfvEXT;

typedef void ( * PFNGLGETMULTITEXENVIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint *params);
extern PFNGLGETMULTITEXENVIVEXTPROC glad_glGetMultiTexEnvivEXT;

typedef void ( * PFNGLGETMULTITEXGENDVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLdouble *params);
extern PFNGLGETMULTITEXGENDVEXTPROC glad_glGetMultiTexGendvEXT;

typedef void ( * PFNGLGETMULTITEXGENFVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLfloat *params);
extern PFNGLGETMULTITEXGENFVEXTPROC glad_glGetMultiTexGenfvEXT;

typedef void ( * PFNGLGETMULTITEXGENIVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLint *params);
extern PFNGLGETMULTITEXGENIVEXTPROC glad_glGetMultiTexGenivEXT;

typedef void ( * PFNGLMULTITEXPARAMETERIEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint param);
extern PFNGLMULTITEXPARAMETERIEXTPROC glad_glMultiTexParameteriEXT;

typedef void ( * PFNGLMULTITEXPARAMETERIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLint *params);
extern PFNGLMULTITEXPARAMETERIVEXTPROC glad_glMultiTexParameterivEXT;

typedef void ( * PFNGLMULTITEXPARAMETERFEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLfloat param);
extern PFNGLMULTITEXPARAMETERFEXTPROC glad_glMultiTexParameterfEXT;

typedef void ( * PFNGLMULTITEXPARAMETERFVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLfloat *params);
extern PFNGLMULTITEXPARAMETERFVEXTPROC glad_glMultiTexParameterfvEXT;

typedef void ( * PFNGLMULTITEXIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
extern PFNGLMULTITEXIMAGE1DEXTPROC glad_glMultiTexImage1DEXT;

typedef void ( * PFNGLMULTITEXIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
extern PFNGLMULTITEXIMAGE2DEXTPROC glad_glMultiTexImage2DEXT;

typedef void ( * PFNGLMULTITEXSUBIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
extern PFNGLMULTITEXSUBIMAGE1DEXTPROC glad_glMultiTexSubImage1DEXT;

typedef void ( * PFNGLMULTITEXSUBIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
extern PFNGLMULTITEXSUBIMAGE2DEXTPROC glad_glMultiTexSubImage2DEXT;

typedef void ( * PFNGLCOPYMULTITEXIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
extern PFNGLCOPYMULTITEXIMAGE1DEXTPROC glad_glCopyMultiTexImage1DEXT;

typedef void ( * PFNGLCOPYMULTITEXIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern PFNGLCOPYMULTITEXIMAGE2DEXTPROC glad_glCopyMultiTexImage2DEXT;

typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC glad_glCopyMultiTexSubImage1DEXT;

typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC glad_glCopyMultiTexSubImage2DEXT;

typedef void ( * PFNGLGETMULTITEXIMAGEEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
extern PFNGLGETMULTITEXIMAGEEXTPROC glad_glGetMultiTexImageEXT;

typedef void ( * PFNGLGETMULTITEXPARAMETERFVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETMULTITEXPARAMETERFVEXTPROC glad_glGetMultiTexParameterfvEXT;

typedef void ( * PFNGLGETMULTITEXPARAMETERIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint *params);
extern PFNGLGETMULTITEXPARAMETERIVEXTPROC glad_glGetMultiTexParameterivEXT;

typedef void ( * PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params);
extern PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC glad_glGetMultiTexLevelParameterfvEXT;

typedef void ( * PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params);
extern PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC glad_glGetMultiTexLevelParameterivEXT;

typedef void ( * PFNGLMULTITEXIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
extern PFNGLMULTITEXIMAGE3DEXTPROC glad_glMultiTexImage3DEXT;

typedef void ( * PFNGLMULTITEXSUBIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
extern PFNGLMULTITEXSUBIMAGE3DEXTPROC glad_glMultiTexSubImage3DEXT;

typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC glad_glCopyMultiTexSubImage3DEXT;

typedef void ( * PFNGLENABLECLIENTSTATEINDEXEDEXTPROC)(GLenum array, GLuint index);
extern PFNGLENABLECLIENTSTATEINDEXEDEXTPROC glad_glEnableClientStateIndexedEXT;

typedef void ( * PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC)(GLenum array, GLuint index);
extern PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC glad_glDisableClientStateIndexedEXT;

typedef void ( * PFNGLGETFLOATINDEXEDVEXTPROC)(GLenum target, GLuint index, GLfloat *data);
extern PFNGLGETFLOATINDEXEDVEXTPROC glad_glGetFloatIndexedvEXT;

typedef void ( * PFNGLGETDOUBLEINDEXEDVEXTPROC)(GLenum target, GLuint index, GLdouble *data);
extern PFNGLGETDOUBLEINDEXEDVEXTPROC glad_glGetDoubleIndexedvEXT;

typedef void ( * PFNGLGETPOINTERINDEXEDVEXTPROC)(GLenum target, GLuint index, void **data);
extern PFNGLGETPOINTERINDEXEDVEXTPROC glad_glGetPointerIndexedvEXT;

typedef void ( * PFNGLENABLEINDEXEDEXTPROC)(GLenum target, GLuint index);
extern PFNGLENABLEINDEXEDEXTPROC glad_glEnableIndexedEXT;

typedef void ( * PFNGLDISABLEINDEXEDEXTPROC)(GLenum target, GLuint index);
extern PFNGLDISABLEINDEXEDEXTPROC glad_glDisableIndexedEXT;

typedef GLboolean ( * PFNGLISENABLEDINDEXEDEXTPROC)(GLenum target, GLuint index);
extern PFNGLISENABLEDINDEXEDEXTPROC glad_glIsEnabledIndexedEXT;

typedef void ( * PFNGLGETINTEGERINDEXEDVEXTPROC)(GLenum target, GLuint index, GLint *data);
extern PFNGLGETINTEGERINDEXEDVEXTPROC glad_glGetIntegerIndexedvEXT;

typedef void ( * PFNGLGETBOOLEANINDEXEDVEXTPROC)(GLenum target, GLuint index, GLboolean *data);
extern PFNGLGETBOOLEANINDEXEDVEXTPROC glad_glGetBooleanIndexedvEXT;

typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *bits);
extern PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC glad_glCompressedTextureImage3DEXT;

typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *bits);
extern PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC glad_glCompressedTextureImage2DEXT;

typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *bits);
extern PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC glad_glCompressedTextureImage1DEXT;

typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *bits);
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC glad_glCompressedTextureSubImage3DEXT;

typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *bits);
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC glad_glCompressedTextureSubImage2DEXT;

typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *bits);
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC glad_glCompressedTextureSubImage1DEXT;

typedef void ( * PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC)(GLuint texture, GLenum target, GLint lod, void *img);
extern PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC glad_glGetCompressedTextureImageEXT;

typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *bits);
extern PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC glad_glCompressedMultiTexImage3DEXT;

typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *bits);
extern PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC glad_glCompressedMultiTexImage2DEXT;

typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *bits);
extern PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC glad_glCompressedMultiTexImage1DEXT;

typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *bits);
extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC glad_glCompressedMultiTexSubImage3DEXT;

typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *bits);
extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC glad_glCompressedMultiTexSubImage2DEXT;

typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *bits);
extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC glad_glCompressedMultiTexSubImage1DEXT;

typedef void ( * PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC)(GLenum texunit, GLenum target, GLint lod, void *img);
extern PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC glad_glGetCompressedMultiTexImageEXT;

typedef void ( * PFNGLMATRIXLOADTRANSPOSEFEXTPROC)(GLenum mode, const GLfloat *m);
extern PFNGLMATRIXLOADTRANSPOSEFEXTPROC glad_glMatrixLoadTransposefEXT;

typedef void ( * PFNGLMATRIXLOADTRANSPOSEDEXTPROC)(GLenum mode, const GLdouble *m);
extern PFNGLMATRIXLOADTRANSPOSEDEXTPROC glad_glMatrixLoadTransposedEXT;

typedef void ( * PFNGLMATRIXMULTTRANSPOSEFEXTPROC)(GLenum mode, const GLfloat *m);
extern PFNGLMATRIXMULTTRANSPOSEFEXTPROC glad_glMatrixMultTransposefEXT;

typedef void ( * PFNGLMATRIXMULTTRANSPOSEDEXTPROC)(GLenum mode, const GLdouble *m);
extern PFNGLMATRIXMULTTRANSPOSEDEXTPROC glad_glMatrixMultTransposedEXT;

typedef void ( * PFNGLNAMEDBUFFERDATAEXTPROC)(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
extern PFNGLNAMEDBUFFERDATAEXTPROC glad_glNamedBufferDataEXT;

typedef void ( * PFNGLNAMEDBUFFERSUBDATAEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
extern PFNGLNAMEDBUFFERSUBDATAEXTPROC glad_glNamedBufferSubDataEXT;

typedef void * ( * PFNGLMAPNAMEDBUFFEREXTPROC)(GLuint buffer, GLenum access);
extern PFNGLMAPNAMEDBUFFEREXTPROC glad_glMapNamedBufferEXT;

typedef GLboolean ( * PFNGLUNMAPNAMEDBUFFEREXTPROC)(GLuint buffer);
extern PFNGLUNMAPNAMEDBUFFEREXTPROC glad_glUnmapNamedBufferEXT;

typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC)(GLuint buffer, GLenum pname, GLint *params);
extern PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC glad_glGetNamedBufferParameterivEXT;

typedef void ( * PFNGLGETNAMEDBUFFERPOINTERVEXTPROC)(GLuint buffer, GLenum pname, void **params);
extern PFNGLGETNAMEDBUFFERPOINTERVEXTPROC glad_glGetNamedBufferPointervEXT;

typedef void ( * PFNGLGETNAMEDBUFFERSUBDATAEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
extern PFNGLGETNAMEDBUFFERSUBDATAEXTPROC glad_glGetNamedBufferSubDataEXT;

typedef void ( * PFNGLPROGRAMUNIFORM1FEXTPROC)(GLuint program, GLint location, GLfloat v0);
extern PFNGLPROGRAMUNIFORM1FEXTPROC glad_glProgramUniform1fEXT;

typedef void ( * PFNGLPROGRAMUNIFORM2FEXTPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1);
extern PFNGLPROGRAMUNIFORM2FEXTPROC glad_glProgramUniform2fEXT;

typedef void ( * PFNGLPROGRAMUNIFORM3FEXTPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern PFNGLPROGRAMUNIFORM3FEXTPROC glad_glProgramUniform3fEXT;

typedef void ( * PFNGLPROGRAMUNIFORM4FEXTPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern PFNGLPROGRAMUNIFORM4FEXTPROC glad_glProgramUniform4fEXT;

typedef void ( * PFNGLPROGRAMUNIFORM1IEXTPROC)(GLuint program, GLint location, GLint v0);
extern PFNGLPROGRAMUNIFORM1IEXTPROC glad_glProgramUniform1iEXT;

typedef void ( * PFNGLPROGRAMUNIFORM2IEXTPROC)(GLuint program, GLint location, GLint v0, GLint v1);
extern PFNGLPROGRAMUNIFORM2IEXTPROC glad_glProgramUniform2iEXT;

typedef void ( * PFNGLPROGRAMUNIFORM3IEXTPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
extern PFNGLPROGRAMUNIFORM3IEXTPROC glad_glProgramUniform3iEXT;

typedef void ( * PFNGLPROGRAMUNIFORM4IEXTPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern PFNGLPROGRAMUNIFORM4IEXTPROC glad_glProgramUniform4iEXT;

typedef void ( * PFNGLPROGRAMUNIFORM1FVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
extern PFNGLPROGRAMUNIFORM1FVEXTPROC glad_glProgramUniform1fvEXT;

typedef void ( * PFNGLPROGRAMUNIFORM2FVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
extern PFNGLPROGRAMUNIFORM2FVEXTPROC glad_glProgramUniform2fvEXT;

typedef void ( * PFNGLPROGRAMUNIFORM3FVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
extern PFNGLPROGRAMUNIFORM3FVEXTPROC glad_glProgramUniform3fvEXT;

typedef void ( * PFNGLPROGRAMUNIFORM4FVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
extern PFNGLPROGRAMUNIFORM4FVEXTPROC glad_glProgramUniform4fvEXT;

typedef void ( * PFNGLPROGRAMUNIFORM1IVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
extern PFNGLPROGRAMUNIFORM1IVEXTPROC glad_glProgramUniform1ivEXT;

typedef void ( * PFNGLPROGRAMUNIFORM2IVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
extern PFNGLPROGRAMUNIFORM2IVEXTPROC glad_glProgramUniform2ivEXT;

typedef void ( * PFNGLPROGRAMUNIFORM3IVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
extern PFNGLPROGRAMUNIFORM3IVEXTPROC glad_glProgramUniform3ivEXT;

typedef void ( * PFNGLPROGRAMUNIFORM4IVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLint *value);
extern PFNGLPROGRAMUNIFORM4IVEXTPROC glad_glProgramUniform4ivEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC glad_glProgramUniformMatrix2fvEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC glad_glProgramUniformMatrix3fvEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC glad_glProgramUniformMatrix4fvEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC glad_glProgramUniformMatrix2x3fvEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC glad_glProgramUniformMatrix3x2fvEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC glad_glProgramUniformMatrix2x4fvEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC glad_glProgramUniformMatrix4x2fvEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC glad_glProgramUniformMatrix3x4fvEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC glad_glProgramUniformMatrix4x3fvEXT;

typedef void ( * PFNGLTEXTUREBUFFEREXTPROC)(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
extern PFNGLTEXTUREBUFFEREXTPROC glad_glTextureBufferEXT;

typedef void ( * PFNGLMULTITEXBUFFEREXTPROC)(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
extern PFNGLMULTITEXBUFFEREXTPROC glad_glMultiTexBufferEXT;

typedef void ( * PFNGLTEXTUREPARAMETERIIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, const GLint *params);
extern PFNGLTEXTUREPARAMETERIIVEXTPROC glad_glTextureParameterIivEXT;

typedef void ( * PFNGLTEXTUREPARAMETERIUIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, const GLuint *params);
extern PFNGLTEXTUREPARAMETERIUIVEXTPROC glad_glTextureParameterIuivEXT;

typedef void ( * PFNGLGETTEXTUREPARAMETERIIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLint *params);
extern PFNGLGETTEXTUREPARAMETERIIVEXTPROC glad_glGetTextureParameterIivEXT;

typedef void ( * PFNGLGETTEXTUREPARAMETERIUIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLuint *params);
extern PFNGLGETTEXTUREPARAMETERIUIVEXTPROC glad_glGetTextureParameterIuivEXT;

typedef void ( * PFNGLMULTITEXPARAMETERIIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLint *params);
extern PFNGLMULTITEXPARAMETERIIVEXTPROC glad_glMultiTexParameterIivEXT;

typedef void ( * PFNGLMULTITEXPARAMETERIUIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLuint *params);
extern PFNGLMULTITEXPARAMETERIUIVEXTPROC glad_glMultiTexParameterIuivEXT;

typedef void ( * PFNGLGETMULTITEXPARAMETERIIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint *params);
extern PFNGLGETMULTITEXPARAMETERIIVEXTPROC glad_glGetMultiTexParameterIivEXT;

typedef void ( * PFNGLGETMULTITEXPARAMETERIUIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLuint *params);
extern PFNGLGETMULTITEXPARAMETERIUIVEXTPROC glad_glGetMultiTexParameterIuivEXT;

typedef void ( * PFNGLPROGRAMUNIFORM1UIEXTPROC)(GLuint program, GLint location, GLuint v0);
extern PFNGLPROGRAMUNIFORM1UIEXTPROC glad_glProgramUniform1uiEXT;

typedef void ( * PFNGLPROGRAMUNIFORM2UIEXTPROC)(GLuint program, GLint location, GLuint v0, GLuint v1);
extern PFNGLPROGRAMUNIFORM2UIEXTPROC glad_glProgramUniform2uiEXT;

typedef void ( * PFNGLPROGRAMUNIFORM3UIEXTPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
extern PFNGLPROGRAMUNIFORM3UIEXTPROC glad_glProgramUniform3uiEXT;

typedef void ( * PFNGLPROGRAMUNIFORM4UIEXTPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
extern PFNGLPROGRAMUNIFORM4UIEXTPROC glad_glProgramUniform4uiEXT;

typedef void ( * PFNGLPROGRAMUNIFORM1UIVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
extern PFNGLPROGRAMUNIFORM1UIVEXTPROC glad_glProgramUniform1uivEXT;

typedef void ( * PFNGLPROGRAMUNIFORM2UIVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
extern PFNGLPROGRAMUNIFORM2UIVEXTPROC glad_glProgramUniform2uivEXT;

typedef void ( * PFNGLPROGRAMUNIFORM3UIVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
extern PFNGLPROGRAMUNIFORM3UIVEXTPROC glad_glProgramUniform3uivEXT;

typedef void ( * PFNGLPROGRAMUNIFORM4UIVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLuint *value);
extern PFNGLPROGRAMUNIFORM4UIVEXTPROC glad_glProgramUniform4uivEXT;

typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC)(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params);
extern PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC glad_glNamedProgramLocalParameters4fvEXT;

typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC)(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC glad_glNamedProgramLocalParameterI4iEXT;

typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC)(GLuint program, GLenum target, GLuint index, const GLint *params);
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC glad_glNamedProgramLocalParameterI4ivEXT;

typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC)(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params);
extern PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC glad_glNamedProgramLocalParametersI4ivEXT;

typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC)(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC glad_glNamedProgramLocalParameterI4uiEXT;

typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC)(GLuint program, GLenum target, GLuint index, const GLuint *params);
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC glad_glNamedProgramLocalParameterI4uivEXT;

typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC)(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params);
extern PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC glad_glNamedProgramLocalParametersI4uivEXT;

typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC)(GLuint program, GLenum target, GLuint index, GLint *params);
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC glad_glGetNamedProgramLocalParameterIivEXT;

typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC)(GLuint program, GLenum target, GLuint index, GLuint *params);
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC glad_glGetNamedProgramLocalParameterIuivEXT;

typedef void ( * PFNGLENABLECLIENTSTATEIEXTPROC)(GLenum array, GLuint index);
extern PFNGLENABLECLIENTSTATEIEXTPROC glad_glEnableClientStateiEXT;

typedef void ( * PFNGLDISABLECLIENTSTATEIEXTPROC)(GLenum array, GLuint index);
extern PFNGLDISABLECLIENTSTATEIEXTPROC glad_glDisableClientStateiEXT;

typedef void ( * PFNGLGETFLOATI_VEXTPROC)(GLenum pname, GLuint index, GLfloat *params);
extern PFNGLGETFLOATI_VEXTPROC glad_glGetFloati_vEXT;

typedef void ( * PFNGLGETDOUBLEI_VEXTPROC)(GLenum pname, GLuint index, GLdouble *params);
extern PFNGLGETDOUBLEI_VEXTPROC glad_glGetDoublei_vEXT;

typedef void ( * PFNGLGETPOINTERI_VEXTPROC)(GLenum pname, GLuint index, void **params);
extern PFNGLGETPOINTERI_VEXTPROC glad_glGetPointeri_vEXT;

typedef void ( * PFNGLNAMEDPROGRAMSTRINGEXTPROC)(GLuint program, GLenum target, GLenum format, GLsizei len, const void *string);
extern PFNGLNAMEDPROGRAMSTRINGEXTPROC glad_glNamedProgramStringEXT;

typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC)(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC glad_glNamedProgramLocalParameter4dEXT;

typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC)(GLuint program, GLenum target, GLuint index, const GLdouble *params);
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC glad_glNamedProgramLocalParameter4dvEXT;

typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC)(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC glad_glNamedProgramLocalParameter4fEXT;

typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC)(GLuint program, GLenum target, GLuint index, const GLfloat *params);
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC glad_glNamedProgramLocalParameter4fvEXT;

typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC)(GLuint program, GLenum target, GLuint index, GLdouble *params);
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC glad_glGetNamedProgramLocalParameterdvEXT;

typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC)(GLuint program, GLenum target, GLuint index, GLfloat *params);
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC glad_glGetNamedProgramLocalParameterfvEXT;

typedef void ( * PFNGLGETNAMEDPROGRAMIVEXTPROC)(GLuint program, GLenum target, GLenum pname, GLint *params);
extern PFNGLGETNAMEDPROGRAMIVEXTPROC glad_glGetNamedProgramivEXT;

typedef void ( * PFNGLGETNAMEDPROGRAMSTRINGEXTPROC)(GLuint program, GLenum target, GLenum pname, void *string);
extern PFNGLGETNAMEDPROGRAMSTRINGEXTPROC glad_glGetNamedProgramStringEXT;

typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC)(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC glad_glNamedRenderbufferStorageEXT;

typedef void ( * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC)(GLuint renderbuffer, GLenum pname, GLint *params);
extern PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC glad_glGetNamedRenderbufferParameterivEXT;

typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC)(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC glad_glNamedRenderbufferStorageMultisampleEXT;

typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC)(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC glad_glNamedRenderbufferStorageMultisampleCoverageEXT;

typedef GLenum ( * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC)(GLuint framebuffer, GLenum target);
extern PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC glad_glCheckNamedFramebufferStatusEXT;

typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC)(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC glad_glNamedFramebufferTexture1DEXT;

typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC)(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC glad_glNamedFramebufferTexture2DEXT;

typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC)(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
extern PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC glad_glNamedFramebufferTexture3DEXT;

typedef void ( * PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC)(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC glad_glNamedFramebufferRenderbufferEXT;

typedef void ( * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params);
extern PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC glad_glGetNamedFramebufferAttachmentParameterivEXT;

typedef void ( * PFNGLGENERATETEXTUREMIPMAPEXTPROC)(GLuint texture, GLenum target);
extern PFNGLGENERATETEXTUREMIPMAPEXTPROC glad_glGenerateTextureMipmapEXT;

typedef void ( * PFNGLGENERATEMULTITEXMIPMAPEXTPROC)(GLenum texunit, GLenum target);
extern PFNGLGENERATEMULTITEXMIPMAPEXTPROC glad_glGenerateMultiTexMipmapEXT;

typedef void ( * PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC)(GLuint framebuffer, GLenum mode);
extern PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC glad_glFramebufferDrawBufferEXT;

typedef void ( * PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC)(GLuint framebuffer, GLsizei n, const GLenum *bufs);
extern PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC glad_glFramebufferDrawBuffersEXT;

typedef void ( * PFNGLFRAMEBUFFERREADBUFFEREXTPROC)(GLuint framebuffer, GLenum mode);
extern PFNGLFRAMEBUFFERREADBUFFEREXTPROC glad_glFramebufferReadBufferEXT;

typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC)(GLuint framebuffer, GLenum pname, GLint *params);
extern PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC glad_glGetFramebufferParameterivEXT;

typedef void ( * PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC)(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
extern PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC glad_glNamedCopyBufferSubDataEXT;

typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
extern PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC glad_glNamedFramebufferTextureEXT;

typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
extern PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC glad_glNamedFramebufferTextureLayerEXT;

typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
extern PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC glad_glNamedFramebufferTextureFaceEXT;

typedef void ( * PFNGLTEXTURERENDERBUFFEREXTPROC)(GLuint texture, GLenum target, GLuint renderbuffer);
extern PFNGLTEXTURERENDERBUFFEREXTPROC glad_glTextureRenderbufferEXT;

typedef void ( * PFNGLMULTITEXRENDERBUFFEREXTPROC)(GLenum texunit, GLenum target, GLuint renderbuffer);
extern PFNGLMULTITEXRENDERBUFFEREXTPROC glad_glMultiTexRenderbufferEXT;

typedef void ( * PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
extern PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC glad_glVertexArrayVertexOffsetEXT;

typedef void ( * PFNGLVERTEXARRAYCOLOROFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
extern PFNGLVERTEXARRAYCOLOROFFSETEXTPROC glad_glVertexArrayColorOffsetEXT;

typedef void ( * PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset);
extern PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC glad_glVertexArrayEdgeFlagOffsetEXT;

typedef void ( * PFNGLVERTEXARRAYINDEXOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
extern PFNGLVERTEXARRAYINDEXOFFSETEXTPROC glad_glVertexArrayIndexOffsetEXT;

typedef void ( * PFNGLVERTEXARRAYNORMALOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
extern PFNGLVERTEXARRAYNORMALOFFSETEXTPROC glad_glVertexArrayNormalOffsetEXT;

typedef void ( * PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
extern PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC glad_glVertexArrayTexCoordOffsetEXT;

typedef void ( * PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset);
extern PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC glad_glVertexArrayMultiTexCoordOffsetEXT;

typedef void ( * PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
extern PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC glad_glVertexArrayFogCoordOffsetEXT;

typedef void ( * PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
extern PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC glad_glVertexArraySecondaryColorOffsetEXT;

typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
extern PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC glad_glVertexArrayVertexAttribOffsetEXT;

typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
extern PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC glad_glVertexArrayVertexAttribIOffsetEXT;

typedef void ( * PFNGLENABLEVERTEXARRAYEXTPROC)(GLuint vaobj, GLenum array);
extern PFNGLENABLEVERTEXARRAYEXTPROC glad_glEnableVertexArrayEXT;

typedef void ( * PFNGLDISABLEVERTEXARRAYEXTPROC)(GLuint vaobj, GLenum array);
extern PFNGLDISABLEVERTEXARRAYEXTPROC glad_glDisableVertexArrayEXT;

typedef void ( * PFNGLENABLEVERTEXARRAYATTRIBEXTPROC)(GLuint vaobj, GLuint index);
extern PFNGLENABLEVERTEXARRAYATTRIBEXTPROC glad_glEnableVertexArrayAttribEXT;

typedef void ( * PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC)(GLuint vaobj, GLuint index);
extern PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC glad_glDisableVertexArrayAttribEXT;

typedef void ( * PFNGLGETVERTEXARRAYINTEGERVEXTPROC)(GLuint vaobj, GLenum pname, GLint *param);
extern PFNGLGETVERTEXARRAYINTEGERVEXTPROC glad_glGetVertexArrayIntegervEXT;

typedef void ( * PFNGLGETVERTEXARRAYPOINTERVEXTPROC)(GLuint vaobj, GLenum pname, void **param);
extern PFNGLGETVERTEXARRAYPOINTERVEXTPROC glad_glGetVertexArrayPointervEXT;

typedef void ( * PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint *param);
extern PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC glad_glGetVertexArrayIntegeri_vEXT;

typedef void ( * PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC)(GLuint vaobj, GLuint index, GLenum pname, void **param);
extern PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC glad_glGetVertexArrayPointeri_vEXT;

typedef void * ( * PFNGLMAPNAMEDBUFFERRANGEEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
extern PFNGLMAPNAMEDBUFFERRANGEEXTPROC glad_glMapNamedBufferRangeEXT;

typedef void ( * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
extern PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC glad_glFlushMappedNamedBufferRangeEXT;

typedef void ( * PFNGLNAMEDBUFFERSTORAGEEXTPROC)(GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);
extern PFNGLNAMEDBUFFERSTORAGEEXTPROC glad_glNamedBufferStorageEXT;

typedef void ( * PFNGLCLEARNAMEDBUFFERDATAEXTPROC)(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
extern PFNGLCLEARNAMEDBUFFERDATAEXTPROC glad_glClearNamedBufferDataEXT;

typedef void ( * PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC)(GLuint buffer, GLenum internalformat, GLsizeiptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
extern PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC glad_glClearNamedBufferSubDataEXT;

typedef void ( * PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC)(GLuint framebuffer, GLenum pname, GLint param);
extern PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC glad_glNamedFramebufferParameteriEXT;

typedef void ( * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC)(GLuint framebuffer, GLenum pname, GLint *params);
extern PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC glad_glGetNamedFramebufferParameterivEXT;

typedef void ( * PFNGLPROGRAMUNIFORM1DEXTPROC)(GLuint program, GLint location, GLdouble x);
extern PFNGLPROGRAMUNIFORM1DEXTPROC glad_glProgramUniform1dEXT;

typedef void ( * PFNGLPROGRAMUNIFORM2DEXTPROC)(GLuint program, GLint location, GLdouble x, GLdouble y);
extern PFNGLPROGRAMUNIFORM2DEXTPROC glad_glProgramUniform2dEXT;

typedef void ( * PFNGLPROGRAMUNIFORM3DEXTPROC)(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
extern PFNGLPROGRAMUNIFORM3DEXTPROC glad_glProgramUniform3dEXT;

typedef void ( * PFNGLPROGRAMUNIFORM4DEXTPROC)(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLPROGRAMUNIFORM4DEXTPROC glad_glProgramUniform4dEXT;

typedef void ( * PFNGLPROGRAMUNIFORM1DVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
extern PFNGLPROGRAMUNIFORM1DVEXTPROC glad_glProgramUniform1dvEXT;

typedef void ( * PFNGLPROGRAMUNIFORM2DVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
extern PFNGLPROGRAMUNIFORM2DVEXTPROC glad_glProgramUniform2dvEXT;

typedef void ( * PFNGLPROGRAMUNIFORM3DVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
extern PFNGLPROGRAMUNIFORM3DVEXTPROC glad_glProgramUniform3dvEXT;

typedef void ( * PFNGLPROGRAMUNIFORM4DVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
extern PFNGLPROGRAMUNIFORM4DVEXTPROC glad_glProgramUniform4dvEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC glad_glProgramUniformMatrix2dvEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC glad_glProgramUniformMatrix3dvEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC glad_glProgramUniformMatrix4dvEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC glad_glProgramUniformMatrix2x3dvEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC glad_glProgramUniformMatrix2x4dvEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC glad_glProgramUniformMatrix3x2dvEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC glad_glProgramUniformMatrix3x4dvEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC glad_glProgramUniformMatrix4x2dvEXT;

typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
extern PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC glad_glProgramUniformMatrix4x3dvEXT;

typedef void ( * PFNGLTEXTUREBUFFERRANGEEXTPROC)(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern PFNGLTEXTUREBUFFERRANGEEXTPROC glad_glTextureBufferRangeEXT;

typedef void ( * PFNGLTEXTURESTORAGE1DEXTPROC)(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
extern PFNGLTEXTURESTORAGE1DEXTPROC glad_glTextureStorage1DEXT;

typedef void ( * PFNGLTEXTURESTORAGE2DEXTPROC)(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLTEXTURESTORAGE2DEXTPROC glad_glTextureStorage2DEXT;

typedef void ( * PFNGLTEXTURESTORAGE3DEXTPROC)(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
extern PFNGLTEXTURESTORAGE3DEXTPROC glad_glTextureStorage3DEXT;

typedef void ( * PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC)(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
extern PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC glad_glTextureStorage2DMultisampleEXT;

typedef void ( * PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC)(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
extern PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC glad_glTextureStorage3DMultisampleEXT;

typedef void ( * PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC)(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
extern PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC glad_glVertexArrayBindVertexBufferEXT;

typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
extern PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC glad_glVertexArrayVertexAttribFormatEXT;

typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
extern PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC glad_glVertexArrayVertexAttribIFormatEXT;

typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
extern PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC glad_glVertexArrayVertexAttribLFormatEXT;

typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC)(GLuint vaobj, GLuint attribindex, GLuint bindingindex);
extern PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC glad_glVertexArrayVertexAttribBindingEXT;

typedef void ( * PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC)(GLuint vaobj, GLuint bindingindex, GLuint divisor);
extern PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC glad_glVertexArrayVertexBindingDivisorEXT;

typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
extern PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC glad_glVertexArrayVertexAttribLOffsetEXT;

typedef void ( * PFNGLTEXTUREPAGECOMMITMENTEXTPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
extern PFNGLTEXTUREPAGECOMMITMENTEXTPROC glad_glTexturePageCommitmentEXT;

typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC)(GLuint vaobj, GLuint index, GLuint divisor);
extern PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC glad_glVertexArrayVertexAttribDivisorEXT;




extern int GLAD_GL_EXT_draw_buffers2;
typedef void ( * PFNGLCOLORMASKINDEXEDEXTPROC)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
extern PFNGLCOLORMASKINDEXEDEXTPROC glad_glColorMaskIndexedEXT;




extern int GLAD_GL_EXT_draw_instanced;
typedef void ( * PFNGLDRAWARRAYSINSTANCEDEXTPROC)(GLenum mode, GLint start, GLsizei count, GLsizei primcount);
extern PFNGLDRAWARRAYSINSTANCEDEXTPROC glad_glDrawArraysInstancedEXT;

typedef void ( * PFNGLDRAWELEMENTSINSTANCEDEXTPROC)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
extern PFNGLDRAWELEMENTSINSTANCEDEXTPROC glad_glDrawElementsInstancedEXT;




extern int GLAD_GL_EXT_draw_range_elements;
typedef void ( * PFNGLDRAWRANGEELEMENTSEXTPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
extern PFNGLDRAWRANGEELEMENTSEXTPROC glad_glDrawRangeElementsEXT;




extern int GLAD_GL_EXT_external_buffer;
typedef void ( * PFNGLBUFFERSTORAGEEXTERNALEXTPROC)(GLenum target, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);
extern PFNGLBUFFERSTORAGEEXTERNALEXTPROC glad_glBufferStorageExternalEXT;

typedef void ( * PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);
extern PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC glad_glNamedBufferStorageExternalEXT;




extern int GLAD_GL_EXT_fog_coord;
typedef void ( * PFNGLFOGCOORDFEXTPROC)(GLfloat coord);
extern PFNGLFOGCOORDFEXTPROC glad_glFogCoordfEXT;

typedef void ( * PFNGLFOGCOORDFVEXTPROC)(const GLfloat *coord);
extern PFNGLFOGCOORDFVEXTPROC glad_glFogCoordfvEXT;

typedef void ( * PFNGLFOGCOORDDEXTPROC)(GLdouble coord);
extern PFNGLFOGCOORDDEXTPROC glad_glFogCoorddEXT;

typedef void ( * PFNGLFOGCOORDDVEXTPROC)(const GLdouble *coord);
extern PFNGLFOGCOORDDVEXTPROC glad_glFogCoorddvEXT;

typedef void ( * PFNGLFOGCOORDPOINTEREXTPROC)(GLenum type, GLsizei stride, const void *pointer);
extern PFNGLFOGCOORDPOINTEREXTPROC glad_glFogCoordPointerEXT;




extern int GLAD_GL_EXT_framebuffer_blit;
typedef void ( * PFNGLBLITFRAMEBUFFEREXTPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
extern PFNGLBLITFRAMEBUFFEREXTPROC glad_glBlitFramebufferEXT;




extern int GLAD_GL_EXT_framebuffer_blit_layers;
typedef void ( * PFNGLBLITFRAMEBUFFERLAYERSEXTPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
extern PFNGLBLITFRAMEBUFFERLAYERSEXTPROC glad_glBlitFramebufferLayersEXT;

typedef void ( * PFNGLBLITFRAMEBUFFERLAYEREXTPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint srcLayer, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLint dstLayer, GLbitfield mask, GLenum filter);
extern PFNGLBLITFRAMEBUFFERLAYEREXTPROC glad_glBlitFramebufferLayerEXT;




extern int GLAD_GL_EXT_framebuffer_multisample;
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC glad_glRenderbufferStorageMultisampleEXT;




extern int GLAD_GL_EXT_framebuffer_multisample_blit_scaled;



extern int GLAD_GL_EXT_framebuffer_object;
typedef GLboolean ( * PFNGLISRENDERBUFFEREXTPROC)(GLuint renderbuffer);
extern PFNGLISRENDERBUFFEREXTPROC glad_glIsRenderbufferEXT;

typedef void ( * PFNGLBINDRENDERBUFFEREXTPROC)(GLenum target, GLuint renderbuffer);
extern PFNGLBINDRENDERBUFFEREXTPROC glad_glBindRenderbufferEXT;

typedef void ( * PFNGLDELETERENDERBUFFERSEXTPROC)(GLsizei n, const GLuint *renderbuffers);
extern PFNGLDELETERENDERBUFFERSEXTPROC glad_glDeleteRenderbuffersEXT;

typedef void ( * PFNGLGENRENDERBUFFERSEXTPROC)(GLsizei n, GLuint *renderbuffers);
extern PFNGLGENRENDERBUFFERSEXTPROC glad_glGenRenderbuffersEXT;

typedef void ( * PFNGLRENDERBUFFERSTORAGEEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLRENDERBUFFERSTORAGEEXTPROC glad_glRenderbufferStorageEXT;

typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC glad_glGetRenderbufferParameterivEXT;

typedef GLboolean ( * PFNGLISFRAMEBUFFEREXTPROC)(GLuint framebuffer);
extern PFNGLISFRAMEBUFFEREXTPROC glad_glIsFramebufferEXT;

typedef void ( * PFNGLBINDFRAMEBUFFEREXTPROC)(GLenum target, GLuint framebuffer);
extern PFNGLBINDFRAMEBUFFEREXTPROC glad_glBindFramebufferEXT;

typedef void ( * PFNGLDELETEFRAMEBUFFERSEXTPROC)(GLsizei n, const GLuint *framebuffers);
extern PFNGLDELETEFRAMEBUFFERSEXTPROC glad_glDeleteFramebuffersEXT;

typedef void ( * PFNGLGENFRAMEBUFFERSEXTPROC)(GLsizei n, GLuint *framebuffers);
extern PFNGLGENFRAMEBUFFERSEXTPROC glad_glGenFramebuffersEXT;

typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC)(GLenum target);
extern PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC glad_glCheckFramebufferStatusEXT;

typedef void ( * PFNGLFRAMEBUFFERTEXTURE1DEXTPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern PFNGLFRAMEBUFFERTEXTURE1DEXTPROC glad_glFramebufferTexture1DEXT;

typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DEXTPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern PFNGLFRAMEBUFFERTEXTURE2DEXTPROC glad_glFramebufferTexture2DEXT;

typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DEXTPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
extern PFNGLFRAMEBUFFERTEXTURE3DEXTPROC glad_glFramebufferTexture3DEXT;

typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC glad_glFramebufferRenderbufferEXT;

typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)(GLenum target, GLenum attachment, GLenum pname, GLint *params);
extern PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC glad_glGetFramebufferAttachmentParameterivEXT;

typedef void ( * PFNGLGENERATEMIPMAPEXTPROC)(GLenum target);
extern PFNGLGENERATEMIPMAPEXTPROC glad_glGenerateMipmapEXT;




extern int GLAD_GL_EXT_framebuffer_sRGB;



extern int GLAD_GL_EXT_geometry_shader4;
typedef void ( * PFNGLPROGRAMPARAMETERIEXTPROC)(GLuint program, GLenum pname, GLint value);
extern PFNGLPROGRAMPARAMETERIEXTPROC glad_glProgramParameteriEXT;




extern int GLAD_GL_EXT_gpu_program_parameters;
typedef void ( * PFNGLPROGRAMENVPARAMETERS4FVEXTPROC)(GLenum target, GLuint index, GLsizei count, const GLfloat *params);
extern PFNGLPROGRAMENVPARAMETERS4FVEXTPROC glad_glProgramEnvParameters4fvEXT;

typedef void ( * PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC)(GLenum target, GLuint index, GLsizei count, const GLfloat *params);
extern PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC glad_glProgramLocalParameters4fvEXT;




extern int GLAD_GL_EXT_gpu_shader4;
typedef void ( * PFNGLGETUNIFORMUIVEXTPROC)(GLuint program, GLint location, GLuint *params);
extern PFNGLGETUNIFORMUIVEXTPROC glad_glGetUniformuivEXT;

typedef void ( * PFNGLBINDFRAGDATALOCATIONEXTPROC)(GLuint program, GLuint color, const GLchar *name);
extern PFNGLBINDFRAGDATALOCATIONEXTPROC glad_glBindFragDataLocationEXT;

typedef GLint ( * PFNGLGETFRAGDATALOCATIONEXTPROC)(GLuint program, const GLchar *name);
extern PFNGLGETFRAGDATALOCATIONEXTPROC glad_glGetFragDataLocationEXT;

typedef void ( * PFNGLUNIFORM1UIEXTPROC)(GLint location, GLuint v0);
extern PFNGLUNIFORM1UIEXTPROC glad_glUniform1uiEXT;

typedef void ( * PFNGLUNIFORM2UIEXTPROC)(GLint location, GLuint v0, GLuint v1);
extern PFNGLUNIFORM2UIEXTPROC glad_glUniform2uiEXT;

typedef void ( * PFNGLUNIFORM3UIEXTPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2);
extern PFNGLUNIFORM3UIEXTPROC glad_glUniform3uiEXT;

typedef void ( * PFNGLUNIFORM4UIEXTPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
extern PFNGLUNIFORM4UIEXTPROC glad_glUniform4uiEXT;

typedef void ( * PFNGLUNIFORM1UIVEXTPROC)(GLint location, GLsizei count, const GLuint *value);
extern PFNGLUNIFORM1UIVEXTPROC glad_glUniform1uivEXT;

typedef void ( * PFNGLUNIFORM2UIVEXTPROC)(GLint location, GLsizei count, const GLuint *value);
extern PFNGLUNIFORM2UIVEXTPROC glad_glUniform2uivEXT;

typedef void ( * PFNGLUNIFORM3UIVEXTPROC)(GLint location, GLsizei count, const GLuint *value);
extern PFNGLUNIFORM3UIVEXTPROC glad_glUniform3uivEXT;

typedef void ( * PFNGLUNIFORM4UIVEXTPROC)(GLint location, GLsizei count, const GLuint *value);
extern PFNGLUNIFORM4UIVEXTPROC glad_glUniform4uivEXT;

typedef void ( * PFNGLVERTEXATTRIBI1IEXTPROC)(GLuint index, GLint x);
extern PFNGLVERTEXATTRIBI1IEXTPROC glad_glVertexAttribI1iEXT;

typedef void ( * PFNGLVERTEXATTRIBI2IEXTPROC)(GLuint index, GLint x, GLint y);
extern PFNGLVERTEXATTRIBI2IEXTPROC glad_glVertexAttribI2iEXT;

typedef void ( * PFNGLVERTEXATTRIBI3IEXTPROC)(GLuint index, GLint x, GLint y, GLint z);
extern PFNGLVERTEXATTRIBI3IEXTPROC glad_glVertexAttribI3iEXT;

typedef void ( * PFNGLVERTEXATTRIBI4IEXTPROC)(GLuint index, GLint x, GLint y, GLint z, GLint w);
extern PFNGLVERTEXATTRIBI4IEXTPROC glad_glVertexAttribI4iEXT;

typedef void ( * PFNGLVERTEXATTRIBI1UIEXTPROC)(GLuint index, GLuint x);
extern PFNGLVERTEXATTRIBI1UIEXTPROC glad_glVertexAttribI1uiEXT;

typedef void ( * PFNGLVERTEXATTRIBI2UIEXTPROC)(GLuint index, GLuint x, GLuint y);
extern PFNGLVERTEXATTRIBI2UIEXTPROC glad_glVertexAttribI2uiEXT;

typedef void ( * PFNGLVERTEXATTRIBI3UIEXTPROC)(GLuint index, GLuint x, GLuint y, GLuint z);
extern PFNGLVERTEXATTRIBI3UIEXTPROC glad_glVertexAttribI3uiEXT;

typedef void ( * PFNGLVERTEXATTRIBI4UIEXTPROC)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
extern PFNGLVERTEXATTRIBI4UIEXTPROC glad_glVertexAttribI4uiEXT;

typedef void ( * PFNGLVERTEXATTRIBI1IVEXTPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIBI1IVEXTPROC glad_glVertexAttribI1ivEXT;

typedef void ( * PFNGLVERTEXATTRIBI2IVEXTPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIBI2IVEXTPROC glad_glVertexAttribI2ivEXT;

typedef void ( * PFNGLVERTEXATTRIBI3IVEXTPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIBI3IVEXTPROC glad_glVertexAttribI3ivEXT;

typedef void ( * PFNGLVERTEXATTRIBI4IVEXTPROC)(GLuint index, const GLint *v);
extern PFNGLVERTEXATTRIBI4IVEXTPROC glad_glVertexAttribI4ivEXT;

typedef void ( * PFNGLVERTEXATTRIBI1UIVEXTPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIBI1UIVEXTPROC glad_glVertexAttribI1uivEXT;

typedef void ( * PFNGLVERTEXATTRIBI2UIVEXTPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIBI2UIVEXTPROC glad_glVertexAttribI2uivEXT;

typedef void ( * PFNGLVERTEXATTRIBI3UIVEXTPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIBI3UIVEXTPROC glad_glVertexAttribI3uivEXT;

typedef void ( * PFNGLVERTEXATTRIBI4UIVEXTPROC)(GLuint index, const GLuint *v);
extern PFNGLVERTEXATTRIBI4UIVEXTPROC glad_glVertexAttribI4uivEXT;

typedef void ( * PFNGLVERTEXATTRIBI4BVEXTPROC)(GLuint index, const GLbyte *v);
extern PFNGLVERTEXATTRIBI4BVEXTPROC glad_glVertexAttribI4bvEXT;

typedef void ( * PFNGLVERTEXATTRIBI4SVEXTPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIBI4SVEXTPROC glad_glVertexAttribI4svEXT;

typedef void ( * PFNGLVERTEXATTRIBI4UBVEXTPROC)(GLuint index, const GLubyte *v);
extern PFNGLVERTEXATTRIBI4UBVEXTPROC glad_glVertexAttribI4ubvEXT;

typedef void ( * PFNGLVERTEXATTRIBI4USVEXTPROC)(GLuint index, const GLushort *v);
extern PFNGLVERTEXATTRIBI4USVEXTPROC glad_glVertexAttribI4usvEXT;

typedef void ( * PFNGLVERTEXATTRIBIPOINTEREXTPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
extern PFNGLVERTEXATTRIBIPOINTEREXTPROC glad_glVertexAttribIPointerEXT;

typedef void ( * PFNGLGETVERTEXATTRIBIIVEXTPROC)(GLuint index, GLenum pname, GLint *params);
extern PFNGLGETVERTEXATTRIBIIVEXTPROC glad_glGetVertexAttribIivEXT;

typedef void ( * PFNGLGETVERTEXATTRIBIUIVEXTPROC)(GLuint index, GLenum pname, GLuint *params);
extern PFNGLGETVERTEXATTRIBIUIVEXTPROC glad_glGetVertexAttribIuivEXT;




extern int GLAD_GL_EXT_histogram;
typedef void ( * PFNGLGETHISTOGRAMEXTPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
extern PFNGLGETHISTOGRAMEXTPROC glad_glGetHistogramEXT;

typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETHISTOGRAMPARAMETERFVEXTPROC glad_glGetHistogramParameterfvEXT;

typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETHISTOGRAMPARAMETERIVEXTPROC glad_glGetHistogramParameterivEXT;

typedef void ( * PFNGLGETMINMAXEXTPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
extern PFNGLGETMINMAXEXTPROC glad_glGetMinmaxEXT;

typedef void ( * PFNGLGETMINMAXPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETMINMAXPARAMETERFVEXTPROC glad_glGetMinmaxParameterfvEXT;

typedef void ( * PFNGLGETMINMAXPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETMINMAXPARAMETERIVEXTPROC glad_glGetMinmaxParameterivEXT;

typedef void ( * PFNGLHISTOGRAMEXTPROC)(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
extern PFNGLHISTOGRAMEXTPROC glad_glHistogramEXT;

typedef void ( * PFNGLMINMAXEXTPROC)(GLenum target, GLenum internalformat, GLboolean sink);
extern PFNGLMINMAXEXTPROC glad_glMinmaxEXT;

typedef void ( * PFNGLRESETHISTOGRAMEXTPROC)(GLenum target);
extern PFNGLRESETHISTOGRAMEXTPROC glad_glResetHistogramEXT;

typedef void ( * PFNGLRESETMINMAXEXTPROC)(GLenum target);
extern PFNGLRESETMINMAXEXTPROC glad_glResetMinmaxEXT;




extern int GLAD_GL_EXT_index_array_formats;



extern int GLAD_GL_EXT_index_func;
typedef void ( * PFNGLINDEXFUNCEXTPROC)(GLenum func, GLclampf ref);
extern PFNGLINDEXFUNCEXTPROC glad_glIndexFuncEXT;




extern int GLAD_GL_EXT_index_material;
typedef void ( * PFNGLINDEXMATERIALEXTPROC)(GLenum face, GLenum mode);
extern PFNGLINDEXMATERIALEXTPROC glad_glIndexMaterialEXT;




extern int GLAD_GL_EXT_index_texture;



extern int GLAD_GL_EXT_light_texture;
typedef void ( * PFNGLAPPLYTEXTUREEXTPROC)(GLenum mode);
extern PFNGLAPPLYTEXTUREEXTPROC glad_glApplyTextureEXT;

typedef void ( * PFNGLTEXTURELIGHTEXTPROC)(GLenum pname);
extern PFNGLTEXTURELIGHTEXTPROC glad_glTextureLightEXT;

typedef void ( * PFNGLTEXTUREMATERIALEXTPROC)(GLenum face, GLenum mode);
extern PFNGLTEXTUREMATERIALEXTPROC glad_glTextureMaterialEXT;




extern int GLAD_GL_EXT_memory_object;
typedef void ( * PFNGLGETUNSIGNEDBYTEVEXTPROC)(GLenum pname, GLubyte *data);
extern PFNGLGETUNSIGNEDBYTEVEXTPROC glad_glGetUnsignedBytevEXT;

typedef void ( * PFNGLGETUNSIGNEDBYTEI_VEXTPROC)(GLenum target, GLuint index, GLubyte *data);
extern PFNGLGETUNSIGNEDBYTEI_VEXTPROC glad_glGetUnsignedBytei_vEXT;

typedef void ( * PFNGLDELETEMEMORYOBJECTSEXTPROC)(GLsizei n, const GLuint *memoryObjects);
extern PFNGLDELETEMEMORYOBJECTSEXTPROC glad_glDeleteMemoryObjectsEXT;

typedef GLboolean ( * PFNGLISMEMORYOBJECTEXTPROC)(GLuint memoryObject);
extern PFNGLISMEMORYOBJECTEXTPROC glad_glIsMemoryObjectEXT;

typedef void ( * PFNGLCREATEMEMORYOBJECTSEXTPROC)(GLsizei n, GLuint *memoryObjects);
extern PFNGLCREATEMEMORYOBJECTSEXTPROC glad_glCreateMemoryObjectsEXT;

typedef void ( * PFNGLMEMORYOBJECTPARAMETERIVEXTPROC)(GLuint memoryObject, GLenum pname, const GLint *params);
extern PFNGLMEMORYOBJECTPARAMETERIVEXTPROC glad_glMemoryObjectParameterivEXT;

typedef void ( * PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC)(GLuint memoryObject, GLenum pname, GLint *params);
extern PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC glad_glGetMemoryObjectParameterivEXT;

typedef void ( * PFNGLTEXSTORAGEMEM2DEXTPROC)(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);
extern PFNGLTEXSTORAGEMEM2DEXTPROC glad_glTexStorageMem2DEXT;

typedef void ( * PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC)(GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
extern PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC glad_glTexStorageMem2DMultisampleEXT;

typedef void ( * PFNGLTEXSTORAGEMEM3DEXTPROC)(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);
extern PFNGLTEXSTORAGEMEM3DEXTPROC glad_glTexStorageMem3DEXT;

typedef void ( * PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC)(GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
extern PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC glad_glTexStorageMem3DMultisampleEXT;

typedef void ( * PFNGLBUFFERSTORAGEMEMEXTPROC)(GLenum target, GLsizeiptr size, GLuint memory, GLuint64 offset);
extern PFNGLBUFFERSTORAGEMEMEXTPROC glad_glBufferStorageMemEXT;

typedef void ( * PFNGLTEXTURESTORAGEMEM2DEXTPROC)(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);
extern PFNGLTEXTURESTORAGEMEM2DEXTPROC glad_glTextureStorageMem2DEXT;

typedef void ( * PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC)(GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
extern PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC glad_glTextureStorageMem2DMultisampleEXT;

typedef void ( * PFNGLTEXTURESTORAGEMEM3DEXTPROC)(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);
extern PFNGLTEXTURESTORAGEMEM3DEXTPROC glad_glTextureStorageMem3DEXT;

typedef void ( * PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC)(GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
extern PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC glad_glTextureStorageMem3DMultisampleEXT;

typedef void ( * PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC)(GLuint buffer, GLsizeiptr size, GLuint memory, GLuint64 offset);
extern PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC glad_glNamedBufferStorageMemEXT;

typedef void ( * PFNGLTEXSTORAGEMEM1DEXTPROC)(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);
extern PFNGLTEXSTORAGEMEM1DEXTPROC glad_glTexStorageMem1DEXT;

typedef void ( * PFNGLTEXTURESTORAGEMEM1DEXTPROC)(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);
extern PFNGLTEXTURESTORAGEMEM1DEXTPROC glad_glTextureStorageMem1DEXT;




extern int GLAD_GL_EXT_memory_object_fd;
typedef void ( * PFNGLIMPORTMEMORYFDEXTPROC)(GLuint memory, GLuint64 size, GLenum handleType, GLint fd);
extern PFNGLIMPORTMEMORYFDEXTPROC glad_glImportMemoryFdEXT;




extern int GLAD_GL_EXT_memory_object_win32;
typedef void ( * PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC)(GLuint memory, GLuint64 size, GLenum handleType, void *handle);
extern PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC glad_glImportMemoryWin32HandleEXT;

typedef void ( * PFNGLIMPORTMEMORYWIN32NAMEEXTPROC)(GLuint memory, GLuint64 size, GLenum handleType, const void *name);
extern PFNGLIMPORTMEMORYWIN32NAMEEXTPROC glad_glImportMemoryWin32NameEXT;




extern int GLAD_GL_EXT_misc_attribute;



extern int GLAD_GL_EXT_multi_draw_arrays;
typedef void ( * PFNGLMULTIDRAWARRAYSEXTPROC)(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
extern PFNGLMULTIDRAWARRAYSEXTPROC glad_glMultiDrawArraysEXT;

typedef void ( * PFNGLMULTIDRAWELEMENTSEXTPROC)(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount);
extern PFNGLMULTIDRAWELEMENTSEXTPROC glad_glMultiDrawElementsEXT;




extern int GLAD_GL_EXT_multisample;
typedef void ( * PFNGLSAMPLEMASKEXTPROC)(GLclampf value, GLboolean invert);
extern PFNGLSAMPLEMASKEXTPROC glad_glSampleMaskEXT;

typedef void ( * PFNGLSAMPLEPATTERNEXTPROC)(GLenum pattern);
extern PFNGLSAMPLEPATTERNEXTPROC glad_glSamplePatternEXT;




extern int GLAD_GL_EXT_multiview_tessellation_geometry_shader;



extern int GLAD_GL_EXT_multiview_texture_multisample;



extern int GLAD_GL_EXT_multiview_timer_query;



extern int GLAD_GL_EXT_packed_depth_stencil;



extern int GLAD_GL_EXT_packed_float;



extern int GLAD_GL_EXT_packed_pixels;



extern int GLAD_GL_EXT_paletted_texture;
typedef void ( * PFNGLCOLORTABLEEXTPROC)(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void *table);
extern PFNGLCOLORTABLEEXTPROC glad_glColorTableEXT;

typedef void ( * PFNGLGETCOLORTABLEEXTPROC)(GLenum target, GLenum format, GLenum type, void *data);
extern PFNGLGETCOLORTABLEEXTPROC glad_glGetColorTableEXT;

typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETCOLORTABLEPARAMETERIVEXTPROC glad_glGetColorTableParameterivEXT;

typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETCOLORTABLEPARAMETERFVEXTPROC glad_glGetColorTableParameterfvEXT;




extern int GLAD_GL_EXT_pixel_buffer_object;



extern int GLAD_GL_EXT_pixel_transform;
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIEXTPROC)(GLenum target, GLenum pname, GLint param);
extern PFNGLPIXELTRANSFORMPARAMETERIEXTPROC glad_glPixelTransformParameteriEXT;

typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFEXTPROC)(GLenum target, GLenum pname, GLfloat param);
extern PFNGLPIXELTRANSFORMPARAMETERFEXTPROC glad_glPixelTransformParameterfEXT;

typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC)(GLenum target, GLenum pname, const GLint *params);
extern PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC glad_glPixelTransformParameterivEXT;

typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC)(GLenum target, GLenum pname, const GLfloat *params);
extern PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC glad_glPixelTransformParameterfvEXT;

typedef void ( * PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC glad_glGetPixelTransformParameterivEXT;

typedef void ( * PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC glad_glGetPixelTransformParameterfvEXT;




extern int GLAD_GL_EXT_pixel_transform_color_table;



extern int GLAD_GL_EXT_point_parameters;
typedef void ( * PFNGLPOINTPARAMETERFEXTPROC)(GLenum pname, GLfloat param);
extern PFNGLPOINTPARAMETERFEXTPROC glad_glPointParameterfEXT;

typedef void ( * PFNGLPOINTPARAMETERFVEXTPROC)(GLenum pname, const GLfloat *params);
extern PFNGLPOINTPARAMETERFVEXTPROC glad_glPointParameterfvEXT;




extern int GLAD_GL_EXT_polygon_offset;
typedef void ( * PFNGLPOLYGONOFFSETEXTPROC)(GLfloat factor, GLfloat bias);
extern PFNGLPOLYGONOFFSETEXTPROC glad_glPolygonOffsetEXT;




extern int GLAD_GL_EXT_polygon_offset_clamp;
typedef void ( * PFNGLPOLYGONOFFSETCLAMPEXTPROC)(GLfloat factor, GLfloat units, GLfloat clamp);
extern PFNGLPOLYGONOFFSETCLAMPEXTPROC glad_glPolygonOffsetClampEXT;




extern int GLAD_GL_EXT_post_depth_coverage;



extern int GLAD_GL_EXT_provoking_vertex;
typedef void ( * PFNGLPROVOKINGVERTEXEXTPROC)(GLenum mode);
extern PFNGLPROVOKINGVERTEXEXTPROC glad_glProvokingVertexEXT;




extern int GLAD_GL_EXT_raster_multisample;
typedef void ( * PFNGLRASTERSAMPLESEXTPROC)(GLuint samples, GLboolean fixedsamplelocations);
extern PFNGLRASTERSAMPLESEXTPROC glad_glRasterSamplesEXT;




extern int GLAD_GL_EXT_rescale_normal;



extern int GLAD_GL_EXT_secondary_color;
typedef void ( * PFNGLSECONDARYCOLOR3BEXTPROC)(GLbyte red, GLbyte green, GLbyte blue);
extern PFNGLSECONDARYCOLOR3BEXTPROC glad_glSecondaryColor3bEXT;

typedef void ( * PFNGLSECONDARYCOLOR3BVEXTPROC)(const GLbyte *v);
extern PFNGLSECONDARYCOLOR3BVEXTPROC glad_glSecondaryColor3bvEXT;

typedef void ( * PFNGLSECONDARYCOLOR3DEXTPROC)(GLdouble red, GLdouble green, GLdouble blue);
extern PFNGLSECONDARYCOLOR3DEXTPROC glad_glSecondaryColor3dEXT;

typedef void ( * PFNGLSECONDARYCOLOR3DVEXTPROC)(const GLdouble *v);
extern PFNGLSECONDARYCOLOR3DVEXTPROC glad_glSecondaryColor3dvEXT;

typedef void ( * PFNGLSECONDARYCOLOR3FEXTPROC)(GLfloat red, GLfloat green, GLfloat blue);
extern PFNGLSECONDARYCOLOR3FEXTPROC glad_glSecondaryColor3fEXT;

typedef void ( * PFNGLSECONDARYCOLOR3FVEXTPROC)(const GLfloat *v);
extern PFNGLSECONDARYCOLOR3FVEXTPROC glad_glSecondaryColor3fvEXT;

typedef void ( * PFNGLSECONDARYCOLOR3IEXTPROC)(GLint red, GLint green, GLint blue);
extern PFNGLSECONDARYCOLOR3IEXTPROC glad_glSecondaryColor3iEXT;

typedef void ( * PFNGLSECONDARYCOLOR3IVEXTPROC)(const GLint *v);
extern PFNGLSECONDARYCOLOR3IVEXTPROC glad_glSecondaryColor3ivEXT;

typedef void ( * PFNGLSECONDARYCOLOR3SEXTPROC)(GLshort red, GLshort green, GLshort blue);
extern PFNGLSECONDARYCOLOR3SEXTPROC glad_glSecondaryColor3sEXT;

typedef void ( * PFNGLSECONDARYCOLOR3SVEXTPROC)(const GLshort *v);
extern PFNGLSECONDARYCOLOR3SVEXTPROC glad_glSecondaryColor3svEXT;

typedef void ( * PFNGLSECONDARYCOLOR3UBEXTPROC)(GLubyte red, GLubyte green, GLubyte blue);
extern PFNGLSECONDARYCOLOR3UBEXTPROC glad_glSecondaryColor3ubEXT;

typedef void ( * PFNGLSECONDARYCOLOR3UBVEXTPROC)(const GLubyte *v);
extern PFNGLSECONDARYCOLOR3UBVEXTPROC glad_glSecondaryColor3ubvEXT;

typedef void ( * PFNGLSECONDARYCOLOR3UIEXTPROC)(GLuint red, GLuint green, GLuint blue);
extern PFNGLSECONDARYCOLOR3UIEXTPROC glad_glSecondaryColor3uiEXT;

typedef void ( * PFNGLSECONDARYCOLOR3UIVEXTPROC)(const GLuint *v);
extern PFNGLSECONDARYCOLOR3UIVEXTPROC glad_glSecondaryColor3uivEXT;

typedef void ( * PFNGLSECONDARYCOLOR3USEXTPROC)(GLushort red, GLushort green, GLushort blue);
extern PFNGLSECONDARYCOLOR3USEXTPROC glad_glSecondaryColor3usEXT;

typedef void ( * PFNGLSECONDARYCOLOR3USVEXTPROC)(const GLushort *v);
extern PFNGLSECONDARYCOLOR3USVEXTPROC glad_glSecondaryColor3usvEXT;

typedef void ( * PFNGLSECONDARYCOLORPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, const void *pointer);
extern PFNGLSECONDARYCOLORPOINTEREXTPROC glad_glSecondaryColorPointerEXT;




extern int GLAD_GL_EXT_semaphore;
typedef void ( * PFNGLGENSEMAPHORESEXTPROC)(GLsizei n, GLuint *semaphores);
extern PFNGLGENSEMAPHORESEXTPROC glad_glGenSemaphoresEXT;

typedef void ( * PFNGLDELETESEMAPHORESEXTPROC)(GLsizei n, const GLuint *semaphores);
extern PFNGLDELETESEMAPHORESEXTPROC glad_glDeleteSemaphoresEXT;

typedef GLboolean ( * PFNGLISSEMAPHOREEXTPROC)(GLuint semaphore);
extern PFNGLISSEMAPHOREEXTPROC glad_glIsSemaphoreEXT;

typedef void ( * PFNGLSEMAPHOREPARAMETERUI64VEXTPROC)(GLuint semaphore, GLenum pname, const GLuint64 *params);
extern PFNGLSEMAPHOREPARAMETERUI64VEXTPROC glad_glSemaphoreParameterui64vEXT;

typedef void ( * PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC)(GLuint semaphore, GLenum pname, GLuint64 *params);
extern PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC glad_glGetSemaphoreParameterui64vEXT;

typedef void ( * PFNGLWAITSEMAPHOREEXTPROC)(GLuint semaphore, GLuint numBufferBarriers, const GLuint *buffers, GLuint numTextureBarriers, const GLuint *textures, const GLenum *srcLayouts);
extern PFNGLWAITSEMAPHOREEXTPROC glad_glWaitSemaphoreEXT;

typedef void ( * PFNGLSIGNALSEMAPHOREEXTPROC)(GLuint semaphore, GLuint numBufferBarriers, const GLuint *buffers, GLuint numTextureBarriers, const GLuint *textures, const GLenum *dstLayouts);
extern PFNGLSIGNALSEMAPHOREEXTPROC glad_glSignalSemaphoreEXT;




extern int GLAD_GL_EXT_semaphore_fd;
typedef void ( * PFNGLIMPORTSEMAPHOREFDEXTPROC)(GLuint semaphore, GLenum handleType, GLint fd);
extern PFNGLIMPORTSEMAPHOREFDEXTPROC glad_glImportSemaphoreFdEXT;




extern int GLAD_GL_EXT_semaphore_win32;
typedef void ( * PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC)(GLuint semaphore, GLenum handleType, void *handle);
extern PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC glad_glImportSemaphoreWin32HandleEXT;

typedef void ( * PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC)(GLuint semaphore, GLenum handleType, const void *name);
extern PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC glad_glImportSemaphoreWin32NameEXT;




extern int GLAD_GL_EXT_separate_shader_objects;
typedef void ( * PFNGLUSESHADERPROGRAMEXTPROC)(GLenum type, GLuint program);
extern PFNGLUSESHADERPROGRAMEXTPROC glad_glUseShaderProgramEXT;

typedef void ( * PFNGLACTIVEPROGRAMEXTPROC)(GLuint program);
extern PFNGLACTIVEPROGRAMEXTPROC glad_glActiveProgramEXT;

typedef GLuint ( * PFNGLCREATESHADERPROGRAMEXTPROC)(GLenum type, const GLchar *string);
extern PFNGLCREATESHADERPROGRAMEXTPROC glad_glCreateShaderProgramEXT;

typedef void ( * PFNGLACTIVESHADERPROGRAMEXTPROC)(GLuint pipeline, GLuint program);
extern PFNGLACTIVESHADERPROGRAMEXTPROC glad_glActiveShaderProgramEXT;

typedef void ( * PFNGLBINDPROGRAMPIPELINEEXTPROC)(GLuint pipeline);
extern PFNGLBINDPROGRAMPIPELINEEXTPROC glad_glBindProgramPipelineEXT;

typedef GLuint ( * PFNGLCREATESHADERPROGRAMVEXTPROC)(GLenum type, GLsizei count, const GLchar *const*strings);
extern PFNGLCREATESHADERPROGRAMVEXTPROC glad_glCreateShaderProgramvEXT;

typedef void ( * PFNGLDELETEPROGRAMPIPELINESEXTPROC)(GLsizei n, const GLuint *pipelines);
extern PFNGLDELETEPROGRAMPIPELINESEXTPROC glad_glDeleteProgramPipelinesEXT;

typedef void ( * PFNGLGENPROGRAMPIPELINESEXTPROC)(GLsizei n, GLuint *pipelines);
extern PFNGLGENPROGRAMPIPELINESEXTPROC glad_glGenProgramPipelinesEXT;

typedef void ( * PFNGLGETPROGRAMPIPELINEINFOLOGEXTPROC)(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern PFNGLGETPROGRAMPIPELINEINFOLOGEXTPROC glad_glGetProgramPipelineInfoLogEXT;

typedef void ( * PFNGLGETPROGRAMPIPELINEIVEXTPROC)(GLuint pipeline, GLenum pname, GLint *params);
extern PFNGLGETPROGRAMPIPELINEIVEXTPROC glad_glGetProgramPipelineivEXT;

typedef GLboolean ( * PFNGLISPROGRAMPIPELINEEXTPROC)(GLuint pipeline);
extern PFNGLISPROGRAMPIPELINEEXTPROC glad_glIsProgramPipelineEXT;

typedef void ( * PFNGLUSEPROGRAMSTAGESEXTPROC)(GLuint pipeline, GLbitfield stages, GLuint program);
extern PFNGLUSEPROGRAMSTAGESEXTPROC glad_glUseProgramStagesEXT;

typedef void ( * PFNGLVALIDATEPROGRAMPIPELINEEXTPROC)(GLuint pipeline);
extern PFNGLVALIDATEPROGRAMPIPELINEEXTPROC glad_glValidateProgramPipelineEXT;




extern int GLAD_GL_EXT_separate_specular_color;



extern int GLAD_GL_EXT_shader_framebuffer_fetch;



extern int GLAD_GL_EXT_shader_framebuffer_fetch_non_coherent;
typedef void ( * PFNGLFRAMEBUFFERFETCHBARRIEREXTPROC)(void);
extern PFNGLFRAMEBUFFERFETCHBARRIEREXTPROC glad_glFramebufferFetchBarrierEXT;




extern int GLAD_GL_EXT_shader_image_load_formatted;



extern int GLAD_GL_EXT_shader_image_load_store;
typedef void ( * PFNGLBINDIMAGETEXTUREEXTPROC)(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);
extern PFNGLBINDIMAGETEXTUREEXTPROC glad_glBindImageTextureEXT;

typedef void ( * PFNGLMEMORYBARRIEREXTPROC)(GLbitfield barriers);
extern PFNGLMEMORYBARRIEREXTPROC glad_glMemoryBarrierEXT;




extern int GLAD_GL_EXT_shader_integer_mix;



extern int GLAD_GL_EXT_shader_samples_identical;



extern int GLAD_GL_EXT_shadow_funcs;



extern int GLAD_GL_EXT_shared_texture_palette;



extern int GLAD_GL_EXT_sparse_texture2;



extern int GLAD_GL_EXT_stencil_clear_tag;
typedef void ( * PFNGLSTENCILCLEARTAGEXTPROC)(GLsizei stencilTagBits, GLuint stencilClearTag);
extern PFNGLSTENCILCLEARTAGEXTPROC glad_glStencilClearTagEXT;




extern int GLAD_GL_EXT_stencil_two_side;
typedef void ( * PFNGLACTIVESTENCILFACEEXTPROC)(GLenum face);
extern PFNGLACTIVESTENCILFACEEXTPROC glad_glActiveStencilFaceEXT;




extern int GLAD_GL_EXT_stencil_wrap;



extern int GLAD_GL_EXT_subtexture;
typedef void ( * PFNGLTEXSUBIMAGE1DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXSUBIMAGE1DEXTPROC glad_glTexSubImage1DEXT;

typedef void ( * PFNGLTEXSUBIMAGE2DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXSUBIMAGE2DEXTPROC glad_glTexSubImage2DEXT;




extern int GLAD_GL_EXT_texture;



extern int GLAD_GL_EXT_texture3D;
typedef void ( * PFNGLTEXIMAGE3DEXTPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXIMAGE3DEXTPROC glad_glTexImage3DEXT;

typedef void ( * PFNGLTEXSUBIMAGE3DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXSUBIMAGE3DEXTPROC glad_glTexSubImage3DEXT;




extern int GLAD_GL_EXT_texture_array;
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
extern PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC glad_glFramebufferTextureLayerEXT;




extern int GLAD_GL_EXT_texture_buffer_object;
typedef void ( * PFNGLTEXBUFFEREXTPROC)(GLenum target, GLenum internalformat, GLuint buffer);
extern PFNGLTEXBUFFEREXTPROC glad_glTexBufferEXT;




extern int GLAD_GL_EXT_texture_compression_latc;



extern int GLAD_GL_EXT_texture_compression_rgtc;



extern int GLAD_GL_EXT_texture_compression_s3tc;



extern int GLAD_GL_EXT_texture_cube_map;



extern int GLAD_GL_EXT_texture_env_add;



extern int GLAD_GL_EXT_texture_env_combine;



extern int GLAD_GL_EXT_texture_env_dot3;



extern int GLAD_GL_EXT_texture_filter_anisotropic;



extern int GLAD_GL_EXT_texture_filter_minmax;



extern int GLAD_GL_EXT_texture_integer;
typedef void ( * PFNGLTEXPARAMETERIIVEXTPROC)(GLenum target, GLenum pname, const GLint *params);
extern PFNGLTEXPARAMETERIIVEXTPROC glad_glTexParameterIivEXT;

typedef void ( * PFNGLTEXPARAMETERIUIVEXTPROC)(GLenum target, GLenum pname, const GLuint *params);
extern PFNGLTEXPARAMETERIUIVEXTPROC glad_glTexParameterIuivEXT;

typedef void ( * PFNGLGETTEXPARAMETERIIVEXTPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETTEXPARAMETERIIVEXTPROC glad_glGetTexParameterIivEXT;

typedef void ( * PFNGLGETTEXPARAMETERIUIVEXTPROC)(GLenum target, GLenum pname, GLuint *params);
extern PFNGLGETTEXPARAMETERIUIVEXTPROC glad_glGetTexParameterIuivEXT;

typedef void ( * PFNGLCLEARCOLORIIEXTPROC)(GLint red, GLint green, GLint blue, GLint alpha);
extern PFNGLCLEARCOLORIIEXTPROC glad_glClearColorIiEXT;

typedef void ( * PFNGLCLEARCOLORIUIEXTPROC)(GLuint red, GLuint green, GLuint blue, GLuint alpha);
extern PFNGLCLEARCOLORIUIEXTPROC glad_glClearColorIuiEXT;




extern int GLAD_GL_EXT_texture_lod_bias;



extern int GLAD_GL_EXT_texture_mirror_clamp;



extern int GLAD_GL_EXT_texture_object;
typedef GLboolean ( * PFNGLARETEXTURESRESIDENTEXTPROC)(GLsizei n, const GLuint *textures, GLboolean *residences);
extern PFNGLARETEXTURESRESIDENTEXTPROC glad_glAreTexturesResidentEXT;

typedef void ( * PFNGLBINDTEXTUREEXTPROC)(GLenum target, GLuint texture);
extern PFNGLBINDTEXTUREEXTPROC glad_glBindTextureEXT;

typedef void ( * PFNGLDELETETEXTURESEXTPROC)(GLsizei n, const GLuint *textures);
extern PFNGLDELETETEXTURESEXTPROC glad_glDeleteTexturesEXT;

typedef void ( * PFNGLGENTEXTURESEXTPROC)(GLsizei n, GLuint *textures);
extern PFNGLGENTEXTURESEXTPROC glad_glGenTexturesEXT;

typedef GLboolean ( * PFNGLISTEXTUREEXTPROC)(GLuint texture);
extern PFNGLISTEXTUREEXTPROC glad_glIsTextureEXT;

typedef void ( * PFNGLPRIORITIZETEXTURESEXTPROC)(GLsizei n, const GLuint *textures, const GLclampf *priorities);
extern PFNGLPRIORITIZETEXTURESEXTPROC glad_glPrioritizeTexturesEXT;




extern int GLAD_GL_EXT_texture_perturb_normal;
typedef void ( * PFNGLTEXTURENORMALEXTPROC)(GLenum mode);
extern PFNGLTEXTURENORMALEXTPROC glad_glTextureNormalEXT;




extern int GLAD_GL_EXT_texture_sRGB;



extern int GLAD_GL_EXT_texture_sRGB_R8;



extern int GLAD_GL_EXT_texture_sRGB_RG8;



extern int GLAD_GL_EXT_texture_sRGB_decode;



extern int GLAD_GL_EXT_texture_shadow_lod;



extern int GLAD_GL_EXT_texture_shared_exponent;



extern int GLAD_GL_EXT_texture_snorm;



extern int GLAD_GL_EXT_texture_storage;
typedef void ( * PFNGLTEXSTORAGE1DEXTPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
extern PFNGLTEXSTORAGE1DEXTPROC glad_glTexStorage1DEXT;

typedef void ( * PFNGLTEXSTORAGE2DEXTPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLTEXSTORAGE2DEXTPROC glad_glTexStorage2DEXT;

typedef void ( * PFNGLTEXSTORAGE3DEXTPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
extern PFNGLTEXSTORAGE3DEXTPROC glad_glTexStorage3DEXT;




extern int GLAD_GL_EXT_texture_swizzle;



extern int GLAD_GL_EXT_timer_query;
typedef void ( * PFNGLGETQUERYOBJECTI64VEXTPROC)(GLuint id, GLenum pname, GLint64 *params);
extern PFNGLGETQUERYOBJECTI64VEXTPROC glad_glGetQueryObjecti64vEXT;

typedef void ( * PFNGLGETQUERYOBJECTUI64VEXTPROC)(GLuint id, GLenum pname, GLuint64 *params);
extern PFNGLGETQUERYOBJECTUI64VEXTPROC glad_glGetQueryObjectui64vEXT;




extern int GLAD_GL_EXT_transform_feedback;
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKEXTPROC)(GLenum primitiveMode);
extern PFNGLBEGINTRANSFORMFEEDBACKEXTPROC glad_glBeginTransformFeedbackEXT;

typedef void ( * PFNGLENDTRANSFORMFEEDBACKEXTPROC)(void);
extern PFNGLENDTRANSFORMFEEDBACKEXTPROC glad_glEndTransformFeedbackEXT;

typedef void ( * PFNGLBINDBUFFERRANGEEXTPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern PFNGLBINDBUFFERRANGEEXTPROC glad_glBindBufferRangeEXT;

typedef void ( * PFNGLBINDBUFFEROFFSETEXTPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
extern PFNGLBINDBUFFEROFFSETEXTPROC glad_glBindBufferOffsetEXT;

typedef void ( * PFNGLBINDBUFFERBASEEXTPROC)(GLenum target, GLuint index, GLuint buffer);
extern PFNGLBINDBUFFERBASEEXTPROC glad_glBindBufferBaseEXT;

typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC)(GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode);
extern PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC glad_glTransformFeedbackVaryingsEXT;

typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
extern PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC glad_glGetTransformFeedbackVaryingEXT;




extern int GLAD_GL_EXT_vertex_array;
typedef void ( * PFNGLARRAYELEMENTEXTPROC)(GLint i);
extern PFNGLARRAYELEMENTEXTPROC glad_glArrayElementEXT;

typedef void ( * PFNGLCOLORPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
extern PFNGLCOLORPOINTEREXTPROC glad_glColorPointerEXT;

typedef void ( * PFNGLDRAWARRAYSEXTPROC)(GLenum mode, GLint first, GLsizei count);
extern PFNGLDRAWARRAYSEXTPROC glad_glDrawArraysEXT;

typedef void ( * PFNGLEDGEFLAGPOINTEREXTPROC)(GLsizei stride, GLsizei count, const GLboolean *pointer);
extern PFNGLEDGEFLAGPOINTEREXTPROC glad_glEdgeFlagPointerEXT;

typedef void ( * PFNGLGETPOINTERVEXTPROC)(GLenum pname, void **params);
extern PFNGLGETPOINTERVEXTPROC glad_glGetPointervEXT;

typedef void ( * PFNGLINDEXPOINTEREXTPROC)(GLenum type, GLsizei stride, GLsizei count, const void *pointer);
extern PFNGLINDEXPOINTEREXTPROC glad_glIndexPointerEXT;

typedef void ( * PFNGLNORMALPOINTEREXTPROC)(GLenum type, GLsizei stride, GLsizei count, const void *pointer);
extern PFNGLNORMALPOINTEREXTPROC glad_glNormalPointerEXT;

typedef void ( * PFNGLTEXCOORDPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
extern PFNGLTEXCOORDPOINTEREXTPROC glad_glTexCoordPointerEXT;

typedef void ( * PFNGLVERTEXPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
extern PFNGLVERTEXPOINTEREXTPROC glad_glVertexPointerEXT;




extern int GLAD_GL_EXT_vertex_array_bgra;



extern int GLAD_GL_EXT_vertex_attrib_64bit;
typedef void ( * PFNGLVERTEXATTRIBL1DEXTPROC)(GLuint index, GLdouble x);
extern PFNGLVERTEXATTRIBL1DEXTPROC glad_glVertexAttribL1dEXT;

typedef void ( * PFNGLVERTEXATTRIBL2DEXTPROC)(GLuint index, GLdouble x, GLdouble y);
extern PFNGLVERTEXATTRIBL2DEXTPROC glad_glVertexAttribL2dEXT;

typedef void ( * PFNGLVERTEXATTRIBL3DEXTPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern PFNGLVERTEXATTRIBL3DEXTPROC glad_glVertexAttribL3dEXT;

typedef void ( * PFNGLVERTEXATTRIBL4DEXTPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLVERTEXATTRIBL4DEXTPROC glad_glVertexAttribL4dEXT;

typedef void ( * PFNGLVERTEXATTRIBL1DVEXTPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIBL1DVEXTPROC glad_glVertexAttribL1dvEXT;

typedef void ( * PFNGLVERTEXATTRIBL2DVEXTPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIBL2DVEXTPROC glad_glVertexAttribL2dvEXT;

typedef void ( * PFNGLVERTEXATTRIBL3DVEXTPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIBL3DVEXTPROC glad_glVertexAttribL3dvEXT;

typedef void ( * PFNGLVERTEXATTRIBL4DVEXTPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIBL4DVEXTPROC glad_glVertexAttribL4dvEXT;

typedef void ( * PFNGLVERTEXATTRIBLPOINTEREXTPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
extern PFNGLVERTEXATTRIBLPOINTEREXTPROC glad_glVertexAttribLPointerEXT;

typedef void ( * PFNGLGETVERTEXATTRIBLDVEXTPROC)(GLuint index, GLenum pname, GLdouble *params);
extern PFNGLGETVERTEXATTRIBLDVEXTPROC glad_glGetVertexAttribLdvEXT;




extern int GLAD_GL_EXT_vertex_shader;
typedef void ( * PFNGLBEGINVERTEXSHADEREXTPROC)(void);
extern PFNGLBEGINVERTEXSHADEREXTPROC glad_glBeginVertexShaderEXT;

typedef void ( * PFNGLENDVERTEXSHADEREXTPROC)(void);
extern PFNGLENDVERTEXSHADEREXTPROC glad_glEndVertexShaderEXT;

typedef void ( * PFNGLBINDVERTEXSHADEREXTPROC)(GLuint id);
extern PFNGLBINDVERTEXSHADEREXTPROC glad_glBindVertexShaderEXT;

typedef GLuint ( * PFNGLGENVERTEXSHADERSEXTPROC)(GLuint range);
extern PFNGLGENVERTEXSHADERSEXTPROC glad_glGenVertexShadersEXT;

typedef void ( * PFNGLDELETEVERTEXSHADEREXTPROC)(GLuint id);
extern PFNGLDELETEVERTEXSHADEREXTPROC glad_glDeleteVertexShaderEXT;

typedef void ( * PFNGLSHADEROP1EXTPROC)(GLenum op, GLuint res, GLuint arg1);
extern PFNGLSHADEROP1EXTPROC glad_glShaderOp1EXT;

typedef void ( * PFNGLSHADEROP2EXTPROC)(GLenum op, GLuint res, GLuint arg1, GLuint arg2);
extern PFNGLSHADEROP2EXTPROC glad_glShaderOp2EXT;

typedef void ( * PFNGLSHADEROP3EXTPROC)(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
extern PFNGLSHADEROP3EXTPROC glad_glShaderOp3EXT;

typedef void ( * PFNGLSWIZZLEEXTPROC)(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
extern PFNGLSWIZZLEEXTPROC glad_glSwizzleEXT;

typedef void ( * PFNGLWRITEMASKEXTPROC)(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
extern PFNGLWRITEMASKEXTPROC glad_glWriteMaskEXT;

typedef void ( * PFNGLINSERTCOMPONENTEXTPROC)(GLuint res, GLuint src, GLuint num);
extern PFNGLINSERTCOMPONENTEXTPROC glad_glInsertComponentEXT;

typedef void ( * PFNGLEXTRACTCOMPONENTEXTPROC)(GLuint res, GLuint src, GLuint num);
extern PFNGLEXTRACTCOMPONENTEXTPROC glad_glExtractComponentEXT;

typedef GLuint ( * PFNGLGENSYMBOLSEXTPROC)(GLenum datatype, GLenum storagetype, GLenum range, GLuint components);
extern PFNGLGENSYMBOLSEXTPROC glad_glGenSymbolsEXT;

typedef void ( * PFNGLSETINVARIANTEXTPROC)(GLuint id, GLenum type, const void *addr);
extern PFNGLSETINVARIANTEXTPROC glad_glSetInvariantEXT;

typedef void ( * PFNGLSETLOCALCONSTANTEXTPROC)(GLuint id, GLenum type, const void *addr);
extern PFNGLSETLOCALCONSTANTEXTPROC glad_glSetLocalConstantEXT;

typedef void ( * PFNGLVARIANTBVEXTPROC)(GLuint id, const GLbyte *addr);
extern PFNGLVARIANTBVEXTPROC glad_glVariantbvEXT;

typedef void ( * PFNGLVARIANTSVEXTPROC)(GLuint id, const GLshort *addr);
extern PFNGLVARIANTSVEXTPROC glad_glVariantsvEXT;

typedef void ( * PFNGLVARIANTIVEXTPROC)(GLuint id, const GLint *addr);
extern PFNGLVARIANTIVEXTPROC glad_glVariantivEXT;

typedef void ( * PFNGLVARIANTFVEXTPROC)(GLuint id, const GLfloat *addr);
extern PFNGLVARIANTFVEXTPROC glad_glVariantfvEXT;

typedef void ( * PFNGLVARIANTDVEXTPROC)(GLuint id, const GLdouble *addr);
extern PFNGLVARIANTDVEXTPROC glad_glVariantdvEXT;

typedef void ( * PFNGLVARIANTUBVEXTPROC)(GLuint id, const GLubyte *addr);
extern PFNGLVARIANTUBVEXTPROC glad_glVariantubvEXT;

typedef void ( * PFNGLVARIANTUSVEXTPROC)(GLuint id, const GLushort *addr);
extern PFNGLVARIANTUSVEXTPROC glad_glVariantusvEXT;

typedef void ( * PFNGLVARIANTUIVEXTPROC)(GLuint id, const GLuint *addr);
extern PFNGLVARIANTUIVEXTPROC glad_glVariantuivEXT;

typedef void ( * PFNGLVARIANTPOINTEREXTPROC)(GLuint id, GLenum type, GLuint stride, const void *addr);
extern PFNGLVARIANTPOINTEREXTPROC glad_glVariantPointerEXT;

typedef void ( * PFNGLENABLEVARIANTCLIENTSTATEEXTPROC)(GLuint id);
extern PFNGLENABLEVARIANTCLIENTSTATEEXTPROC glad_glEnableVariantClientStateEXT;

typedef void ( * PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC)(GLuint id);
extern PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC glad_glDisableVariantClientStateEXT;

typedef GLuint ( * PFNGLBINDLIGHTPARAMETEREXTPROC)(GLenum light, GLenum value);
extern PFNGLBINDLIGHTPARAMETEREXTPROC glad_glBindLightParameterEXT;

typedef GLuint ( * PFNGLBINDMATERIALPARAMETEREXTPROC)(GLenum face, GLenum value);
extern PFNGLBINDMATERIALPARAMETEREXTPROC glad_glBindMaterialParameterEXT;

typedef GLuint ( * PFNGLBINDTEXGENPARAMETEREXTPROC)(GLenum unit, GLenum coord, GLenum value);
extern PFNGLBINDTEXGENPARAMETEREXTPROC glad_glBindTexGenParameterEXT;

typedef GLuint ( * PFNGLBINDTEXTUREUNITPARAMETEREXTPROC)(GLenum unit, GLenum value);
extern PFNGLBINDTEXTUREUNITPARAMETEREXTPROC glad_glBindTextureUnitParameterEXT;

typedef GLuint ( * PFNGLBINDPARAMETEREXTPROC)(GLenum value);
extern PFNGLBINDPARAMETEREXTPROC glad_glBindParameterEXT;

typedef GLboolean ( * PFNGLISVARIANTENABLEDEXTPROC)(GLuint id, GLenum cap);
extern PFNGLISVARIANTENABLEDEXTPROC glad_glIsVariantEnabledEXT;

typedef void ( * PFNGLGETVARIANTBOOLEANVEXTPROC)(GLuint id, GLenum value, GLboolean *data);
extern PFNGLGETVARIANTBOOLEANVEXTPROC glad_glGetVariantBooleanvEXT;

typedef void ( * PFNGLGETVARIANTINTEGERVEXTPROC)(GLuint id, GLenum value, GLint *data);
extern PFNGLGETVARIANTINTEGERVEXTPROC glad_glGetVariantIntegervEXT;

typedef void ( * PFNGLGETVARIANTFLOATVEXTPROC)(GLuint id, GLenum value, GLfloat *data);
extern PFNGLGETVARIANTFLOATVEXTPROC glad_glGetVariantFloatvEXT;

typedef void ( * PFNGLGETVARIANTPOINTERVEXTPROC)(GLuint id, GLenum value, void **data);
extern PFNGLGETVARIANTPOINTERVEXTPROC glad_glGetVariantPointervEXT;

typedef void ( * PFNGLGETINVARIANTBOOLEANVEXTPROC)(GLuint id, GLenum value, GLboolean *data);
extern PFNGLGETINVARIANTBOOLEANVEXTPROC glad_glGetInvariantBooleanvEXT;

typedef void ( * PFNGLGETINVARIANTINTEGERVEXTPROC)(GLuint id, GLenum value, GLint *data);
extern PFNGLGETINVARIANTINTEGERVEXTPROC glad_glGetInvariantIntegervEXT;

typedef void ( * PFNGLGETINVARIANTFLOATVEXTPROC)(GLuint id, GLenum value, GLfloat *data);
extern PFNGLGETINVARIANTFLOATVEXTPROC glad_glGetInvariantFloatvEXT;

typedef void ( * PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC)(GLuint id, GLenum value, GLboolean *data);
extern PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC glad_glGetLocalConstantBooleanvEXT;

typedef void ( * PFNGLGETLOCALCONSTANTINTEGERVEXTPROC)(GLuint id, GLenum value, GLint *data);
extern PFNGLGETLOCALCONSTANTINTEGERVEXTPROC glad_glGetLocalConstantIntegervEXT;

typedef void ( * PFNGLGETLOCALCONSTANTFLOATVEXTPROC)(GLuint id, GLenum value, GLfloat *data);
extern PFNGLGETLOCALCONSTANTFLOATVEXTPROC glad_glGetLocalConstantFloatvEXT;




extern int GLAD_GL_EXT_vertex_weighting;
typedef void ( * PFNGLVERTEXWEIGHTFEXTPROC)(GLfloat weight);
extern PFNGLVERTEXWEIGHTFEXTPROC glad_glVertexWeightfEXT;

typedef void ( * PFNGLVERTEXWEIGHTFVEXTPROC)(const GLfloat *weight);
extern PFNGLVERTEXWEIGHTFVEXTPROC glad_glVertexWeightfvEXT;

typedef void ( * PFNGLVERTEXWEIGHTPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, const void *pointer);
extern PFNGLVERTEXWEIGHTPOINTEREXTPROC glad_glVertexWeightPointerEXT;




extern int GLAD_GL_EXT_win32_keyed_mutex;
typedef GLboolean ( * PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC)(GLuint memory, GLuint64 key, GLuint timeout);
extern PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC glad_glAcquireKeyedMutexWin32EXT;

typedef GLboolean ( * PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC)(GLuint memory, GLuint64 key);
extern PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC glad_glReleaseKeyedMutexWin32EXT;




extern int GLAD_GL_EXT_window_rectangles;
typedef void ( * PFNGLWINDOWRECTANGLESEXTPROC)(GLenum mode, GLsizei count, const GLint *box);
extern PFNGLWINDOWRECTANGLESEXTPROC glad_glWindowRectanglesEXT;




extern int GLAD_GL_EXT_x11_sync_object;
typedef GLsync ( * PFNGLIMPORTSYNCEXTPROC)(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);
extern PFNGLIMPORTSYNCEXTPROC glad_glImportSyncEXT;




extern int GLAD_GL_GREMEDY_frame_terminator;
typedef void ( * PFNGLFRAMETERMINATORGREMEDYPROC)(void);
extern PFNGLFRAMETERMINATORGREMEDYPROC glad_glFrameTerminatorGREMEDY;




extern int GLAD_GL_GREMEDY_string_marker;
typedef void ( * PFNGLSTRINGMARKERGREMEDYPROC)(GLsizei len, const void *string);
extern PFNGLSTRINGMARKERGREMEDYPROC glad_glStringMarkerGREMEDY;




extern int GLAD_GL_HP_convolution_border_modes;



extern int GLAD_GL_HP_image_transform;
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIHPPROC)(GLenum target, GLenum pname, GLint param);
extern PFNGLIMAGETRANSFORMPARAMETERIHPPROC glad_glImageTransformParameteriHP;

typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFHPPROC)(GLenum target, GLenum pname, GLfloat param);
extern PFNGLIMAGETRANSFORMPARAMETERFHPPROC glad_glImageTransformParameterfHP;

typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIVHPPROC)(GLenum target, GLenum pname, const GLint *params);
extern PFNGLIMAGETRANSFORMPARAMETERIVHPPROC glad_glImageTransformParameterivHP;

typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFVHPPROC)(GLenum target, GLenum pname, const GLfloat *params);
extern PFNGLIMAGETRANSFORMPARAMETERFVHPPROC glad_glImageTransformParameterfvHP;

typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC glad_glGetImageTransformParameterivHP;

typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC)(GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC glad_glGetImageTransformParameterfvHP;




extern int GLAD_GL_HP_occlusion_test;



extern int GLAD_GL_HP_texture_lighting;



extern int GLAD_GL_IBM_cull_vertex;



extern int GLAD_GL_IBM_multimode_draw_arrays;
typedef void ( * PFNGLMULTIMODEDRAWARRAYSIBMPROC)(const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
extern PFNGLMULTIMODEDRAWARRAYSIBMPROC glad_glMultiModeDrawArraysIBM;

typedef void ( * PFNGLMULTIMODEDRAWELEMENTSIBMPROC)(const GLenum *mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount, GLint modestride);
extern PFNGLMULTIMODEDRAWELEMENTSIBMPROC glad_glMultiModeDrawElementsIBM;




extern int GLAD_GL_IBM_rasterpos_clip;



extern int GLAD_GL_IBM_static_data;
typedef void ( * PFNGLFLUSHSTATICDATAIBMPROC)(GLenum target);
extern PFNGLFLUSHSTATICDATAIBMPROC glad_glFlushStaticDataIBM;




extern int GLAD_GL_IBM_texture_mirrored_repeat;



extern int GLAD_GL_IBM_vertex_array_lists;
typedef void ( * PFNGLCOLORPOINTERLISTIBMPROC)(GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride);
extern PFNGLCOLORPOINTERLISTIBMPROC glad_glColorPointerListIBM;

typedef void ( * PFNGLSECONDARYCOLORPOINTERLISTIBMPROC)(GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride);
extern PFNGLSECONDARYCOLORPOINTERLISTIBMPROC glad_glSecondaryColorPointerListIBM;

typedef void ( * PFNGLEDGEFLAGPOINTERLISTIBMPROC)(GLint stride, const GLboolean **pointer, GLint ptrstride);
extern PFNGLEDGEFLAGPOINTERLISTIBMPROC glad_glEdgeFlagPointerListIBM;

typedef void ( * PFNGLFOGCOORDPOINTERLISTIBMPROC)(GLenum type, GLint stride, const void **pointer, GLint ptrstride);
extern PFNGLFOGCOORDPOINTERLISTIBMPROC glad_glFogCoordPointerListIBM;

typedef void ( * PFNGLINDEXPOINTERLISTIBMPROC)(GLenum type, GLint stride, const void **pointer, GLint ptrstride);
extern PFNGLINDEXPOINTERLISTIBMPROC glad_glIndexPointerListIBM;

typedef void ( * PFNGLNORMALPOINTERLISTIBMPROC)(GLenum type, GLint stride, const void **pointer, GLint ptrstride);
extern PFNGLNORMALPOINTERLISTIBMPROC glad_glNormalPointerListIBM;

typedef void ( * PFNGLTEXCOORDPOINTERLISTIBMPROC)(GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride);
extern PFNGLTEXCOORDPOINTERLISTIBMPROC glad_glTexCoordPointerListIBM;

typedef void ( * PFNGLVERTEXPOINTERLISTIBMPROC)(GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride);
extern PFNGLVERTEXPOINTERLISTIBMPROC glad_glVertexPointerListIBM;




extern int GLAD_GL_INGR_blend_func_separate;
typedef void ( * PFNGLBLENDFUNCSEPARATEINGRPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
extern PFNGLBLENDFUNCSEPARATEINGRPROC glad_glBlendFuncSeparateINGR;




extern int GLAD_GL_INGR_color_clamp;



extern int GLAD_GL_INGR_interlace_read;



extern int GLAD_GL_INTEL_blackhole_render;



extern int GLAD_GL_INTEL_conservative_rasterization;



extern int GLAD_GL_INTEL_fragment_shader_ordering;



extern int GLAD_GL_INTEL_framebuffer_CMAA;
typedef void ( * PFNGLAPPLYFRAMEBUFFERATTACHMENTCMAAINTELPROC)(void);
extern PFNGLAPPLYFRAMEBUFFERATTACHMENTCMAAINTELPROC glad_glApplyFramebufferAttachmentCMAAINTEL;




extern int GLAD_GL_INTEL_map_texture;
typedef void ( * PFNGLSYNCTEXTUREINTELPROC)(GLuint texture);
extern PFNGLSYNCTEXTUREINTELPROC glad_glSyncTextureINTEL;

typedef void ( * PFNGLUNMAPTEXTURE2DINTELPROC)(GLuint texture, GLint level);
extern PFNGLUNMAPTEXTURE2DINTELPROC glad_glUnmapTexture2DINTEL;

typedef void * ( * PFNGLMAPTEXTURE2DINTELPROC)(GLuint texture, GLint level, GLbitfield access, GLint *stride, GLenum *layout);
extern PFNGLMAPTEXTURE2DINTELPROC glad_glMapTexture2DINTEL;




extern int GLAD_GL_INTEL_parallel_arrays;
typedef void ( * PFNGLVERTEXPOINTERVINTELPROC)(GLint size, GLenum type, const void **pointer);
extern PFNGLVERTEXPOINTERVINTELPROC glad_glVertexPointervINTEL;

typedef void ( * PFNGLNORMALPOINTERVINTELPROC)(GLenum type, const void **pointer);
extern PFNGLNORMALPOINTERVINTELPROC glad_glNormalPointervINTEL;

typedef void ( * PFNGLCOLORPOINTERVINTELPROC)(GLint size, GLenum type, const void **pointer);
extern PFNGLCOLORPOINTERVINTELPROC glad_glColorPointervINTEL;

typedef void ( * PFNGLTEXCOORDPOINTERVINTELPROC)(GLint size, GLenum type, const void **pointer);
extern PFNGLTEXCOORDPOINTERVINTELPROC glad_glTexCoordPointervINTEL;




extern int GLAD_GL_INTEL_performance_query;
typedef void ( * PFNGLBEGINPERFQUERYINTELPROC)(GLuint queryHandle);
extern PFNGLBEGINPERFQUERYINTELPROC glad_glBeginPerfQueryINTEL;

typedef void ( * PFNGLCREATEPERFQUERYINTELPROC)(GLuint queryId, GLuint *queryHandle);
extern PFNGLCREATEPERFQUERYINTELPROC glad_glCreatePerfQueryINTEL;

typedef void ( * PFNGLDELETEPERFQUERYINTELPROC)(GLuint queryHandle);
extern PFNGLDELETEPERFQUERYINTELPROC glad_glDeletePerfQueryINTEL;

typedef void ( * PFNGLENDPERFQUERYINTELPROC)(GLuint queryHandle);
extern PFNGLENDPERFQUERYINTELPROC glad_glEndPerfQueryINTEL;

typedef void ( * PFNGLGETFIRSTPERFQUERYIDINTELPROC)(GLuint *queryId);
extern PFNGLGETFIRSTPERFQUERYIDINTELPROC glad_glGetFirstPerfQueryIdINTEL;

typedef void ( * PFNGLGETNEXTPERFQUERYIDINTELPROC)(GLuint queryId, GLuint *nextQueryId);
extern PFNGLGETNEXTPERFQUERYIDINTELPROC glad_glGetNextPerfQueryIdINTEL;

typedef void ( * PFNGLGETPERFCOUNTERINFOINTELPROC)(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar *counterName, GLuint counterDescLength, GLchar *counterDesc, GLuint *counterOffset, GLuint *counterDataSize, GLuint *counterTypeEnum, GLuint *counterDataTypeEnum, GLuint64 *rawCounterMaxValue);
extern PFNGLGETPERFCOUNTERINFOINTELPROC glad_glGetPerfCounterInfoINTEL;

typedef void ( * PFNGLGETPERFQUERYDATAINTELPROC)(GLuint queryHandle, GLuint flags, GLsizei dataSize, void *data, GLuint *bytesWritten);
extern PFNGLGETPERFQUERYDATAINTELPROC glad_glGetPerfQueryDataINTEL;

typedef void ( * PFNGLGETPERFQUERYIDBYNAMEINTELPROC)(GLchar *queryName, GLuint *queryId);
extern PFNGLGETPERFQUERYIDBYNAMEINTELPROC glad_glGetPerfQueryIdByNameINTEL;

typedef void ( * PFNGLGETPERFQUERYINFOINTELPROC)(GLuint queryId, GLuint queryNameLength, GLchar *queryName, GLuint *dataSize, GLuint *noCounters, GLuint *noInstances, GLuint *capsMask);
extern PFNGLGETPERFQUERYINFOINTELPROC glad_glGetPerfQueryInfoINTEL;




extern int GLAD_GL_KHR_blend_equation_advanced;
typedef void ( * PFNGLBLENDBARRIERKHRPROC)(void);
extern PFNGLBLENDBARRIERKHRPROC glad_glBlendBarrierKHR;




extern int GLAD_GL_KHR_blend_equation_advanced_coherent;



extern int GLAD_GL_KHR_context_flush_control;



extern int GLAD_GL_KHR_debug;
typedef void ( * PFNGLDEBUGMESSAGECONTROLKHRPROC)(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
extern PFNGLDEBUGMESSAGECONTROLKHRPROC glad_glDebugMessageControlKHR;

typedef void ( * PFNGLDEBUGMESSAGEINSERTKHRPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
extern PFNGLDEBUGMESSAGEINSERTKHRPROC glad_glDebugMessageInsertKHR;

typedef void ( * PFNGLDEBUGMESSAGECALLBACKKHRPROC)(GLDEBUGPROCKHR callback, const void *userParam);
extern PFNGLDEBUGMESSAGECALLBACKKHRPROC glad_glDebugMessageCallbackKHR;

typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGKHRPROC)(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
extern PFNGLGETDEBUGMESSAGELOGKHRPROC glad_glGetDebugMessageLogKHR;

typedef void ( * PFNGLPUSHDEBUGGROUPKHRPROC)(GLenum source, GLuint id, GLsizei length, const GLchar *message);
extern PFNGLPUSHDEBUGGROUPKHRPROC glad_glPushDebugGroupKHR;

typedef void ( * PFNGLPOPDEBUGGROUPKHRPROC)(void);
extern PFNGLPOPDEBUGGROUPKHRPROC glad_glPopDebugGroupKHR;

typedef void ( * PFNGLOBJECTLABELKHRPROC)(GLenum identifier, GLuint name, GLsizei length, const GLchar *label);
extern PFNGLOBJECTLABELKHRPROC glad_glObjectLabelKHR;

typedef void ( * PFNGLGETOBJECTLABELKHRPROC)(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label);
extern PFNGLGETOBJECTLABELKHRPROC glad_glGetObjectLabelKHR;

typedef void ( * PFNGLOBJECTPTRLABELKHRPROC)(const void *ptr, GLsizei length, const GLchar *label);
extern PFNGLOBJECTPTRLABELKHRPROC glad_glObjectPtrLabelKHR;

typedef void ( * PFNGLGETOBJECTPTRLABELKHRPROC)(const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label);
extern PFNGLGETOBJECTPTRLABELKHRPROC glad_glGetObjectPtrLabelKHR;

typedef void ( * PFNGLGETPOINTERVKHRPROC)(GLenum pname, void **params);
extern PFNGLGETPOINTERVKHRPROC glad_glGetPointervKHR;




extern int GLAD_GL_KHR_no_error;



extern int GLAD_GL_KHR_parallel_shader_compile;
typedef void ( * PFNGLMAXSHADERCOMPILERTHREADSKHRPROC)(GLuint count);
extern PFNGLMAXSHADERCOMPILERTHREADSKHRPROC glad_glMaxShaderCompilerThreadsKHR;




extern int GLAD_GL_KHR_robust_buffer_access_behavior;



extern int GLAD_GL_KHR_robustness;
typedef GLenum ( * PFNGLGETGRAPHICSRESETSTATUSKHRPROC)(void);
extern PFNGLGETGRAPHICSRESETSTATUSKHRPROC glad_glGetGraphicsResetStatusKHR;

typedef void ( * PFNGLREADNPIXELSKHRPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);
extern PFNGLREADNPIXELSKHRPROC glad_glReadnPixelsKHR;

typedef void ( * PFNGLGETNUNIFORMFVKHRPROC)(GLuint program, GLint location, GLsizei bufSize, GLfloat *params);
extern PFNGLGETNUNIFORMFVKHRPROC glad_glGetnUniformfvKHR;

typedef void ( * PFNGLGETNUNIFORMIVKHRPROC)(GLuint program, GLint location, GLsizei bufSize, GLint *params);
extern PFNGLGETNUNIFORMIVKHRPROC glad_glGetnUniformivKHR;

typedef void ( * PFNGLGETNUNIFORMUIVKHRPROC)(GLuint program, GLint location, GLsizei bufSize, GLuint *params);
extern PFNGLGETNUNIFORMUIVKHRPROC glad_glGetnUniformuivKHR;




extern int GLAD_GL_KHR_shader_subgroup;



extern int GLAD_GL_KHR_texture_compression_astc_hdr;



extern int GLAD_GL_KHR_texture_compression_astc_ldr;



extern int GLAD_GL_KHR_texture_compression_astc_sliced_3d;



extern int GLAD_GL_MESAX_texture_stack;



extern int GLAD_GL_MESA_framebuffer_flip_x;



extern int GLAD_GL_MESA_framebuffer_flip_y;
typedef void ( * PFNGLFRAMEBUFFERPARAMETERIMESAPROC)(GLenum target, GLenum pname, GLint param);
extern PFNGLFRAMEBUFFERPARAMETERIMESAPROC glad_glFramebufferParameteriMESA;

typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERIVMESAPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETFRAMEBUFFERPARAMETERIVMESAPROC glad_glGetFramebufferParameterivMESA;




extern int GLAD_GL_MESA_framebuffer_swap_xy;



extern int GLAD_GL_MESA_pack_invert;



extern int GLAD_GL_MESA_program_binary_formats;



extern int GLAD_GL_MESA_resize_buffers;
typedef void ( * PFNGLRESIZEBUFFERSMESAPROC)(void);
extern PFNGLRESIZEBUFFERSMESAPROC glad_glResizeBuffersMESA;




extern int GLAD_GL_MESA_shader_integer_functions;



extern int GLAD_GL_MESA_tile_raster_order;



extern int GLAD_GL_MESA_window_pos;
typedef void ( * PFNGLWINDOWPOS2DMESAPROC)(GLdouble x, GLdouble y);
extern PFNGLWINDOWPOS2DMESAPROC glad_glWindowPos2dMESA;

typedef void ( * PFNGLWINDOWPOS2DVMESAPROC)(const GLdouble *v);
extern PFNGLWINDOWPOS2DVMESAPROC glad_glWindowPos2dvMESA;

typedef void ( * PFNGLWINDOWPOS2FMESAPROC)(GLfloat x, GLfloat y);
extern PFNGLWINDOWPOS2FMESAPROC glad_glWindowPos2fMESA;

typedef void ( * PFNGLWINDOWPOS2FVMESAPROC)(const GLfloat *v);
extern PFNGLWINDOWPOS2FVMESAPROC glad_glWindowPos2fvMESA;

typedef void ( * PFNGLWINDOWPOS2IMESAPROC)(GLint x, GLint y);
extern PFNGLWINDOWPOS2IMESAPROC glad_glWindowPos2iMESA;

typedef void ( * PFNGLWINDOWPOS2IVMESAPROC)(const GLint *v);
extern PFNGLWINDOWPOS2IVMESAPROC glad_glWindowPos2ivMESA;

typedef void ( * PFNGLWINDOWPOS2SMESAPROC)(GLshort x, GLshort y);
extern PFNGLWINDOWPOS2SMESAPROC glad_glWindowPos2sMESA;

typedef void ( * PFNGLWINDOWPOS2SVMESAPROC)(const GLshort *v);
extern PFNGLWINDOWPOS2SVMESAPROC glad_glWindowPos2svMESA;

typedef void ( * PFNGLWINDOWPOS3DMESAPROC)(GLdouble x, GLdouble y, GLdouble z);
extern PFNGLWINDOWPOS3DMESAPROC glad_glWindowPos3dMESA;

typedef void ( * PFNGLWINDOWPOS3DVMESAPROC)(const GLdouble *v);
extern PFNGLWINDOWPOS3DVMESAPROC glad_glWindowPos3dvMESA;

typedef void ( * PFNGLWINDOWPOS3FMESAPROC)(GLfloat x, GLfloat y, GLfloat z);
extern PFNGLWINDOWPOS3FMESAPROC glad_glWindowPos3fMESA;

typedef void ( * PFNGLWINDOWPOS3FVMESAPROC)(const GLfloat *v);
extern PFNGLWINDOWPOS3FVMESAPROC glad_glWindowPos3fvMESA;

typedef void ( * PFNGLWINDOWPOS3IMESAPROC)(GLint x, GLint y, GLint z);
extern PFNGLWINDOWPOS3IMESAPROC glad_glWindowPos3iMESA;

typedef void ( * PFNGLWINDOWPOS3IVMESAPROC)(const GLint *v);
extern PFNGLWINDOWPOS3IVMESAPROC glad_glWindowPos3ivMESA;

typedef void ( * PFNGLWINDOWPOS3SMESAPROC)(GLshort x, GLshort y, GLshort z);
extern PFNGLWINDOWPOS3SMESAPROC glad_glWindowPos3sMESA;

typedef void ( * PFNGLWINDOWPOS3SVMESAPROC)(const GLshort *v);
extern PFNGLWINDOWPOS3SVMESAPROC glad_glWindowPos3svMESA;

typedef void ( * PFNGLWINDOWPOS4DMESAPROC)(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLWINDOWPOS4DMESAPROC glad_glWindowPos4dMESA;

typedef void ( * PFNGLWINDOWPOS4DVMESAPROC)(const GLdouble *v);
extern PFNGLWINDOWPOS4DVMESAPROC glad_glWindowPos4dvMESA;

typedef void ( * PFNGLWINDOWPOS4FMESAPROC)(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern PFNGLWINDOWPOS4FMESAPROC glad_glWindowPos4fMESA;

typedef void ( * PFNGLWINDOWPOS4FVMESAPROC)(const GLfloat *v);
extern PFNGLWINDOWPOS4FVMESAPROC glad_glWindowPos4fvMESA;

typedef void ( * PFNGLWINDOWPOS4IMESAPROC)(GLint x, GLint y, GLint z, GLint w);
extern PFNGLWINDOWPOS4IMESAPROC glad_glWindowPos4iMESA;

typedef void ( * PFNGLWINDOWPOS4IVMESAPROC)(const GLint *v);
extern PFNGLWINDOWPOS4IVMESAPROC glad_glWindowPos4ivMESA;

typedef void ( * PFNGLWINDOWPOS4SMESAPROC)(GLshort x, GLshort y, GLshort z, GLshort w);
extern PFNGLWINDOWPOS4SMESAPROC glad_glWindowPos4sMESA;

typedef void ( * PFNGLWINDOWPOS4SVMESAPROC)(const GLshort *v);
extern PFNGLWINDOWPOS4SVMESAPROC glad_glWindowPos4svMESA;




extern int GLAD_GL_MESA_ycbcr_texture;



extern int GLAD_GL_NVX_blend_equation_advanced_multi_draw_buffers;



extern int GLAD_GL_NVX_conditional_render;
typedef void ( * PFNGLBEGINCONDITIONALRENDERNVXPROC)(GLuint id);
extern PFNGLBEGINCONDITIONALRENDERNVXPROC glad_glBeginConditionalRenderNVX;

typedef void ( * PFNGLENDCONDITIONALRENDERNVXPROC)(void);
extern PFNGLENDCONDITIONALRENDERNVXPROC glad_glEndConditionalRenderNVX;




extern int GLAD_GL_NVX_gpu_memory_info;



extern int GLAD_GL_NVX_gpu_multicast2;
typedef void ( * PFNGLUPLOADGPUMASKNVXPROC)(GLbitfield mask);
extern PFNGLUPLOADGPUMASKNVXPROC glad_glUploadGpuMaskNVX;

typedef void ( * PFNGLMULTICASTVIEWPORTARRAYVNVXPROC)(GLuint gpu, GLuint first, GLsizei count, const GLfloat *v);
extern PFNGLMULTICASTVIEWPORTARRAYVNVXPROC glad_glMulticastViewportArrayvNVX;

typedef void ( * PFNGLMULTICASTVIEWPORTPOSITIONWSCALENVXPROC)(GLuint gpu, GLuint index, GLfloat xcoeff, GLfloat ycoeff);
extern PFNGLMULTICASTVIEWPORTPOSITIONWSCALENVXPROC glad_glMulticastViewportPositionWScaleNVX;

typedef void ( * PFNGLMULTICASTSCISSORARRAYVNVXPROC)(GLuint gpu, GLuint first, GLsizei count, const GLint *v);
extern PFNGLMULTICASTSCISSORARRAYVNVXPROC glad_glMulticastScissorArrayvNVX;

typedef GLuint ( * PFNGLASYNCCOPYBUFFERSUBDATANVXPROC)(GLsizei waitSemaphoreCount, const GLuint *waitSemaphoreArray, const GLuint64 *fenceValueArray, GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray);
extern PFNGLASYNCCOPYBUFFERSUBDATANVXPROC glad_glAsyncCopyBufferSubDataNVX;

typedef GLuint ( * PFNGLASYNCCOPYIMAGESUBDATANVXPROC)(GLsizei waitSemaphoreCount, const GLuint *waitSemaphoreArray, const GLuint64 *waitValueArray, GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray);
extern PFNGLASYNCCOPYIMAGESUBDATANVXPROC glad_glAsyncCopyImageSubDataNVX;




extern int GLAD_GL_NVX_linked_gpu_multicast;
typedef void ( * PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC)(GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
extern PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC glad_glLGPUNamedBufferSubDataNVX;

typedef void ( * PFNGLLGPUCOPYIMAGESUBDATANVXPROC)(GLuint sourceGpu, GLbitfield destinationGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srxY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
extern PFNGLLGPUCOPYIMAGESUBDATANVXPROC glad_glLGPUCopyImageSubDataNVX;

typedef void ( * PFNGLLGPUINTERLOCKNVXPROC)(void);
extern PFNGLLGPUINTERLOCKNVXPROC glad_glLGPUInterlockNVX;




extern int GLAD_GL_NVX_progress_fence;
typedef GLuint ( * PFNGLCREATEPROGRESSFENCENVXPROC)(void);
extern PFNGLCREATEPROGRESSFENCENVXPROC glad_glCreateProgressFenceNVX;

typedef void ( * PFNGLSIGNALSEMAPHOREUI64NVXPROC)(GLuint signalGpu, GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray);
extern PFNGLSIGNALSEMAPHOREUI64NVXPROC glad_glSignalSemaphoreui64NVX;

typedef void ( * PFNGLWAITSEMAPHOREUI64NVXPROC)(GLuint waitGpu, GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray);
extern PFNGLWAITSEMAPHOREUI64NVXPROC glad_glWaitSemaphoreui64NVX;

typedef void ( * PFNGLCLIENTWAITSEMAPHOREUI64NVXPROC)(GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray);
extern PFNGLCLIENTWAITSEMAPHOREUI64NVXPROC glad_glClientWaitSemaphoreui64NVX;




extern int GLAD_GL_NV_alpha_to_coverage_dither_control;
typedef void ( * PFNGLALPHATOCOVERAGEDITHERCONTROLNVPROC)(GLenum mode);
extern PFNGLALPHATOCOVERAGEDITHERCONTROLNVPROC glad_glAlphaToCoverageDitherControlNV;




extern int GLAD_GL_NV_bindless_multi_draw_indirect;
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC)(GLenum mode, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
extern PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC glad_glMultiDrawArraysIndirectBindlessNV;

typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC)(GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
extern PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC glad_glMultiDrawElementsIndirectBindlessNV;




extern int GLAD_GL_NV_bindless_multi_draw_indirect_count;
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC)(GLenum mode, const void *indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
extern PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC glad_glMultiDrawArraysIndirectBindlessCountNV;

typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC)(GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
extern PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC glad_glMultiDrawElementsIndirectBindlessCountNV;




extern int GLAD_GL_NV_bindless_texture;
typedef GLuint64 ( * PFNGLGETTEXTUREHANDLENVPROC)(GLuint texture);
extern PFNGLGETTEXTUREHANDLENVPROC glad_glGetTextureHandleNV;

typedef GLuint64 ( * PFNGLGETTEXTURESAMPLERHANDLENVPROC)(GLuint texture, GLuint sampler);
extern PFNGLGETTEXTURESAMPLERHANDLENVPROC glad_glGetTextureSamplerHandleNV;

typedef void ( * PFNGLMAKETEXTUREHANDLERESIDENTNVPROC)(GLuint64 handle);
extern PFNGLMAKETEXTUREHANDLERESIDENTNVPROC glad_glMakeTextureHandleResidentNV;

typedef void ( * PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC)(GLuint64 handle);
extern PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC glad_glMakeTextureHandleNonResidentNV;

typedef GLuint64 ( * PFNGLGETIMAGEHANDLENVPROC)(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
extern PFNGLGETIMAGEHANDLENVPROC glad_glGetImageHandleNV;

typedef void ( * PFNGLMAKEIMAGEHANDLERESIDENTNVPROC)(GLuint64 handle, GLenum access);
extern PFNGLMAKEIMAGEHANDLERESIDENTNVPROC glad_glMakeImageHandleResidentNV;

typedef void ( * PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC)(GLuint64 handle);
extern PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC glad_glMakeImageHandleNonResidentNV;

typedef void ( * PFNGLUNIFORMHANDLEUI64NVPROC)(GLint location, GLuint64 value);
extern PFNGLUNIFORMHANDLEUI64NVPROC glad_glUniformHandleui64NV;

typedef void ( * PFNGLUNIFORMHANDLEUI64VNVPROC)(GLint location, GLsizei count, const GLuint64 *value);
extern PFNGLUNIFORMHANDLEUI64VNVPROC glad_glUniformHandleui64vNV;

typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC)(GLuint program, GLint location, GLuint64 value);
extern PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC glad_glProgramUniformHandleui64NV;

typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 *values);
extern PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC glad_glProgramUniformHandleui64vNV;

typedef GLboolean ( * PFNGLISTEXTUREHANDLERESIDENTNVPROC)(GLuint64 handle);
extern PFNGLISTEXTUREHANDLERESIDENTNVPROC glad_glIsTextureHandleResidentNV;

typedef GLboolean ( * PFNGLISIMAGEHANDLERESIDENTNVPROC)(GLuint64 handle);
extern PFNGLISIMAGEHANDLERESIDENTNVPROC glad_glIsImageHandleResidentNV;




extern int GLAD_GL_NV_blend_equation_advanced;
typedef void ( * PFNGLBLENDPARAMETERINVPROC)(GLenum pname, GLint value);
extern PFNGLBLENDPARAMETERINVPROC glad_glBlendParameteriNV;

typedef void ( * PFNGLBLENDBARRIERNVPROC)(void);
extern PFNGLBLENDBARRIERNVPROC glad_glBlendBarrierNV;




extern int GLAD_GL_NV_blend_equation_advanced_coherent;



extern int GLAD_GL_NV_blend_minmax_factor;



extern int GLAD_GL_NV_blend_square;



extern int GLAD_GL_NV_clip_space_w_scaling;
typedef void ( * PFNGLVIEWPORTPOSITIONWSCALENVPROC)(GLuint index, GLfloat xcoeff, GLfloat ycoeff);
extern PFNGLVIEWPORTPOSITIONWSCALENVPROC glad_glViewportPositionWScaleNV;




extern int GLAD_GL_NV_command_list;
typedef void ( * PFNGLCREATESTATESNVPROC)(GLsizei n, GLuint *states);
extern PFNGLCREATESTATESNVPROC glad_glCreateStatesNV;

typedef void ( * PFNGLDELETESTATESNVPROC)(GLsizei n, const GLuint *states);
extern PFNGLDELETESTATESNVPROC glad_glDeleteStatesNV;

typedef GLboolean ( * PFNGLISSTATENVPROC)(GLuint state);
extern PFNGLISSTATENVPROC glad_glIsStateNV;

typedef void ( * PFNGLSTATECAPTURENVPROC)(GLuint state, GLenum mode);
extern PFNGLSTATECAPTURENVPROC glad_glStateCaptureNV;

typedef GLuint ( * PFNGLGETCOMMANDHEADERNVPROC)(GLenum tokenID, GLuint size);
extern PFNGLGETCOMMANDHEADERNVPROC glad_glGetCommandHeaderNV;

typedef GLushort ( * PFNGLGETSTAGEINDEXNVPROC)(GLenum shadertype);
extern PFNGLGETSTAGEINDEXNVPROC glad_glGetStageIndexNV;

typedef void ( * PFNGLDRAWCOMMANDSNVPROC)(GLenum primitiveMode, GLuint buffer, const GLintptr *indirects, const GLsizei *sizes, GLuint count);
extern PFNGLDRAWCOMMANDSNVPROC glad_glDrawCommandsNV;

typedef void ( * PFNGLDRAWCOMMANDSADDRESSNVPROC)(GLenum primitiveMode, const GLuint64 *indirects, const GLsizei *sizes, GLuint count);
extern PFNGLDRAWCOMMANDSADDRESSNVPROC glad_glDrawCommandsAddressNV;

typedef void ( * PFNGLDRAWCOMMANDSSTATESNVPROC)(GLuint buffer, const GLintptr *indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count);
extern PFNGLDRAWCOMMANDSSTATESNVPROC glad_glDrawCommandsStatesNV;

typedef void ( * PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC)(const GLuint64 *indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count);
extern PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC glad_glDrawCommandsStatesAddressNV;

typedef void ( * PFNGLCREATECOMMANDLISTSNVPROC)(GLsizei n, GLuint *lists);
extern PFNGLCREATECOMMANDLISTSNVPROC glad_glCreateCommandListsNV;

typedef void ( * PFNGLDELETECOMMANDLISTSNVPROC)(GLsizei n, const GLuint *lists);
extern PFNGLDELETECOMMANDLISTSNVPROC glad_glDeleteCommandListsNV;

typedef GLboolean ( * PFNGLISCOMMANDLISTNVPROC)(GLuint list);
extern PFNGLISCOMMANDLISTNVPROC glad_glIsCommandListNV;

typedef void ( * PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC)(GLuint list, GLuint segment, const void **indirects, const GLsizei *sizes, const GLuint *states, const GLuint *fbos, GLuint count);
extern PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC glad_glListDrawCommandsStatesClientNV;

typedef void ( * PFNGLCOMMANDLISTSEGMENTSNVPROC)(GLuint list, GLuint segments);
extern PFNGLCOMMANDLISTSEGMENTSNVPROC glad_glCommandListSegmentsNV;

typedef void ( * PFNGLCOMPILECOMMANDLISTNVPROC)(GLuint list);
extern PFNGLCOMPILECOMMANDLISTNVPROC glad_glCompileCommandListNV;

typedef void ( * PFNGLCALLCOMMANDLISTNVPROC)(GLuint list);
extern PFNGLCALLCOMMANDLISTNVPROC glad_glCallCommandListNV;




extern int GLAD_GL_NV_compute_program5;



extern int GLAD_GL_NV_compute_shader_derivatives;



extern int GLAD_GL_NV_conditional_render;
typedef void ( * PFNGLBEGINCONDITIONALRENDERNVPROC)(GLuint id, GLenum mode);
extern PFNGLBEGINCONDITIONALRENDERNVPROC glad_glBeginConditionalRenderNV;

typedef void ( * PFNGLENDCONDITIONALRENDERNVPROC)(void);
extern PFNGLENDCONDITIONALRENDERNVPROC glad_glEndConditionalRenderNV;




extern int GLAD_GL_NV_conservative_raster;
typedef void ( * PFNGLSUBPIXELPRECISIONBIASNVPROC)(GLuint xbits, GLuint ybits);
extern PFNGLSUBPIXELPRECISIONBIASNVPROC glad_glSubpixelPrecisionBiasNV;




extern int GLAD_GL_NV_conservative_raster_dilate;
typedef void ( * PFNGLCONSERVATIVERASTERPARAMETERFNVPROC)(GLenum pname, GLfloat value);
extern PFNGLCONSERVATIVERASTERPARAMETERFNVPROC glad_glConservativeRasterParameterfNV;




extern int GLAD_GL_NV_conservative_raster_pre_snap;



extern int GLAD_GL_NV_conservative_raster_pre_snap_triangles;
typedef void ( * PFNGLCONSERVATIVERASTERPARAMETERINVPROC)(GLenum pname, GLint param);
extern PFNGLCONSERVATIVERASTERPARAMETERINVPROC glad_glConservativeRasterParameteriNV;




extern int GLAD_GL_NV_conservative_raster_underestimation;



extern int GLAD_GL_NV_copy_depth_to_color;



extern int GLAD_GL_NV_copy_image;
typedef void ( * PFNGLCOPYIMAGESUBDATANVPROC)(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
extern PFNGLCOPYIMAGESUBDATANVPROC glad_glCopyImageSubDataNV;




extern int GLAD_GL_NV_deep_texture3D;



extern int GLAD_GL_NV_depth_buffer_float;
typedef void ( * PFNGLDEPTHRANGEDNVPROC)(GLdouble zNear, GLdouble zFar);
extern PFNGLDEPTHRANGEDNVPROC glad_glDepthRangedNV;

typedef void ( * PFNGLCLEARDEPTHDNVPROC)(GLdouble depth);
extern PFNGLCLEARDEPTHDNVPROC glad_glClearDepthdNV;

typedef void ( * PFNGLDEPTHBOUNDSDNVPROC)(GLdouble zmin, GLdouble zmax);
extern PFNGLDEPTHBOUNDSDNVPROC glad_glDepthBoundsdNV;




extern int GLAD_GL_NV_depth_clamp;



extern int GLAD_GL_NV_draw_texture;
typedef void ( * PFNGLDRAWTEXTURENVPROC)(GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
extern PFNGLDRAWTEXTURENVPROC glad_glDrawTextureNV;




extern int GLAD_GL_NV_draw_vulkan_image;
typedef void ( * PFNGLDRAWVKIMAGENVPROC)(GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
extern PFNGLDRAWVKIMAGENVPROC glad_glDrawVkImageNV;

typedef GLVULKANPROCNV ( * PFNGLGETVKPROCADDRNVPROC)(const GLchar *name);
extern PFNGLGETVKPROCADDRNVPROC glad_glGetVkProcAddrNV;

typedef void ( * PFNGLWAITVKSEMAPHORENVPROC)(GLuint64 vkSemaphore);
extern PFNGLWAITVKSEMAPHORENVPROC glad_glWaitVkSemaphoreNV;

typedef void ( * PFNGLSIGNALVKSEMAPHORENVPROC)(GLuint64 vkSemaphore);
extern PFNGLSIGNALVKSEMAPHORENVPROC glad_glSignalVkSemaphoreNV;

typedef void ( * PFNGLSIGNALVKFENCENVPROC)(GLuint64 vkFence);
extern PFNGLSIGNALVKFENCENVPROC glad_glSignalVkFenceNV;




extern int GLAD_GL_NV_evaluators;
typedef void ( * PFNGLMAPCONTROLPOINTSNVPROC)(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void *points);
extern PFNGLMAPCONTROLPOINTSNVPROC glad_glMapControlPointsNV;

typedef void ( * PFNGLMAPPARAMETERIVNVPROC)(GLenum target, GLenum pname, const GLint *params);
extern PFNGLMAPPARAMETERIVNVPROC glad_glMapParameterivNV;

typedef void ( * PFNGLMAPPARAMETERFVNVPROC)(GLenum target, GLenum pname, const GLfloat *params);
extern PFNGLMAPPARAMETERFVNVPROC glad_glMapParameterfvNV;

typedef void ( * PFNGLGETMAPCONTROLPOINTSNVPROC)(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void *points);
extern PFNGLGETMAPCONTROLPOINTSNVPROC glad_glGetMapControlPointsNV;

typedef void ( * PFNGLGETMAPPARAMETERIVNVPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETMAPPARAMETERIVNVPROC glad_glGetMapParameterivNV;

typedef void ( * PFNGLGETMAPPARAMETERFVNVPROC)(GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETMAPPARAMETERFVNVPROC glad_glGetMapParameterfvNV;

typedef void ( * PFNGLGETMAPATTRIBPARAMETERIVNVPROC)(GLenum target, GLuint index, GLenum pname, GLint *params);
extern PFNGLGETMAPATTRIBPARAMETERIVNVPROC glad_glGetMapAttribParameterivNV;

typedef void ( * PFNGLGETMAPATTRIBPARAMETERFVNVPROC)(GLenum target, GLuint index, GLenum pname, GLfloat *params);
extern PFNGLGETMAPATTRIBPARAMETERFVNVPROC glad_glGetMapAttribParameterfvNV;

typedef void ( * PFNGLEVALMAPSNVPROC)(GLenum target, GLenum mode);
extern PFNGLEVALMAPSNVPROC glad_glEvalMapsNV;




extern int GLAD_GL_NV_explicit_multisample;
typedef void ( * PFNGLGETMULTISAMPLEFVNVPROC)(GLenum pname, GLuint index, GLfloat *val);
extern PFNGLGETMULTISAMPLEFVNVPROC glad_glGetMultisamplefvNV;

typedef void ( * PFNGLSAMPLEMASKINDEXEDNVPROC)(GLuint index, GLbitfield mask);
extern PFNGLSAMPLEMASKINDEXEDNVPROC glad_glSampleMaskIndexedNV;

typedef void ( * PFNGLTEXRENDERBUFFERNVPROC)(GLenum target, GLuint renderbuffer);
extern PFNGLTEXRENDERBUFFERNVPROC glad_glTexRenderbufferNV;




extern int GLAD_GL_NV_fence;
typedef void ( * PFNGLDELETEFENCESNVPROC)(GLsizei n, const GLuint *fences);
extern PFNGLDELETEFENCESNVPROC glad_glDeleteFencesNV;

typedef void ( * PFNGLGENFENCESNVPROC)(GLsizei n, GLuint *fences);
extern PFNGLGENFENCESNVPROC glad_glGenFencesNV;

typedef GLboolean ( * PFNGLISFENCENVPROC)(GLuint fence);
extern PFNGLISFENCENVPROC glad_glIsFenceNV;

typedef GLboolean ( * PFNGLTESTFENCENVPROC)(GLuint fence);
extern PFNGLTESTFENCENVPROC glad_glTestFenceNV;

typedef void ( * PFNGLGETFENCEIVNVPROC)(GLuint fence, GLenum pname, GLint *params);
extern PFNGLGETFENCEIVNVPROC glad_glGetFenceivNV;

typedef void ( * PFNGLFINISHFENCENVPROC)(GLuint fence);
extern PFNGLFINISHFENCENVPROC glad_glFinishFenceNV;

typedef void ( * PFNGLSETFENCENVPROC)(GLuint fence, GLenum condition);
extern PFNGLSETFENCENVPROC glad_glSetFenceNV;




extern int GLAD_GL_NV_fill_rectangle;



extern int GLAD_GL_NV_float_buffer;



extern int GLAD_GL_NV_fog_distance;



extern int GLAD_GL_NV_fragment_coverage_to_color;
typedef void ( * PFNGLFRAGMENTCOVERAGECOLORNVPROC)(GLuint color);
extern PFNGLFRAGMENTCOVERAGECOLORNVPROC glad_glFragmentCoverageColorNV;




extern int GLAD_GL_NV_fragment_program;
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FNVPROC)(GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern PFNGLPROGRAMNAMEDPARAMETER4FNVPROC glad_glProgramNamedParameter4fNV;

typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC)(GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v);
extern PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC glad_glProgramNamedParameter4fvNV;

typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DNVPROC)(GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLPROGRAMNAMEDPARAMETER4DNVPROC glad_glProgramNamedParameter4dNV;

typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC)(GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v);
extern PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC glad_glProgramNamedParameter4dvNV;

typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC)(GLuint id, GLsizei len, const GLubyte *name, GLfloat *params);
extern PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC glad_glGetProgramNamedParameterfvNV;

typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC)(GLuint id, GLsizei len, const GLubyte *name, GLdouble *params);
extern PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC glad_glGetProgramNamedParameterdvNV;




extern int GLAD_GL_NV_fragment_program2;



extern int GLAD_GL_NV_fragment_program4;



extern int GLAD_GL_NV_fragment_program_option;



extern int GLAD_GL_NV_fragment_shader_barycentric;



extern int GLAD_GL_NV_fragment_shader_interlock;



extern int GLAD_GL_NV_framebuffer_mixed_samples;
typedef void ( * PFNGLCOVERAGEMODULATIONTABLENVPROC)(GLsizei n, const GLfloat *v);
extern PFNGLCOVERAGEMODULATIONTABLENVPROC glad_glCoverageModulationTableNV;

typedef void ( * PFNGLGETCOVERAGEMODULATIONTABLENVPROC)(GLsizei bufSize, GLfloat *v);
extern PFNGLGETCOVERAGEMODULATIONTABLENVPROC glad_glGetCoverageModulationTableNV;

typedef void ( * PFNGLCOVERAGEMODULATIONNVPROC)(GLenum components);
extern PFNGLCOVERAGEMODULATIONNVPROC glad_glCoverageModulationNV;




extern int GLAD_GL_NV_framebuffer_multisample_coverage;
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC)(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC glad_glRenderbufferStorageMultisampleCoverageNV;




extern int GLAD_GL_NV_geometry_program4;
typedef void ( * PFNGLPROGRAMVERTEXLIMITNVPROC)(GLenum target, GLint limit);
extern PFNGLPROGRAMVERTEXLIMITNVPROC glad_glProgramVertexLimitNV;

typedef void ( * PFNGLFRAMEBUFFERTEXTUREEXTPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
extern PFNGLFRAMEBUFFERTEXTUREEXTPROC glad_glFramebufferTextureEXT;

typedef void ( * PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
extern PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC glad_glFramebufferTextureFaceEXT;




extern int GLAD_GL_NV_geometry_shader4;



extern int GLAD_GL_NV_geometry_shader_passthrough;



extern int GLAD_GL_NV_gpu_multicast;
typedef void ( * PFNGLRENDERGPUMASKNVPROC)(GLbitfield mask);
extern PFNGLRENDERGPUMASKNVPROC glad_glRenderGpuMaskNV;

typedef void ( * PFNGLMULTICASTBUFFERSUBDATANVPROC)(GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
extern PFNGLMULTICASTBUFFERSUBDATANVPROC glad_glMulticastBufferSubDataNV;

typedef void ( * PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC)(GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
extern PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC glad_glMulticastCopyBufferSubDataNV;

typedef void ( * PFNGLMULTICASTCOPYIMAGESUBDATANVPROC)(GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
extern PFNGLMULTICASTCOPYIMAGESUBDATANVPROC glad_glMulticastCopyImageSubDataNV;

typedef void ( * PFNGLMULTICASTBLITFRAMEBUFFERNVPROC)(GLuint srcGpu, GLuint dstGpu, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
extern PFNGLMULTICASTBLITFRAMEBUFFERNVPROC glad_glMulticastBlitFramebufferNV;

typedef void ( * PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC)(GLuint gpu, GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v);
extern PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC glad_glMulticastFramebufferSampleLocationsfvNV;

typedef void ( * PFNGLMULTICASTBARRIERNVPROC)(void);
extern PFNGLMULTICASTBARRIERNVPROC glad_glMulticastBarrierNV;

typedef void ( * PFNGLMULTICASTWAITSYNCNVPROC)(GLuint signalGpu, GLbitfield waitGpuMask);
extern PFNGLMULTICASTWAITSYNCNVPROC glad_glMulticastWaitSyncNV;

typedef void ( * PFNGLMULTICASTGETQUERYOBJECTIVNVPROC)(GLuint gpu, GLuint id, GLenum pname, GLint *params);
extern PFNGLMULTICASTGETQUERYOBJECTIVNVPROC glad_glMulticastGetQueryObjectivNV;

typedef void ( * PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC)(GLuint gpu, GLuint id, GLenum pname, GLuint *params);
extern PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC glad_glMulticastGetQueryObjectuivNV;

typedef void ( * PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC)(GLuint gpu, GLuint id, GLenum pname, GLint64 *params);
extern PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC glad_glMulticastGetQueryObjecti64vNV;

typedef void ( * PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC)(GLuint gpu, GLuint id, GLenum pname, GLuint64 *params);
extern PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC glad_glMulticastGetQueryObjectui64vNV;




extern int GLAD_GL_NV_gpu_program4;
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4INVPROC)(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
extern PFNGLPROGRAMLOCALPARAMETERI4INVPROC glad_glProgramLocalParameterI4iNV;

typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC)(GLenum target, GLuint index, const GLint *params);
extern PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC glad_glProgramLocalParameterI4ivNV;

typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLint *params);
extern PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC glad_glProgramLocalParametersI4ivNV;

typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UINVPROC)(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
extern PFNGLPROGRAMLOCALPARAMETERI4UINVPROC glad_glProgramLocalParameterI4uiNV;

typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC)(GLenum target, GLuint index, const GLuint *params);
extern PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC glad_glProgramLocalParameterI4uivNV;

typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLuint *params);
extern PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC glad_glProgramLocalParametersI4uivNV;

typedef void ( * PFNGLPROGRAMENVPARAMETERI4INVPROC)(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
extern PFNGLPROGRAMENVPARAMETERI4INVPROC glad_glProgramEnvParameterI4iNV;

typedef void ( * PFNGLPROGRAMENVPARAMETERI4IVNVPROC)(GLenum target, GLuint index, const GLint *params);
extern PFNGLPROGRAMENVPARAMETERI4IVNVPROC glad_glProgramEnvParameterI4ivNV;

typedef void ( * PFNGLPROGRAMENVPARAMETERSI4IVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLint *params);
extern PFNGLPROGRAMENVPARAMETERSI4IVNVPROC glad_glProgramEnvParametersI4ivNV;

typedef void ( * PFNGLPROGRAMENVPARAMETERI4UINVPROC)(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
extern PFNGLPROGRAMENVPARAMETERI4UINVPROC glad_glProgramEnvParameterI4uiNV;

typedef void ( * PFNGLPROGRAMENVPARAMETERI4UIVNVPROC)(GLenum target, GLuint index, const GLuint *params);
extern PFNGLPROGRAMENVPARAMETERI4UIVNVPROC glad_glProgramEnvParameterI4uivNV;

typedef void ( * PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLuint *params);
extern PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC glad_glProgramEnvParametersI4uivNV;

typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC)(GLenum target, GLuint index, GLint *params);
extern PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC glad_glGetProgramLocalParameterIivNV;

typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC)(GLenum target, GLuint index, GLuint *params);
extern PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC glad_glGetProgramLocalParameterIuivNV;

typedef void ( * PFNGLGETPROGRAMENVPARAMETERIIVNVPROC)(GLenum target, GLuint index, GLint *params);
extern PFNGLGETPROGRAMENVPARAMETERIIVNVPROC glad_glGetProgramEnvParameterIivNV;

typedef void ( * PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC)(GLenum target, GLuint index, GLuint *params);
extern PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC glad_glGetProgramEnvParameterIuivNV;




extern int GLAD_GL_NV_gpu_program5;
typedef void ( * PFNGLPROGRAMSUBROUTINEPARAMETERSUIVNVPROC)(GLenum target, GLsizei count, const GLuint *params);
extern PFNGLPROGRAMSUBROUTINEPARAMETERSUIVNVPROC glad_glProgramSubroutineParametersuivNV;

typedef void ( * PFNGLGETPROGRAMSUBROUTINEPARAMETERUIVNVPROC)(GLenum target, GLuint index, GLuint *param);
extern PFNGLGETPROGRAMSUBROUTINEPARAMETERUIVNVPROC glad_glGetProgramSubroutineParameteruivNV;




extern int GLAD_GL_NV_gpu_program5_mem_extended;



extern int GLAD_GL_NV_gpu_shader5;



extern int GLAD_GL_NV_half_float;
typedef void ( * PFNGLVERTEX2HNVPROC)(GLhalfNV x, GLhalfNV y);
extern PFNGLVERTEX2HNVPROC glad_glVertex2hNV;

typedef void ( * PFNGLVERTEX2HVNVPROC)(const GLhalfNV *v);
extern PFNGLVERTEX2HVNVPROC glad_glVertex2hvNV;

typedef void ( * PFNGLVERTEX3HNVPROC)(GLhalfNV x, GLhalfNV y, GLhalfNV z);
extern PFNGLVERTEX3HNVPROC glad_glVertex3hNV;

typedef void ( * PFNGLVERTEX3HVNVPROC)(const GLhalfNV *v);
extern PFNGLVERTEX3HVNVPROC glad_glVertex3hvNV;

typedef void ( * PFNGLVERTEX4HNVPROC)(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
extern PFNGLVERTEX4HNVPROC glad_glVertex4hNV;

typedef void ( * PFNGLVERTEX4HVNVPROC)(const GLhalfNV *v);
extern PFNGLVERTEX4HVNVPROC glad_glVertex4hvNV;

typedef void ( * PFNGLNORMAL3HNVPROC)(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz);
extern PFNGLNORMAL3HNVPROC glad_glNormal3hNV;

typedef void ( * PFNGLNORMAL3HVNVPROC)(const GLhalfNV *v);
extern PFNGLNORMAL3HVNVPROC glad_glNormal3hvNV;

typedef void ( * PFNGLCOLOR3HNVPROC)(GLhalfNV red, GLhalfNV green, GLhalfNV blue);
extern PFNGLCOLOR3HNVPROC glad_glColor3hNV;

typedef void ( * PFNGLCOLOR3HVNVPROC)(const GLhalfNV *v);
extern PFNGLCOLOR3HVNVPROC glad_glColor3hvNV;

typedef void ( * PFNGLCOLOR4HNVPROC)(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha);
extern PFNGLCOLOR4HNVPROC glad_glColor4hNV;

typedef void ( * PFNGLCOLOR4HVNVPROC)(const GLhalfNV *v);
extern PFNGLCOLOR4HVNVPROC glad_glColor4hvNV;

typedef void ( * PFNGLTEXCOORD1HNVPROC)(GLhalfNV s);
extern PFNGLTEXCOORD1HNVPROC glad_glTexCoord1hNV;

typedef void ( * PFNGLTEXCOORD1HVNVPROC)(const GLhalfNV *v);
extern PFNGLTEXCOORD1HVNVPROC glad_glTexCoord1hvNV;

typedef void ( * PFNGLTEXCOORD2HNVPROC)(GLhalfNV s, GLhalfNV t);
extern PFNGLTEXCOORD2HNVPROC glad_glTexCoord2hNV;

typedef void ( * PFNGLTEXCOORD2HVNVPROC)(const GLhalfNV *v);
extern PFNGLTEXCOORD2HVNVPROC glad_glTexCoord2hvNV;

typedef void ( * PFNGLTEXCOORD3HNVPROC)(GLhalfNV s, GLhalfNV t, GLhalfNV r);
extern PFNGLTEXCOORD3HNVPROC glad_glTexCoord3hNV;

typedef void ( * PFNGLTEXCOORD3HVNVPROC)(const GLhalfNV *v);
extern PFNGLTEXCOORD3HVNVPROC glad_glTexCoord3hvNV;

typedef void ( * PFNGLTEXCOORD4HNVPROC)(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
extern PFNGLTEXCOORD4HNVPROC glad_glTexCoord4hNV;

typedef void ( * PFNGLTEXCOORD4HVNVPROC)(const GLhalfNV *v);
extern PFNGLTEXCOORD4HVNVPROC glad_glTexCoord4hvNV;

typedef void ( * PFNGLMULTITEXCOORD1HNVPROC)(GLenum target, GLhalfNV s);
extern PFNGLMULTITEXCOORD1HNVPROC glad_glMultiTexCoord1hNV;

typedef void ( * PFNGLMULTITEXCOORD1HVNVPROC)(GLenum target, const GLhalfNV *v);
extern PFNGLMULTITEXCOORD1HVNVPROC glad_glMultiTexCoord1hvNV;

typedef void ( * PFNGLMULTITEXCOORD2HNVPROC)(GLenum target, GLhalfNV s, GLhalfNV t);
extern PFNGLMULTITEXCOORD2HNVPROC glad_glMultiTexCoord2hNV;

typedef void ( * PFNGLMULTITEXCOORD2HVNVPROC)(GLenum target, const GLhalfNV *v);
extern PFNGLMULTITEXCOORD2HVNVPROC glad_glMultiTexCoord2hvNV;

typedef void ( * PFNGLMULTITEXCOORD3HNVPROC)(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r);
extern PFNGLMULTITEXCOORD3HNVPROC glad_glMultiTexCoord3hNV;

typedef void ( * PFNGLMULTITEXCOORD3HVNVPROC)(GLenum target, const GLhalfNV *v);
extern PFNGLMULTITEXCOORD3HVNVPROC glad_glMultiTexCoord3hvNV;

typedef void ( * PFNGLMULTITEXCOORD4HNVPROC)(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
extern PFNGLMULTITEXCOORD4HNVPROC glad_glMultiTexCoord4hNV;

typedef void ( * PFNGLMULTITEXCOORD4HVNVPROC)(GLenum target, const GLhalfNV *v);
extern PFNGLMULTITEXCOORD4HVNVPROC glad_glMultiTexCoord4hvNV;

typedef void ( * PFNGLVERTEXATTRIB1HNVPROC)(GLuint index, GLhalfNV x);
extern PFNGLVERTEXATTRIB1HNVPROC glad_glVertexAttrib1hNV;

typedef void ( * PFNGLVERTEXATTRIB1HVNVPROC)(GLuint index, const GLhalfNV *v);
extern PFNGLVERTEXATTRIB1HVNVPROC glad_glVertexAttrib1hvNV;

typedef void ( * PFNGLVERTEXATTRIB2HNVPROC)(GLuint index, GLhalfNV x, GLhalfNV y);
extern PFNGLVERTEXATTRIB2HNVPROC glad_glVertexAttrib2hNV;

typedef void ( * PFNGLVERTEXATTRIB2HVNVPROC)(GLuint index, const GLhalfNV *v);
extern PFNGLVERTEXATTRIB2HVNVPROC glad_glVertexAttrib2hvNV;

typedef void ( * PFNGLVERTEXATTRIB3HNVPROC)(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z);
extern PFNGLVERTEXATTRIB3HNVPROC glad_glVertexAttrib3hNV;

typedef void ( * PFNGLVERTEXATTRIB3HVNVPROC)(GLuint index, const GLhalfNV *v);
extern PFNGLVERTEXATTRIB3HVNVPROC glad_glVertexAttrib3hvNV;

typedef void ( * PFNGLVERTEXATTRIB4HNVPROC)(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
extern PFNGLVERTEXATTRIB4HNVPROC glad_glVertexAttrib4hNV;

typedef void ( * PFNGLVERTEXATTRIB4HVNVPROC)(GLuint index, const GLhalfNV *v);
extern PFNGLVERTEXATTRIB4HVNVPROC glad_glVertexAttrib4hvNV;

typedef void ( * PFNGLVERTEXATTRIBS1HVNVPROC)(GLuint index, GLsizei n, const GLhalfNV *v);
extern PFNGLVERTEXATTRIBS1HVNVPROC glad_glVertexAttribs1hvNV;

typedef void ( * PFNGLVERTEXATTRIBS2HVNVPROC)(GLuint index, GLsizei n, const GLhalfNV *v);
extern PFNGLVERTEXATTRIBS2HVNVPROC glad_glVertexAttribs2hvNV;

typedef void ( * PFNGLVERTEXATTRIBS3HVNVPROC)(GLuint index, GLsizei n, const GLhalfNV *v);
extern PFNGLVERTEXATTRIBS3HVNVPROC glad_glVertexAttribs3hvNV;

typedef void ( * PFNGLVERTEXATTRIBS4HVNVPROC)(GLuint index, GLsizei n, const GLhalfNV *v);
extern PFNGLVERTEXATTRIBS4HVNVPROC glad_glVertexAttribs4hvNV;

typedef void ( * PFNGLFOGCOORDHNVPROC)(GLhalfNV fog);
extern PFNGLFOGCOORDHNVPROC glad_glFogCoordhNV;

typedef void ( * PFNGLFOGCOORDHVNVPROC)(const GLhalfNV *fog);
extern PFNGLFOGCOORDHVNVPROC glad_glFogCoordhvNV;

typedef void ( * PFNGLSECONDARYCOLOR3HNVPROC)(GLhalfNV red, GLhalfNV green, GLhalfNV blue);
extern PFNGLSECONDARYCOLOR3HNVPROC glad_glSecondaryColor3hNV;

typedef void ( * PFNGLSECONDARYCOLOR3HVNVPROC)(const GLhalfNV *v);
extern PFNGLSECONDARYCOLOR3HVNVPROC glad_glSecondaryColor3hvNV;

typedef void ( * PFNGLVERTEXWEIGHTHNVPROC)(GLhalfNV weight);
extern PFNGLVERTEXWEIGHTHNVPROC glad_glVertexWeighthNV;

typedef void ( * PFNGLVERTEXWEIGHTHVNVPROC)(const GLhalfNV *weight);
extern PFNGLVERTEXWEIGHTHVNVPROC glad_glVertexWeighthvNV;




extern int GLAD_GL_NV_internalformat_sample_query;
typedef void ( * PFNGLGETINTERNALFORMATSAMPLEIVNVPROC)(GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei count, GLint *params);
extern PFNGLGETINTERNALFORMATSAMPLEIVNVPROC glad_glGetInternalformatSampleivNV;




extern int GLAD_GL_NV_light_max_exponent;



extern int GLAD_GL_NV_memory_attachment;
typedef void ( * PFNGLGETMEMORYOBJECTDETACHEDRESOURCESUIVNVPROC)(GLuint memory, GLenum pname, GLint first, GLsizei count, GLuint *params);
extern PFNGLGETMEMORYOBJECTDETACHEDRESOURCESUIVNVPROC glad_glGetMemoryObjectDetachedResourcesuivNV;

typedef void ( * PFNGLRESETMEMORYOBJECTPARAMETERNVPROC)(GLuint memory, GLenum pname);
extern PFNGLRESETMEMORYOBJECTPARAMETERNVPROC glad_glResetMemoryObjectParameterNV;

typedef void ( * PFNGLTEXATTACHMEMORYNVPROC)(GLenum target, GLuint memory, GLuint64 offset);
extern PFNGLTEXATTACHMEMORYNVPROC glad_glTexAttachMemoryNV;

typedef void ( * PFNGLBUFFERATTACHMEMORYNVPROC)(GLenum target, GLuint memory, GLuint64 offset);
extern PFNGLBUFFERATTACHMEMORYNVPROC glad_glBufferAttachMemoryNV;

typedef void ( * PFNGLTEXTUREATTACHMEMORYNVPROC)(GLuint texture, GLuint memory, GLuint64 offset);
extern PFNGLTEXTUREATTACHMEMORYNVPROC glad_glTextureAttachMemoryNV;

typedef void ( * PFNGLNAMEDBUFFERATTACHMEMORYNVPROC)(GLuint buffer, GLuint memory, GLuint64 offset);
extern PFNGLNAMEDBUFFERATTACHMEMORYNVPROC glad_glNamedBufferAttachMemoryNV;




extern int GLAD_GL_NV_memory_object_sparse;
typedef void ( * PFNGLBUFFERPAGECOMMITMENTMEMNVPROC)(GLenum target, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit);
extern PFNGLBUFFERPAGECOMMITMENTMEMNVPROC glad_glBufferPageCommitmentMemNV;

typedef void ( * PFNGLTEXPAGECOMMITMENTMEMNVPROC)(GLenum target, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit);
extern PFNGLTEXPAGECOMMITMENTMEMNVPROC glad_glTexPageCommitmentMemNV;

typedef void ( * PFNGLNAMEDBUFFERPAGECOMMITMENTMEMNVPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit);
extern PFNGLNAMEDBUFFERPAGECOMMITMENTMEMNVPROC glad_glNamedBufferPageCommitmentMemNV;

typedef void ( * PFNGLTEXTUREPAGECOMMITMENTMEMNVPROC)(GLuint texture, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit);
extern PFNGLTEXTUREPAGECOMMITMENTMEMNVPROC glad_glTexturePageCommitmentMemNV;




extern int GLAD_GL_NV_mesh_shader;
typedef void ( * PFNGLDRAWMESHTASKSNVPROC)(GLuint first, GLuint count);
extern PFNGLDRAWMESHTASKSNVPROC glad_glDrawMeshTasksNV;

typedef void ( * PFNGLDRAWMESHTASKSINDIRECTNVPROC)(GLintptr indirect);
extern PFNGLDRAWMESHTASKSINDIRECTNVPROC glad_glDrawMeshTasksIndirectNV;

typedef void ( * PFNGLMULTIDRAWMESHTASKSINDIRECTNVPROC)(GLintptr indirect, GLsizei drawcount, GLsizei stride);
extern PFNGLMULTIDRAWMESHTASKSINDIRECTNVPROC glad_glMultiDrawMeshTasksIndirectNV;

typedef void ( * PFNGLMULTIDRAWMESHTASKSINDIRECTCOUNTNVPROC)(GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
extern PFNGLMULTIDRAWMESHTASKSINDIRECTCOUNTNVPROC glad_glMultiDrawMeshTasksIndirectCountNV;




extern int GLAD_GL_NV_multisample_coverage;



extern int GLAD_GL_NV_multisample_filter_hint;



extern int GLAD_GL_NV_occlusion_query;
typedef void ( * PFNGLGENOCCLUSIONQUERIESNVPROC)(GLsizei n, GLuint *ids);
extern PFNGLGENOCCLUSIONQUERIESNVPROC glad_glGenOcclusionQueriesNV;

typedef void ( * PFNGLDELETEOCCLUSIONQUERIESNVPROC)(GLsizei n, const GLuint *ids);
extern PFNGLDELETEOCCLUSIONQUERIESNVPROC glad_glDeleteOcclusionQueriesNV;

typedef GLboolean ( * PFNGLISOCCLUSIONQUERYNVPROC)(GLuint id);
extern PFNGLISOCCLUSIONQUERYNVPROC glad_glIsOcclusionQueryNV;

typedef void ( * PFNGLBEGINOCCLUSIONQUERYNVPROC)(GLuint id);
extern PFNGLBEGINOCCLUSIONQUERYNVPROC glad_glBeginOcclusionQueryNV;

typedef void ( * PFNGLENDOCCLUSIONQUERYNVPROC)(void);
extern PFNGLENDOCCLUSIONQUERYNVPROC glad_glEndOcclusionQueryNV;

typedef void ( * PFNGLGETOCCLUSIONQUERYIVNVPROC)(GLuint id, GLenum pname, GLint *params);
extern PFNGLGETOCCLUSIONQUERYIVNVPROC glad_glGetOcclusionQueryivNV;

typedef void ( * PFNGLGETOCCLUSIONQUERYUIVNVPROC)(GLuint id, GLenum pname, GLuint *params);
extern PFNGLGETOCCLUSIONQUERYUIVNVPROC glad_glGetOcclusionQueryuivNV;




extern int GLAD_GL_NV_packed_depth_stencil;



extern int GLAD_GL_NV_parameter_buffer_object;
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC)(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat *params);
extern PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC glad_glProgramBufferParametersfvNV;

typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC)(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint *params);
extern PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC glad_glProgramBufferParametersIivNV;

typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC)(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint *params);
extern PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC glad_glProgramBufferParametersIuivNV;




extern int GLAD_GL_NV_parameter_buffer_object2;



extern int GLAD_GL_NV_path_rendering;
typedef GLuint ( * PFNGLGENPATHSNVPROC)(GLsizei range);
extern PFNGLGENPATHSNVPROC glad_glGenPathsNV;

typedef void ( * PFNGLDELETEPATHSNVPROC)(GLuint path, GLsizei range);
extern PFNGLDELETEPATHSNVPROC glad_glDeletePathsNV;

typedef GLboolean ( * PFNGLISPATHNVPROC)(GLuint path);
extern PFNGLISPATHNVPROC glad_glIsPathNV;

typedef void ( * PFNGLPATHCOMMANDSNVPROC)(GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords);
extern PFNGLPATHCOMMANDSNVPROC glad_glPathCommandsNV;

typedef void ( * PFNGLPATHCOORDSNVPROC)(GLuint path, GLsizei numCoords, GLenum coordType, const void *coords);
extern PFNGLPATHCOORDSNVPROC glad_glPathCoordsNV;

typedef void ( * PFNGLPATHSUBCOMMANDSNVPROC)(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords);
extern PFNGLPATHSUBCOMMANDSNVPROC glad_glPathSubCommandsNV;

typedef void ( * PFNGLPATHSUBCOORDSNVPROC)(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void *coords);
extern PFNGLPATHSUBCOORDSNVPROC glad_glPathSubCoordsNV;

typedef void ( * PFNGLPATHSTRINGNVPROC)(GLuint path, GLenum format, GLsizei length, const void *pathString);
extern PFNGLPATHSTRINGNVPROC glad_glPathStringNV;

typedef void ( * PFNGLPATHGLYPHSNVPROC)(GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
extern PFNGLPATHGLYPHSNVPROC glad_glPathGlyphsNV;

typedef void ( * PFNGLPATHGLYPHRANGENVPROC)(GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
extern PFNGLPATHGLYPHRANGENVPROC glad_glPathGlyphRangeNV;

typedef void ( * PFNGLWEIGHTPATHSNVPROC)(GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights);
extern PFNGLWEIGHTPATHSNVPROC glad_glWeightPathsNV;

typedef void ( * PFNGLCOPYPATHNVPROC)(GLuint resultPath, GLuint srcPath);
extern PFNGLCOPYPATHNVPROC glad_glCopyPathNV;

typedef void ( * PFNGLINTERPOLATEPATHSNVPROC)(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
extern PFNGLINTERPOLATEPATHSNVPROC glad_glInterpolatePathsNV;

typedef void ( * PFNGLTRANSFORMPATHNVPROC)(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues);
extern PFNGLTRANSFORMPATHNVPROC glad_glTransformPathNV;

typedef void ( * PFNGLPATHPARAMETERIVNVPROC)(GLuint path, GLenum pname, const GLint *value);
extern PFNGLPATHPARAMETERIVNVPROC glad_glPathParameterivNV;

typedef void ( * PFNGLPATHPARAMETERINVPROC)(GLuint path, GLenum pname, GLint value);
extern PFNGLPATHPARAMETERINVPROC glad_glPathParameteriNV;

typedef void ( * PFNGLPATHPARAMETERFVNVPROC)(GLuint path, GLenum pname, const GLfloat *value);
extern PFNGLPATHPARAMETERFVNVPROC glad_glPathParameterfvNV;

typedef void ( * PFNGLPATHPARAMETERFNVPROC)(GLuint path, GLenum pname, GLfloat value);
extern PFNGLPATHPARAMETERFNVPROC glad_glPathParameterfNV;

typedef void ( * PFNGLPATHDASHARRAYNVPROC)(GLuint path, GLsizei dashCount, const GLfloat *dashArray);
extern PFNGLPATHDASHARRAYNVPROC glad_glPathDashArrayNV;

typedef void ( * PFNGLPATHSTENCILFUNCNVPROC)(GLenum func, GLint ref, GLuint mask);
extern PFNGLPATHSTENCILFUNCNVPROC glad_glPathStencilFuncNV;

typedef void ( * PFNGLPATHSTENCILDEPTHOFFSETNVPROC)(GLfloat factor, GLfloat units);
extern PFNGLPATHSTENCILDEPTHOFFSETNVPROC glad_glPathStencilDepthOffsetNV;

typedef void ( * PFNGLSTENCILFILLPATHNVPROC)(GLuint path, GLenum fillMode, GLuint mask);
extern PFNGLSTENCILFILLPATHNVPROC glad_glStencilFillPathNV;

typedef void ( * PFNGLSTENCILSTROKEPATHNVPROC)(GLuint path, GLint reference, GLuint mask);
extern PFNGLSTENCILSTROKEPATHNVPROC glad_glStencilStrokePathNV;

typedef void ( * PFNGLSTENCILFILLPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues);
extern PFNGLSTENCILFILLPATHINSTANCEDNVPROC glad_glStencilFillPathInstancedNV;

typedef void ( * PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues);
extern PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC glad_glStencilStrokePathInstancedNV;

typedef void ( * PFNGLPATHCOVERDEPTHFUNCNVPROC)(GLenum func);
extern PFNGLPATHCOVERDEPTHFUNCNVPROC glad_glPathCoverDepthFuncNV;

typedef void ( * PFNGLCOVERFILLPATHNVPROC)(GLuint path, GLenum coverMode);
extern PFNGLCOVERFILLPATHNVPROC glad_glCoverFillPathNV;

typedef void ( * PFNGLCOVERSTROKEPATHNVPROC)(GLuint path, GLenum coverMode);
extern PFNGLCOVERSTROKEPATHNVPROC glad_glCoverStrokePathNV;

typedef void ( * PFNGLCOVERFILLPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
extern PFNGLCOVERFILLPATHINSTANCEDNVPROC glad_glCoverFillPathInstancedNV;

typedef void ( * PFNGLCOVERSTROKEPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
extern PFNGLCOVERSTROKEPATHINSTANCEDNVPROC glad_glCoverStrokePathInstancedNV;

typedef void ( * PFNGLGETPATHPARAMETERIVNVPROC)(GLuint path, GLenum pname, GLint *value);
extern PFNGLGETPATHPARAMETERIVNVPROC glad_glGetPathParameterivNV;

typedef void ( * PFNGLGETPATHPARAMETERFVNVPROC)(GLuint path, GLenum pname, GLfloat *value);
extern PFNGLGETPATHPARAMETERFVNVPROC glad_glGetPathParameterfvNV;

typedef void ( * PFNGLGETPATHCOMMANDSNVPROC)(GLuint path, GLubyte *commands);
extern PFNGLGETPATHCOMMANDSNVPROC glad_glGetPathCommandsNV;

typedef void ( * PFNGLGETPATHCOORDSNVPROC)(GLuint path, GLfloat *coords);
extern PFNGLGETPATHCOORDSNVPROC glad_glGetPathCoordsNV;

typedef void ( * PFNGLGETPATHDASHARRAYNVPROC)(GLuint path, GLfloat *dashArray);
extern PFNGLGETPATHDASHARRAYNVPROC glad_glGetPathDashArrayNV;

typedef void ( * PFNGLGETPATHMETRICSNVPROC)(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics);
extern PFNGLGETPATHMETRICSNVPROC glad_glGetPathMetricsNV;

typedef void ( * PFNGLGETPATHMETRICRANGENVPROC)(GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics);
extern PFNGLGETPATHMETRICRANGENVPROC glad_glGetPathMetricRangeNV;

typedef void ( * PFNGLGETPATHSPACINGNVPROC)(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing);
extern PFNGLGETPATHSPACINGNVPROC glad_glGetPathSpacingNV;

typedef GLboolean ( * PFNGLISPOINTINFILLPATHNVPROC)(GLuint path, GLuint mask, GLfloat x, GLfloat y);
extern PFNGLISPOINTINFILLPATHNVPROC glad_glIsPointInFillPathNV;

typedef GLboolean ( * PFNGLISPOINTINSTROKEPATHNVPROC)(GLuint path, GLfloat x, GLfloat y);
extern PFNGLISPOINTINSTROKEPATHNVPROC glad_glIsPointInStrokePathNV;

typedef GLfloat ( * PFNGLGETPATHLENGTHNVPROC)(GLuint path, GLsizei startSegment, GLsizei numSegments);
extern PFNGLGETPATHLENGTHNVPROC glad_glGetPathLengthNV;

typedef GLboolean ( * PFNGLPOINTALONGPATHNVPROC)(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY);
extern PFNGLPOINTALONGPATHNVPROC glad_glPointAlongPathNV;

typedef void ( * PFNGLMATRIXLOAD3X2FNVPROC)(GLenum matrixMode, const GLfloat *m);
extern PFNGLMATRIXLOAD3X2FNVPROC glad_glMatrixLoad3x2fNV;

typedef void ( * PFNGLMATRIXLOAD3X3FNVPROC)(GLenum matrixMode, const GLfloat *m);
extern PFNGLMATRIXLOAD3X3FNVPROC glad_glMatrixLoad3x3fNV;

typedef void ( * PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC)(GLenum matrixMode, const GLfloat *m);
extern PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC glad_glMatrixLoadTranspose3x3fNV;

typedef void ( * PFNGLMATRIXMULT3X2FNVPROC)(GLenum matrixMode, const GLfloat *m);
extern PFNGLMATRIXMULT3X2FNVPROC glad_glMatrixMult3x2fNV;

typedef void ( * PFNGLMATRIXMULT3X3FNVPROC)(GLenum matrixMode, const GLfloat *m);
extern PFNGLMATRIXMULT3X3FNVPROC glad_glMatrixMult3x3fNV;

typedef void ( * PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC)(GLenum matrixMode, const GLfloat *m);
extern PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC glad_glMatrixMultTranspose3x3fNV;

typedef void ( * PFNGLSTENCILTHENCOVERFILLPATHNVPROC)(GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode);
extern PFNGLSTENCILTHENCOVERFILLPATHNVPROC glad_glStencilThenCoverFillPathNV;

typedef void ( * PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC)(GLuint path, GLint reference, GLuint mask, GLenum coverMode);
extern PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC glad_glStencilThenCoverStrokePathNV;

typedef void ( * PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
extern PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC glad_glStencilThenCoverFillPathInstancedNV;

typedef void ( * PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
extern PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC glad_glStencilThenCoverStrokePathInstancedNV;

typedef GLenum ( * PFNGLPATHGLYPHINDEXRANGENVPROC)(GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint *baseAndCount);
extern PFNGLPATHGLYPHINDEXRANGENVPROC glad_glPathGlyphIndexRangeNV;

typedef GLenum ( * PFNGLPATHGLYPHINDEXARRAYNVPROC)(GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
extern PFNGLPATHGLYPHINDEXARRAYNVPROC glad_glPathGlyphIndexArrayNV;

typedef GLenum ( * PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC)(GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void *fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
extern PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC glad_glPathMemoryGlyphIndexArrayNV;

typedef void ( * PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC)(GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat *coeffs);
extern PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC glad_glProgramPathFragmentInputGenNV;

typedef void ( * PFNGLGETPROGRAMRESOURCEFVNVPROC)(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei count, GLsizei *length, GLfloat *params);
extern PFNGLGETPROGRAMRESOURCEFVNVPROC glad_glGetProgramResourcefvNV;

typedef void ( * PFNGLPATHCOLORGENNVPROC)(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs);
extern PFNGLPATHCOLORGENNVPROC glad_glPathColorGenNV;

typedef void ( * PFNGLPATHTEXGENNVPROC)(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs);
extern PFNGLPATHTEXGENNVPROC glad_glPathTexGenNV;

typedef void ( * PFNGLPATHFOGGENNVPROC)(GLenum genMode);
extern PFNGLPATHFOGGENNVPROC glad_glPathFogGenNV;

typedef void ( * PFNGLGETPATHCOLORGENIVNVPROC)(GLenum color, GLenum pname, GLint *value);
extern PFNGLGETPATHCOLORGENIVNVPROC glad_glGetPathColorGenivNV;

typedef void ( * PFNGLGETPATHCOLORGENFVNVPROC)(GLenum color, GLenum pname, GLfloat *value);
extern PFNGLGETPATHCOLORGENFVNVPROC glad_glGetPathColorGenfvNV;

typedef void ( * PFNGLGETPATHTEXGENIVNVPROC)(GLenum texCoordSet, GLenum pname, GLint *value);
extern PFNGLGETPATHTEXGENIVNVPROC glad_glGetPathTexGenivNV;

typedef void ( * PFNGLGETPATHTEXGENFVNVPROC)(GLenum texCoordSet, GLenum pname, GLfloat *value);
extern PFNGLGETPATHTEXGENFVNVPROC glad_glGetPathTexGenfvNV;




extern int GLAD_GL_NV_path_rendering_shared_edge;



extern int GLAD_GL_NV_pixel_data_range;
typedef void ( * PFNGLPIXELDATARANGENVPROC)(GLenum target, GLsizei length, const void *pointer);
extern PFNGLPIXELDATARANGENVPROC glad_glPixelDataRangeNV;

typedef void ( * PFNGLFLUSHPIXELDATARANGENVPROC)(GLenum target);
extern PFNGLFLUSHPIXELDATARANGENVPROC glad_glFlushPixelDataRangeNV;




extern int GLAD_GL_NV_point_sprite;
typedef void ( * PFNGLPOINTPARAMETERINVPROC)(GLenum pname, GLint param);
extern PFNGLPOINTPARAMETERINVPROC glad_glPointParameteriNV;

typedef void ( * PFNGLPOINTPARAMETERIVNVPROC)(GLenum pname, const GLint *params);
extern PFNGLPOINTPARAMETERIVNVPROC glad_glPointParameterivNV;




extern int GLAD_GL_NV_present_video;
typedef void ( * PFNGLPRESENTFRAMEKEYEDNVPROC)(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);
extern PFNGLPRESENTFRAMEKEYEDNVPROC glad_glPresentFrameKeyedNV;

typedef void ( * PFNGLPRESENTFRAMEDUALFILLNVPROC)(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
extern PFNGLPRESENTFRAMEDUALFILLNVPROC glad_glPresentFrameDualFillNV;

typedef void ( * PFNGLGETVIDEOIVNVPROC)(GLuint video_slot, GLenum pname, GLint *params);
extern PFNGLGETVIDEOIVNVPROC glad_glGetVideoivNV;

typedef void ( * PFNGLGETVIDEOUIVNVPROC)(GLuint video_slot, GLenum pname, GLuint *params);
extern PFNGLGETVIDEOUIVNVPROC glad_glGetVideouivNV;

typedef void ( * PFNGLGETVIDEOI64VNVPROC)(GLuint video_slot, GLenum pname, GLint64EXT *params);
extern PFNGLGETVIDEOI64VNVPROC glad_glGetVideoi64vNV;

typedef void ( * PFNGLGETVIDEOUI64VNVPROC)(GLuint video_slot, GLenum pname, GLuint64EXT *params);
extern PFNGLGETVIDEOUI64VNVPROC glad_glGetVideoui64vNV;




extern int GLAD_GL_NV_primitive_restart;
typedef void ( * PFNGLPRIMITIVERESTARTNVPROC)(void);
extern PFNGLPRIMITIVERESTARTNVPROC glad_glPrimitiveRestartNV;

typedef void ( * PFNGLPRIMITIVERESTARTINDEXNVPROC)(GLuint index);
extern PFNGLPRIMITIVERESTARTINDEXNVPROC glad_glPrimitiveRestartIndexNV;




extern int GLAD_GL_NV_primitive_shading_rate;



extern int GLAD_GL_NV_query_resource;
typedef GLint ( * PFNGLQUERYRESOURCENVPROC)(GLenum queryType, GLint tagId, GLuint count, GLint *buffer);
extern PFNGLQUERYRESOURCENVPROC glad_glQueryResourceNV;




extern int GLAD_GL_NV_query_resource_tag;
typedef void ( * PFNGLGENQUERYRESOURCETAGNVPROC)(GLsizei n, GLint *tagIds);
extern PFNGLGENQUERYRESOURCETAGNVPROC glad_glGenQueryResourceTagNV;

typedef void ( * PFNGLDELETEQUERYRESOURCETAGNVPROC)(GLsizei n, const GLint *tagIds);
extern PFNGLDELETEQUERYRESOURCETAGNVPROC glad_glDeleteQueryResourceTagNV;

typedef void ( * PFNGLQUERYRESOURCETAGNVPROC)(GLint tagId, const GLchar *tagString);
extern PFNGLQUERYRESOURCETAGNVPROC glad_glQueryResourceTagNV;




extern int GLAD_GL_NV_register_combiners;
typedef void ( * PFNGLCOMBINERPARAMETERFVNVPROC)(GLenum pname, const GLfloat *params);
extern PFNGLCOMBINERPARAMETERFVNVPROC glad_glCombinerParameterfvNV;

typedef void ( * PFNGLCOMBINERPARAMETERFNVPROC)(GLenum pname, GLfloat param);
extern PFNGLCOMBINERPARAMETERFNVPROC glad_glCombinerParameterfNV;

typedef void ( * PFNGLCOMBINERPARAMETERIVNVPROC)(GLenum pname, const GLint *params);
extern PFNGLCOMBINERPARAMETERIVNVPROC glad_glCombinerParameterivNV;

typedef void ( * PFNGLCOMBINERPARAMETERINVPROC)(GLenum pname, GLint param);
extern PFNGLCOMBINERPARAMETERINVPROC glad_glCombinerParameteriNV;

typedef void ( * PFNGLCOMBINERINPUTNVPROC)(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
extern PFNGLCOMBINERINPUTNVPROC glad_glCombinerInputNV;

typedef void ( * PFNGLCOMBINEROUTPUTNVPROC)(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
extern PFNGLCOMBINEROUTPUTNVPROC glad_glCombinerOutputNV;

typedef void ( * PFNGLFINALCOMBINERINPUTNVPROC)(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
extern PFNGLFINALCOMBINERINPUTNVPROC glad_glFinalCombinerInputNV;

typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC)(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params);
extern PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC glad_glGetCombinerInputParameterfvNV;

typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC)(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params);
extern PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC glad_glGetCombinerInputParameterivNV;

typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC)(GLenum stage, GLenum portion, GLenum pname, GLfloat *params);
extern PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC glad_glGetCombinerOutputParameterfvNV;

typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC)(GLenum stage, GLenum portion, GLenum pname, GLint *params);
extern PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC glad_glGetCombinerOutputParameterivNV;

typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC)(GLenum variable, GLenum pname, GLfloat *params);
extern PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC glad_glGetFinalCombinerInputParameterfvNV;

typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC)(GLenum variable, GLenum pname, GLint *params);
extern PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC glad_glGetFinalCombinerInputParameterivNV;




extern int GLAD_GL_NV_register_combiners2;
typedef void ( * PFNGLCOMBINERSTAGEPARAMETERFVNVPROC)(GLenum stage, GLenum pname, const GLfloat *params);
extern PFNGLCOMBINERSTAGEPARAMETERFVNVPROC glad_glCombinerStageParameterfvNV;

typedef void ( * PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC)(GLenum stage, GLenum pname, GLfloat *params);
extern PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC glad_glGetCombinerStageParameterfvNV;




extern int GLAD_GL_NV_representative_fragment_test;



extern int GLAD_GL_NV_robustness_video_memory_purge;



extern int GLAD_GL_NV_sample_locations;
typedef void ( * PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC)(GLenum target, GLuint start, GLsizei count, const GLfloat *v);
extern PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC glad_glFramebufferSampleLocationsfvNV;

typedef void ( * PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC)(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *v);
extern PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC glad_glNamedFramebufferSampleLocationsfvNV;

typedef void ( * PFNGLRESOLVEDEPTHVALUESNVPROC)(void);
extern PFNGLRESOLVEDEPTHVALUESNVPROC glad_glResolveDepthValuesNV;




extern int GLAD_GL_NV_sample_mask_override_coverage;



extern int GLAD_GL_NV_scissor_exclusive;
typedef void ( * PFNGLSCISSOREXCLUSIVENVPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
extern PFNGLSCISSOREXCLUSIVENVPROC glad_glScissorExclusiveNV;

typedef void ( * PFNGLSCISSOREXCLUSIVEARRAYVNVPROC)(GLuint first, GLsizei count, const GLint *v);
extern PFNGLSCISSOREXCLUSIVEARRAYVNVPROC glad_glScissorExclusiveArrayvNV;




extern int GLAD_GL_NV_shader_atomic_counters;



extern int GLAD_GL_NV_shader_atomic_float;



extern int GLAD_GL_NV_shader_atomic_float64;



extern int GLAD_GL_NV_shader_atomic_fp16_vector;



extern int GLAD_GL_NV_shader_atomic_int64;



extern int GLAD_GL_NV_shader_buffer_load;
typedef void ( * PFNGLMAKEBUFFERRESIDENTNVPROC)(GLenum target, GLenum access);
extern PFNGLMAKEBUFFERRESIDENTNVPROC glad_glMakeBufferResidentNV;

typedef void ( * PFNGLMAKEBUFFERNONRESIDENTNVPROC)(GLenum target);
extern PFNGLMAKEBUFFERNONRESIDENTNVPROC glad_glMakeBufferNonResidentNV;

typedef GLboolean ( * PFNGLISBUFFERRESIDENTNVPROC)(GLenum target);
extern PFNGLISBUFFERRESIDENTNVPROC glad_glIsBufferResidentNV;

typedef void ( * PFNGLMAKENAMEDBUFFERRESIDENTNVPROC)(GLuint buffer, GLenum access);
extern PFNGLMAKENAMEDBUFFERRESIDENTNVPROC glad_glMakeNamedBufferResidentNV;

typedef void ( * PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC)(GLuint buffer);
extern PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC glad_glMakeNamedBufferNonResidentNV;

typedef GLboolean ( * PFNGLISNAMEDBUFFERRESIDENTNVPROC)(GLuint buffer);
extern PFNGLISNAMEDBUFFERRESIDENTNVPROC glad_glIsNamedBufferResidentNV;

typedef void ( * PFNGLGETBUFFERPARAMETERUI64VNVPROC)(GLenum target, GLenum pname, GLuint64EXT *params);
extern PFNGLGETBUFFERPARAMETERUI64VNVPROC glad_glGetBufferParameterui64vNV;

typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC)(GLuint buffer, GLenum pname, GLuint64EXT *params);
extern PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC glad_glGetNamedBufferParameterui64vNV;

typedef void ( * PFNGLGETINTEGERUI64VNVPROC)(GLenum value, GLuint64EXT *result);
extern PFNGLGETINTEGERUI64VNVPROC glad_glGetIntegerui64vNV;

typedef void ( * PFNGLUNIFORMUI64NVPROC)(GLint location, GLuint64EXT value);
extern PFNGLUNIFORMUI64NVPROC glad_glUniformui64NV;

typedef void ( * PFNGLUNIFORMUI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT *value);
extern PFNGLUNIFORMUI64VNVPROC glad_glUniformui64vNV;

typedef void ( * PFNGLPROGRAMUNIFORMUI64NVPROC)(GLuint program, GLint location, GLuint64EXT value);
extern PFNGLPROGRAMUNIFORMUI64NVPROC glad_glProgramUniformui64NV;

typedef void ( * PFNGLPROGRAMUNIFORMUI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
extern PFNGLPROGRAMUNIFORMUI64VNVPROC glad_glProgramUniformui64vNV;




extern int GLAD_GL_NV_shader_buffer_store;



extern int GLAD_GL_NV_shader_storage_buffer_object;



extern int GLAD_GL_NV_shader_subgroup_partitioned;



extern int GLAD_GL_NV_shader_texture_footprint;



extern int GLAD_GL_NV_shader_thread_group;



extern int GLAD_GL_NV_shader_thread_shuffle;



extern int GLAD_GL_NV_shading_rate_image;
typedef void ( * PFNGLBINDSHADINGRATEIMAGENVPROC)(GLuint texture);
extern PFNGLBINDSHADINGRATEIMAGENVPROC glad_glBindShadingRateImageNV;

typedef void ( * PFNGLGETSHADINGRATEIMAGEPALETTENVPROC)(GLuint viewport, GLuint entry, GLenum *rate);
extern PFNGLGETSHADINGRATEIMAGEPALETTENVPROC glad_glGetShadingRateImagePaletteNV;

typedef void ( * PFNGLGETSHADINGRATESAMPLELOCATIONIVNVPROC)(GLenum rate, GLuint samples, GLuint index, GLint *location);
extern PFNGLGETSHADINGRATESAMPLELOCATIONIVNVPROC glad_glGetShadingRateSampleLocationivNV;

typedef void ( * PFNGLSHADINGRATEIMAGEBARRIERNVPROC)(GLboolean synchronize);
extern PFNGLSHADINGRATEIMAGEBARRIERNVPROC glad_glShadingRateImageBarrierNV;

typedef void ( * PFNGLSHADINGRATEIMAGEPALETTENVPROC)(GLuint viewport, GLuint first, GLsizei count, const GLenum *rates);
extern PFNGLSHADINGRATEIMAGEPALETTENVPROC glad_glShadingRateImagePaletteNV;

typedef void ( * PFNGLSHADINGRATESAMPLEORDERNVPROC)(GLenum order);
extern PFNGLSHADINGRATESAMPLEORDERNVPROC glad_glShadingRateSampleOrderNV;

typedef void ( * PFNGLSHADINGRATESAMPLEORDERCUSTOMNVPROC)(GLenum rate, GLuint samples, const GLint *locations);
extern PFNGLSHADINGRATESAMPLEORDERCUSTOMNVPROC glad_glShadingRateSampleOrderCustomNV;




extern int GLAD_GL_NV_stereo_view_rendering;



extern int GLAD_GL_NV_tessellation_program5;



extern int GLAD_GL_NV_texgen_emboss;



extern int GLAD_GL_NV_texgen_reflection;



extern int GLAD_GL_NV_texture_barrier;
typedef void ( * PFNGLTEXTUREBARRIERNVPROC)(void);
extern PFNGLTEXTUREBARRIERNVPROC glad_glTextureBarrierNV;




extern int GLAD_GL_NV_texture_compression_vtc;



extern int GLAD_GL_NV_texture_env_combine4;



extern int GLAD_GL_NV_texture_expand_normal;



extern int GLAD_GL_NV_texture_multisample;
typedef void ( * PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC)(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
extern PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC glad_glTexImage2DMultisampleCoverageNV;

typedef void ( * PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC)(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
extern PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC glad_glTexImage3DMultisampleCoverageNV;

typedef void ( * PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC)(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
extern PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC glad_glTextureImage2DMultisampleNV;

typedef void ( * PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC)(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
extern PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC glad_glTextureImage3DMultisampleNV;

typedef void ( * PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC)(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
extern PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC glad_glTextureImage2DMultisampleCoverageNV;

typedef void ( * PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC)(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
extern PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC glad_glTextureImage3DMultisampleCoverageNV;




extern int GLAD_GL_NV_texture_rectangle;



extern int GLAD_GL_NV_texture_rectangle_compressed;



extern int GLAD_GL_NV_texture_shader;



extern int GLAD_GL_NV_texture_shader2;



extern int GLAD_GL_NV_texture_shader3;



extern int GLAD_GL_NV_timeline_semaphore;
typedef void ( * PFNGLCREATESEMAPHORESNVPROC)(GLsizei n, GLuint *semaphores);
extern PFNGLCREATESEMAPHORESNVPROC glad_glCreateSemaphoresNV;

typedef void ( * PFNGLSEMAPHOREPARAMETERIVNVPROC)(GLuint semaphore, GLenum pname, const GLint *params);
extern PFNGLSEMAPHOREPARAMETERIVNVPROC glad_glSemaphoreParameterivNV;

typedef void ( * PFNGLGETSEMAPHOREPARAMETERIVNVPROC)(GLuint semaphore, GLenum pname, GLint *params);
extern PFNGLGETSEMAPHOREPARAMETERIVNVPROC glad_glGetSemaphoreParameterivNV;




extern int GLAD_GL_NV_transform_feedback;
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKNVPROC)(GLenum primitiveMode);
extern PFNGLBEGINTRANSFORMFEEDBACKNVPROC glad_glBeginTransformFeedbackNV;

typedef void ( * PFNGLENDTRANSFORMFEEDBACKNVPROC)(void);
extern PFNGLENDTRANSFORMFEEDBACKNVPROC glad_glEndTransformFeedbackNV;

typedef void ( * PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC)(GLsizei count, const GLint *attribs, GLenum bufferMode);
extern PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC glad_glTransformFeedbackAttribsNV;

typedef void ( * PFNGLBINDBUFFERRANGENVPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern PFNGLBINDBUFFERRANGENVPROC glad_glBindBufferRangeNV;

typedef void ( * PFNGLBINDBUFFEROFFSETNVPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
extern PFNGLBINDBUFFEROFFSETNVPROC glad_glBindBufferOffsetNV;

typedef void ( * PFNGLBINDBUFFERBASENVPROC)(GLenum target, GLuint index, GLuint buffer);
extern PFNGLBINDBUFFERBASENVPROC glad_glBindBufferBaseNV;

typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC)(GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);
extern PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC glad_glTransformFeedbackVaryingsNV;

typedef void ( * PFNGLACTIVEVARYINGNVPROC)(GLuint program, const GLchar *name);
extern PFNGLACTIVEVARYINGNVPROC glad_glActiveVaryingNV;

typedef GLint ( * PFNGLGETVARYINGLOCATIONNVPROC)(GLuint program, const GLchar *name);
extern PFNGLGETVARYINGLOCATIONNVPROC glad_glGetVaryingLocationNV;

typedef void ( * PFNGLGETACTIVEVARYINGNVPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
extern PFNGLGETACTIVEVARYINGNVPROC glad_glGetActiveVaryingNV;

typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC)(GLuint program, GLuint index, GLint *location);
extern PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC glad_glGetTransformFeedbackVaryingNV;

typedef void ( * PFNGLTRANSFORMFEEDBACKSTREAMATTRIBSNVPROC)(GLsizei count, const GLint *attribs, GLsizei nbuffers, const GLint *bufstreams, GLenum bufferMode);
extern PFNGLTRANSFORMFEEDBACKSTREAMATTRIBSNVPROC glad_glTransformFeedbackStreamAttribsNV;




extern int GLAD_GL_NV_transform_feedback2;
typedef void ( * PFNGLBINDTRANSFORMFEEDBACKNVPROC)(GLenum target, GLuint id);
extern PFNGLBINDTRANSFORMFEEDBACKNVPROC glad_glBindTransformFeedbackNV;

typedef void ( * PFNGLDELETETRANSFORMFEEDBACKSNVPROC)(GLsizei n, const GLuint *ids);
extern PFNGLDELETETRANSFORMFEEDBACKSNVPROC glad_glDeleteTransformFeedbacksNV;

typedef void ( * PFNGLGENTRANSFORMFEEDBACKSNVPROC)(GLsizei n, GLuint *ids);
extern PFNGLGENTRANSFORMFEEDBACKSNVPROC glad_glGenTransformFeedbacksNV;

typedef GLboolean ( * PFNGLISTRANSFORMFEEDBACKNVPROC)(GLuint id);
extern PFNGLISTRANSFORMFEEDBACKNVPROC glad_glIsTransformFeedbackNV;

typedef void ( * PFNGLPAUSETRANSFORMFEEDBACKNVPROC)(void);
extern PFNGLPAUSETRANSFORMFEEDBACKNVPROC glad_glPauseTransformFeedbackNV;

typedef void ( * PFNGLRESUMETRANSFORMFEEDBACKNVPROC)(void);
extern PFNGLRESUMETRANSFORMFEEDBACKNVPROC glad_glResumeTransformFeedbackNV;

typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKNVPROC)(GLenum mode, GLuint id);
extern PFNGLDRAWTRANSFORMFEEDBACKNVPROC glad_glDrawTransformFeedbackNV;




extern int GLAD_GL_NV_uniform_buffer_std430_layout;



extern int GLAD_GL_NV_uniform_buffer_unified_memory;



extern int GLAD_GL_NV_vdpau_interop;
typedef void ( * PFNGLVDPAUINITNVPROC)(const void *vdpDevice, const void *getProcAddress);
extern PFNGLVDPAUINITNVPROC glad_glVDPAUInitNV;

typedef void ( * PFNGLVDPAUFININVPROC)(void);
extern PFNGLVDPAUFININVPROC glad_glVDPAUFiniNV;

typedef GLvdpauSurfaceNV ( * PFNGLVDPAUREGISTERVIDEOSURFACENVPROC)(const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
extern PFNGLVDPAUREGISTERVIDEOSURFACENVPROC glad_glVDPAURegisterVideoSurfaceNV;

typedef GLvdpauSurfaceNV ( * PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC)(const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
extern PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC glad_glVDPAURegisterOutputSurfaceNV;

typedef GLboolean ( * PFNGLVDPAUISSURFACENVPROC)(GLvdpauSurfaceNV surface);
extern PFNGLVDPAUISSURFACENVPROC glad_glVDPAUIsSurfaceNV;

typedef void ( * PFNGLVDPAUUNREGISTERSURFACENVPROC)(GLvdpauSurfaceNV surface);
extern PFNGLVDPAUUNREGISTERSURFACENVPROC glad_glVDPAUUnregisterSurfaceNV;

typedef void ( * PFNGLVDPAUGETSURFACEIVNVPROC)(GLvdpauSurfaceNV surface, GLenum pname, GLsizei count, GLsizei *length, GLint *values);
extern PFNGLVDPAUGETSURFACEIVNVPROC glad_glVDPAUGetSurfaceivNV;

typedef void ( * PFNGLVDPAUSURFACEACCESSNVPROC)(GLvdpauSurfaceNV surface, GLenum access);
extern PFNGLVDPAUSURFACEACCESSNVPROC glad_glVDPAUSurfaceAccessNV;

typedef void ( * PFNGLVDPAUMAPSURFACESNVPROC)(GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces);
extern PFNGLVDPAUMAPSURFACESNVPROC glad_glVDPAUMapSurfacesNV;

typedef void ( * PFNGLVDPAUUNMAPSURFACESNVPROC)(GLsizei numSurface, const GLvdpauSurfaceNV *surfaces);
extern PFNGLVDPAUUNMAPSURFACESNVPROC glad_glVDPAUUnmapSurfacesNV;




extern int GLAD_GL_NV_vdpau_interop2;
typedef GLvdpauSurfaceNV ( * PFNGLVDPAUREGISTERVIDEOSURFACEWITHPICTURESTRUCTURENVPROC)(const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames, GLboolean isFrameStructure);
extern PFNGLVDPAUREGISTERVIDEOSURFACEWITHPICTURESTRUCTURENVPROC glad_glVDPAURegisterVideoSurfaceWithPictureStructureNV;




extern int GLAD_GL_NV_vertex_array_range;
typedef void ( * PFNGLFLUSHVERTEXARRAYRANGENVPROC)(void);
extern PFNGLFLUSHVERTEXARRAYRANGENVPROC glad_glFlushVertexArrayRangeNV;

typedef void ( * PFNGLVERTEXARRAYRANGENVPROC)(GLsizei length, const void *pointer);
extern PFNGLVERTEXARRAYRANGENVPROC glad_glVertexArrayRangeNV;




extern int GLAD_GL_NV_vertex_array_range2;



extern int GLAD_GL_NV_vertex_attrib_integer_64bit;
typedef void ( * PFNGLVERTEXATTRIBL1I64NVPROC)(GLuint index, GLint64EXT x);
extern PFNGLVERTEXATTRIBL1I64NVPROC glad_glVertexAttribL1i64NV;

typedef void ( * PFNGLVERTEXATTRIBL2I64NVPROC)(GLuint index, GLint64EXT x, GLint64EXT y);
extern PFNGLVERTEXATTRIBL2I64NVPROC glad_glVertexAttribL2i64NV;

typedef void ( * PFNGLVERTEXATTRIBL3I64NVPROC)(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
extern PFNGLVERTEXATTRIBL3I64NVPROC glad_glVertexAttribL3i64NV;

typedef void ( * PFNGLVERTEXATTRIBL4I64NVPROC)(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
extern PFNGLVERTEXATTRIBL4I64NVPROC glad_glVertexAttribL4i64NV;

typedef void ( * PFNGLVERTEXATTRIBL1I64VNVPROC)(GLuint index, const GLint64EXT *v);
extern PFNGLVERTEXATTRIBL1I64VNVPROC glad_glVertexAttribL1i64vNV;

typedef void ( * PFNGLVERTEXATTRIBL2I64VNVPROC)(GLuint index, const GLint64EXT *v);
extern PFNGLVERTEXATTRIBL2I64VNVPROC glad_glVertexAttribL2i64vNV;

typedef void ( * PFNGLVERTEXATTRIBL3I64VNVPROC)(GLuint index, const GLint64EXT *v);
extern PFNGLVERTEXATTRIBL3I64VNVPROC glad_glVertexAttribL3i64vNV;

typedef void ( * PFNGLVERTEXATTRIBL4I64VNVPROC)(GLuint index, const GLint64EXT *v);
extern PFNGLVERTEXATTRIBL4I64VNVPROC glad_glVertexAttribL4i64vNV;

typedef void ( * PFNGLVERTEXATTRIBL1UI64NVPROC)(GLuint index, GLuint64EXT x);
extern PFNGLVERTEXATTRIBL1UI64NVPROC glad_glVertexAttribL1ui64NV;

typedef void ( * PFNGLVERTEXATTRIBL2UI64NVPROC)(GLuint index, GLuint64EXT x, GLuint64EXT y);
extern PFNGLVERTEXATTRIBL2UI64NVPROC glad_glVertexAttribL2ui64NV;

typedef void ( * PFNGLVERTEXATTRIBL3UI64NVPROC)(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
extern PFNGLVERTEXATTRIBL3UI64NVPROC glad_glVertexAttribL3ui64NV;

typedef void ( * PFNGLVERTEXATTRIBL4UI64NVPROC)(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
extern PFNGLVERTEXATTRIBL4UI64NVPROC glad_glVertexAttribL4ui64NV;

typedef void ( * PFNGLVERTEXATTRIBL1UI64VNVPROC)(GLuint index, const GLuint64EXT *v);
extern PFNGLVERTEXATTRIBL1UI64VNVPROC glad_glVertexAttribL1ui64vNV;

typedef void ( * PFNGLVERTEXATTRIBL2UI64VNVPROC)(GLuint index, const GLuint64EXT *v);
extern PFNGLVERTEXATTRIBL2UI64VNVPROC glad_glVertexAttribL2ui64vNV;

typedef void ( * PFNGLVERTEXATTRIBL3UI64VNVPROC)(GLuint index, const GLuint64EXT *v);
extern PFNGLVERTEXATTRIBL3UI64VNVPROC glad_glVertexAttribL3ui64vNV;

typedef void ( * PFNGLVERTEXATTRIBL4UI64VNVPROC)(GLuint index, const GLuint64EXT *v);
extern PFNGLVERTEXATTRIBL4UI64VNVPROC glad_glVertexAttribL4ui64vNV;

typedef void ( * PFNGLGETVERTEXATTRIBLI64VNVPROC)(GLuint index, GLenum pname, GLint64EXT *params);
extern PFNGLGETVERTEXATTRIBLI64VNVPROC glad_glGetVertexAttribLi64vNV;

typedef void ( * PFNGLGETVERTEXATTRIBLUI64VNVPROC)(GLuint index, GLenum pname, GLuint64EXT *params);
extern PFNGLGETVERTEXATTRIBLUI64VNVPROC glad_glGetVertexAttribLui64vNV;

typedef void ( * PFNGLVERTEXATTRIBLFORMATNVPROC)(GLuint index, GLint size, GLenum type, GLsizei stride);
extern PFNGLVERTEXATTRIBLFORMATNVPROC glad_glVertexAttribLFormatNV;




extern int GLAD_GL_NV_vertex_buffer_unified_memory;
typedef void ( * PFNGLBUFFERADDRESSRANGENVPROC)(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
extern PFNGLBUFFERADDRESSRANGENVPROC glad_glBufferAddressRangeNV;

typedef void ( * PFNGLVERTEXFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
extern PFNGLVERTEXFORMATNVPROC glad_glVertexFormatNV;

typedef void ( * PFNGLNORMALFORMATNVPROC)(GLenum type, GLsizei stride);
extern PFNGLNORMALFORMATNVPROC glad_glNormalFormatNV;

typedef void ( * PFNGLCOLORFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
extern PFNGLCOLORFORMATNVPROC glad_glColorFormatNV;

typedef void ( * PFNGLINDEXFORMATNVPROC)(GLenum type, GLsizei stride);
extern PFNGLINDEXFORMATNVPROC glad_glIndexFormatNV;

typedef void ( * PFNGLTEXCOORDFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
extern PFNGLTEXCOORDFORMATNVPROC glad_glTexCoordFormatNV;

typedef void ( * PFNGLEDGEFLAGFORMATNVPROC)(GLsizei stride);
extern PFNGLEDGEFLAGFORMATNVPROC glad_glEdgeFlagFormatNV;

typedef void ( * PFNGLSECONDARYCOLORFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
extern PFNGLSECONDARYCOLORFORMATNVPROC glad_glSecondaryColorFormatNV;

typedef void ( * PFNGLFOGCOORDFORMATNVPROC)(GLenum type, GLsizei stride);
extern PFNGLFOGCOORDFORMATNVPROC glad_glFogCoordFormatNV;

typedef void ( * PFNGLVERTEXATTRIBFORMATNVPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
extern PFNGLVERTEXATTRIBFORMATNVPROC glad_glVertexAttribFormatNV;

typedef void ( * PFNGLVERTEXATTRIBIFORMATNVPROC)(GLuint index, GLint size, GLenum type, GLsizei stride);
extern PFNGLVERTEXATTRIBIFORMATNVPROC glad_glVertexAttribIFormatNV;

typedef void ( * PFNGLGETINTEGERUI64I_VNVPROC)(GLenum value, GLuint index, GLuint64EXT *result);
extern PFNGLGETINTEGERUI64I_VNVPROC glad_glGetIntegerui64i_vNV;




extern int GLAD_GL_NV_vertex_program;
typedef GLboolean ( * PFNGLAREPROGRAMSRESIDENTNVPROC)(GLsizei n, const GLuint *programs, GLboolean *residences);
extern PFNGLAREPROGRAMSRESIDENTNVPROC glad_glAreProgramsResidentNV;

typedef void ( * PFNGLBINDPROGRAMNVPROC)(GLenum target, GLuint id);
extern PFNGLBINDPROGRAMNVPROC glad_glBindProgramNV;

typedef void ( * PFNGLDELETEPROGRAMSNVPROC)(GLsizei n, const GLuint *programs);
extern PFNGLDELETEPROGRAMSNVPROC glad_glDeleteProgramsNV;

typedef void ( * PFNGLEXECUTEPROGRAMNVPROC)(GLenum target, GLuint id, const GLfloat *params);
extern PFNGLEXECUTEPROGRAMNVPROC glad_glExecuteProgramNV;

typedef void ( * PFNGLGENPROGRAMSNVPROC)(GLsizei n, GLuint *programs);
extern PFNGLGENPROGRAMSNVPROC glad_glGenProgramsNV;

typedef void ( * PFNGLGETPROGRAMPARAMETERDVNVPROC)(GLenum target, GLuint index, GLenum pname, GLdouble *params);
extern PFNGLGETPROGRAMPARAMETERDVNVPROC glad_glGetProgramParameterdvNV;

typedef void ( * PFNGLGETPROGRAMPARAMETERFVNVPROC)(GLenum target, GLuint index, GLenum pname, GLfloat *params);
extern PFNGLGETPROGRAMPARAMETERFVNVPROC glad_glGetProgramParameterfvNV;

typedef void ( * PFNGLGETPROGRAMIVNVPROC)(GLuint id, GLenum pname, GLint *params);
extern PFNGLGETPROGRAMIVNVPROC glad_glGetProgramivNV;

typedef void ( * PFNGLGETPROGRAMSTRINGNVPROC)(GLuint id, GLenum pname, GLubyte *program);
extern PFNGLGETPROGRAMSTRINGNVPROC glad_glGetProgramStringNV;

typedef void ( * PFNGLGETTRACKMATRIXIVNVPROC)(GLenum target, GLuint address, GLenum pname, GLint *params);
extern PFNGLGETTRACKMATRIXIVNVPROC glad_glGetTrackMatrixivNV;

typedef void ( * PFNGLGETVERTEXATTRIBDVNVPROC)(GLuint index, GLenum pname, GLdouble *params);
extern PFNGLGETVERTEXATTRIBDVNVPROC glad_glGetVertexAttribdvNV;

typedef void ( * PFNGLGETVERTEXATTRIBFVNVPROC)(GLuint index, GLenum pname, GLfloat *params);
extern PFNGLGETVERTEXATTRIBFVNVPROC glad_glGetVertexAttribfvNV;

typedef void ( * PFNGLGETVERTEXATTRIBIVNVPROC)(GLuint index, GLenum pname, GLint *params);
extern PFNGLGETVERTEXATTRIBIVNVPROC glad_glGetVertexAttribivNV;

typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVNVPROC)(GLuint index, GLenum pname, void **pointer);
extern PFNGLGETVERTEXATTRIBPOINTERVNVPROC glad_glGetVertexAttribPointervNV;

typedef GLboolean ( * PFNGLISPROGRAMNVPROC)(GLuint id);
extern PFNGLISPROGRAMNVPROC glad_glIsProgramNV;

typedef void ( * PFNGLLOADPROGRAMNVPROC)(GLenum target, GLuint id, GLsizei len, const GLubyte *program);
extern PFNGLLOADPROGRAMNVPROC glad_glLoadProgramNV;

typedef void ( * PFNGLPROGRAMPARAMETER4DNVPROC)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLPROGRAMPARAMETER4DNVPROC glad_glProgramParameter4dNV;

typedef void ( * PFNGLPROGRAMPARAMETER4DVNVPROC)(GLenum target, GLuint index, const GLdouble *v);
extern PFNGLPROGRAMPARAMETER4DVNVPROC glad_glProgramParameter4dvNV;

typedef void ( * PFNGLPROGRAMPARAMETER4FNVPROC)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern PFNGLPROGRAMPARAMETER4FNVPROC glad_glProgramParameter4fNV;

typedef void ( * PFNGLPROGRAMPARAMETER4FVNVPROC)(GLenum target, GLuint index, const GLfloat *v);
extern PFNGLPROGRAMPARAMETER4FVNVPROC glad_glProgramParameter4fvNV;

typedef void ( * PFNGLPROGRAMPARAMETERS4DVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLdouble *v);
extern PFNGLPROGRAMPARAMETERS4DVNVPROC glad_glProgramParameters4dvNV;

typedef void ( * PFNGLPROGRAMPARAMETERS4FVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLfloat *v);
extern PFNGLPROGRAMPARAMETERS4FVNVPROC glad_glProgramParameters4fvNV;

typedef void ( * PFNGLREQUESTRESIDENTPROGRAMSNVPROC)(GLsizei n, const GLuint *programs);
extern PFNGLREQUESTRESIDENTPROGRAMSNVPROC glad_glRequestResidentProgramsNV;

typedef void ( * PFNGLTRACKMATRIXNVPROC)(GLenum target, GLuint address, GLenum matrix, GLenum transform);
extern PFNGLTRACKMATRIXNVPROC glad_glTrackMatrixNV;

typedef void ( * PFNGLVERTEXATTRIBPOINTERNVPROC)(GLuint index, GLint fsize, GLenum type, GLsizei stride, const void *pointer);
extern PFNGLVERTEXATTRIBPOINTERNVPROC glad_glVertexAttribPointerNV;

typedef void ( * PFNGLVERTEXATTRIB1DNVPROC)(GLuint index, GLdouble x);
extern PFNGLVERTEXATTRIB1DNVPROC glad_glVertexAttrib1dNV;

typedef void ( * PFNGLVERTEXATTRIB1DVNVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB1DVNVPROC glad_glVertexAttrib1dvNV;

typedef void ( * PFNGLVERTEXATTRIB1FNVPROC)(GLuint index, GLfloat x);
extern PFNGLVERTEXATTRIB1FNVPROC glad_glVertexAttrib1fNV;

typedef void ( * PFNGLVERTEXATTRIB1FVNVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB1FVNVPROC glad_glVertexAttrib1fvNV;

typedef void ( * PFNGLVERTEXATTRIB1SNVPROC)(GLuint index, GLshort x);
extern PFNGLVERTEXATTRIB1SNVPROC glad_glVertexAttrib1sNV;

typedef void ( * PFNGLVERTEXATTRIB1SVNVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB1SVNVPROC glad_glVertexAttrib1svNV;

typedef void ( * PFNGLVERTEXATTRIB2DNVPROC)(GLuint index, GLdouble x, GLdouble y);
extern PFNGLVERTEXATTRIB2DNVPROC glad_glVertexAttrib2dNV;

typedef void ( * PFNGLVERTEXATTRIB2DVNVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB2DVNVPROC glad_glVertexAttrib2dvNV;

typedef void ( * PFNGLVERTEXATTRIB2FNVPROC)(GLuint index, GLfloat x, GLfloat y);
extern PFNGLVERTEXATTRIB2FNVPROC glad_glVertexAttrib2fNV;

typedef void ( * PFNGLVERTEXATTRIB2FVNVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB2FVNVPROC glad_glVertexAttrib2fvNV;

typedef void ( * PFNGLVERTEXATTRIB2SNVPROC)(GLuint index, GLshort x, GLshort y);
extern PFNGLVERTEXATTRIB2SNVPROC glad_glVertexAttrib2sNV;

typedef void ( * PFNGLVERTEXATTRIB2SVNVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB2SVNVPROC glad_glVertexAttrib2svNV;

typedef void ( * PFNGLVERTEXATTRIB3DNVPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern PFNGLVERTEXATTRIB3DNVPROC glad_glVertexAttrib3dNV;

typedef void ( * PFNGLVERTEXATTRIB3DVNVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB3DVNVPROC glad_glVertexAttrib3dvNV;

typedef void ( * PFNGLVERTEXATTRIB3FNVPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLVERTEXATTRIB3FNVPROC glad_glVertexAttrib3fNV;

typedef void ( * PFNGLVERTEXATTRIB3FVNVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB3FVNVPROC glad_glVertexAttrib3fvNV;

typedef void ( * PFNGLVERTEXATTRIB3SNVPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
extern PFNGLVERTEXATTRIB3SNVPROC glad_glVertexAttrib3sNV;

typedef void ( * PFNGLVERTEXATTRIB3SVNVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB3SVNVPROC glad_glVertexAttrib3svNV;

typedef void ( * PFNGLVERTEXATTRIB4DNVPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern PFNGLVERTEXATTRIB4DNVPROC glad_glVertexAttrib4dNV;

typedef void ( * PFNGLVERTEXATTRIB4DVNVPROC)(GLuint index, const GLdouble *v);
extern PFNGLVERTEXATTRIB4DVNVPROC glad_glVertexAttrib4dvNV;

typedef void ( * PFNGLVERTEXATTRIB4FNVPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern PFNGLVERTEXATTRIB4FNVPROC glad_glVertexAttrib4fNV;

typedef void ( * PFNGLVERTEXATTRIB4FVNVPROC)(GLuint index, const GLfloat *v);
extern PFNGLVERTEXATTRIB4FVNVPROC glad_glVertexAttrib4fvNV;

typedef void ( * PFNGLVERTEXATTRIB4SNVPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern PFNGLVERTEXATTRIB4SNVPROC glad_glVertexAttrib4sNV;

typedef void ( * PFNGLVERTEXATTRIB4SVNVPROC)(GLuint index, const GLshort *v);
extern PFNGLVERTEXATTRIB4SVNVPROC glad_glVertexAttrib4svNV;

typedef void ( * PFNGLVERTEXATTRIB4UBNVPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern PFNGLVERTEXATTRIB4UBNVPROC glad_glVertexAttrib4ubNV;

typedef void ( * PFNGLVERTEXATTRIB4UBVNVPROC)(GLuint index, const GLubyte *v);
extern PFNGLVERTEXATTRIB4UBVNVPROC glad_glVertexAttrib4ubvNV;

typedef void ( * PFNGLVERTEXATTRIBS1DVNVPROC)(GLuint index, GLsizei count, const GLdouble *v);
extern PFNGLVERTEXATTRIBS1DVNVPROC glad_glVertexAttribs1dvNV;

typedef void ( * PFNGLVERTEXATTRIBS1FVNVPROC)(GLuint index, GLsizei count, const GLfloat *v);
extern PFNGLVERTEXATTRIBS1FVNVPROC glad_glVertexAttribs1fvNV;

typedef void ( * PFNGLVERTEXATTRIBS1SVNVPROC)(GLuint index, GLsizei count, const GLshort *v);
extern PFNGLVERTEXATTRIBS1SVNVPROC glad_glVertexAttribs1svNV;

typedef void ( * PFNGLVERTEXATTRIBS2DVNVPROC)(GLuint index, GLsizei count, const GLdouble *v);
extern PFNGLVERTEXATTRIBS2DVNVPROC glad_glVertexAttribs2dvNV;

typedef void ( * PFNGLVERTEXATTRIBS2FVNVPROC)(GLuint index, GLsizei count, const GLfloat *v);
extern PFNGLVERTEXATTRIBS2FVNVPROC glad_glVertexAttribs2fvNV;

typedef void ( * PFNGLVERTEXATTRIBS2SVNVPROC)(GLuint index, GLsizei count, const GLshort *v);
extern PFNGLVERTEXATTRIBS2SVNVPROC glad_glVertexAttribs2svNV;

typedef void ( * PFNGLVERTEXATTRIBS3DVNVPROC)(GLuint index, GLsizei count, const GLdouble *v);
extern PFNGLVERTEXATTRIBS3DVNVPROC glad_glVertexAttribs3dvNV;

typedef void ( * PFNGLVERTEXATTRIBS3FVNVPROC)(GLuint index, GLsizei count, const GLfloat *v);
extern PFNGLVERTEXATTRIBS3FVNVPROC glad_glVertexAttribs3fvNV;

typedef void ( * PFNGLVERTEXATTRIBS3SVNVPROC)(GLuint index, GLsizei count, const GLshort *v);
extern PFNGLVERTEXATTRIBS3SVNVPROC glad_glVertexAttribs3svNV;

typedef void ( * PFNGLVERTEXATTRIBS4DVNVPROC)(GLuint index, GLsizei count, const GLdouble *v);
extern PFNGLVERTEXATTRIBS4DVNVPROC glad_glVertexAttribs4dvNV;

typedef void ( * PFNGLVERTEXATTRIBS4FVNVPROC)(GLuint index, GLsizei count, const GLfloat *v);
extern PFNGLVERTEXATTRIBS4FVNVPROC glad_glVertexAttribs4fvNV;

typedef void ( * PFNGLVERTEXATTRIBS4SVNVPROC)(GLuint index, GLsizei count, const GLshort *v);
extern PFNGLVERTEXATTRIBS4SVNVPROC glad_glVertexAttribs4svNV;

typedef void ( * PFNGLVERTEXATTRIBS4UBVNVPROC)(GLuint index, GLsizei count, const GLubyte *v);
extern PFNGLVERTEXATTRIBS4UBVNVPROC glad_glVertexAttribs4ubvNV;




extern int GLAD_GL_NV_vertex_program1_1;



extern int GLAD_GL_NV_vertex_program2;



extern int GLAD_GL_NV_vertex_program2_option;



extern int GLAD_GL_NV_vertex_program3;



extern int GLAD_GL_NV_vertex_program4;



extern int GLAD_GL_NV_video_capture;
typedef void ( * PFNGLBEGINVIDEOCAPTURENVPROC)(GLuint video_capture_slot);
extern PFNGLBEGINVIDEOCAPTURENVPROC glad_glBeginVideoCaptureNV;

typedef void ( * PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);
extern PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC glad_glBindVideoCaptureStreamBufferNV;

typedef void ( * PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC)(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);
extern PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC glad_glBindVideoCaptureStreamTextureNV;

typedef void ( * PFNGLENDVIDEOCAPTURENVPROC)(GLuint video_capture_slot);
extern PFNGLENDVIDEOCAPTURENVPROC glad_glEndVideoCaptureNV;

typedef void ( * PFNGLGETVIDEOCAPTUREIVNVPROC)(GLuint video_capture_slot, GLenum pname, GLint *params);
extern PFNGLGETVIDEOCAPTUREIVNVPROC glad_glGetVideoCaptureivNV;

typedef void ( * PFNGLGETVIDEOCAPTURESTREAMIVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params);
extern PFNGLGETVIDEOCAPTURESTREAMIVNVPROC glad_glGetVideoCaptureStreamivNV;

typedef void ( * PFNGLGETVIDEOCAPTURESTREAMFVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params);
extern PFNGLGETVIDEOCAPTURESTREAMFVNVPROC glad_glGetVideoCaptureStreamfvNV;

typedef void ( * PFNGLGETVIDEOCAPTURESTREAMDVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params);
extern PFNGLGETVIDEOCAPTURESTREAMDVNVPROC glad_glGetVideoCaptureStreamdvNV;

typedef GLenum ( * PFNGLVIDEOCAPTURENVPROC)(GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time);
extern PFNGLVIDEOCAPTURENVPROC glad_glVideoCaptureNV;

typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params);
extern PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC glad_glVideoCaptureStreamParameterivNV;

typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params);
extern PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC glad_glVideoCaptureStreamParameterfvNV;

typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params);
extern PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC glad_glVideoCaptureStreamParameterdvNV;




extern int GLAD_GL_NV_viewport_array2;



extern int GLAD_GL_NV_viewport_swizzle;
typedef void ( * PFNGLVIEWPORTSWIZZLENVPROC)(GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew);
extern PFNGLVIEWPORTSWIZZLENVPROC glad_glViewportSwizzleNV;




extern int GLAD_GL_OES_byte_coordinates;
typedef void ( * PFNGLMULTITEXCOORD1BOESPROC)(GLenum texture, GLbyte s);
extern PFNGLMULTITEXCOORD1BOESPROC glad_glMultiTexCoord1bOES;

typedef void ( * PFNGLMULTITEXCOORD1BVOESPROC)(GLenum texture, const GLbyte *coords);
extern PFNGLMULTITEXCOORD1BVOESPROC glad_glMultiTexCoord1bvOES;

typedef void ( * PFNGLMULTITEXCOORD2BOESPROC)(GLenum texture, GLbyte s, GLbyte t);
extern PFNGLMULTITEXCOORD2BOESPROC glad_glMultiTexCoord2bOES;

typedef void ( * PFNGLMULTITEXCOORD2BVOESPROC)(GLenum texture, const GLbyte *coords);
extern PFNGLMULTITEXCOORD2BVOESPROC glad_glMultiTexCoord2bvOES;

typedef void ( * PFNGLMULTITEXCOORD3BOESPROC)(GLenum texture, GLbyte s, GLbyte t, GLbyte r);
extern PFNGLMULTITEXCOORD3BOESPROC glad_glMultiTexCoord3bOES;

typedef void ( * PFNGLMULTITEXCOORD3BVOESPROC)(GLenum texture, const GLbyte *coords);
extern PFNGLMULTITEXCOORD3BVOESPROC glad_glMultiTexCoord3bvOES;

typedef void ( * PFNGLMULTITEXCOORD4BOESPROC)(GLenum texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q);
extern PFNGLMULTITEXCOORD4BOESPROC glad_glMultiTexCoord4bOES;

typedef void ( * PFNGLMULTITEXCOORD4BVOESPROC)(GLenum texture, const GLbyte *coords);
extern PFNGLMULTITEXCOORD4BVOESPROC glad_glMultiTexCoord4bvOES;

typedef void ( * PFNGLTEXCOORD1BOESPROC)(GLbyte s);
extern PFNGLTEXCOORD1BOESPROC glad_glTexCoord1bOES;

typedef void ( * PFNGLTEXCOORD1BVOESPROC)(const GLbyte *coords);
extern PFNGLTEXCOORD1BVOESPROC glad_glTexCoord1bvOES;

typedef void ( * PFNGLTEXCOORD2BOESPROC)(GLbyte s, GLbyte t);
extern PFNGLTEXCOORD2BOESPROC glad_glTexCoord2bOES;

typedef void ( * PFNGLTEXCOORD2BVOESPROC)(const GLbyte *coords);
extern PFNGLTEXCOORD2BVOESPROC glad_glTexCoord2bvOES;

typedef void ( * PFNGLTEXCOORD3BOESPROC)(GLbyte s, GLbyte t, GLbyte r);
extern PFNGLTEXCOORD3BOESPROC glad_glTexCoord3bOES;

typedef void ( * PFNGLTEXCOORD3BVOESPROC)(const GLbyte *coords);
extern PFNGLTEXCOORD3BVOESPROC glad_glTexCoord3bvOES;

typedef void ( * PFNGLTEXCOORD4BOESPROC)(GLbyte s, GLbyte t, GLbyte r, GLbyte q);
extern PFNGLTEXCOORD4BOESPROC glad_glTexCoord4bOES;

typedef void ( * PFNGLTEXCOORD4BVOESPROC)(const GLbyte *coords);
extern PFNGLTEXCOORD4BVOESPROC glad_glTexCoord4bvOES;

typedef void ( * PFNGLVERTEX2BOESPROC)(GLbyte x, GLbyte y);
extern PFNGLVERTEX2BOESPROC glad_glVertex2bOES;

typedef void ( * PFNGLVERTEX2BVOESPROC)(const GLbyte *coords);
extern PFNGLVERTEX2BVOESPROC glad_glVertex2bvOES;

typedef void ( * PFNGLVERTEX3BOESPROC)(GLbyte x, GLbyte y, GLbyte z);
extern PFNGLVERTEX3BOESPROC glad_glVertex3bOES;

typedef void ( * PFNGLVERTEX3BVOESPROC)(const GLbyte *coords);
extern PFNGLVERTEX3BVOESPROC glad_glVertex3bvOES;

typedef void ( * PFNGLVERTEX4BOESPROC)(GLbyte x, GLbyte y, GLbyte z, GLbyte w);
extern PFNGLVERTEX4BOESPROC glad_glVertex4bOES;

typedef void ( * PFNGLVERTEX4BVOESPROC)(const GLbyte *coords);
extern PFNGLVERTEX4BVOESPROC glad_glVertex4bvOES;




extern int GLAD_GL_OES_compressed_paletted_texture;



extern int GLAD_GL_OES_fixed_point;
typedef void ( * PFNGLALPHAFUNCXOESPROC)(GLenum func, GLfixed ref);
extern PFNGLALPHAFUNCXOESPROC glad_glAlphaFuncxOES;

typedef void ( * PFNGLCLEARCOLORXOESPROC)(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
extern PFNGLCLEARCOLORXOESPROC glad_glClearColorxOES;

typedef void ( * PFNGLCLEARDEPTHXOESPROC)(GLfixed depth);
extern PFNGLCLEARDEPTHXOESPROC glad_glClearDepthxOES;

typedef void ( * PFNGLCLIPPLANEXOESPROC)(GLenum plane, const GLfixed *equation);
extern PFNGLCLIPPLANEXOESPROC glad_glClipPlanexOES;

typedef void ( * PFNGLCOLOR4XOESPROC)(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
extern PFNGLCOLOR4XOESPROC glad_glColor4xOES;

typedef void ( * PFNGLDEPTHRANGEXOESPROC)(GLfixed n, GLfixed f);
extern PFNGLDEPTHRANGEXOESPROC glad_glDepthRangexOES;

typedef void ( * PFNGLFOGXOESPROC)(GLenum pname, GLfixed param);
extern PFNGLFOGXOESPROC glad_glFogxOES;

typedef void ( * PFNGLFOGXVOESPROC)(GLenum pname, const GLfixed *param);
extern PFNGLFOGXVOESPROC glad_glFogxvOES;

typedef void ( * PFNGLFRUSTUMXOESPROC)(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f);
extern PFNGLFRUSTUMXOESPROC glad_glFrustumxOES;

typedef void ( * PFNGLGETCLIPPLANEXOESPROC)(GLenum plane, GLfixed *equation);
extern PFNGLGETCLIPPLANEXOESPROC glad_glGetClipPlanexOES;

typedef void ( * PFNGLGETFIXEDVOESPROC)(GLenum pname, GLfixed *params);
extern PFNGLGETFIXEDVOESPROC glad_glGetFixedvOES;

typedef void ( * PFNGLGETTEXENVXVOESPROC)(GLenum target, GLenum pname, GLfixed *params);
extern PFNGLGETTEXENVXVOESPROC glad_glGetTexEnvxvOES;

typedef void ( * PFNGLGETTEXPARAMETERXVOESPROC)(GLenum target, GLenum pname, GLfixed *params);
extern PFNGLGETTEXPARAMETERXVOESPROC glad_glGetTexParameterxvOES;

typedef void ( * PFNGLLIGHTMODELXOESPROC)(GLenum pname, GLfixed param);
extern PFNGLLIGHTMODELXOESPROC glad_glLightModelxOES;

typedef void ( * PFNGLLIGHTMODELXVOESPROC)(GLenum pname, const GLfixed *param);
extern PFNGLLIGHTMODELXVOESPROC glad_glLightModelxvOES;

typedef void ( * PFNGLLIGHTXOESPROC)(GLenum light, GLenum pname, GLfixed param);
extern PFNGLLIGHTXOESPROC glad_glLightxOES;

typedef void ( * PFNGLLIGHTXVOESPROC)(GLenum light, GLenum pname, const GLfixed *params);
extern PFNGLLIGHTXVOESPROC glad_glLightxvOES;

typedef void ( * PFNGLLINEWIDTHXOESPROC)(GLfixed width);
extern PFNGLLINEWIDTHXOESPROC glad_glLineWidthxOES;

typedef void ( * PFNGLLOADMATRIXXOESPROC)(const GLfixed *m);
extern PFNGLLOADMATRIXXOESPROC glad_glLoadMatrixxOES;

typedef void ( * PFNGLMATERIALXOESPROC)(GLenum face, GLenum pname, GLfixed param);
extern PFNGLMATERIALXOESPROC glad_glMaterialxOES;

typedef void ( * PFNGLMATERIALXVOESPROC)(GLenum face, GLenum pname, const GLfixed *param);
extern PFNGLMATERIALXVOESPROC glad_glMaterialxvOES;

typedef void ( * PFNGLMULTMATRIXXOESPROC)(const GLfixed *m);
extern PFNGLMULTMATRIXXOESPROC glad_glMultMatrixxOES;

typedef void ( * PFNGLMULTITEXCOORD4XOESPROC)(GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
extern PFNGLMULTITEXCOORD4XOESPROC glad_glMultiTexCoord4xOES;

typedef void ( * PFNGLNORMAL3XOESPROC)(GLfixed nx, GLfixed ny, GLfixed nz);
extern PFNGLNORMAL3XOESPROC glad_glNormal3xOES;

typedef void ( * PFNGLORTHOXOESPROC)(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f);
extern PFNGLORTHOXOESPROC glad_glOrthoxOES;

typedef void ( * PFNGLPOINTPARAMETERXVOESPROC)(GLenum pname, const GLfixed *params);
extern PFNGLPOINTPARAMETERXVOESPROC glad_glPointParameterxvOES;

typedef void ( * PFNGLPOINTSIZEXOESPROC)(GLfixed size);
extern PFNGLPOINTSIZEXOESPROC glad_glPointSizexOES;

typedef void ( * PFNGLPOLYGONOFFSETXOESPROC)(GLfixed factor, GLfixed units);
extern PFNGLPOLYGONOFFSETXOESPROC glad_glPolygonOffsetxOES;

typedef void ( * PFNGLROTATEXOESPROC)(GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
extern PFNGLROTATEXOESPROC glad_glRotatexOES;

typedef void ( * PFNGLSCALEXOESPROC)(GLfixed x, GLfixed y, GLfixed z);
extern PFNGLSCALEXOESPROC glad_glScalexOES;

typedef void ( * PFNGLTEXENVXOESPROC)(GLenum target, GLenum pname, GLfixed param);
extern PFNGLTEXENVXOESPROC glad_glTexEnvxOES;

typedef void ( * PFNGLTEXENVXVOESPROC)(GLenum target, GLenum pname, const GLfixed *params);
extern PFNGLTEXENVXVOESPROC glad_glTexEnvxvOES;

typedef void ( * PFNGLTEXPARAMETERXOESPROC)(GLenum target, GLenum pname, GLfixed param);
extern PFNGLTEXPARAMETERXOESPROC glad_glTexParameterxOES;

typedef void ( * PFNGLTEXPARAMETERXVOESPROC)(GLenum target, GLenum pname, const GLfixed *params);
extern PFNGLTEXPARAMETERXVOESPROC glad_glTexParameterxvOES;

typedef void ( * PFNGLTRANSLATEXOESPROC)(GLfixed x, GLfixed y, GLfixed z);
extern PFNGLTRANSLATEXOESPROC glad_glTranslatexOES;

typedef void ( * PFNGLGETLIGHTXVOESPROC)(GLenum light, GLenum pname, GLfixed *params);
extern PFNGLGETLIGHTXVOESPROC glad_glGetLightxvOES;

typedef void ( * PFNGLGETMATERIALXVOESPROC)(GLenum face, GLenum pname, GLfixed *params);
extern PFNGLGETMATERIALXVOESPROC glad_glGetMaterialxvOES;

typedef void ( * PFNGLPOINTPARAMETERXOESPROC)(GLenum pname, GLfixed param);
extern PFNGLPOINTPARAMETERXOESPROC glad_glPointParameterxOES;

typedef void ( * PFNGLSAMPLECOVERAGEXOESPROC)(GLclampx value, GLboolean invert);
extern PFNGLSAMPLECOVERAGEXOESPROC glad_glSampleCoveragexOES;

typedef void ( * PFNGLACCUMXOESPROC)(GLenum op, GLfixed value);
extern PFNGLACCUMXOESPROC glad_glAccumxOES;

typedef void ( * PFNGLBITMAPXOESPROC)(GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const GLubyte *bitmap);
extern PFNGLBITMAPXOESPROC glad_glBitmapxOES;

typedef void ( * PFNGLBLENDCOLORXOESPROC)(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
extern PFNGLBLENDCOLORXOESPROC glad_glBlendColorxOES;

typedef void ( * PFNGLCLEARACCUMXOESPROC)(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
extern PFNGLCLEARACCUMXOESPROC glad_glClearAccumxOES;

typedef void ( * PFNGLCOLOR3XOESPROC)(GLfixed red, GLfixed green, GLfixed blue);
extern PFNGLCOLOR3XOESPROC glad_glColor3xOES;

typedef void ( * PFNGLCOLOR3XVOESPROC)(const GLfixed *components);
extern PFNGLCOLOR3XVOESPROC glad_glColor3xvOES;

typedef void ( * PFNGLCOLOR4XVOESPROC)(const GLfixed *components);
extern PFNGLCOLOR4XVOESPROC glad_glColor4xvOES;

typedef void ( * PFNGLCONVOLUTIONPARAMETERXOESPROC)(GLenum target, GLenum pname, GLfixed param);
extern PFNGLCONVOLUTIONPARAMETERXOESPROC glad_glConvolutionParameterxOES;

typedef void ( * PFNGLCONVOLUTIONPARAMETERXVOESPROC)(GLenum target, GLenum pname, const GLfixed *params);
extern PFNGLCONVOLUTIONPARAMETERXVOESPROC glad_glConvolutionParameterxvOES;

typedef void ( * PFNGLEVALCOORD1XOESPROC)(GLfixed u);
extern PFNGLEVALCOORD1XOESPROC glad_glEvalCoord1xOES;

typedef void ( * PFNGLEVALCOORD1XVOESPROC)(const GLfixed *coords);
extern PFNGLEVALCOORD1XVOESPROC glad_glEvalCoord1xvOES;

typedef void ( * PFNGLEVALCOORD2XOESPROC)(GLfixed u, GLfixed v);
extern PFNGLEVALCOORD2XOESPROC glad_glEvalCoord2xOES;

typedef void ( * PFNGLEVALCOORD2XVOESPROC)(const GLfixed *coords);
extern PFNGLEVALCOORD2XVOESPROC glad_glEvalCoord2xvOES;

typedef void ( * PFNGLFEEDBACKBUFFERXOESPROC)(GLsizei n, GLenum type, const GLfixed *buffer);
extern PFNGLFEEDBACKBUFFERXOESPROC glad_glFeedbackBufferxOES;

typedef void ( * PFNGLGETCONVOLUTIONPARAMETERXVOESPROC)(GLenum target, GLenum pname, GLfixed *params);
extern PFNGLGETCONVOLUTIONPARAMETERXVOESPROC glad_glGetConvolutionParameterxvOES;

typedef void ( * PFNGLGETHISTOGRAMPARAMETERXVOESPROC)(GLenum target, GLenum pname, GLfixed *params);
extern PFNGLGETHISTOGRAMPARAMETERXVOESPROC glad_glGetHistogramParameterxvOES;

typedef void ( * PFNGLGETLIGHTXOESPROC)(GLenum light, GLenum pname, GLfixed *params);
extern PFNGLGETLIGHTXOESPROC glad_glGetLightxOES;

typedef void ( * PFNGLGETMAPXVOESPROC)(GLenum target, GLenum query, GLfixed *v);
extern PFNGLGETMAPXVOESPROC glad_glGetMapxvOES;

typedef void ( * PFNGLGETMATERIALXOESPROC)(GLenum face, GLenum pname, GLfixed param);
extern PFNGLGETMATERIALXOESPROC glad_glGetMaterialxOES;

typedef void ( * PFNGLGETPIXELMAPXVPROC)(GLenum map, GLint size, GLfixed *values);
extern PFNGLGETPIXELMAPXVPROC glad_glGetPixelMapxv;

typedef void ( * PFNGLGETTEXGENXVOESPROC)(GLenum coord, GLenum pname, GLfixed *params);
extern PFNGLGETTEXGENXVOESPROC glad_glGetTexGenxvOES;

typedef void ( * PFNGLGETTEXLEVELPARAMETERXVOESPROC)(GLenum target, GLint level, GLenum pname, GLfixed *params);
extern PFNGLGETTEXLEVELPARAMETERXVOESPROC glad_glGetTexLevelParameterxvOES;

typedef void ( * PFNGLINDEXXOESPROC)(GLfixed component);
extern PFNGLINDEXXOESPROC glad_glIndexxOES;

typedef void ( * PFNGLINDEXXVOESPROC)(const GLfixed *component);
extern PFNGLINDEXXVOESPROC glad_glIndexxvOES;

typedef void ( * PFNGLLOADTRANSPOSEMATRIXXOESPROC)(const GLfixed *m);
extern PFNGLLOADTRANSPOSEMATRIXXOESPROC glad_glLoadTransposeMatrixxOES;

typedef void ( * PFNGLMAP1XOESPROC)(GLenum target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points);
extern PFNGLMAP1XOESPROC glad_glMap1xOES;

typedef void ( * PFNGLMAP2XOESPROC)(GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points);
extern PFNGLMAP2XOESPROC glad_glMap2xOES;

typedef void ( * PFNGLMAPGRID1XOESPROC)(GLint n, GLfixed u1, GLfixed u2);
extern PFNGLMAPGRID1XOESPROC glad_glMapGrid1xOES;

typedef void ( * PFNGLMAPGRID2XOESPROC)(GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2);
extern PFNGLMAPGRID2XOESPROC glad_glMapGrid2xOES;

typedef void ( * PFNGLMULTTRANSPOSEMATRIXXOESPROC)(const GLfixed *m);
extern PFNGLMULTTRANSPOSEMATRIXXOESPROC glad_glMultTransposeMatrixxOES;

typedef void ( * PFNGLMULTITEXCOORD1XOESPROC)(GLenum texture, GLfixed s);
extern PFNGLMULTITEXCOORD1XOESPROC glad_glMultiTexCoord1xOES;

typedef void ( * PFNGLMULTITEXCOORD1XVOESPROC)(GLenum texture, const GLfixed *coords);
extern PFNGLMULTITEXCOORD1XVOESPROC glad_glMultiTexCoord1xvOES;

typedef void ( * PFNGLMULTITEXCOORD2XOESPROC)(GLenum texture, GLfixed s, GLfixed t);
extern PFNGLMULTITEXCOORD2XOESPROC glad_glMultiTexCoord2xOES;

typedef void ( * PFNGLMULTITEXCOORD2XVOESPROC)(GLenum texture, const GLfixed *coords);
extern PFNGLMULTITEXCOORD2XVOESPROC glad_glMultiTexCoord2xvOES;

typedef void ( * PFNGLMULTITEXCOORD3XOESPROC)(GLenum texture, GLfixed s, GLfixed t, GLfixed r);
extern PFNGLMULTITEXCOORD3XOESPROC glad_glMultiTexCoord3xOES;

typedef void ( * PFNGLMULTITEXCOORD3XVOESPROC)(GLenum texture, const GLfixed *coords);
extern PFNGLMULTITEXCOORD3XVOESPROC glad_glMultiTexCoord3xvOES;

typedef void ( * PFNGLMULTITEXCOORD4XVOESPROC)(GLenum texture, const GLfixed *coords);
extern PFNGLMULTITEXCOORD4XVOESPROC glad_glMultiTexCoord4xvOES;

typedef void ( * PFNGLNORMAL3XVOESPROC)(const GLfixed *coords);
extern PFNGLNORMAL3XVOESPROC glad_glNormal3xvOES;

typedef void ( * PFNGLPASSTHROUGHXOESPROC)(GLfixed token);
extern PFNGLPASSTHROUGHXOESPROC glad_glPassThroughxOES;

typedef void ( * PFNGLPIXELMAPXPROC)(GLenum map, GLint size, const GLfixed *values);
extern PFNGLPIXELMAPXPROC glad_glPixelMapx;

typedef void ( * PFNGLPIXELSTOREXPROC)(GLenum pname, GLfixed param);
extern PFNGLPIXELSTOREXPROC glad_glPixelStorex;

typedef void ( * PFNGLPIXELTRANSFERXOESPROC)(GLenum pname, GLfixed param);
extern PFNGLPIXELTRANSFERXOESPROC glad_glPixelTransferxOES;

typedef void ( * PFNGLPIXELZOOMXOESPROC)(GLfixed xfactor, GLfixed yfactor);
extern PFNGLPIXELZOOMXOESPROC glad_glPixelZoomxOES;

typedef void ( * PFNGLPRIORITIZETEXTURESXOESPROC)(GLsizei n, const GLuint *textures, const GLfixed *priorities);
extern PFNGLPRIORITIZETEXTURESXOESPROC glad_glPrioritizeTexturesxOES;

typedef void ( * PFNGLRASTERPOS2XOESPROC)(GLfixed x, GLfixed y);
extern PFNGLRASTERPOS2XOESPROC glad_glRasterPos2xOES;

typedef void ( * PFNGLRASTERPOS2XVOESPROC)(const GLfixed *coords);
extern PFNGLRASTERPOS2XVOESPROC glad_glRasterPos2xvOES;

typedef void ( * PFNGLRASTERPOS3XOESPROC)(GLfixed x, GLfixed y, GLfixed z);
extern PFNGLRASTERPOS3XOESPROC glad_glRasterPos3xOES;

typedef void ( * PFNGLRASTERPOS3XVOESPROC)(const GLfixed *coords);
extern PFNGLRASTERPOS3XVOESPROC glad_glRasterPos3xvOES;

typedef void ( * PFNGLRASTERPOS4XOESPROC)(GLfixed x, GLfixed y, GLfixed z, GLfixed w);
extern PFNGLRASTERPOS4XOESPROC glad_glRasterPos4xOES;

typedef void ( * PFNGLRASTERPOS4XVOESPROC)(const GLfixed *coords);
extern PFNGLRASTERPOS4XVOESPROC glad_glRasterPos4xvOES;

typedef void ( * PFNGLRECTXOESPROC)(GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2);
extern PFNGLRECTXOESPROC glad_glRectxOES;

typedef void ( * PFNGLRECTXVOESPROC)(const GLfixed *v1, const GLfixed *v2);
extern PFNGLRECTXVOESPROC glad_glRectxvOES;

typedef void ( * PFNGLTEXCOORD1XOESPROC)(GLfixed s);
extern PFNGLTEXCOORD1XOESPROC glad_glTexCoord1xOES;

typedef void ( * PFNGLTEXCOORD1XVOESPROC)(const GLfixed *coords);
extern PFNGLTEXCOORD1XVOESPROC glad_glTexCoord1xvOES;

typedef void ( * PFNGLTEXCOORD2XOESPROC)(GLfixed s, GLfixed t);
extern PFNGLTEXCOORD2XOESPROC glad_glTexCoord2xOES;

typedef void ( * PFNGLTEXCOORD2XVOESPROC)(const GLfixed *coords);
extern PFNGLTEXCOORD2XVOESPROC glad_glTexCoord2xvOES;

typedef void ( * PFNGLTEXCOORD3XOESPROC)(GLfixed s, GLfixed t, GLfixed r);
extern PFNGLTEXCOORD3XOESPROC glad_glTexCoord3xOES;

typedef void ( * PFNGLTEXCOORD3XVOESPROC)(const GLfixed *coords);
extern PFNGLTEXCOORD3XVOESPROC glad_glTexCoord3xvOES;

typedef void ( * PFNGLTEXCOORD4XOESPROC)(GLfixed s, GLfixed t, GLfixed r, GLfixed q);
extern PFNGLTEXCOORD4XOESPROC glad_glTexCoord4xOES;

typedef void ( * PFNGLTEXCOORD4XVOESPROC)(const GLfixed *coords);
extern PFNGLTEXCOORD4XVOESPROC glad_glTexCoord4xvOES;

typedef void ( * PFNGLTEXGENXOESPROC)(GLenum coord, GLenum pname, GLfixed param);
extern PFNGLTEXGENXOESPROC glad_glTexGenxOES;

typedef void ( * PFNGLTEXGENXVOESPROC)(GLenum coord, GLenum pname, const GLfixed *params);
extern PFNGLTEXGENXVOESPROC glad_glTexGenxvOES;

typedef void ( * PFNGLVERTEX2XOESPROC)(GLfixed x);
extern PFNGLVERTEX2XOESPROC glad_glVertex2xOES;

typedef void ( * PFNGLVERTEX2XVOESPROC)(const GLfixed *coords);
extern PFNGLVERTEX2XVOESPROC glad_glVertex2xvOES;

typedef void ( * PFNGLVERTEX3XOESPROC)(GLfixed x, GLfixed y);
extern PFNGLVERTEX3XOESPROC glad_glVertex3xOES;

typedef void ( * PFNGLVERTEX3XVOESPROC)(const GLfixed *coords);
extern PFNGLVERTEX3XVOESPROC glad_glVertex3xvOES;

typedef void ( * PFNGLVERTEX4XOESPROC)(GLfixed x, GLfixed y, GLfixed z);
extern PFNGLVERTEX4XOESPROC glad_glVertex4xOES;

typedef void ( * PFNGLVERTEX4XVOESPROC)(const GLfixed *coords);
extern PFNGLVERTEX4XVOESPROC glad_glVertex4xvOES;




extern int GLAD_GL_OES_query_matrix;
typedef GLbitfield ( * PFNGLQUERYMATRIXXOESPROC)(GLfixed *mantissa, GLint *exponent);
extern PFNGLQUERYMATRIXXOESPROC glad_glQueryMatrixxOES;




extern int GLAD_GL_OES_read_format;



extern int GLAD_GL_OES_single_precision;
typedef void ( * PFNGLCLEARDEPTHFOESPROC)(GLclampf depth);
extern PFNGLCLEARDEPTHFOESPROC glad_glClearDepthfOES;

typedef void ( * PFNGLCLIPPLANEFOESPROC)(GLenum plane, const GLfloat *equation);
extern PFNGLCLIPPLANEFOESPROC glad_glClipPlanefOES;

typedef void ( * PFNGLDEPTHRANGEFOESPROC)(GLclampf n, GLclampf f);
extern PFNGLDEPTHRANGEFOESPROC glad_glDepthRangefOES;

typedef void ( * PFNGLFRUSTUMFOESPROC)(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
extern PFNGLFRUSTUMFOESPROC glad_glFrustumfOES;

typedef void ( * PFNGLGETCLIPPLANEFOESPROC)(GLenum plane, GLfloat *equation);
extern PFNGLGETCLIPPLANEFOESPROC glad_glGetClipPlanefOES;

typedef void ( * PFNGLORTHOFOESPROC)(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
extern PFNGLORTHOFOESPROC glad_glOrthofOES;




extern int GLAD_GL_OML_interlace;



extern int GLAD_GL_OML_resample;



extern int GLAD_GL_OML_subsample;



extern int GLAD_GL_OVR_multiview;
typedef void ( * PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews);
extern PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC glad_glFramebufferTextureMultiviewOVR;

typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews);
extern PFNGLNAMEDFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC glad_glNamedFramebufferTextureMultiviewOVR;




extern int GLAD_GL_OVR_multiview2;



extern int GLAD_GL_PGI_misc_hints;
typedef void ( * PFNGLHINTPGIPROC)(GLenum target, GLint mode);
extern PFNGLHINTPGIPROC glad_glHintPGI;




extern int GLAD_GL_PGI_vertex_hints;



extern int GLAD_GL_REND_screen_coordinates;



extern int GLAD_GL_S3_s3tc;



extern int GLAD_GL_SGIS_detail_texture;
typedef void ( * PFNGLDETAILTEXFUNCSGISPROC)(GLenum target, GLsizei n, const GLfloat *points);
extern PFNGLDETAILTEXFUNCSGISPROC glad_glDetailTexFuncSGIS;

typedef void ( * PFNGLGETDETAILTEXFUNCSGISPROC)(GLenum target, GLfloat *points);
extern PFNGLGETDETAILTEXFUNCSGISPROC glad_glGetDetailTexFuncSGIS;




extern int GLAD_GL_SGIS_fog_function;
typedef void ( * PFNGLFOGFUNCSGISPROC)(GLsizei n, const GLfloat *points);
extern PFNGLFOGFUNCSGISPROC glad_glFogFuncSGIS;

typedef void ( * PFNGLGETFOGFUNCSGISPROC)(GLfloat *points);
extern PFNGLGETFOGFUNCSGISPROC glad_glGetFogFuncSGIS;




extern int GLAD_GL_SGIS_generate_mipmap;



extern int GLAD_GL_SGIS_multisample;
typedef void ( * PFNGLSAMPLEMASKSGISPROC)(GLclampf value, GLboolean invert);
extern PFNGLSAMPLEMASKSGISPROC glad_glSampleMaskSGIS;

typedef void ( * PFNGLSAMPLEPATTERNSGISPROC)(GLenum pattern);
extern PFNGLSAMPLEPATTERNSGISPROC glad_glSamplePatternSGIS;




extern int GLAD_GL_SGIS_pixel_texture;
typedef void ( * PFNGLPIXELTEXGENPARAMETERISGISPROC)(GLenum pname, GLint param);
extern PFNGLPIXELTEXGENPARAMETERISGISPROC glad_glPixelTexGenParameteriSGIS;

typedef void ( * PFNGLPIXELTEXGENPARAMETERIVSGISPROC)(GLenum pname, const GLint *params);
extern PFNGLPIXELTEXGENPARAMETERIVSGISPROC glad_glPixelTexGenParameterivSGIS;

typedef void ( * PFNGLPIXELTEXGENPARAMETERFSGISPROC)(GLenum pname, GLfloat param);
extern PFNGLPIXELTEXGENPARAMETERFSGISPROC glad_glPixelTexGenParameterfSGIS;

typedef void ( * PFNGLPIXELTEXGENPARAMETERFVSGISPROC)(GLenum pname, const GLfloat *params);
extern PFNGLPIXELTEXGENPARAMETERFVSGISPROC glad_glPixelTexGenParameterfvSGIS;

typedef void ( * PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC)(GLenum pname, GLint *params);
extern PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC glad_glGetPixelTexGenParameterivSGIS;

typedef void ( * PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC)(GLenum pname, GLfloat *params);
extern PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC glad_glGetPixelTexGenParameterfvSGIS;




extern int GLAD_GL_SGIS_point_line_texgen;



extern int GLAD_GL_SGIS_point_parameters;
typedef void ( * PFNGLPOINTPARAMETERFSGISPROC)(GLenum pname, GLfloat param);
extern PFNGLPOINTPARAMETERFSGISPROC glad_glPointParameterfSGIS;

typedef void ( * PFNGLPOINTPARAMETERFVSGISPROC)(GLenum pname, const GLfloat *params);
extern PFNGLPOINTPARAMETERFVSGISPROC glad_glPointParameterfvSGIS;




extern int GLAD_GL_SGIS_sharpen_texture;
typedef void ( * PFNGLSHARPENTEXFUNCSGISPROC)(GLenum target, GLsizei n, const GLfloat *points);
extern PFNGLSHARPENTEXFUNCSGISPROC glad_glSharpenTexFuncSGIS;

typedef void ( * PFNGLGETSHARPENTEXFUNCSGISPROC)(GLenum target, GLfloat *points);
extern PFNGLGETSHARPENTEXFUNCSGISPROC glad_glGetSharpenTexFuncSGIS;




extern int GLAD_GL_SGIS_texture4D;
typedef void ( * PFNGLTEXIMAGE4DSGISPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXIMAGE4DSGISPROC glad_glTexImage4DSGIS;

typedef void ( * PFNGLTEXSUBIMAGE4DSGISPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const void *pixels);
extern PFNGLTEXSUBIMAGE4DSGISPROC glad_glTexSubImage4DSGIS;




extern int GLAD_GL_SGIS_texture_border_clamp;



extern int GLAD_GL_SGIS_texture_color_mask;
typedef void ( * PFNGLTEXTURECOLORMASKSGISPROC)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern PFNGLTEXTURECOLORMASKSGISPROC glad_glTextureColorMaskSGIS;




extern int GLAD_GL_SGIS_texture_edge_clamp;



extern int GLAD_GL_SGIS_texture_filter4;
typedef void ( * PFNGLGETTEXFILTERFUNCSGISPROC)(GLenum target, GLenum filter, GLfloat *weights);
extern PFNGLGETTEXFILTERFUNCSGISPROC glad_glGetTexFilterFuncSGIS;

typedef void ( * PFNGLTEXFILTERFUNCSGISPROC)(GLenum target, GLenum filter, GLsizei n, const GLfloat *weights);
extern PFNGLTEXFILTERFUNCSGISPROC glad_glTexFilterFuncSGIS;




extern int GLAD_GL_SGIS_texture_lod;



extern int GLAD_GL_SGIS_texture_select;



extern int GLAD_GL_SGIX_async;
typedef void ( * PFNGLASYNCMARKERSGIXPROC)(GLuint marker);
extern PFNGLASYNCMARKERSGIXPROC glad_glAsyncMarkerSGIX;

typedef GLint ( * PFNGLFINISHASYNCSGIXPROC)(GLuint *markerp);
extern PFNGLFINISHASYNCSGIXPROC glad_glFinishAsyncSGIX;

typedef GLint ( * PFNGLPOLLASYNCSGIXPROC)(GLuint *markerp);
extern PFNGLPOLLASYNCSGIXPROC glad_glPollAsyncSGIX;

typedef GLuint ( * PFNGLGENASYNCMARKERSSGIXPROC)(GLsizei range);
extern PFNGLGENASYNCMARKERSSGIXPROC glad_glGenAsyncMarkersSGIX;

typedef void ( * PFNGLDELETEASYNCMARKERSSGIXPROC)(GLuint marker, GLsizei range);
extern PFNGLDELETEASYNCMARKERSSGIXPROC glad_glDeleteAsyncMarkersSGIX;

typedef GLboolean ( * PFNGLISASYNCMARKERSGIXPROC)(GLuint marker);
extern PFNGLISASYNCMARKERSGIXPROC glad_glIsAsyncMarkerSGIX;




extern int GLAD_GL_SGIX_async_histogram;



extern int GLAD_GL_SGIX_async_pixel;



extern int GLAD_GL_SGIX_blend_alpha_minmax;



extern int GLAD_GL_SGIX_calligraphic_fragment;



extern int GLAD_GL_SGIX_clipmap;



extern int GLAD_GL_SGIX_convolution_accuracy;



extern int GLAD_GL_SGIX_depth_pass_instrument;



extern int GLAD_GL_SGIX_depth_texture;



extern int GLAD_GL_SGIX_flush_raster;
typedef void ( * PFNGLFLUSHRASTERSGIXPROC)(void);
extern PFNGLFLUSHRASTERSGIXPROC glad_glFlushRasterSGIX;




extern int GLAD_GL_SGIX_fog_offset;



extern int GLAD_GL_SGIX_fragment_lighting;
typedef void ( * PFNGLFRAGMENTCOLORMATERIALSGIXPROC)(GLenum face, GLenum mode);
extern PFNGLFRAGMENTCOLORMATERIALSGIXPROC glad_glFragmentColorMaterialSGIX;

typedef void ( * PFNGLFRAGMENTLIGHTFSGIXPROC)(GLenum light, GLenum pname, GLfloat param);
extern PFNGLFRAGMENTLIGHTFSGIXPROC glad_glFragmentLightfSGIX;

typedef void ( * PFNGLFRAGMENTLIGHTFVSGIXPROC)(GLenum light, GLenum pname, const GLfloat *params);
extern PFNGLFRAGMENTLIGHTFVSGIXPROC glad_glFragmentLightfvSGIX;

typedef void ( * PFNGLFRAGMENTLIGHTISGIXPROC)(GLenum light, GLenum pname, GLint param);
extern PFNGLFRAGMENTLIGHTISGIXPROC glad_glFragmentLightiSGIX;

typedef void ( * PFNGLFRAGMENTLIGHTIVSGIXPROC)(GLenum light, GLenum pname, const GLint *params);
extern PFNGLFRAGMENTLIGHTIVSGIXPROC glad_glFragmentLightivSGIX;

typedef void ( * PFNGLFRAGMENTLIGHTMODELFSGIXPROC)(GLenum pname, GLfloat param);
extern PFNGLFRAGMENTLIGHTMODELFSGIXPROC glad_glFragmentLightModelfSGIX;

typedef void ( * PFNGLFRAGMENTLIGHTMODELFVSGIXPROC)(GLenum pname, const GLfloat *params);
extern PFNGLFRAGMENTLIGHTMODELFVSGIXPROC glad_glFragmentLightModelfvSGIX;

typedef void ( * PFNGLFRAGMENTLIGHTMODELISGIXPROC)(GLenum pname, GLint param);
extern PFNGLFRAGMENTLIGHTMODELISGIXPROC glad_glFragmentLightModeliSGIX;

typedef void ( * PFNGLFRAGMENTLIGHTMODELIVSGIXPROC)(GLenum pname, const GLint *params);
extern PFNGLFRAGMENTLIGHTMODELIVSGIXPROC glad_glFragmentLightModelivSGIX;

typedef void ( * PFNGLFRAGMENTMATERIALFSGIXPROC)(GLenum face, GLenum pname, GLfloat param);
extern PFNGLFRAGMENTMATERIALFSGIXPROC glad_glFragmentMaterialfSGIX;

typedef void ( * PFNGLFRAGMENTMATERIALFVSGIXPROC)(GLenum face, GLenum pname, const GLfloat *params);
extern PFNGLFRAGMENTMATERIALFVSGIXPROC glad_glFragmentMaterialfvSGIX;

typedef void ( * PFNGLFRAGMENTMATERIALISGIXPROC)(GLenum face, GLenum pname, GLint param);
extern PFNGLFRAGMENTMATERIALISGIXPROC glad_glFragmentMaterialiSGIX;

typedef void ( * PFNGLFRAGMENTMATERIALIVSGIXPROC)(GLenum face, GLenum pname, const GLint *params);
extern PFNGLFRAGMENTMATERIALIVSGIXPROC glad_glFragmentMaterialivSGIX;

typedef void ( * PFNGLGETFRAGMENTLIGHTFVSGIXPROC)(GLenum light, GLenum pname, GLfloat *params);
extern PFNGLGETFRAGMENTLIGHTFVSGIXPROC glad_glGetFragmentLightfvSGIX;

typedef void ( * PFNGLGETFRAGMENTLIGHTIVSGIXPROC)(GLenum light, GLenum pname, GLint *params);
extern PFNGLGETFRAGMENTLIGHTIVSGIXPROC glad_glGetFragmentLightivSGIX;

typedef void ( * PFNGLGETFRAGMENTMATERIALFVSGIXPROC)(GLenum face, GLenum pname, GLfloat *params);
extern PFNGLGETFRAGMENTMATERIALFVSGIXPROC glad_glGetFragmentMaterialfvSGIX;

typedef void ( * PFNGLGETFRAGMENTMATERIALIVSGIXPROC)(GLenum face, GLenum pname, GLint *params);
extern PFNGLGETFRAGMENTMATERIALIVSGIXPROC glad_glGetFragmentMaterialivSGIX;

typedef void ( * PFNGLLIGHTENVISGIXPROC)(GLenum pname, GLint param);
extern PFNGLLIGHTENVISGIXPROC glad_glLightEnviSGIX;




extern int GLAD_GL_SGIX_framezoom;
typedef void ( * PFNGLFRAMEZOOMSGIXPROC)(GLint factor);
extern PFNGLFRAMEZOOMSGIXPROC glad_glFrameZoomSGIX;




extern int GLAD_GL_SGIX_igloo_interface;
typedef void ( * PFNGLIGLOOINTERFACESGIXPROC)(GLenum pname, const void *params);
extern PFNGLIGLOOINTERFACESGIXPROC glad_glIglooInterfaceSGIX;




extern int GLAD_GL_SGIX_instruments;
typedef GLint ( * PFNGLGETINSTRUMENTSSGIXPROC)(void);
extern PFNGLGETINSTRUMENTSSGIXPROC glad_glGetInstrumentsSGIX;

typedef void ( * PFNGLINSTRUMENTSBUFFERSGIXPROC)(GLsizei size, GLint *buffer);
extern PFNGLINSTRUMENTSBUFFERSGIXPROC glad_glInstrumentsBufferSGIX;

typedef GLint ( * PFNGLPOLLINSTRUMENTSSGIXPROC)(GLint *marker_p);
extern PFNGLPOLLINSTRUMENTSSGIXPROC glad_glPollInstrumentsSGIX;

typedef void ( * PFNGLREADINSTRUMENTSSGIXPROC)(GLint marker);
extern PFNGLREADINSTRUMENTSSGIXPROC glad_glReadInstrumentsSGIX;

typedef void ( * PFNGLSTARTINSTRUMENTSSGIXPROC)(void);
extern PFNGLSTARTINSTRUMENTSSGIXPROC glad_glStartInstrumentsSGIX;

typedef void ( * PFNGLSTOPINSTRUMENTSSGIXPROC)(GLint marker);
extern PFNGLSTOPINSTRUMENTSSGIXPROC glad_glStopInstrumentsSGIX;




extern int GLAD_GL_SGIX_interlace;



extern int GLAD_GL_SGIX_ir_instrument1;



extern int GLAD_GL_SGIX_list_priority;
typedef void ( * PFNGLGETLISTPARAMETERFVSGIXPROC)(GLuint list, GLenum pname, GLfloat *params);
extern PFNGLGETLISTPARAMETERFVSGIXPROC glad_glGetListParameterfvSGIX;

typedef void ( * PFNGLGETLISTPARAMETERIVSGIXPROC)(GLuint list, GLenum pname, GLint *params);
extern PFNGLGETLISTPARAMETERIVSGIXPROC glad_glGetListParameterivSGIX;

typedef void ( * PFNGLLISTPARAMETERFSGIXPROC)(GLuint list, GLenum pname, GLfloat param);
extern PFNGLLISTPARAMETERFSGIXPROC glad_glListParameterfSGIX;

typedef void ( * PFNGLLISTPARAMETERFVSGIXPROC)(GLuint list, GLenum pname, const GLfloat *params);
extern PFNGLLISTPARAMETERFVSGIXPROC glad_glListParameterfvSGIX;

typedef void ( * PFNGLLISTPARAMETERISGIXPROC)(GLuint list, GLenum pname, GLint param);
extern PFNGLLISTPARAMETERISGIXPROC glad_glListParameteriSGIX;

typedef void ( * PFNGLLISTPARAMETERIVSGIXPROC)(GLuint list, GLenum pname, const GLint *params);
extern PFNGLLISTPARAMETERIVSGIXPROC glad_glListParameterivSGIX;




extern int GLAD_GL_SGIX_pixel_texture;
typedef void ( * PFNGLPIXELTEXGENSGIXPROC)(GLenum mode);
extern PFNGLPIXELTEXGENSGIXPROC glad_glPixelTexGenSGIX;




extern int GLAD_GL_SGIX_pixel_tiles;



extern int GLAD_GL_SGIX_polynomial_ffd;
typedef void ( * PFNGLDEFORMATIONMAP3DSGIXPROC)(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points);
extern PFNGLDEFORMATIONMAP3DSGIXPROC glad_glDeformationMap3dSGIX;

typedef void ( * PFNGLDEFORMATIONMAP3FSGIXPROC)(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points);
extern PFNGLDEFORMATIONMAP3FSGIXPROC glad_glDeformationMap3fSGIX;

typedef void ( * PFNGLDEFORMSGIXPROC)(GLbitfield mask);
extern PFNGLDEFORMSGIXPROC glad_glDeformSGIX;

typedef void ( * PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC)(GLbitfield mask);
extern PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC glad_glLoadIdentityDeformationMapSGIX;




extern int GLAD_GL_SGIX_reference_plane;
typedef void ( * PFNGLREFERENCEPLANESGIXPROC)(const GLdouble *equation);
extern PFNGLREFERENCEPLANESGIXPROC glad_glReferencePlaneSGIX;




extern int GLAD_GL_SGIX_resample;



extern int GLAD_GL_SGIX_scalebias_hint;



extern int GLAD_GL_SGIX_shadow;



extern int GLAD_GL_SGIX_shadow_ambient;



extern int GLAD_GL_SGIX_sprite;
typedef void ( * PFNGLSPRITEPARAMETERFSGIXPROC)(GLenum pname, GLfloat param);
extern PFNGLSPRITEPARAMETERFSGIXPROC glad_glSpriteParameterfSGIX;

typedef void ( * PFNGLSPRITEPARAMETERFVSGIXPROC)(GLenum pname, const GLfloat *params);
extern PFNGLSPRITEPARAMETERFVSGIXPROC glad_glSpriteParameterfvSGIX;

typedef void ( * PFNGLSPRITEPARAMETERISGIXPROC)(GLenum pname, GLint param);
extern PFNGLSPRITEPARAMETERISGIXPROC glad_glSpriteParameteriSGIX;

typedef void ( * PFNGLSPRITEPARAMETERIVSGIXPROC)(GLenum pname, const GLint *params);
extern PFNGLSPRITEPARAMETERIVSGIXPROC glad_glSpriteParameterivSGIX;




extern int GLAD_GL_SGIX_subsample;



extern int GLAD_GL_SGIX_tag_sample_buffer;
typedef void ( * PFNGLTAGSAMPLEBUFFERSGIXPROC)(void);
extern PFNGLTAGSAMPLEBUFFERSGIXPROC glad_glTagSampleBufferSGIX;




extern int GLAD_GL_SGIX_texture_add_env;



extern int GLAD_GL_SGIX_texture_coordinate_clamp;



extern int GLAD_GL_SGIX_texture_lod_bias;



extern int GLAD_GL_SGIX_texture_multi_buffer;



extern int GLAD_GL_SGIX_texture_scale_bias;



extern int GLAD_GL_SGIX_vertex_preclip;



extern int GLAD_GL_SGIX_ycrcb;



extern int GLAD_GL_SGIX_ycrcb_subsample;



extern int GLAD_GL_SGIX_ycrcba;



extern int GLAD_GL_SGI_color_matrix;



extern int GLAD_GL_SGI_color_table;
typedef void ( * PFNGLCOLORTABLESGIPROC)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
extern PFNGLCOLORTABLESGIPROC glad_glColorTableSGI;

typedef void ( * PFNGLCOLORTABLEPARAMETERFVSGIPROC)(GLenum target, GLenum pname, const GLfloat *params);
extern PFNGLCOLORTABLEPARAMETERFVSGIPROC glad_glColorTableParameterfvSGI;

typedef void ( * PFNGLCOLORTABLEPARAMETERIVSGIPROC)(GLenum target, GLenum pname, const GLint *params);
extern PFNGLCOLORTABLEPARAMETERIVSGIPROC glad_glColorTableParameterivSGI;

typedef void ( * PFNGLCOPYCOLORTABLESGIPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern PFNGLCOPYCOLORTABLESGIPROC glad_glCopyColorTableSGI;

typedef void ( * PFNGLGETCOLORTABLESGIPROC)(GLenum target, GLenum format, GLenum type, void *table);
extern PFNGLGETCOLORTABLESGIPROC glad_glGetColorTableSGI;

typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVSGIPROC)(GLenum target, GLenum pname, GLfloat *params);
extern PFNGLGETCOLORTABLEPARAMETERFVSGIPROC glad_glGetColorTableParameterfvSGI;

typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVSGIPROC)(GLenum target, GLenum pname, GLint *params);
extern PFNGLGETCOLORTABLEPARAMETERIVSGIPROC glad_glGetColorTableParameterivSGI;




extern int GLAD_GL_SGI_texture_color_table;



extern int GLAD_GL_SUNX_constant_data;
typedef void ( * PFNGLFINISHTEXTURESUNXPROC)(void);
extern PFNGLFINISHTEXTURESUNXPROC glad_glFinishTextureSUNX;




extern int GLAD_GL_SUN_convolution_border_modes;



extern int GLAD_GL_SUN_global_alpha;
typedef void ( * PFNGLGLOBALALPHAFACTORBSUNPROC)(GLbyte factor);
extern PFNGLGLOBALALPHAFACTORBSUNPROC glad_glGlobalAlphaFactorbSUN;

typedef void ( * PFNGLGLOBALALPHAFACTORSSUNPROC)(GLshort factor);
extern PFNGLGLOBALALPHAFACTORSSUNPROC glad_glGlobalAlphaFactorsSUN;

typedef void ( * PFNGLGLOBALALPHAFACTORISUNPROC)(GLint factor);
extern PFNGLGLOBALALPHAFACTORISUNPROC glad_glGlobalAlphaFactoriSUN;

typedef void ( * PFNGLGLOBALALPHAFACTORFSUNPROC)(GLfloat factor);
extern PFNGLGLOBALALPHAFACTORFSUNPROC glad_glGlobalAlphaFactorfSUN;

typedef void ( * PFNGLGLOBALALPHAFACTORDSUNPROC)(GLdouble factor);
extern PFNGLGLOBALALPHAFACTORDSUNPROC glad_glGlobalAlphaFactordSUN;

typedef void ( * PFNGLGLOBALALPHAFACTORUBSUNPROC)(GLubyte factor);
extern PFNGLGLOBALALPHAFACTORUBSUNPROC glad_glGlobalAlphaFactorubSUN;

typedef void ( * PFNGLGLOBALALPHAFACTORUSSUNPROC)(GLushort factor);
extern PFNGLGLOBALALPHAFACTORUSSUNPROC glad_glGlobalAlphaFactorusSUN;

typedef void ( * PFNGLGLOBALALPHAFACTORUISUNPROC)(GLuint factor);
extern PFNGLGLOBALALPHAFACTORUISUNPROC glad_glGlobalAlphaFactoruiSUN;




extern int GLAD_GL_SUN_mesh_array;
typedef void ( * PFNGLDRAWMESHARRAYSSUNPROC)(GLenum mode, GLint first, GLsizei count, GLsizei width);
extern PFNGLDRAWMESHARRAYSSUNPROC glad_glDrawMeshArraysSUN;




extern int GLAD_GL_SUN_slice_accum;



extern int GLAD_GL_SUN_triangle_list;
typedef void ( * PFNGLREPLACEMENTCODEUISUNPROC)(GLuint code);
extern PFNGLREPLACEMENTCODEUISUNPROC glad_glReplacementCodeuiSUN;

typedef void ( * PFNGLREPLACEMENTCODEUSSUNPROC)(GLushort code);
extern PFNGLREPLACEMENTCODEUSSUNPROC glad_glReplacementCodeusSUN;

typedef void ( * PFNGLREPLACEMENTCODEUBSUNPROC)(GLubyte code);
extern PFNGLREPLACEMENTCODEUBSUNPROC glad_glReplacementCodeubSUN;

typedef void ( * PFNGLREPLACEMENTCODEUIVSUNPROC)(const GLuint *code);
extern PFNGLREPLACEMENTCODEUIVSUNPROC glad_glReplacementCodeuivSUN;

typedef void ( * PFNGLREPLACEMENTCODEUSVSUNPROC)(const GLushort *code);
extern PFNGLREPLACEMENTCODEUSVSUNPROC glad_glReplacementCodeusvSUN;

typedef void ( * PFNGLREPLACEMENTCODEUBVSUNPROC)(const GLubyte *code);
extern PFNGLREPLACEMENTCODEUBVSUNPROC glad_glReplacementCodeubvSUN;

typedef void ( * PFNGLREPLACEMENTCODEPOINTERSUNPROC)(GLenum type, GLsizei stride, const void **pointer);
extern PFNGLREPLACEMENTCODEPOINTERSUNPROC glad_glReplacementCodePointerSUN;




extern int GLAD_GL_SUN_vertex;
typedef void ( * PFNGLCOLOR4UBVERTEX2FSUNPROC)(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
extern PFNGLCOLOR4UBVERTEX2FSUNPROC glad_glColor4ubVertex2fSUN;

typedef void ( * PFNGLCOLOR4UBVERTEX2FVSUNPROC)(const GLubyte *c, const GLfloat *v);
extern PFNGLCOLOR4UBVERTEX2FVSUNPROC glad_glColor4ubVertex2fvSUN;

typedef void ( * PFNGLCOLOR4UBVERTEX3FSUNPROC)(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLCOLOR4UBVERTEX3FSUNPROC glad_glColor4ubVertex3fSUN;

typedef void ( * PFNGLCOLOR4UBVERTEX3FVSUNPROC)(const GLubyte *c, const GLfloat *v);
extern PFNGLCOLOR4UBVERTEX3FVSUNPROC glad_glColor4ubVertex3fvSUN;

typedef void ( * PFNGLCOLOR3FVERTEX3FSUNPROC)(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLCOLOR3FVERTEX3FSUNPROC glad_glColor3fVertex3fSUN;

typedef void ( * PFNGLCOLOR3FVERTEX3FVSUNPROC)(const GLfloat *c, const GLfloat *v);
extern PFNGLCOLOR3FVERTEX3FVSUNPROC glad_glColor3fVertex3fvSUN;

typedef void ( * PFNGLNORMAL3FVERTEX3FSUNPROC)(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLNORMAL3FVERTEX3FSUNPROC glad_glNormal3fVertex3fSUN;

typedef void ( * PFNGLNORMAL3FVERTEX3FVSUNPROC)(const GLfloat *n, const GLfloat *v);
extern PFNGLNORMAL3FVERTEX3FVSUNPROC glad_glNormal3fVertex3fvSUN;

typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC)(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC glad_glColor4fNormal3fVertex3fSUN;

typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const GLfloat *c, const GLfloat *n, const GLfloat *v);
extern PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC glad_glColor4fNormal3fVertex3fvSUN;

typedef void ( * PFNGLTEXCOORD2FVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLTEXCOORD2FVERTEX3FSUNPROC glad_glTexCoord2fVertex3fSUN;

typedef void ( * PFNGLTEXCOORD2FVERTEX3FVSUNPROC)(const GLfloat *tc, const GLfloat *v);
extern PFNGLTEXCOORD2FVERTEX3FVSUNPROC glad_glTexCoord2fVertex3fvSUN;

typedef void ( * PFNGLTEXCOORD4FVERTEX4FSUNPROC)(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern PFNGLTEXCOORD4FVERTEX4FSUNPROC glad_glTexCoord4fVertex4fSUN;

typedef void ( * PFNGLTEXCOORD4FVERTEX4FVSUNPROC)(const GLfloat *tc, const GLfloat *v);
extern PFNGLTEXCOORD4FVERTEX4FVSUNPROC glad_glTexCoord4fVertex4fvSUN;

typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC glad_glTexCoord2fColor4ubVertex3fSUN;

typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC)(const GLfloat *tc, const GLubyte *c, const GLfloat *v);
extern PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC glad_glTexCoord2fColor4ubVertex3fvSUN;

typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC glad_glTexCoord2fColor3fVertex3fSUN;

typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC)(const GLfloat *tc, const GLfloat *c, const GLfloat *v);
extern PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC glad_glTexCoord2fColor3fVertex3fvSUN;

typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC glad_glTexCoord2fNormal3fVertex3fSUN;

typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC)(const GLfloat *tc, const GLfloat *n, const GLfloat *v);
extern PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC glad_glTexCoord2fNormal3fVertex3fvSUN;

typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC glad_glTexCoord2fColor4fNormal3fVertex3fSUN;

typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
extern PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC glad_glTexCoord2fColor4fNormal3fVertex3fvSUN;

typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC)(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC glad_glTexCoord4fColor4fNormal3fVertex4fSUN;

typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC)(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
extern PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC glad_glTexCoord4fColor4fNormal3fVertex4fvSUN;

typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC)(GLuint rc, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC glad_glReplacementCodeuiVertex3fSUN;

typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *v);
extern PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC glad_glReplacementCodeuiVertex3fvSUN;

typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC)(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC glad_glReplacementCodeuiColor4ubVertex3fSUN;

typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC)(const GLuint *rc, const GLubyte *c, const GLfloat *v);
extern PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC glad_glReplacementCodeuiColor4ubVertex3fvSUN;

typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC)(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC glad_glReplacementCodeuiColor3fVertex3fSUN;

typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *c, const GLfloat *v);
extern PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC glad_glReplacementCodeuiColor3fVertex3fvSUN;

typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC)(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC glad_glReplacementCodeuiNormal3fVertex3fSUN;

typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *n, const GLfloat *v);
extern PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC glad_glReplacementCodeuiNormal3fVertex3fvSUN;

typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC)(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC glad_glReplacementCodeuiColor4fNormal3fVertex3fSUN;

typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
extern PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC glad_glReplacementCodeuiColor4fNormal3fVertex3fvSUN;

typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC)(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC glad_glReplacementCodeuiTexCoord2fVertex3fSUN;

typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *tc, const GLfloat *v);
extern PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC glad_glReplacementCodeuiTexCoord2fVertex3fvSUN;

typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC)(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC glad_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;

typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
extern PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC glad_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;

typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC)(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
extern PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC glad_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;

typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
extern PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC glad_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;




extern int GLAD_GL_WIN_phong_shading;



extern int GLAD_GL_WIN_specular_fog;



}
# 7 "/home/tayler/projects/marmalade/src/graphics/shader.cpp" 2
# 1 "/usr/include/glm/gtc/type_ptr.hpp" 1 3 4
# 34 "/usr/include/glm/gtc/type_ptr.hpp" 3 4
       


# 1 "/usr/include/glm/gtc/quaternion.hpp" 1 3 4
# 14 "/usr/include/glm/gtc/quaternion.hpp" 3 4
       


# 1 "/usr/include/glm/gtc/constants.hpp" 1 3 4
# 13 "/usr/include/glm/gtc/constants.hpp" 3 4
       


# 1 "/usr/include/glm/ext/scalar_constants.hpp" 1 3 4
# 11 "/usr/include/glm/ext/scalar_constants.hpp" 3 4
       


# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 15 "/usr/include/glm/ext/scalar_constants.hpp" 2 3 4






# 20 "/usr/include/glm/ext/scalar_constants.hpp" 3 4
namespace glm
{




 template<typename genType>
 [[nodiscard]] constexpr genType epsilon();


 template<typename genType>
 [[nodiscard]] constexpr genType pi();


 template<typename genType>
 [[nodiscard]] constexpr genType cos_one_over_two();


}

# 1 "/usr/include/glm/ext/scalar_constants.inl" 1 3 4


namespace glm
{
 template<typename genType>
 inline constexpr genType epsilon()
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'epsilon' only accepts floating-point inputs");
  return std::numeric_limits<genType>::epsilon();
 }

 template<typename genType>
 inline constexpr genType pi()
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'pi' only accepts floating-point inputs");
  return static_cast<genType>(3.14159265358979323846264338327950288);
 }

 template<typename genType>
 inline constexpr genType cos_one_over_two()
 {
  return genType(0.877582561890372716130286068203503191);
 }
}
# 41 "/usr/include/glm/ext/scalar_constants.hpp" 2 3 4
# 17 "/usr/include/glm/gtc/constants.hpp" 2 3 4





namespace glm
{





 template<typename genType>
 [[nodiscard]] constexpr genType zero();



 template<typename genType>
 [[nodiscard]] constexpr genType one();



 template<typename genType>
 [[nodiscard]] constexpr genType two_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType tau();



 template<typename genType>
 [[nodiscard]] constexpr genType root_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType half_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType three_over_two_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType quarter_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType one_over_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType one_over_two_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType two_over_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType four_over_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType two_over_root_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType one_over_root_two();



 template<typename genType>
 [[nodiscard]] constexpr genType root_half_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType root_two_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType root_ln_four();



 template<typename genType>
 [[nodiscard]] constexpr genType e();



 template<typename genType>
 [[nodiscard]] constexpr genType euler();



 template<typename genType>
 [[nodiscard]] constexpr genType root_two();



 template<typename genType>
 [[nodiscard]] constexpr genType root_three();



 template<typename genType>
 [[nodiscard]] constexpr genType root_five();



 template<typename genType>
 [[nodiscard]] constexpr genType ln_two();



 template<typename genType>
 [[nodiscard]] constexpr genType ln_ten();



 template<typename genType>
 [[nodiscard]] constexpr genType ln_ln_two();



 template<typename genType>
 [[nodiscard]] constexpr genType third();



 template<typename genType>
 [[nodiscard]] constexpr genType two_thirds();



 template<typename genType>
 [[nodiscard]] constexpr genType golden_ratio();


}

# 1 "/usr/include/glm/gtc/constants.inl" 1 3 4


namespace glm
{
 template<typename genType>
 inline constexpr genType zero()
 {
  return genType(0);
 }

 template<typename genType>
 inline constexpr genType one()
 {
  return genType(1);
 }

 template<typename genType>
 inline constexpr genType two_pi()
 {
  return genType(6.28318530717958647692528676655900576);
 }

 template<typename genType>
 inline constexpr genType tau()
 {
  return two_pi<genType>();
 }

 template<typename genType>
 inline constexpr genType root_pi()
 {
  return genType(1.772453850905516027);
 }

 template<typename genType>
 inline constexpr genType half_pi()
 {
  return genType(1.57079632679489661923132169163975144);
 }

 template<typename genType>
 inline constexpr genType three_over_two_pi()
 {
  return genType(4.71238898038468985769396507491925432);
 }

 template<typename genType>
 inline constexpr genType quarter_pi()
 {
  return genType(0.785398163397448309615660845819875721);
 }

 template<typename genType>
 inline constexpr genType one_over_pi()
 {
  return genType(0.318309886183790671537767526745028724);
 }

 template<typename genType>
 inline constexpr genType one_over_two_pi()
 {
  return genType(0.159154943091895335768883763372514362);
 }

 template<typename genType>
 inline constexpr genType two_over_pi()
 {
  return genType(0.636619772367581343075535053490057448);
 }

 template<typename genType>
 inline constexpr genType four_over_pi()
 {
  return genType(1.273239544735162686151070106980114898);
 }

 template<typename genType>
 inline constexpr genType two_over_root_pi()
 {
  return genType(1.12837916709551257389615890312154517);
 }

 template<typename genType>
 inline constexpr genType one_over_root_two()
 {
  return genType(0.707106781186547524400844362104849039);
 }

 template<typename genType>
 inline constexpr genType root_half_pi()
 {
  return genType(1.253314137315500251);
 }

 template<typename genType>
 inline constexpr genType root_two_pi()
 {
  return genType(2.506628274631000502);
 }

 template<typename genType>
 inline constexpr genType root_ln_four()
 {
  return genType(1.17741002251547469);
 }

 template<typename genType>
 inline constexpr genType e()
 {
  return genType(2.71828182845904523536);
 }

 template<typename genType>
 inline constexpr genType euler()
 {
  return genType(0.577215664901532860606);
 }

 template<typename genType>
 inline constexpr genType root_two()
 {
  return genType(1.41421356237309504880168872420969808);
 }

 template<typename genType>
 inline constexpr genType root_three()
 {
  return genType(1.73205080756887729352744634150587236);
 }

 template<typename genType>
 inline constexpr genType root_five()
 {
  return genType(2.23606797749978969640917366873127623);
 }

 template<typename genType>
 inline constexpr genType ln_two()
 {
  return genType(0.693147180559945309417232121458176568);
 }

 template<typename genType>
 inline constexpr genType ln_ten()
 {
  return genType(2.30258509299404568401799145468436421);
 }

 template<typename genType>
 inline constexpr genType ln_ln_two()
 {
  return genType(-0.3665129205816643);
 }

 template<typename genType>
 inline constexpr genType third()
 {
  return genType(0.3333333333333333333333333333333333333333);
 }

 template<typename genType>
 inline constexpr genType two_thirds()
 {
  return genType(0.666666666666666666666666666666666666667);
 }

 template<typename genType>
 inline constexpr genType golden_ratio()
 {
  return genType(1.61803398874989484820458683436563811);
 }

}
# 171 "/usr/include/glm/gtc/constants.hpp" 2 3 4
# 18 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 1 "/usr/include/glm/gtc/matrix_transform.hpp" 1 3 4
# 21 "/usr/include/glm/gtc/matrix_transform.hpp" 3 4
       






# 1 "/usr/include/glm/ext/matrix_projection.hpp" 1 3 4
# 20 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
       
# 32 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
namespace glm
{
# 49 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> projectZO(
  vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 65 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> projectNO(
  vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 81 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> project(
  vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 97 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> unProjectZO(
  vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 113 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> unProjectNO(
  vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 129 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> unProject(
  vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 142 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
 template<typename T, qualifier Q, typename U>
 [[nodiscard]] mat<4, 4, T, Q> pickMatrix(
  vec<2, T, Q> const& center, vec<2, T, Q> const& delta, vec<4, U, Q> const& viewport);


}

# 1 "/usr/include/glm/ext/matrix_projection.inl" 1 3 4
namespace glm
{
 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> projectZO(vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {
  vec<4, T, Q> tmp = vec<4, T, Q>(obj, static_cast<T>(1));
  tmp = model * tmp;
  tmp = proj * tmp;

  tmp /= tmp.w;
  tmp.x = tmp.x * static_cast<T>(0.5) + static_cast<T>(0.5);
  tmp.y = tmp.y * static_cast<T>(0.5) + static_cast<T>(0.5);

  tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
  tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

  return vec<3, T, Q>(tmp);
 }

 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> projectNO(vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {
  vec<4, T, Q> tmp = vec<4, T, Q>(obj, static_cast<T>(1));
  tmp = model * tmp;
  tmp = proj * tmp;

  tmp /= tmp.w;
  tmp = tmp * static_cast<T>(0.5) + static_cast<T>(0.5);
  tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
  tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

  return vec<3, T, Q>(tmp);
 }

 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> project(vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {



   return projectNO(obj, model, proj, viewport);

 }

 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> unProjectZO(vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {
  mat<4, 4, T, Q> Inverse = inverse(proj * model);

  vec<4, T, Q> tmp = vec<4, T, Q>(win, T(1));
  tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
  tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);
  tmp.x = tmp.x * static_cast<T>(2) - static_cast<T>(1);
  tmp.y = tmp.y * static_cast<T>(2) - static_cast<T>(1);

  vec<4, T, Q> obj = Inverse * tmp;
  obj /= obj.w;

  return vec<3, T, Q>(obj);
 }

 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> unProjectNO(vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {
  mat<4, 4, T, Q> Inverse = inverse(proj * model);

  vec<4, T, Q> tmp = vec<4, T, Q>(win, T(1));
  tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
  tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);
  tmp = tmp * static_cast<T>(2) - static_cast<T>(1);

  vec<4, T, Q> obj = Inverse * tmp;
  obj /= obj.w;

  return vec<3, T, Q>(obj);
 }

 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> unProject(vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {



   return unProjectNO(win, model, proj, viewport);

 }

 template<typename T, qualifier Q, typename U>
 inline mat<4, 4, T, Q> pickMatrix(vec<2, T, Q> const& center, vec<2, T, Q> const& delta, vec<4, U, Q> const& viewport)
 {
  (static_cast <bool> (delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)) ? void (0) : __assert_fail ("delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  mat<4, 4, T, Q> Result(static_cast<T>(1));

  if(!(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)))
   return Result;

  vec<3, T, Q> Temp(
   (static_cast<T>(viewport[2]) - static_cast<T>(2) * (center.x - static_cast<T>(viewport[0]))) / delta.x,
   (static_cast<T>(viewport[3]) - static_cast<T>(2) * (center.y - static_cast<T>(viewport[1]))) / delta.y,
   static_cast<T>(0));


  Result = translate(Result, Temp);
  return scale(Result, vec<3, T, Q>(static_cast<T>(viewport[2]) / delta.x, static_cast<T>(viewport[3]) / delta.y, static_cast<T>(1)));
 }
}
# 150 "/usr/include/glm/ext/matrix_projection.hpp" 2 3 4
# 29 "/usr/include/glm/gtc/matrix_transform.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_clip_space.hpp" 1 3 4
# 20 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
       
# 31 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
namespace glm
{
# 42 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> ortho(
  T left, T right, T bottom, T top);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoLH_ZO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoLH_NO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoRH_ZO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoRH_NO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoZO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoNO(
  T left, T right, T bottom, T top, T zNear, T zFar);
# 113 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoLH(
  T left, T right, T bottom, T top, T zNear, T zFar);
# 124 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoRH(
  T left, T right, T bottom, T top, T zNear, T zFar);
# 135 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> ortho(
  T left, T right, T bottom, T top, T zNear, T zFar);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumLH_ZO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumLH_NO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumRH_ZO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumRH_NO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumZO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumNO(
  T left, T right, T bottom, T top, T near, T far);






 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumLH(
  T left, T right, T bottom, T top, T near, T far);






 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumRH(
  T left, T right, T bottom, T top, T near, T far);






 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustum(
  T left, T right, T bottom, T top, T near, T far);
# 224 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveRH_ZO(
  T fovy, T aspect, T near, T far);
# 237 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveRH_NO(
  T fovy, T aspect, T near, T far);
# 250 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveLH_ZO(
  T fovy, T aspect, T near, T far);
# 263 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveLH_NO(
  T fovy, T aspect, T near, T far);
# 276 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveZO(
  T fovy, T aspect, T near, T far);
# 289 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveNO(
  T fovy, T aspect, T near, T far);
# 303 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveRH(
  T fovy, T aspect, T near, T far);
# 317 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveLH(
  T fovy, T aspect, T near, T far);
# 331 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspective(
  T fovy, T aspect, T near, T far);
# 345 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovRH_ZO(
  T fov, T width, T height, T near, T far);
# 359 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovRH_NO(
  T fov, T width, T height, T near, T far);
# 373 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovLH_ZO(
  T fov, T width, T height, T near, T far);
# 387 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovLH_NO(
  T fov, T width, T height, T near, T far);
# 401 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovZO(
  T fov, T width, T height, T near, T far);
# 415 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovNO(
  T fov, T width, T height, T near, T far);
# 430 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovRH(
  T fov, T width, T height, T near, T far);
# 445 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovLH(
  T fov, T width, T height, T near, T far);
# 459 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFov(
  T fov, T width, T height, T near, T far);
# 470 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> infinitePerspectiveLH(
  T fovy, T aspect, T near);
# 481 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> infinitePerspectiveRH(
  T fovy, T aspect, T near);
# 492 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> infinitePerspective(
  T fovy, T aspect, T near);
# 503 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> tweakedInfinitePerspective(
  T fovy, T aspect, T near);
# 515 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> tweakedInfinitePerspective(
  T fovy, T aspect, T near, T ep);


}

# 1 "/usr/include/glm/ext/matrix_clip_space.inl" 1 3 4
namespace glm
{
 template<typename T>
 inline mat<4, 4, T, defaultp> ortho(T left, T right, T bottom, T top)
 {
  mat<4, 4, T, defaultp> Result(static_cast<T>(1));
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - static_cast<T>(1);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoLH_ZO(T left, T right, T bottom, T top, T zNear, T zFar)
 {
  mat<4, 4, T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = static_cast<T>(1) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - zNear / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoLH_NO(T left, T right, T bottom, T top, T zNear, T zFar)
 {
  mat<4, 4, T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = static_cast<T>(2) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - (zFar + zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoRH_ZO(T left, T right, T bottom, T top, T zNear, T zFar)
 {
  mat<4, 4, T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - static_cast<T>(1) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - zNear / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoRH_NO(T left, T right, T bottom, T top, T zNear, T zFar)
 {
  mat<4, 4, T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - static_cast<T>(2) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - (zFar + zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoZO(T left, T right, T bottom, T top, T zNear, T zFar)
 {



   return orthoRH_ZO(left, right, bottom, top, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoNO(T left, T right, T bottom, T top, T zNear, T zFar)
 {



   return orthoRH_NO(left, right, bottom, top, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoLH(T left, T right, T bottom, T top, T zNear, T zFar)
 {



   return orthoLH_NO(left, right, bottom, top, zNear, zFar);


 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoRH(T left, T right, T bottom, T top, T zNear, T zFar)
 {



   return orthoRH_NO(left, right, bottom, top, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> ortho(T left, T right, T bottom, T top, T zNear, T zFar)
 {







   return orthoRH_NO(left, right, bottom, top, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumLH_ZO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {
  mat<4, 4, T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = -(right + left) / (right - left);
  Result[2][1] = -(top + bottom) / (top - bottom);
  Result[2][2] = farVal / (farVal - nearVal);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = -(farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumLH_NO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {
  mat<4, 4, T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = -(right + left) / (right - left);
  Result[2][1] = -(top + bottom) / (top - bottom);
  Result[2][2] = (farVal + nearVal) / (farVal - nearVal);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumRH_ZO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {
  mat<4, 4, T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = (right + left) / (right - left);
  Result[2][1] = (top + bottom) / (top - bottom);
  Result[2][2] = farVal / (nearVal - farVal);
  Result[2][3] = static_cast<T>(-1);
  Result[3][2] = -(farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumRH_NO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {
  mat<4, 4, T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = (right + left) / (right - left);
  Result[2][1] = (top + bottom) / (top - bottom);
  Result[2][2] = - (farVal + nearVal) / (farVal - nearVal);
  Result[2][3] = static_cast<T>(-1);
  Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumZO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {



   return frustumRH_ZO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumNO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {



   return frustumRH_NO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumLH(T left, T right, T bottom, T top, T nearVal, T farVal)
 {



   return frustumLH_NO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumRH(T left, T right, T bottom, T top, T nearVal, T farVal)
 {



   return frustumRH_NO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustum(T left, T right, T bottom, T top, T nearVal, T farVal)
 {







   return frustumRH_NO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveRH_ZO(T fovy, T aspect, T zNear, T zFar)
 {
  (static_cast <bool> (abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)) ? void (0) : __assert_fail ("abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][2] = zFar / (zNear - zFar);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = -(zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveRH_NO(T fovy, T aspect, T zNear, T zFar)
 {
  (static_cast <bool> (abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)) ? void (0) : __assert_fail ("abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][2] = - (zFar + zNear) / (zFar - zNear);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveLH_ZO(T fovy, T aspect, T zNear, T zFar)
 {
  (static_cast <bool> (abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)) ? void (0) : __assert_fail ("abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][2] = zFar / (zFar - zNear);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = -(zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveLH_NO(T fovy, T aspect, T zNear, T zFar)
 {
  (static_cast <bool> (abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)) ? void (0) : __assert_fail ("abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][2] = (zFar + zNear) / (zFar - zNear);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveZO(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveRH_ZO(fovy, aspect, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveNO(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveRH_NO(fovy, aspect, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveLH(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveLH_NO(fovy, aspect, zNear, zFar);


 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveRH(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveRH_NO(fovy, aspect, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspective(T fovy, T aspect, T zNear, T zFar)
 {







   return perspectiveRH_NO(fovy, aspect, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovRH_ZO(T fov, T width, T height, T zNear, T zFar)
 {
  (static_cast <bool> (width > static_cast<T>(0)) ? void (0) : __assert_fail ("width > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (height > static_cast<T>(0)) ? void (0) : __assert_fail ("height > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (fov > static_cast<T>(0)) ? void (0) : __assert_fail ("fov > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = zFar / (zNear - zFar);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = -(zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovRH_NO(T fov, T width, T height, T zNear, T zFar)
 {
  (static_cast <bool> (width > static_cast<T>(0)) ? void (0) : __assert_fail ("width > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (height > static_cast<T>(0)) ? void (0) : __assert_fail ("height > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (fov > static_cast<T>(0)) ? void (0) : __assert_fail ("fov > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = - (zFar + zNear) / (zFar - zNear);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovLH_ZO(T fov, T width, T height, T zNear, T zFar)
 {
  (static_cast <bool> (width > static_cast<T>(0)) ? void (0) : __assert_fail ("width > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (height > static_cast<T>(0)) ? void (0) : __assert_fail ("height > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (fov > static_cast<T>(0)) ? void (0) : __assert_fail ("fov > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = zFar / (zFar - zNear);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = -(zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovLH_NO(T fov, T width, T height, T zNear, T zFar)
 {
  (static_cast <bool> (width > static_cast<T>(0)) ? void (0) : __assert_fail ("width > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (height > static_cast<T>(0)) ? void (0) : __assert_fail ("height > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (fov > static_cast<T>(0)) ? void (0) : __assert_fail ("fov > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = (zFar + zNear) / (zFar - zNear);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovZO(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovRH_ZO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovNO(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovRH_NO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovLH(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovLH_NO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovRH(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovRH_NO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFov(T fov, T width, T height, T zNear, T zFar)
 {







   return perspectiveFovRH_NO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> infinitePerspectiveRH_NO(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = - static_cast<T>(1);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - static_cast<T>(2) * zNear;
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> infinitePerspectiveRH_ZO(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = - static_cast<T>(1);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - zNear;
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> infinitePerspectiveLH_NO(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(T(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = static_cast<T>(1);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - static_cast<T>(2) * zNear;
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> infinitePerspectiveLH_ZO(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(T(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = static_cast<T>(1);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - zNear;
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> infinitePerspective(T fovy, T aspect, T zNear)
 {







   return infinitePerspectiveRH_NO(fovy, aspect, zNear);

 }


 template<typename T>
 inline mat<4, 4, T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear, T ep)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = ep - static_cast<T>(1);
  Result[2][3] = static_cast<T>(-1);
  Result[3][2] = (ep - static_cast<T>(2)) * zNear;
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear)
 {
  return tweakedInfinitePerspective(fovy, aspect, zNear, epsilon<T>());
 }
}
# 523 "/usr/include/glm/ext/matrix_clip_space.hpp" 2 3 4
# 30 "/usr/include/glm/gtc/matrix_transform.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_transform.hpp" 1 3 4
# 20 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
       
# 32 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
namespace glm
{




 template<typename genType>
 [[nodiscard]] constexpr genType identity();
# 63 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> translate(
  mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v);
# 79 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> rotate(
  mat<4, 4, T, Q> const& m, T angle, vec<3, T, Q> const& axis);
# 94 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> scale(
  mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v);
# 121 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
    template <typename T, qualifier Q>
    inline mat<4, 4, T, Q> shear(
        mat<4, 4, T, Q> const &m, vec<3, T, Q> const& p, vec<2, T, Q> const &l_x, vec<2, T, Q> const &l_y, vec<2, T, Q> const &l_z);
# 135 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> lookAtRH(
  vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up);
# 149 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> lookAtLH(
  vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up);
# 164 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> lookAt(
  vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up);


}

# 1 "/usr/include/glm/ext/matrix_transform.inl" 1 3 4
namespace glm
{
 template<typename genType>
 inline constexpr genType identity()
 {
  return detail::init_gentype<genType, detail::genTypeTrait<genType>::GENTYPE>::identity();
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> translate(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
 {
  mat<4, 4, T, Q> Result(m);
  Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> rotate(mat<4, 4, T, Q> const& m, T angle, vec<3, T, Q> const& v)
 {
  T const a = angle;
  T const c = cos(a);
  T const s = sin(a);

  vec<3, T, Q> axis(normalize(v));
  vec<3, T, Q> temp((T(1) - c) * axis);

  mat<4, 4, T, Q> Rotate;
  Rotate[0][0] = c + temp[0] * axis[0];
  Rotate[0][1] = temp[0] * axis[1] + s * axis[2];
  Rotate[0][2] = temp[0] * axis[2] - s * axis[1];

  Rotate[1][0] = temp[1] * axis[0] - s * axis[2];
  Rotate[1][1] = c + temp[1] * axis[1];
  Rotate[1][2] = temp[1] * axis[2] + s * axis[0];

  Rotate[2][0] = temp[2] * axis[0] + s * axis[1];
  Rotate[2][1] = temp[2] * axis[1] - s * axis[0];
  Rotate[2][2] = c + temp[2] * axis[2];

  mat<4, 4, T, Q> Result;
  Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];
  Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];
  Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];
  Result[3] = m[3];
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> rotate_slow(mat<4, 4, T, Q> const& m, T angle, vec<3, T, Q> const& v)
 {
  T const a = angle;
  T const c = cos(a);
  T const s = sin(a);
  mat<4, 4, T, Q> Result;

  vec<3, T, Q> axis = normalize(v);

  Result[0][0] = c + (static_cast<T>(1) - c) * axis.x * axis.x;
  Result[0][1] = (static_cast<T>(1) - c) * axis.x * axis.y + s * axis.z;
  Result[0][2] = (static_cast<T>(1) - c) * axis.x * axis.z - s * axis.y;
  Result[0][3] = static_cast<T>(0);

  Result[1][0] = (static_cast<T>(1) - c) * axis.y * axis.x - s * axis.z;
  Result[1][1] = c + (static_cast<T>(1) - c) * axis.y * axis.y;
  Result[1][2] = (static_cast<T>(1) - c) * axis.y * axis.z + s * axis.x;
  Result[1][3] = static_cast<T>(0);

  Result[2][0] = (static_cast<T>(1) - c) * axis.z * axis.x + s * axis.y;
  Result[2][1] = (static_cast<T>(1) - c) * axis.z * axis.y - s * axis.x;
  Result[2][2] = c + (static_cast<T>(1) - c) * axis.z * axis.z;
  Result[2][3] = static_cast<T>(0);

  Result[3] = vec<4, T, Q>(0, 0, 0, 1);
  return m * Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> scale(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
 {
  mat<4, 4, T, Q> Result;
  Result[0] = m[0] * v[0];
  Result[1] = m[1] * v[1];
  Result[2] = m[2] * v[2];
  Result[3] = m[3];
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> scale_slow(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
 {
  mat<4, 4, T, Q> Result(T(1));
  Result[0][0] = v.x;
  Result[1][1] = v.y;
  Result[2][2] = v.z;
  return m * Result;
 }

    template <typename T, qualifier Q>
    inline mat<4, 4, T, Q> shear(mat<4, 4, T, Q> const &m, vec<3, T, Q> const& p, vec<2, T, Q> const &l_x, vec<2, T, Q> const &l_y, vec<2, T, Q> const &l_z)
    {
        T const lambda_xy = l_x[0];
        T const lambda_xz = l_x[1];
        T const lambda_yx = l_y[0];
        T const lambda_yz = l_y[1];
        T const lambda_zx = l_z[0];
        T const lambda_zy = l_z[1];

        vec<3, T, Q> point_lambda = vec<3, T, Q>(
            (lambda_xy + lambda_xz), (lambda_yx + lambda_yz), (lambda_zx + lambda_zy)
        );

        mat<4, 4, T, Q> Shear = mat<4, 4, T, Q>(
            1 , lambda_yx , lambda_zx , 0,
            lambda_xy , 1 , lambda_zy , 0,
            lambda_xz , lambda_yz , 1 , 0,
            -point_lambda[0] * p[0], -point_lambda[1] * p[1], -point_lambda[2] * p[2], 1
        );

        mat<4, 4, T, Q> Result;
  Result[0] = m[0] * Shear[0][0] + m[1] * Shear[0][1] + m[2] * Shear[0][2] + m[3] * Shear[0][3];
  Result[1] = m[0] * Shear[1][0] + m[1] * Shear[1][1] + m[2] * Shear[1][2] + m[3] * Shear[1][3];
  Result[2] = m[0] * Shear[2][0] + m[1] * Shear[2][1] + m[2] * Shear[2][2] + m[3] * Shear[2][3];
  Result[3] = m[0] * Shear[3][0] + m[1] * Shear[3][1] + m[2] * Shear[3][2] + m[3] * Shear[3][3];
        return Result;
    }

    template <typename T, qualifier Q>
    inline mat<4, 4, T, Q> shear_slow(mat<4, 4, T, Q> const &m, vec<3, T, Q> const& p, vec<2, T, Q> const &l_x, vec<2, T, Q> const &l_y, vec<2, T, Q> const &l_z)
    {
        T const lambda_xy = static_cast<T>(l_x[0]);
        T const lambda_xz = static_cast<T>(l_x[1]);
        T const lambda_yx = static_cast<T>(l_y[0]);
        T const lambda_yz = static_cast<T>(l_y[1]);
        T const lambda_zx = static_cast<T>(l_z[0]);
        T const lambda_zy = static_cast<T>(l_z[1]);

        vec<3, T, Q> point_lambda = vec<3, T, Q>(
            static_cast<T>(lambda_xy + lambda_xz),
            static_cast<T>(lambda_yx + lambda_yz),
            static_cast<T>(lambda_zx + lambda_zy)
        );

        mat<4, 4, T, Q> Shear = mat<4, 4, T, Q>(
            1 , lambda_yx , lambda_zx , 0,
            lambda_xy , 1 , lambda_zy , 0,
            lambda_xz , lambda_yz , 1 , 0,
            -point_lambda[0] * p[0], -point_lambda[1] * p[1], -point_lambda[2] * p[2], 1
        );
        return m * Shear;
    }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> lookAtRH(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
 {
  vec<3, T, Q> const f(normalize(center - eye));
  vec<3, T, Q> const s(normalize(cross(f, up)));
  vec<3, T, Q> const u(cross(s, f));

  mat<4, 4, T, Q> Result(1);
  Result[0][0] = s.x;
  Result[1][0] = s.y;
  Result[2][0] = s.z;
  Result[0][1] = u.x;
  Result[1][1] = u.y;
  Result[2][1] = u.z;
  Result[0][2] =-f.x;
  Result[1][2] =-f.y;
  Result[2][2] =-f.z;
  Result[3][0] =-dot(s, eye);
  Result[3][1] =-dot(u, eye);
  Result[3][2] = dot(f, eye);
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> lookAtLH(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
 {
  vec<3, T, Q> const f(normalize(center - eye));
  vec<3, T, Q> const s(normalize(cross(up, f)));
  vec<3, T, Q> const u(cross(f, s));

  mat<4, 4, T, Q> Result(1);
  Result[0][0] = s.x;
  Result[1][0] = s.y;
  Result[2][0] = s.z;
  Result[0][1] = u.x;
  Result[1][1] = u.y;
  Result[2][1] = u.z;
  Result[0][2] = f.x;
  Result[1][2] = f.y;
  Result[2][2] = f.z;
  Result[3][0] = -dot(s, eye);
  Result[3][1] = -dot(u, eye);
  Result[3][2] = -dot(f, eye);
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> lookAt(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
 {



            return lookAtRH(eye, center, up);

 }
}
# 172 "/usr/include/glm/ext/matrix_transform.hpp" 2 3 4
# 31 "/usr/include/glm/gtc/matrix_transform.hpp" 2 3 4





# 1 "/usr/include/glm/gtc/matrix_transform.inl" 1 3 4
# 37 "/usr/include/glm/gtc/matrix_transform.hpp" 2 3 4
# 19 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_relational.hpp" 1 3 4
# 18 "/usr/include/glm/ext/vector_relational.hpp" 3 4
       
# 27 "/usr/include/glm/ext/vector_relational.hpp" 3 4
namespace glm
{
# 38 "/usr/include/glm/ext/vector_relational.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T epsilon);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T epsilon);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int ULPs);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& ULPs);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int ULPs);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& ULPs);


}

# 1 "/usr/include/glm/ext/vector_relational.inl" 1 3 4



# 1 "/usr/include/glm/detail/type_float.hpp" 1 3 4
       

# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 4 "/usr/include/glm/detail/type_float.hpp" 2 3 4






namespace glm{
namespace detail
{
 template <typename T>
 union float_t
 {};


 template <>
 union float_t<float>
 {
  typedef int int_type;
  typedef float float_type;

  constexpr float_t(float_type Num = 0.0f) : f(Num) {}

  constexpr float_t& operator=(float_t const& x)
  {
   f = x.f;
   return *this;
  }


  constexpr bool negative() const { return i < 0; }
  constexpr int_type mantissa() const { return i & ((1 << 23) - 1); }
  constexpr int_type exponent() const { return (i >> 23) & ((1 << 8) - 1); }

  int_type i;
  float_type f;
 };

 template <>
 union float_t<double>
 {
  typedef detail::int64 int_type;
  typedef double float_type;

  constexpr float_t(float_type Num = static_cast<float_type>(0)) : f(Num) {}

  constexpr float_t& operator=(float_t const& x)
  {
   f = x.f;
   return *this;
  }


  constexpr bool negative() const { return i < 0; }
  constexpr int_type mantissa() const { return i & ((int_type(1) << 52) - 1); }
  constexpr int_type exponent() const { return (i >> 52) & ((int_type(1) << 11) - 1); }

  int_type i;
  float_type f;
 };
}
}
# 5 "/usr/include/glm/ext/vector_relational.inl" 2 3 4

namespace glm
{
 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T Epsilon)
 {
  return equal(x, y, vec<L, T, Q>(Epsilon));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& Epsilon)
 {
  return lessThanEqual(abs(x - y), Epsilon);
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T Epsilon)
 {
  return notEqual(x, y, vec<L, T, Q>(Epsilon));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& Epsilon)
 {
  return greaterThan(abs(x - y), Epsilon);
 }


 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int MaxULPs)
 {
  return equal(x, y, vec<L, int, Q>(MaxULPs));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& MaxULPs)
 {
  vec<L, bool, Q> Result(false);
  for(length_t i = 0; i < L; ++i)
  {
   detail::float_t<T> const a(x[i]);
   detail::float_t<T> const b(y[i]);


   if(a.negative() != b.negative())
   {

    Result[i] = a.mantissa() == b.mantissa() && a.exponent() == b.exponent();
   }
   else
   {

    typename detail::float_t<T>::int_type const DiffULPs = abs(a.i - b.i);
    Result[i] = DiffULPs <= MaxULPs[i];
   }
  }
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int MaxULPs)
 {
  return notEqual(x, y, vec<L, int, Q>(MaxULPs));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& MaxULPs)
 {
  return not_(equal(x, y, MaxULPs));
 }
}
# 108 "/usr/include/glm/ext/vector_relational.hpp" 2 3 4
# 20 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 1 "/usr/include/glm/ext/quaternion_common.hpp" 1 3 4
# 21 "/usr/include/glm/ext/quaternion_common.hpp" 3 4
       



# 1 "/usr/include/glm/ext/quaternion_geometric.hpp" 1 3 4
# 15 "/usr/include/glm/ext/quaternion_geometric.hpp" 3 4
       
# 26 "/usr/include/glm/ext/quaternion_geometric.hpp" 3 4
namespace glm
{
# 37 "/usr/include/glm/ext/quaternion_geometric.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] T length(qua<T, Q> const& q);







 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> normalize(qua<T, Q> const& q);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr T dot(qua<T, Q> const& x, qua<T, Q> const& y);







 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> cross(qua<T, Q> const& q1, qua<T, Q> const& q2);


}

# 1 "/usr/include/glm/ext/quaternion_geometric.inl" 1 3 4
namespace glm
{
 template<typename T, qualifier Q>
 inline constexpr T dot(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'dot' accepts only floating-point inputs");
  return detail::compute_dot<qua<T, Q>, T, detail::is_aligned<Q>::value>::call(x, y);
 }

 template<typename T, qualifier Q>
 inline T length(qua<T, Q> const& q)
 {
  return glm::sqrt(dot(q, q));
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> normalize(qua<T, Q> const& q)
 {
  T len = length(q);
  if(len <= static_cast<T>(0))
   return qua<T, Q>::wxyz(static_cast<T>(1), static_cast<T>(0), static_cast<T>(0), static_cast<T>(0));
  T oneOverLen = static_cast<T>(1) / len;
  return qua<T, Q>::wxyz(q.w * oneOverLen, q.x * oneOverLen, q.y * oneOverLen, q.z * oneOverLen);
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> cross(qua<T, Q> const& q1, qua<T, Q> const& q2)
 {
  return qua<T, Q>::wxyz(
   q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
   q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
   q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z,
   q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x);
 }
}
# 71 "/usr/include/glm/ext/quaternion_geometric.hpp" 2 3 4
# 26 "/usr/include/glm/ext/quaternion_common.hpp" 2 3 4
# 35 "/usr/include/glm/ext/quaternion_common.hpp" 3 4
namespace glm
{
# 52 "/usr/include/glm/ext/quaternion_common.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> mix(qua<T, Q> const& x, qua<T, Q> const& y, T a);
# 64 "/usr/include/glm/ext/quaternion_common.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> lerp(qua<T, Q> const& x, qua<T, Q> const& y, T a);
# 76 "/usr/include/glm/ext/quaternion_common.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a);
# 91 "/usr/include/glm/ext/quaternion_common.hpp" 3 4
    template<typename T, typename S, qualifier Q>
    [[nodiscard]] qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a, S k);





 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> conjugate(qua<T, Q> const& q);





 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> inverse(qua<T, Q> const& q);
# 118 "/usr/include/glm/ext/quaternion_common.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> isnan(qua<T, Q> const& x);
# 129 "/usr/include/glm/ext/quaternion_common.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> isinf(qua<T, Q> const& x);


}

# 1 "/usr/include/glm/ext/quaternion_common.inl" 1 3 4
namespace glm
{
 template<typename T, qualifier Q>
 inline qua<T, Q> mix(qua<T, Q> const& x, qua<T, Q> const& y, T a)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'mix' only accept floating-point inputs");

  T const cosTheta = dot(x, y);


  if(cosTheta > static_cast<T>(1) - epsilon<T>())
  {

   return qua<T, Q>::wxyz(
    mix(x.w, y.w, a),
    mix(x.x, y.x, a),
    mix(x.y, y.y, a),
    mix(x.z, y.z, a));
  }
  else
  {

   T angle = acos(cosTheta);
   return (sin((static_cast<T>(1) - a) * angle) * x + sin(a * angle) * y) / sin(angle);
  }
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> lerp(qua<T, Q> const& x, qua<T, Q> const& y, T a)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'lerp' only accept floating-point inputs");


  (static_cast <bool> (a >= static_cast<T>(0)) ? void (0) : __assert_fail ("a >= static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (a <= static_cast<T>(1)) ? void (0) : __assert_fail ("a <= static_cast<T>(1)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  return x * (static_cast<T>(1) - a) + (y * a);
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'slerp' only accept floating-point inputs");

  qua<T, Q> z = y;

  T cosTheta = dot(x, y);



  if(cosTheta < static_cast<T>(0))
  {
   z = -y;
   cosTheta = -cosTheta;
  }


  if(cosTheta > static_cast<T>(1) - epsilon<T>())
  {

   return qua<T, Q>::wxyz(
    mix(x.w, z.w, a),
    mix(x.x, z.x, a),
    mix(x.y, z.y, a),
    mix(x.z, z.z, a));
  }
  else
  {

   T angle = acos(cosTheta);
   return (sin((static_cast<T>(1) - a) * angle) * x + sin(a * angle) * z) / sin(angle);
  }
 }

    template<typename T, typename S, qualifier Q>
    inline qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a, S k)
    {
        static_assert(std::numeric_limits<T>::is_iec559 || 0, "'slerp' only accept floating-point inputs");
        static_assert(std::numeric_limits<S>::is_integer, "'slerp' only accept integer for spin count");

        qua<T, Q> z = y;

        T cosTheta = dot(x, y);



        if (cosTheta < static_cast<T>(0))
        {
            z = -y;
            cosTheta = -cosTheta;
        }


        if (cosTheta > static_cast<T>(1) - epsilon<T>())
        {

            return qua<T, Q>::wxyz(
                mix(x.w, z.w, a),
                mix(x.x, z.x, a),
                mix(x.y, z.y, a),
                mix(x.z, z.z, a));
        }
        else
        {

            T angle = acos(cosTheta);
            T phi = angle + static_cast<T>(k) * glm::pi<T>();
            return (sin(angle - a * phi)* x + sin(a * phi) * z) / sin(angle);
        }
    }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> conjugate(qua<T, Q> const& q)
 {
  return qua<T, Q>::wxyz(q.w, -q.x, -q.y, -q.z);
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> inverse(qua<T, Q> const& q)
 {
  return conjugate(q) / dot(q, q);
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> isnan(qua<T, Q> const& q)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isnan' only accept floating-point inputs");

  return vec<4, bool, Q>(isnan(q.x), isnan(q.y), isnan(q.z), isnan(q.w));
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> isinf(qua<T, Q> const& q)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isinf' only accept floating-point inputs");

  return vec<4, bool, Q>(isinf(q.x), isinf(q.y), isinf(q.z), isinf(q.w));
 }
}
# 136 "/usr/include/glm/ext/quaternion_common.hpp" 2 3 4
# 21 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 1 "/usr/include/glm/ext/quaternion_float.hpp" 1 3 4
# 20 "/usr/include/glm/ext/quaternion_float.hpp" 3 4
       


# 1 "/usr/include/glm/detail/type_quat.hpp" 1 3 4



       







# 1 "/usr/include/glm/ext/quaternion_relational.hpp" 1 3 4
# 17 "/usr/include/glm/ext/quaternion_relational.hpp" 3 4
       
# 26 "/usr/include/glm/ext/quaternion_relational.hpp" 3 4
namespace glm
{







 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y);





 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon);





 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y);





 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon);


}

# 1 "/usr/include/glm/ext/quaternion_relational.inl" 1 3 4
namespace glm
{
 template<typename T, qualifier Q>
 inline vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result;
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] == y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon)
 {
  vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return lessThan(abs(v), vec<4, T, Q>(epsilon));
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result;
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] != y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon)
 {
  vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return greaterThanEqual(abs(v), vec<4, T, Q>(epsilon));
 }
}
# 63 "/usr/include/glm/ext/quaternion_relational.hpp" 2 3 4
# 13 "/usr/include/glm/detail/type_quat.hpp" 2 3 4



namespace glm
{


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 32 "/usr/include/glm/detail/type_quat.hpp" 3 4
 template<typename T, qualifier Q>
 struct qua
 {


  typedef qua<T, Q> type;
  typedef T value_type;
# 57 "/usr/include/glm/detail/type_quat.hpp" 3 4
    T x, y, z, w;





  typedef length_t length_type;


  [[nodiscard]] static constexpr length_type length(){return 4;}

  [[nodiscard]] constexpr T & operator[](length_type i);
  [[nodiscard]] constexpr T const& operator[](length_type i) const;



  constexpr qua() = default;
  constexpr qua(qua<T, Q> const& q) = default;
  template<qualifier P>
  constexpr qua(qua<T, P> const& q);



  constexpr qua(T s, vec<3, T, Q> const& v);




  constexpr qua(T w, T x, T y, T z);


  [[nodiscard]] static constexpr qua<T, Q> wxyz(T w, T x, T y, T z);



  template<typename U, qualifier P>
  constexpr qua(qua<U, P> const& q);



   [[nodiscard]] explicit operator mat<3, 3, T, Q>() const;
   [[nodiscard]] explicit operator mat<4, 4, T, Q>() const;
# 107 "/usr/include/glm/detail/type_quat.hpp" 3 4
  qua(vec<3, T, Q> const& u, vec<3, T, Q> const& v);


  constexpr qua(vec<3, T, Q> const& eulerAngles);
  constexpr qua(mat<3, 3, T, Q> const& q);
  constexpr qua(mat<4, 4, T, Q> const& q);



  constexpr qua<T, Q>& operator=(qua<T, Q> const& q) = default;

  template<typename U>
  constexpr qua<T, Q>& operator=(qua<U, Q> const& q);
  template<typename U>
  constexpr qua<T, Q>& operator+=(qua<U, Q> const& q);
  template<typename U>
  constexpr qua<T, Q>& operator-=(qua<U, Q> const& q);
  template<typename U>
  constexpr qua<T, Q>& operator*=(qua<U, Q> const& q);
  template<typename U>
  constexpr qua<T, Q>& operator*=(U s);
  template<typename U>
  constexpr qua<T, Q>& operator/=(U s);
 };





#pragma GCC diagnostic pop







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator+(qua<T, Q> const& q);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator-(qua<T, Q> const& q);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator+(qua<T, Q> const& q, qua<T, Q> const& p);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator-(qua<T, Q> const& q, qua<T, Q> const& p);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator*(qua<T, Q> const& q, qua<T, Q> const& p);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(qua<T, Q> const& q, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, qua<T, Q> const& q);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(qua<T, Q> const& q, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, qua<T, Q> const& q);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator*(qua<T, Q> const& q, T const& s);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator*(T const& s, qua<T, Q> const& q);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator/(qua<T, Q> const& q, T const& s);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(qua<T, Q> const& q1, qua<T, Q> const& q2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(qua<T, Q> const& q1, qua<T, Q> const& q2);
}


# 1 "/usr/include/glm/detail/type_quat.inl" 1 3 4






namespace glm{
namespace detail
{
 template <typename T>
 struct genTypeTrait<qua<T> >
 {
  static const genTypeEnum GENTYPE = GENTYPE_QUAT;
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<qua<T, Q>, T, Aligned>
 {
  inline constexpr static T call(qua<T, Q> const& a, qua<T, Q> const& b)
  {
   vec<4, T, Q> tmp(a.w * b.w, a.x * b.x, a.y * b.y, a.z * b.z);
   return (tmp.x + tmp.y) + (tmp.z + tmp.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_add
 {
  inline constexpr static qua<T, Q> call(qua<T, Q> const& q, qua<T, Q> const& p)
  {
   return qua<T, Q>::wxyz(q.w + p.w, q.x + p.x, q.y + p.y, q.z + p.z);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_sub
 {
  inline constexpr static qua<T, Q> call(qua<T, Q> const& q, qua<T, Q> const& p)
  {
   return qua<T, Q>::wxyz(q.w - p.w, q.x - p.x, q.y - p.y, q.z - p.z);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_mul_scalar
 {
  inline constexpr static qua<T, Q> call(qua<T, Q> const& q, T s)
  {
   return qua<T, Q>::wxyz(q.w * s, q.x * s, q.y * s, q.z * s);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_div_scalar
 {
  inline constexpr static qua<T, Q> call(qua<T, Q> const& q, T s)
  {
   return qua<T, Q>::wxyz(q.w / s, q.x / s, q.y / s, q.z / s);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_mul_vec4
 {
  inline constexpr static vec<4, T, Q> call(qua<T, Q> const& q, vec<4, T, Q> const& v)
  {
   return vec<4, T, Q>(q * vec<3, T, Q>(v), v.w);
  }
 };
}



 template<typename T, qualifier Q>
 inline constexpr T & qua<T, Q>::operator[](typename qua<T, Q>::length_type i)
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));



   return (&x)[i];

 }

 template<typename T, qualifier Q>
 inline constexpr T const& qua<T, Q>::operator[](typename qua<T, Q>::length_type i) const
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));



   return (&x)[i];

 }
# 122 "/usr/include/glm/detail/type_quat.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr qua<T, Q>::qua(qua<T, P> const& q)



   : x(q.x), y(q.y), z(q.z), w(q.w)

 {}



 template<typename T, qualifier Q>
 inline constexpr qua<T, Q>::qua(T s, vec<3, T, Q> const& v)



   : x(v.x), y(v.y), z(v.z), w(s)

 {}

 template <typename T, qualifier Q>



 inline constexpr qua<T, Q>::qua(T _w, T _x, T _y, T _z)




   : x(_x), y(_y), z(_z), w(_w)

 {}

 template <typename T, qualifier Q>
 constexpr qua<T, Q> qua<T, Q>::wxyz(T w, T x, T y, T z) {



  return qua<T, Q>(w, x, y, z);

 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr qua<T, Q>::qua(qua<U, P> const& q)



   : x(static_cast<T>(q.x)), y(static_cast<T>(q.y)), z(static_cast<T>(q.z)), w(static_cast<T>(q.w))

 {}
# 195 "/usr/include/glm/detail/type_quat.inl" 3 4
 template<typename T, qualifier Q>
 inline qua<T, Q>::qua(vec<3, T, Q> const& u, vec<3, T, Q> const& v)
 {
  T norm_u_norm_v = sqrt(dot(u, u) * dot(v, v));
  T real_part = norm_u_norm_v + dot(u, v);
  vec<3, T, Q> t;

  if(real_part < static_cast<T>(1.e-6f) * norm_u_norm_v)
  {



   real_part = static_cast<T>(0);
   t = abs(u.x) > abs(u.z) ? vec<3, T, Q>(-u.y, u.x, static_cast<T>(0)) : vec<3, T, Q>(static_cast<T>(0), -u.z, u.y);
  }
  else
  {

   t = cross(u, v);
  }

  *this = normalize(qua<T, Q>::wxyz(real_part, t.x, t.y, t.z));
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q>::qua(vec<3, T, Q> const& eulerAngle)
 {
  vec<3, T, Q> c = glm::cos(eulerAngle * T(0.5));
  vec<3, T, Q> s = glm::sin(eulerAngle * T(0.5));

  this->w = c.x * c.y * c.z + s.x * s.y * s.z;
  this->x = s.x * c.y * c.z - c.x * s.y * s.z;
  this->y = c.x * s.y * c.z + s.x * c.y * s.z;
  this->z = c.x * c.y * s.z - s.x * s.y * c.z;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q>::qua(mat<3, 3, T, Q> const& m)
 {
  *this = quat_cast(m);
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q>::qua(mat<4, 4, T, Q> const& m)
 {
  *this = quat_cast(m);
 }


 template<typename T, qualifier Q>
 inline qua<T, Q>::operator mat<3, 3, T, Q>() const
 {
  return mat3_cast(*this);
 }

 template<typename T, qualifier Q>
 inline qua<T, Q>::operator mat<4, 4, T, Q>() const
 {
  return mat4_cast(*this);
 }
# 271 "/usr/include/glm/detail/type_quat.inl" 3 4
 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator=(qua<U, Q> const& q)
 {
  this->w = static_cast<T>(q.w);
  this->x = static_cast<T>(q.x);
  this->y = static_cast<T>(q.y);
  this->z = static_cast<T>(q.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator+=(qua<U, Q> const& q)
 {
  return (*this = detail::compute_quat_add<T, Q, detail::is_aligned<Q>::value>::call(*this, qua<T, Q>(q)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator-=(qua<U, Q> const& q)
 {
  return (*this = detail::compute_quat_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, qua<T, Q>(q)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator*=(qua<U, Q> const& r)
 {
  qua<T, Q> const p(*this);
  qua<T, Q> const q(r);

  this->w = p.w * q.w - p.x * q.x - p.y * q.y - p.z * q.z;
  this->x = p.w * q.x + p.x * q.w + p.y * q.z - p.z * q.y;
  this->y = p.w * q.y + p.y * q.w + p.z * q.x - p.x * q.z;
  this->z = p.w * q.z + p.z * q.w + p.x * q.y - p.y * q.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator*=(U s)
 {
  return (*this = detail::compute_quat_mul_scalar<T, Q, detail::is_aligned<Q>::value>::call(*this, static_cast<U>(s)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator/=(U s)
 {
  return (*this = detail::compute_quat_div_scalar<T, Q, detail::is_aligned<Q>::value>::call(*this, static_cast<U>(s)));
 }



 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator+(qua<T, Q> const& q)
 {
  return q;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator-(qua<T, Q> const& q)
 {
  return qua<T, Q>::wxyz(-q.w, -q.x, -q.y, -q.z);
 }



 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator+(qua<T, Q> const& q, qua<T, Q> const& p)
 {
  return qua<T, Q>(q) += p;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator-(qua<T, Q> const& q, qua<T, Q> const& p)
 {
  return qua<T, Q>(q) -= p;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator*(qua<T, Q> const& q, qua<T, Q> const& p)
 {
  return qua<T, Q>(q) *= p;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(qua<T, Q> const& q, vec<3, T, Q> const& v)
 {
  vec<3, T, Q> const QuatVector(q.x, q.y, q.z);
  vec<3, T, Q> const uv(glm::cross(QuatVector, v));
  vec<3, T, Q> const uuv(glm::cross(QuatVector, uv));

  return v + ((uv * q.w) + uuv) * static_cast<T>(2);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, qua<T, Q> const& q)
 {
  return glm::inverse(q) * v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(qua<T, Q> const& q, vec<4, T, Q> const& v)
 {
  return detail::compute_quat_mul_vec4<T, Q, detail::is_aligned<Q>::value>::call(q, v);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, qua<T, Q> const& q)
 {
  return glm::inverse(q) * v;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator*(qua<T, Q> const& q, T const& s)
 {
  return qua<T, Q>::wxyz(
   q.w * s, q.x * s, q.y * s, q.z * s);
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator*(T const& s, qua<T, Q> const& q)
 {
  return q * s;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator/(qua<T, Q> const& q, T const& s)
 {
  return qua<T, Q>::wxyz(
   q.w / s, q.x / s, q.y / s, q.z / s);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(qua<T, Q> const& q1, qua<T, Q> const& q2)
 {
  return q1.x == q2.x && q1.y == q2.y && q1.z == q2.z && q1.w == q2.w;
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(qua<T, Q> const& q1, qua<T, Q> const& q2)
 {
  return q1.x != q2.x || q1.y != q2.y || q1.z != q2.z || q1.w != q2.w;
 }
}
# 193 "/usr/include/glm/detail/type_quat.hpp" 2 3 4
# 24 "/usr/include/glm/ext/quaternion_float.hpp" 2 3 4





namespace glm
{




 typedef qua<float, defaultp> quat;


}
# 22 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 1 "/usr/include/glm/ext/quaternion_float_precision.hpp" 1 3 4
# 11 "/usr/include/glm/ext/quaternion_float_precision.hpp" 3 4
       
# 20 "/usr/include/glm/ext/quaternion_float_precision.hpp" 3 4
namespace glm
{




 typedef qua<float, lowp> lowp_quat;


 typedef qua<float, mediump> mediump_quat;


 typedef qua<float, highp> highp_quat;


}
# 23 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 1 "/usr/include/glm/ext/quaternion_double.hpp" 1 3 4
# 20 "/usr/include/glm/ext/quaternion_double.hpp" 3 4
       
# 29 "/usr/include/glm/ext/quaternion_double.hpp" 3 4
namespace glm
{




 typedef qua<double, defaultp> dquat;


}
# 24 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 1 "/usr/include/glm/ext/quaternion_double_precision.hpp" 1 3 4
# 11 "/usr/include/glm/ext/quaternion_double_precision.hpp" 3 4
       
# 20 "/usr/include/glm/ext/quaternion_double_precision.hpp" 3 4
namespace glm
{






 typedef qua<double, lowp> lowp_dquat;




 typedef qua<double, mediump> mediump_dquat;




 typedef qua<double, highp> highp_dquat;


}
# 25 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4


# 1 "/usr/include/glm/ext/quaternion_trigonometric.hpp" 1 3 4
# 18 "/usr/include/glm/ext/quaternion_trigonometric.hpp" 3 4
       
# 31 "/usr/include/glm/ext/quaternion_trigonometric.hpp" 3 4
namespace glm
{
# 42 "/usr/include/glm/ext/quaternion_trigonometric.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] T angle(qua<T, Q> const& x);





 template<typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> axis(qua<T, Q> const& x);
# 59 "/usr/include/glm/ext/quaternion_trigonometric.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> angleAxis(T const& angle, vec<3, T, Q> const& axis);


}

# 1 "/usr/include/glm/ext/quaternion_trigonometric.inl" 1 3 4


namespace glm
{
 template<typename T, qualifier Q>
 inline T angle(qua<T, Q> const& x)
 {
  if (abs(x.w) > cos_one_over_two<T>())
  {
   T const a = asin(sqrt(x.x * x.x + x.y * x.y + x.z * x.z)) * static_cast<T>(2);
   if(x.w < static_cast<T>(0))
    return pi<T>() * static_cast<T>(2) - a;
   return a;
  }

  return acos(x.w) * static_cast<T>(2);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> axis(qua<T, Q> const& x)
 {
  T const tmp1 = static_cast<T>(1) - x.w * x.w;
  if(tmp1 <= static_cast<T>(0))
   return vec<3, T, Q>(0, 0, 1);
  T const tmp2 = static_cast<T>(1) / sqrt(tmp1);
  return vec<3, T, Q>(x.x * tmp2, x.y * tmp2, x.z * tmp2);
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> angleAxis(T const& angle, vec<3, T, Q> const& v)
 {
  T const a(angle);
  T const s = glm::sin(a * static_cast<T>(0.5));

  return qua<T, Q>(glm::cos(a * static_cast<T>(0.5)), v * s);
 }
}
# 66 "/usr/include/glm/ext/quaternion_trigonometric.hpp" 2 3 4
# 28 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 1 "/usr/include/glm/ext/quaternion_transform.hpp" 1 3 4
# 18 "/usr/include/glm/ext/quaternion_transform.hpp" 3 4
       
# 29 "/usr/include/glm/ext/quaternion_transform.hpp" 3 4
namespace glm
{
# 42 "/usr/include/glm/ext/quaternion_transform.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> rotate(qua<T, Q> const& q, T const& angle, vec<3, T, Q> const& axis);

}

# 1 "/usr/include/glm/ext/quaternion_transform.inl" 1 3 4
namespace glm
{
 template<typename T, qualifier Q>
 inline qua<T, Q> rotate(qua<T, Q> const& q, T const& angle, vec<3, T, Q> const& v)
 {
  vec<3, T, Q> Tmp = v;


  T len = glm::length(Tmp);
  if(abs(len - static_cast<T>(1)) > static_cast<T>(0.001))
  {
   T oneOverLen = static_cast<T>(1) / len;
   Tmp.x *= oneOverLen;
   Tmp.y *= oneOverLen;
   Tmp.z *= oneOverLen;
  }

  T const AngleRad(angle);
  T const Sin = sin(AngleRad * static_cast<T>(0.5));

  return q * qua<T, Q>::wxyz(cos(AngleRad * static_cast<T>(0.5)), Tmp.x * Sin, Tmp.y * Sin, Tmp.z * Sin);
 }
}
# 48 "/usr/include/glm/ext/quaternion_transform.hpp" 2 3 4
# 29 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 38 "/usr/include/glm/gtc/quaternion.hpp" 3 4
namespace glm
{
# 49 "/usr/include/glm/gtc/quaternion.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> eulerAngles(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] T roll(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] T pitch(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] T yaw(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] mat<3, 3, T, Q> mat3_cast(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> mat4_cast(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> quat_cast(mat<3, 3, T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> quat_cast(mat<4, 4, T, Q> const& x);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> lessThan(qua<T, Q> const& x, qua<T, Q> const& y);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> lessThanEqual(qua<T, Q> const& x, qua<T, Q> const& y);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> greaterThan(qua<T, Q> const& x, qua<T, Q> const& y);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> greaterThanEqual(qua<T, Q> const& x, qua<T, Q> const& y);





 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> quatLookAt(
  vec<3, T, Q> const& direction,
  vec<3, T, Q> const& up);





 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> quatLookAtRH(
  vec<3, T, Q> const& direction,
  vec<3, T, Q> const& up);





 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> quatLookAtLH(
  vec<3, T, Q> const& direction,
  vec<3, T, Q> const& up);

}

# 1 "/usr/include/glm/gtc/quaternion.inl" 1 3 4



# 1 "/usr/include/glm/gtc/epsilon.hpp" 1 3 4
# 14 "/usr/include/glm/gtc/epsilon.hpp" 3 4
       


# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 18 "/usr/include/glm/gtc/epsilon.hpp" 2 3 4






namespace glm
{







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, bool, Q> epsilonEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon);





 template<typename genType>
 [[nodiscard]] bool epsilonEqual(genType const& x, genType const& y, genType const& epsilon);





 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, bool, Q> epsilonNotEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon);





 template<typename genType>
 [[nodiscard]] bool epsilonNotEqual(genType const& x, genType const& y, genType const& epsilon);


}

# 1 "/usr/include/glm/gtc/epsilon.inl" 1 3 4






namespace glm
{
 template<>
 inline bool epsilonEqual
 (
  float const& x,
  float const& y,
  float const& epsilon
 )
 {
  return abs(x - y) < epsilon;
 }

 template<>
 inline bool epsilonEqual
 (
  double const& x,
  double const& y,
  double const& epsilon
 )
 {
  return abs(x - y) < epsilon;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> epsilonEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon)
 {
  return lessThan(abs(x - y), vec<L, T, Q>(epsilon));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> epsilonEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon)
 {
  return lessThan(abs(x - y), vec<L, T, Q>(epsilon));
 }

 template<>
 inline bool epsilonNotEqual(float const& x, float const& y, float const& epsilon)
 {
  return abs(x - y) >= epsilon;
 }

 template<>
 inline bool epsilonNotEqual(double const& x, double const& y, double const& epsilon)
 {
  return abs(x - y) >= epsilon;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> epsilonNotEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon)
 {
  return greaterThanEqual(abs(x - y), vec<L, T, Q>(epsilon));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> epsilonNotEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon)
 {
  return greaterThanEqual(abs(x - y), vec<L, T, Q>(epsilon));
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> epsilonEqual(qua<T, Q> const& x, qua<T, Q> const& y, T const& epsilon)
 {
  vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return lessThan(abs(v), vec<4, T, Q>(epsilon));
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> epsilonNotEqual(qua<T, Q> const& x, qua<T, Q> const& y, T const& epsilon)
 {
  vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return greaterThanEqual(abs(v), vec<4, T, Q>(epsilon));
 }
}
# 61 "/usr/include/glm/gtc/epsilon.hpp" 2 3 4
# 5 "/usr/include/glm/gtc/quaternion.inl" 2 3 4


namespace glm
{
 template<typename T, qualifier Q>
 inline vec<3, T, Q> eulerAngles(qua<T, Q> const& x)
 {
  return vec<3, T, Q>(pitch(x), yaw(x), roll(x));
 }

 template<typename T, qualifier Q>
 inline T roll(qua<T, Q> const& q)
 {
  T const y = static_cast<T>(2) * (q.x * q.y + q.w * q.z);
  T const x = q.w * q.w + q.x * q.x - q.y * q.y - q.z * q.z;

  if(all(equal(vec<2, T, Q>(x, y), vec<2, T, Q>(0), epsilon<T>())))
   return static_cast<T>(0);

  return static_cast<T>(atan(y, x));
 }

 template<typename T, qualifier Q>
 inline T pitch(qua<T, Q> const& q)
 {

  T const y = static_cast<T>(2) * (q.y * q.z + q.w * q.x);
  T const x = q.w * q.w - q.x * q.x - q.y * q.y + q.z * q.z;

  if(all(equal(vec<2, T, Q>(x, y), vec<2, T, Q>(0), epsilon<T>())))
   return static_cast<T>(static_cast<T>(2) * atan(q.x, q.w));

  return static_cast<T>(atan(y, x));
 }

 template<typename T, qualifier Q>
 inline T yaw(qua<T, Q> const& q)
 {
  return asin(clamp(static_cast<T>(-2) * (q.x * q.z - q.w * q.y), static_cast<T>(-1), static_cast<T>(1)));
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> mat3_cast(qua<T, Q> const& q)
 {
  mat<3, 3, T, Q> Result(T(1));
  T qxx(q.x * q.x);
  T qyy(q.y * q.y);
  T qzz(q.z * q.z);
  T qxz(q.x * q.z);
  T qxy(q.x * q.y);
  T qyz(q.y * q.z);
  T qwx(q.w * q.x);
  T qwy(q.w * q.y);
  T qwz(q.w * q.z);

  Result[0][0] = T(1) - T(2) * (qyy + qzz);
  Result[0][1] = T(2) * (qxy + qwz);
  Result[0][2] = T(2) * (qxz - qwy);

  Result[1][0] = T(2) * (qxy - qwz);
  Result[1][1] = T(1) - T(2) * (qxx + qzz);
  Result[1][2] = T(2) * (qyz + qwx);

  Result[2][0] = T(2) * (qxz + qwy);
  Result[2][1] = T(2) * (qyz - qwx);
  Result[2][2] = T(1) - T(2) * (qxx + qyy);
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> mat4_cast(qua<T, Q> const& q)
 {
  return mat<4, 4, T, Q>(mat3_cast(q));
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> quat_cast(mat<3, 3, T, Q> const& m)
 {
  T fourXSquaredMinus1 = m[0][0] - m[1][1] - m[2][2];
  T fourYSquaredMinus1 = m[1][1] - m[0][0] - m[2][2];
  T fourZSquaredMinus1 = m[2][2] - m[0][0] - m[1][1];
  T fourWSquaredMinus1 = m[0][0] + m[1][1] + m[2][2];

  int biggestIndex = 0;
  T fourBiggestSquaredMinus1 = fourWSquaredMinus1;
  if(fourXSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourXSquaredMinus1;
   biggestIndex = 1;
  }
  if(fourYSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourYSquaredMinus1;
   biggestIndex = 2;
  }
  if(fourZSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourZSquaredMinus1;
   biggestIndex = 3;
  }

  T biggestVal = sqrt(fourBiggestSquaredMinus1 + static_cast<T>(1)) * static_cast<T>(0.5);
  T mult = static_cast<T>(0.25) / biggestVal;

  switch(biggestIndex)
  {
  case 0:
   return qua<T, Q>::wxyz(biggestVal, (m[1][2] - m[2][1]) * mult, (m[2][0] - m[0][2]) * mult, (m[0][1] - m[1][0]) * mult);
  case 1:
   return qua<T, Q>::wxyz((m[1][2] - m[2][1]) * mult, biggestVal, (m[0][1] + m[1][0]) * mult, (m[2][0] + m[0][2]) * mult);
  case 2:
   return qua<T, Q>::wxyz((m[2][0] - m[0][2]) * mult, (m[0][1] + m[1][0]) * mult, biggestVal, (m[1][2] + m[2][1]) * mult);
  case 3:
   return qua<T, Q>::wxyz((m[0][1] - m[1][0]) * mult, (m[2][0] + m[0][2]) * mult, (m[1][2] + m[2][1]) * mult, biggestVal);
  default:
   (static_cast <bool> (false) ? void (0) : __assert_fail ("false", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
   return qua<T, Q>::wxyz(1, 0, 0, 0);
  }
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> quat_cast(mat<4, 4, T, Q> const& m4)
 {
  return quat_cast(mat<3, 3, T, Q>(m4));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, bool, Q> lessThan(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result(false, false, false, false);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] < y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, bool, Q> lessThanEqual(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result(false, false, false, false);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] <= y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, bool, Q> greaterThan(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result(false, false, false, false);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] > y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, bool, Q> greaterThanEqual(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result(false, false, false, false);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] >= y[i];
  return Result;
 }


 template<typename T, qualifier Q>
 inline qua<T, Q> quatLookAt(vec<3, T, Q> const& direction, vec<3, T, Q> const& up)
 {



   return quatLookAtRH(direction, up);

 }

 template<typename T, qualifier Q>
 inline qua<T, Q> quatLookAtRH(vec<3, T, Q> const& direction, vec<3, T, Q> const& up)
 {
  mat<3, 3, T, Q> Result;

  Result[2] = -direction;
  vec<3, T, Q> const& Right = cross(up, Result[2]);
  Result[0] = Right * inversesqrt(max(static_cast<T>(0.00001), dot(Right, Right)));
  Result[1] = cross(Result[2], Result[0]);

  return quat_cast(Result);
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> quatLookAtLH(vec<3, T, Q> const& direction, vec<3, T, Q> const& up)
 {
  mat<3, 3, T, Q> Result;

  Result[2] = direction;
  vec<3, T, Q> const& Right = cross(up, Result[2]);
  Result[0] = Right * inversesqrt(max(static_cast<T>(0.00001), dot(Right, Right)));
  Result[1] = cross(Result[2], Result[0]);

  return quat_cast(Result);
 }
}
# 174 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 38 "/usr/include/glm/gtc/type_ptr.hpp" 2 3 4
# 1 "/usr/include/glm/gtc/vec1.hpp" 1 3 4
# 13 "/usr/include/glm/gtc/vec1.hpp" 3 4
       


# 1 "/usr/include/glm/ext/vector_bool1.hpp" 1 3 4
# 13 "/usr/include/glm/ext/vector_bool1.hpp" 3 4
       







namespace glm
{




 typedef vec<1, bool, defaultp> bvec1;


}
# 17 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_bool1_precision.hpp" 1 3 4
# 11 "/usr/include/glm/ext/vector_bool1_precision.hpp" 3 4
       







namespace glm
{




 typedef vec<1, bool, highp> highp_bvec1;


 typedef vec<1, bool, mediump> mediump_bvec1;


 typedef vec<1, bool, lowp> lowp_bvec1;


}
# 18 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_float1.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_float1.hpp" 3 4
       







namespace glm
{




 typedef vec<1, float, defaultp> vec1;


}
# 19 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_float1_precision.hpp" 1 3 4
# 13 "/usr/include/glm/ext/vector_float1_precision.hpp" 3 4
       







namespace glm
{




 typedef vec<1, float, highp> highp_vec1;


 typedef vec<1, float, mediump> mediump_vec1;


 typedef vec<1, float, lowp> lowp_vec1;


}
# 20 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_double1.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_double1.hpp" 3 4
       







namespace glm
{




 typedef vec<1, double, defaultp> dvec1;


}
# 21 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_double1_precision.hpp" 1 3 4
# 13 "/usr/include/glm/ext/vector_double1_precision.hpp" 3 4
       







namespace glm
{




 typedef vec<1, double, highp> highp_dvec1;


 typedef vec<1, double, mediump> mediump_dvec1;


 typedef vec<1, double, lowp> lowp_dvec1;


}
# 22 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_int1.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_int1.hpp" 3 4
       







namespace glm
{




 typedef vec<1, int, defaultp> ivec1;


}
# 23 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_int1_sized.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_int1_sized.hpp" 3 4
       
# 23 "/usr/include/glm/ext/vector_int1_sized.hpp" 3 4
namespace glm
{






 typedef vec<1, int8, defaultp> i8vec1;




 typedef vec<1, int16, defaultp> i16vec1;




 typedef vec<1, int32, defaultp> i32vec1;




 typedef vec<1, int64, defaultp> i64vec1;


}
# 24 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_uint1.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_uint1.hpp" 3 4
       







namespace glm
{




 typedef vec<1, unsigned int, defaultp> uvec1;


}
# 25 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_uint1_sized.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_uint1_sized.hpp" 3 4
       
# 23 "/usr/include/glm/ext/vector_uint1_sized.hpp" 3 4
namespace glm
{






 typedef vec<1, uint8, defaultp> u8vec1;




 typedef vec<1, uint16, defaultp> u16vec1;




 typedef vec<1, uint32, defaultp> u32vec1;




 typedef vec<1, uint64, defaultp> u64vec1;


}
# 26 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 39 "/usr/include/glm/gtc/type_ptr.hpp" 2 3 4
# 51 "/usr/include/glm/gtc/type_ptr.hpp" 3 4
# 1 "/usr/include/c++/14.2.1/cstring" 1 3 4
# 39 "/usr/include/c++/14.2.1/cstring" 3 4
       
# 40 "/usr/include/c++/14.2.1/cstring" 3


# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 43 "/usr/include/c++/14.2.1/cstring" 2 3
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4

extern "C" {




# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 4)));




extern void *memset (void *__s, int __c, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 80 "/usr/include/string.h" 3 4
extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 105 "/usr/include/string.h" 3 4
}
# 115 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
# 141 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 1, 3)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) noexcept (true) __attribute__ ((__nonnull__ (2, 4)))
     __attribute__ ((__access__ (__write_only__, 1, 3)));





extern char *strdup (const char *__s)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 244 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 271 "/usr/include/string.h" 3 4
}
# 281 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 293 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 321 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 348 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 389 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)))
    __attribute__ ((__access__ (__read_only__, 1, 2)))
    __attribute__ ((__access__ (__read_only__, 3, 4)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) noexcept (true);
# 444 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));




extern const char *strerrordesc_np (int __err) noexcept (true);

extern const char *strerrorname_np (int __err) noexcept (true);





extern char *strerror_l (int __errnum, locale_t __l) noexcept (true);



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *index (char *__s, int __c)
     noexcept (true) __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     noexcept (true) __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 66 "/usr/include/strings.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     noexcept (true) __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     noexcept (true) __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 94 "/usr/include/strings.h" 3 4
}
# 104 "/usr/include/strings.h" 3 4
extern int ffs (int __i) noexcept (true) __attribute__ ((__const__));





extern int ffsl (long int __l) noexcept (true) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     noexcept (true) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 463 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) noexcept (true);



extern const char *sigabbrev_np (int __sig) noexcept (true);


extern const char *sigdescr_np (int __sig) noexcept (true);



extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlcpy (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 3)));



extern size_t strlcat (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__read_write__, 1, 3)));




extern int strverscmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__read_write__, 1, 2)));







extern "C++" char *basename (char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 552 "/usr/include/string.h" 3 4
}
# 44 "/usr/include/c++/14.2.1/cstring" 2 3
# 72 "/usr/include/c++/14.2.1/cstring" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;

  using ::strtok;

  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 125 "/usr/include/c++/14.2.1/cstring" 3

}
}
# 52 "/usr/include/glm/gtc/type_ptr.hpp" 2 3 4





namespace glm
{





 template<typename genType>
 [[nodiscard]] typename genType::value_type const * value_ptr(genType const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<1, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<2, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<3, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<4, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<1, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<2, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<3, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<4, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<1, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<2, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<3, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<4, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<1, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<2, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<3, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<4, T, Q> const& v);



 template<typename T>
 [[nodiscard]] vec<2, T, defaultp> make_vec2(T const * const ptr);



 template<typename T>
 [[nodiscard]] vec<3, T, defaultp> make_vec3(T const * const ptr);



 template<typename T>
 [[nodiscard]] vec<4, T, defaultp> make_vec4(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<2, 2, T, defaultp> make_mat2x2(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<2, 3, T, defaultp> make_mat2x3(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<2, 4, T, defaultp> make_mat2x4(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<3, 2, T, defaultp> make_mat3x2(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<3, 3, T, defaultp> make_mat3x3(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<3, 4, T, defaultp> make_mat3x4(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<4, 2, T, defaultp> make_mat4x2(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<4, 3, T, defaultp> make_mat4x3(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> make_mat4x4(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<2, 2, T, defaultp> make_mat2(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<3, 3, T, defaultp> make_mat3(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> make_mat4(T const * const ptr);



 template<typename T>
 [[nodiscard]] qua<T, defaultp> make_quat(T const * const ptr);


}

# 1 "/usr/include/glm/gtc/type_ptr.inl" 1 3 4


# 1 "/usr/include/c++/14.2.1/cstring" 1 3 4
# 39 "/usr/include/c++/14.2.1/cstring" 3 4
       
# 40 "/usr/include/c++/14.2.1/cstring" 3


# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 43 "/usr/include/c++/14.2.1/cstring" 2 3
# 4 "/usr/include/glm/gtc/type_ptr.inl" 2 3 4

namespace glm
{



 template<typename T, qualifier Q>
 inline T const* value_ptr(vec<2, T, Q> const& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(vec<2, T, Q>& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T const * value_ptr(vec<3, T, Q> const& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(vec<3, T, Q>& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(vec<4, T, Q> const& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(vec<4, T, Q>& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<2, 2, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<2, 2, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<3, 3, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<3, 3, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<4, 4, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<4, 4, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<2, 3, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<2, 3, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<3, 2, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<3, 2, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<2, 4, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<2, 4, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<4, 2, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<4, 2, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<3, 4, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<3, 4, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<4, 3, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T * value_ptr(mat<4, 3, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const * value_ptr(qua<T, Q> const& q)
 {
  return &(q[0]);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(qua<T, Q>& q)
 {
  return &(q[0]);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<1, T, Q> const& v)
 {
  return v;
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<2, T, Q> const& v)
 {
  return vec<1, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<3, T, Q> const& v)
 {
  return vec<1, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<4, T, Q> const& v)
 {
  return vec<1, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<1, T, Q> const& v)
 {
  return vec<2, T, Q>(v.x, static_cast<T>(0));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<2, T, Q> const& v)
 {
  return v;
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<3, T, Q> const& v)
 {
  return vec<2, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<4, T, Q> const& v)
 {
  return vec<2, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<1, T, Q> const& v)
 {
  return vec<3, T, Q>(v.x, static_cast<T>(0), static_cast<T>(0));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<2, T, Q> const& v)
 {
  return vec<3, T, Q>(v.x, v.y, static_cast<T>(0));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<3, T, Q> const& v)
 {
  return v;
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<4, T, Q> const& v)
 {
  return vec<3, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<1, T, Q> const& v)
 {
  return vec<4, T, Q>(v.x, static_cast<T>(0), static_cast<T>(0), static_cast<T>(1));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<2, T, Q> const& v)
 {
  return vec<4, T, Q>(v.x, v.y, static_cast<T>(0), static_cast<T>(1));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<3, T, Q> const& v)
 {
  return vec<4, T, Q>(v.x, v.y, v.z, static_cast<T>(1));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<4, T, Q> const& v)
 {
  return v;
 }

 template<typename T>
 inline vec<2, T, defaultp> make_vec2(T const *const ptr)
 {
  vec<2, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(vec<2, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline vec<3, T, defaultp> make_vec3(T const *const ptr)
 {
  vec<3, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(vec<3, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline vec<4, T, defaultp> make_vec4(T const *const ptr)
 {
  vec<4, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(vec<4, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<2, 2, T, defaultp> make_mat2x2(T const *const ptr)
 {
  mat<2, 2, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<2, 2, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<2, 3, T, defaultp> make_mat2x3(T const *const ptr)
 {
  mat<2, 3, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<2, 3, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<2, 4, T, defaultp> make_mat2x4(T const *const ptr)
 {
  mat<2, 4, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<2, 4, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<3, 2, T, defaultp> make_mat3x2(T const *const ptr)
 {
  mat<3, 2, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<3, 2, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<3, 3, T, defaultp> make_mat3x3(T const *const ptr)
 {
  mat<3, 3, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<3, 3, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<3, 4, T, defaultp> make_mat3x4(T const *const ptr)
 {
  mat<3, 4, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<3, 4, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<4, 2, T, defaultp> make_mat4x2(T const *const ptr)
 {
  mat<4, 2, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<4, 2, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<4, 3, T, defaultp> make_mat4x3(T const *const ptr)
 {
  mat<4, 3, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<4, 3, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> make_mat4x4(T const *const ptr)
 {
  mat<4, 4, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<4, 4, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<2, 2, T, defaultp> make_mat2(T const *const ptr)
 {
  return make_mat2x2(ptr);
 }

 template<typename T>
 inline mat<3, 3, T, defaultp> make_mat3(T const *const ptr)
 {
  return make_mat3x3(ptr);
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> make_mat4(T const *const ptr)
 {
  return make_mat4x4(ptr);
 }

 template<typename T>
 inline qua<T, defaultp> make_quat(T const *const ptr)
 {
  qua<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(qua<T, defaultp>));
  return Result;
 }


}
# 231 "/usr/include/glm/gtc/type_ptr.hpp" 2 3 4
# 8 "/home/tayler/projects/marmalade/src/graphics/shader.cpp" 2


# 1 "/usr/include/glm/gtx/string_cast.hpp" 1 3 4
# 15 "/usr/include/glm/gtx/string_cast.hpp" 3 4
       



# 1 "/usr/include/glm/gtc/type_precision.hpp" 1 3 4
# 14 "/usr/include/glm/gtc/type_precision.hpp" 3 4
       
# 46 "/usr/include/glm/gtc/type_precision.hpp" 3 4
namespace glm
{
# 56 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef detail::int8 lowp_int8;



 typedef detail::int16 lowp_int16;



 typedef detail::int32 lowp_int32;



 typedef detail::int64 lowp_int64;



 typedef detail::int8 lowp_int8_t;



 typedef detail::int16 lowp_int16_t;



 typedef detail::int32 lowp_int32_t;



 typedef detail::int64 lowp_int64_t;



 typedef detail::int8 lowp_i8;



 typedef detail::int16 lowp_i16;



 typedef detail::int32 lowp_i32;



 typedef detail::int64 lowp_i64;



 typedef detail::int8 mediump_int8;



 typedef detail::int16 mediump_int16;



 typedef detail::int32 mediump_int32;



 typedef detail::int64 mediump_int64;



 typedef detail::int8 mediump_int8_t;



 typedef detail::int16 mediump_int16_t;



 typedef detail::int32 mediump_int32_t;



 typedef detail::int64 mediump_int64_t;



 typedef detail::int8 mediump_i8;



 typedef detail::int16 mediump_i16;



 typedef detail::int32 mediump_i32;



 typedef detail::int64 mediump_i64;



 typedef detail::int8 highp_int8;



 typedef detail::int16 highp_int16;



 typedef detail::int32 highp_int32;



 typedef detail::int64 highp_int64;



 typedef detail::int8 highp_int8_t;



 typedef detail::int16 highp_int16_t;



 typedef detail::int32 highp_int32_t;



 typedef detail::int64 highp_int64_t;



 typedef detail::int8 highp_i8;



 typedef detail::int16 highp_i16;



 typedef detail::int32 highp_i32;



 typedef detail::int64 highp_i64;



 using std::int8_t;
 using std::int16_t;
 using std::int32_t;
 using std::int64_t;
# 224 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef detail::int8 i8;



 typedef detail::int16 i16;



 typedef detail::int32 i32;



 typedef detail::int64 i64;






 typedef detail::uint8 lowp_uint8;



 typedef detail::uint16 lowp_uint16;



 typedef detail::uint32 lowp_uint32;



 typedef detail::uint64 lowp_uint64;



 typedef detail::uint8 lowp_uint8_t;



 typedef detail::uint16 lowp_uint16_t;



 typedef detail::uint32 lowp_uint32_t;



 typedef detail::uint64 lowp_uint64_t;



 typedef detail::uint8 lowp_u8;



 typedef detail::uint16 lowp_u16;



 typedef detail::uint32 lowp_u32;



 typedef detail::uint64 lowp_u64;



 typedef detail::uint8 mediump_uint8;



 typedef detail::uint16 mediump_uint16;



 typedef detail::uint32 mediump_uint32;



 typedef detail::uint64 mediump_uint64;



 typedef detail::uint8 mediump_uint8_t;



 typedef detail::uint16 mediump_uint16_t;



 typedef detail::uint32 mediump_uint32_t;



 typedef detail::uint64 mediump_uint64_t;



 typedef detail::uint8 mediump_u8;



 typedef detail::uint16 mediump_u16;



 typedef detail::uint32 mediump_u32;



 typedef detail::uint64 mediump_u64;



 typedef detail::uint8 highp_uint8;



 typedef detail::uint16 highp_uint16;



 typedef detail::uint32 highp_uint32;



 typedef detail::uint64 highp_uint64;



 typedef detail::uint8 highp_uint8_t;



 typedef detail::uint16 highp_uint16_t;



 typedef detail::uint32 highp_uint32_t;



 typedef detail::uint64 highp_uint64_t;



 typedef detail::uint8 highp_u8;



 typedef detail::uint16 highp_u16;



 typedef detail::uint32 highp_u32;



 typedef detail::uint64 highp_u64;


 using std::uint8_t;
 using std::uint16_t;
 using std::uint32_t;
 using std::uint64_t;
# 410 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef detail::uint8 u8;



 typedef detail::uint16 u16;



 typedef detail::uint32 u32;



 typedef detail::uint64 u64;
# 433 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef float float32;



 typedef double float64;



 typedef float32 lowp_float32;



 typedef float64 lowp_float64;



 typedef float32 lowp_float32_t;



 typedef float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;



 typedef float32 lowp_float32;



 typedef float64 lowp_float64;



 typedef float32 lowp_float32_t;



 typedef float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;




 typedef float32 lowp_float32;



 typedef float64 lowp_float64;



 typedef float32 lowp_float32_t;



 typedef float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;




 typedef float32 mediump_float32;



 typedef float64 mediump_float64;



 typedef float32 mediump_float32_t;



 typedef float64 mediump_float64_t;



 typedef float32 mediump_f32;



 typedef float64 mediump_f64;




 typedef float32 highp_float32;



 typedef float64 highp_float64;



 typedef float32 highp_float32_t;



 typedef float64 highp_float64_t;



 typedef float32 highp_f32;



 typedef float64 highp_f64;
# 601 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef highp_float32_t float32_t;



 typedef highp_float64_t float64_t;



 typedef highp_float32_t f32;



 typedef highp_float64_t f64;





 typedef vec<1, float, lowp> lowp_fvec1;



 typedef vec<2, float, lowp> lowp_fvec2;



 typedef vec<3, float, lowp> lowp_fvec3;



 typedef vec<4, float, lowp> lowp_fvec4;




 typedef vec<1, float, mediump> mediump_fvec1;



 typedef vec<2, float, mediump> mediump_fvec2;



 typedef vec<3, float, mediump> mediump_fvec3;



 typedef vec<4, float, mediump> mediump_fvec4;




 typedef vec<1, float, highp> highp_fvec1;



 typedef vec<2, float, highp> highp_fvec2;



 typedef vec<3, float, highp> highp_fvec3;



 typedef vec<4, float, highp> highp_fvec4;




 typedef vec<1, f32, lowp> lowp_f32vec1;



 typedef vec<2, f32, lowp> lowp_f32vec2;



 typedef vec<3, f32, lowp> lowp_f32vec3;



 typedef vec<4, f32, lowp> lowp_f32vec4;



 typedef vec<1, f32, mediump> mediump_f32vec1;



 typedef vec<2, f32, mediump> mediump_f32vec2;



 typedef vec<3, f32, mediump> mediump_f32vec3;



 typedef vec<4, f32, mediump> mediump_f32vec4;



 typedef vec<1, f32, highp> highp_f32vec1;



 typedef vec<2, f32, highp> highp_f32vec2;



 typedef vec<3, f32, highp> highp_f32vec3;



 typedef vec<4, f32, highp> highp_f32vec4;




 typedef vec<1, f64, lowp> lowp_f64vec1;



 typedef vec<2, f64, lowp> lowp_f64vec2;



 typedef vec<3, f64, lowp> lowp_f64vec3;



 typedef vec<4, f64, lowp> lowp_f64vec4;



 typedef vec<1, f64, mediump> mediump_f64vec1;



 typedef vec<2, f64, mediump> mediump_f64vec2;



 typedef vec<3, f64, mediump> mediump_f64vec3;



 typedef vec<4, f64, mediump> mediump_f64vec4;



 typedef vec<1, f64, highp> highp_f64vec1;



 typedef vec<2, f64, highp> highp_f64vec2;



 typedef vec<3, f64, highp> highp_f64vec3;



 typedef vec<4, f64, highp> highp_f64vec4;
# 776 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef mat<2, 2, f32, lowp> lowp_fmat2x2;



 typedef mat<2, 3, f32, lowp> lowp_fmat2x3;



 typedef mat<2, 4, f32, lowp> lowp_fmat2x4;



 typedef mat<3, 2, f32, lowp> lowp_fmat3x2;



 typedef mat<3, 3, f32, lowp> lowp_fmat3x3;



 typedef mat<3, 4, f32, lowp> lowp_fmat3x4;



 typedef mat<4, 2, f32, lowp> lowp_fmat4x2;



 typedef mat<4, 3, f32, lowp> lowp_fmat4x3;



 typedef mat<4, 4, f32, lowp> lowp_fmat4x4;







 typedef lowp_fmat2x2 lowp_fmat2;



 typedef lowp_fmat3x3 lowp_fmat3;



 typedef lowp_fmat4x4 lowp_fmat4;
# 833 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef mat<2, 2, f32, mediump> mediump_fmat2x2;



 typedef mat<2, 3, f32, mediump> mediump_fmat2x3;



 typedef mat<2, 4, f32, mediump> mediump_fmat2x4;



 typedef mat<3, 2, f32, mediump> mediump_fmat3x2;



 typedef mat<3, 3, f32, mediump> mediump_fmat3x3;



 typedef mat<3, 4, f32, mediump> mediump_fmat3x4;



 typedef mat<4, 2, f32, mediump> mediump_fmat4x2;



 typedef mat<4, 3, f32, mediump> mediump_fmat4x3;



 typedef mat<4, 4, f32, mediump> mediump_fmat4x4;







 typedef mediump_fmat2x2 mediump_fmat2;



 typedef mediump_fmat3x3 mediump_fmat3;



 typedef mediump_fmat4x4 mediump_fmat4;
# 890 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef mat<2, 2, f32, highp> highp_fmat2x2;



 typedef mat<2, 3, f32, highp> highp_fmat2x3;



 typedef mat<2, 4, f32, highp> highp_fmat2x4;



 typedef mat<3, 2, f32, highp> highp_fmat3x2;



 typedef mat<3, 3, f32, highp> highp_fmat3x3;



 typedef mat<3, 4, f32, highp> highp_fmat3x4;



 typedef mat<4, 2, f32, highp> highp_fmat4x2;



 typedef mat<4, 3, f32, highp> highp_fmat4x3;



 typedef mat<4, 4, f32, highp> highp_fmat4x4;







 typedef highp_fmat2x2 highp_fmat2;



 typedef highp_fmat3x3 highp_fmat3;



 typedef highp_fmat4x4 highp_fmat4;
# 947 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef mat<2, 2, f32, lowp> lowp_f32mat2x2;



 typedef mat<2, 3, f32, lowp> lowp_f32mat2x3;



 typedef mat<2, 4, f32, lowp> lowp_f32mat2x4;



 typedef mat<3, 2, f32, lowp> lowp_f32mat3x2;



 typedef mat<3, 3, f32, lowp> lowp_f32mat3x3;



 typedef mat<3, 4, f32, lowp> lowp_f32mat3x4;



 typedef mat<4, 2, f32, lowp> lowp_f32mat4x2;



 typedef mat<4, 3, f32, lowp> lowp_f32mat4x3;



 typedef mat<4, 4, f32, lowp> lowp_f32mat4x4;







 typedef lowp_f32mat2x2 lowp_f32mat2;



 typedef lowp_f32mat3x3 lowp_f32mat3;



 typedef lowp_f32mat4x4 lowp_f32mat4;
# 1004 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef mat<2, 2, f32, mediump> mediump_f32mat2x2;



 typedef mat<2, 3, f32, mediump> mediump_f32mat2x3;



 typedef mat<2, 4, f32, mediump> mediump_f32mat2x4;



 typedef mat<3, 2, f32, mediump> mediump_f32mat3x2;



 typedef mat<3, 3, f32, mediump> mediump_f32mat3x3;



 typedef mat<3, 4, f32, mediump> mediump_f32mat3x4;



 typedef mat<4, 2, f32, mediump> mediump_f32mat4x2;



 typedef mat<4, 3, f32, mediump> mediump_f32mat4x3;



 typedef mat<4, 4, f32, mediump> mediump_f32mat4x4;







 typedef mediump_f32mat2x2 mediump_f32mat2;



 typedef mediump_f32mat3x3 mediump_f32mat3;



 typedef mediump_f32mat4x4 mediump_f32mat4;
# 1061 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef mat<2, 2, f32, highp> highp_f32mat2x2;



 typedef mat<2, 3, f32, highp> highp_f32mat2x3;



 typedef mat<2, 4, f32, highp> highp_f32mat2x4;



 typedef mat<3, 2, f32, highp> highp_f32mat3x2;



 typedef mat<3, 3, f32, highp> highp_f32mat3x3;



 typedef mat<3, 4, f32, highp> highp_f32mat3x4;



 typedef mat<4, 2, f32, highp> highp_f32mat4x2;



 typedef mat<4, 3, f32, highp> highp_f32mat4x3;



 typedef mat<4, 4, f32, highp> highp_f32mat4x4;







 typedef highp_f32mat2x2 highp_f32mat2;



 typedef highp_f32mat3x3 highp_f32mat3;



 typedef highp_f32mat4x4 highp_f32mat4;
# 1118 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef mat<2, 2, f64, lowp> lowp_f64mat2x2;



 typedef mat<2, 3, f64, lowp> lowp_f64mat2x3;



 typedef mat<2, 4, f64, lowp> lowp_f64mat2x4;



 typedef mat<3, 2, f64, lowp> lowp_f64mat3x2;



 typedef mat<3, 3, f64, lowp> lowp_f64mat3x3;



 typedef mat<3, 4, f64, lowp> lowp_f64mat3x4;



 typedef mat<4, 2, f64, lowp> lowp_f64mat4x2;



 typedef mat<4, 3, f64, lowp> lowp_f64mat4x3;



 typedef mat<4, 4, f64, lowp> lowp_f64mat4x4;







 typedef lowp_f64mat2x2 lowp_f64mat2;



 typedef lowp_f64mat3x3 lowp_f64mat3;



 typedef lowp_f64mat4x4 lowp_f64mat4;
# 1175 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef mat<2, 2, f64, mediump> mediump_f64mat2x2;



 typedef mat<2, 3, f64, mediump> mediump_f64mat2x3;



 typedef mat<2, 4, f64, mediump> mediump_f64mat2x4;



 typedef mat<3, 2, f64, mediump> mediump_f64mat3x2;



 typedef mat<3, 3, f64, mediump> mediump_f64mat3x3;



 typedef mat<3, 4, f64, mediump> mediump_f64mat3x4;



 typedef mat<4, 2, f64, mediump> mediump_f64mat4x2;



 typedef mat<4, 3, f64, mediump> mediump_f64mat4x3;



 typedef mat<4, 4, f64, mediump> mediump_f64mat4x4;







 typedef mediump_f64mat2x2 mediump_f64mat2;



 typedef mediump_f64mat3x3 mediump_f64mat3;



 typedef mediump_f64mat4x4 mediump_f64mat4;







 typedef mat<2, 2, f64, highp> highp_f64mat2x2;



 typedef mat<2, 3, f64, highp> highp_f64mat2x3;



 typedef mat<2, 4, f64, highp> highp_f64mat2x4;



 typedef mat<3, 2, f64, highp> highp_f64mat3x2;



 typedef mat<3, 3, f64, highp> highp_f64mat3x3;



 typedef mat<3, 4, f64, highp> highp_f64mat3x4;



 typedef mat<4, 2, f64, highp> highp_f64mat4x2;



 typedef mat<4, 3, f64, highp> highp_f64mat4x3;



 typedef mat<4, 4, f64, highp> highp_f64mat4x4;







 typedef highp_f64mat2x2 highp_f64mat2;



 typedef highp_f64mat3x3 highp_f64mat3;



 typedef highp_f64mat4x4 highp_f64mat4;







 typedef vec<1, int, lowp> lowp_ivec1;



 typedef vec<2, int, lowp> lowp_ivec2;



 typedef vec<3, int, lowp> lowp_ivec3;



 typedef vec<4, int, lowp> lowp_ivec4;




 typedef vec<1, int, mediump> mediump_ivec1;



 typedef vec<2, int, mediump> mediump_ivec2;



 typedef vec<3, int, mediump> mediump_ivec3;



 typedef vec<4, int, mediump> mediump_ivec4;




 typedef vec<1, int, highp> highp_ivec1;



 typedef vec<2, int, highp> highp_ivec2;



 typedef vec<3, int, highp> highp_ivec3;



 typedef vec<4, int, highp> highp_ivec4;




 typedef vec<1, i8, lowp> lowp_i8vec1;



 typedef vec<2, i8, lowp> lowp_i8vec2;



 typedef vec<3, i8, lowp> lowp_i8vec3;



 typedef vec<4, i8, lowp> lowp_i8vec4;




 typedef vec<1, i8, mediump> mediump_i8vec1;



 typedef vec<2, i8, mediump> mediump_i8vec2;



 typedef vec<3, i8, mediump> mediump_i8vec3;



 typedef vec<4, i8, mediump> mediump_i8vec4;




 typedef vec<1, i8, highp> highp_i8vec1;



 typedef vec<2, i8, highp> highp_i8vec2;



 typedef vec<3, i8, highp> highp_i8vec3;



 typedef vec<4, i8, highp> highp_i8vec4;




 typedef vec<1, i16, lowp> lowp_i16vec1;



 typedef vec<2, i16, lowp> lowp_i16vec2;



 typedef vec<3, i16, lowp> lowp_i16vec3;



 typedef vec<4, i16, lowp> lowp_i16vec4;




 typedef vec<1, i16, mediump> mediump_i16vec1;



 typedef vec<2, i16, mediump> mediump_i16vec2;



 typedef vec<3, i16, mediump> mediump_i16vec3;



 typedef vec<4, i16, mediump> mediump_i16vec4;




 typedef vec<1, i16, highp> highp_i16vec1;



 typedef vec<2, i16, highp> highp_i16vec2;



 typedef vec<3, i16, highp> highp_i16vec3;



 typedef vec<4, i16, highp> highp_i16vec4;




 typedef vec<1, i32, lowp> lowp_i32vec1;



 typedef vec<2, i32, lowp> lowp_i32vec2;



 typedef vec<3, i32, lowp> lowp_i32vec3;



 typedef vec<4, i32, lowp> lowp_i32vec4;




 typedef vec<1, i32, mediump> mediump_i32vec1;



 typedef vec<2, i32, mediump> mediump_i32vec2;



 typedef vec<3, i32, mediump> mediump_i32vec3;



 typedef vec<4, i32, mediump> mediump_i32vec4;




 typedef vec<1, i32, highp> highp_i32vec1;



 typedef vec<2, i32, highp> highp_i32vec2;



 typedef vec<3, i32, highp> highp_i32vec3;



 typedef vec<4, i32, highp> highp_i32vec4;




 typedef vec<1, i64, lowp> lowp_i64vec1;



 typedef vec<2, i64, lowp> lowp_i64vec2;



 typedef vec<3, i64, lowp> lowp_i64vec3;



 typedef vec<4, i64, lowp> lowp_i64vec4;




 typedef vec<1, i64, mediump> mediump_i64vec1;



 typedef vec<2, i64, mediump> mediump_i64vec2;



 typedef vec<3, i64, mediump> mediump_i64vec3;



 typedef vec<4, i64, mediump> mediump_i64vec4;




 typedef vec<1, i64, highp> highp_i64vec1;



 typedef vec<2, i64, highp> highp_i64vec2;



 typedef vec<3, i64, highp> highp_i64vec3;



 typedef vec<4, i64, highp> highp_i64vec4;







 typedef vec<1, uint, lowp> lowp_uvec1;



 typedef vec<2, uint, lowp> lowp_uvec2;



 typedef vec<3, uint, lowp> lowp_uvec3;



 typedef vec<4, uint, lowp> lowp_uvec4;




 typedef vec<1, uint, mediump> mediump_uvec1;



 typedef vec<2, uint, mediump> mediump_uvec2;



 typedef vec<3, uint, mediump> mediump_uvec3;



 typedef vec<4, uint, mediump> mediump_uvec4;




 typedef vec<1, uint, highp> highp_uvec1;



 typedef vec<2, uint, highp> highp_uvec2;



 typedef vec<3, uint, highp> highp_uvec3;



 typedef vec<4, uint, highp> highp_uvec4;




 typedef vec<1, u8, lowp> lowp_u8vec1;



 typedef vec<2, u8, lowp> lowp_u8vec2;



 typedef vec<3, u8, lowp> lowp_u8vec3;



 typedef vec<4, u8, lowp> lowp_u8vec4;




 typedef vec<1, u8, mediump> mediump_u8vec1;



 typedef vec<2, u8, mediump> mediump_u8vec2;



 typedef vec<3, u8, mediump> mediump_u8vec3;



 typedef vec<4, u8, mediump> mediump_u8vec4;




 typedef vec<1, u8, highp> highp_u8vec1;



 typedef vec<2, u8, highp> highp_u8vec2;



 typedef vec<3, u8, highp> highp_u8vec3;



 typedef vec<4, u8, highp> highp_u8vec4;




 typedef vec<1, u16, lowp> lowp_u16vec1;



 typedef vec<2, u16, lowp> lowp_u16vec2;



 typedef vec<3, u16, lowp> lowp_u16vec3;



 typedef vec<4, u16, lowp> lowp_u16vec4;




 typedef vec<1, u16, mediump> mediump_u16vec1;



 typedef vec<2, u16, mediump> mediump_u16vec2;



 typedef vec<3, u16, mediump> mediump_u16vec3;



 typedef vec<4, u16, mediump> mediump_u16vec4;




 typedef vec<1, u16, highp> highp_u16vec1;



 typedef vec<2, u16, highp> highp_u16vec2;



 typedef vec<3, u16, highp> highp_u16vec3;



 typedef vec<4, u16, highp> highp_u16vec4;




 typedef vec<1, u32, lowp> lowp_u32vec1;



 typedef vec<2, u32, lowp> lowp_u32vec2;



 typedef vec<3, u32, lowp> lowp_u32vec3;



 typedef vec<4, u32, lowp> lowp_u32vec4;




 typedef vec<1, u32, mediump> mediump_u32vec1;



 typedef vec<2, u32, mediump> mediump_u32vec2;



 typedef vec<3, u32, mediump> mediump_u32vec3;



 typedef vec<4, u32, mediump> mediump_u32vec4;




 typedef vec<1, u32, highp> highp_u32vec1;



 typedef vec<2, u32, highp> highp_u32vec2;



 typedef vec<3, u32, highp> highp_u32vec3;



 typedef vec<4, u32, highp> highp_u32vec4;




 typedef vec<1, u64, lowp> lowp_u64vec1;



 typedef vec<2, u64, lowp> lowp_u64vec2;



 typedef vec<3, u64, lowp> lowp_u64vec3;



 typedef vec<4, u64, lowp> lowp_u64vec4;




 typedef vec<1, u64, mediump> mediump_u64vec1;



 typedef vec<2, u64, mediump> mediump_u64vec2;



 typedef vec<3, u64, mediump> mediump_u64vec3;



 typedef vec<4, u64, mediump> mediump_u64vec4;




 typedef vec<1, u64, highp> highp_u64vec1;



 typedef vec<2, u64, highp> highp_u64vec2;



 typedef vec<3, u64, highp> highp_u64vec3;



 typedef vec<4, u64, highp> highp_u64vec4;







 typedef float32 float32_t;



 typedef float32 f32;





  typedef float64 float64_t;



  typedef float64 f64;




 typedef vec<1, float, defaultp> fvec1;



 typedef vec<2, float, defaultp> fvec2;



 typedef vec<3, float, defaultp> fvec3;



 typedef vec<4, float, defaultp> fvec4;




 typedef vec<1, f32, defaultp> f32vec1;



 typedef vec<2, f32, defaultp> f32vec2;



 typedef vec<3, f32, defaultp> f32vec3;



 typedef vec<4, f32, defaultp> f32vec4;




  typedef vec<1, f64, defaultp> f64vec1;



  typedef vec<2, f64, defaultp> f64vec2;



  typedef vec<3, f64, defaultp> f64vec3;



  typedef vec<4, f64, defaultp> f64vec4;
# 1881 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef mat<2, 2, f32, defaultp> fmat2;



 typedef mat<3, 3, f32, defaultp> fmat3;



 typedef mat<4, 4, f32, defaultp> fmat4;
# 1898 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef mat<2, 2, f32, defaultp> fmat2x2;



 typedef mat<2, 3, f32, defaultp> fmat2x3;



 typedef mat<2, 4, f32, defaultp> fmat2x4;



 typedef mat<3, 2, f32, defaultp> fmat3x2;



 typedef mat<3, 3, f32, defaultp> fmat3x3;



 typedef mat<3, 4, f32, defaultp> fmat3x4;



 typedef mat<4, 2, f32, defaultp> fmat4x2;



 typedef mat<4, 3, f32, defaultp> fmat4x3;



 typedef mat<4, 4, f32, defaultp> fmat4x4;
# 1939 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef mat<2, 2, f32, defaultp> f32mat2;



 typedef mat<3, 3, f32, defaultp> f32mat3;



 typedef mat<4, 4, f32, defaultp> f32mat4;
# 1956 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef mat<2, 2, f32, defaultp> f32mat2x2;



 typedef mat<2, 3, f32, defaultp> f32mat2x3;



 typedef mat<2, 4, f32, defaultp> f32mat2x4;



 typedef mat<3, 2, f32, defaultp> f32mat3x2;



 typedef mat<3, 3, f32, defaultp> f32mat3x3;



 typedef mat<3, 4, f32, defaultp> f32mat3x4;



 typedef mat<4, 2, f32, defaultp> f32mat4x2;



 typedef mat<4, 3, f32, defaultp> f32mat4x3;



 typedef mat<4, 4, f32, defaultp> f32mat4x4;
# 1999 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef mat<2, 2, f64, defaultp> f64mat2;



 typedef mat<3, 3, f64, defaultp> f64mat3;



 typedef mat<4, 4, f64, defaultp> f64mat4;
# 2016 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef mat<2, 2, f64, defaultp> f64mat2x2;



 typedef mat<2, 3, f64, defaultp> f64mat2x3;



 typedef mat<2, 4, f64, defaultp> f64mat2x4;



 typedef mat<3, 2, f64, defaultp> f64mat3x2;



 typedef mat<3, 3, f64, defaultp> f64mat3x3;



 typedef mat<3, 4, f64, defaultp> f64mat3x4;



 typedef mat<4, 2, f64, defaultp> f64mat4x2;



 typedef mat<4, 3, f64, defaultp> f64mat4x3;



 typedef mat<4, 4, f64, defaultp> f64mat4x4;
# 2057 "/usr/include/glm/gtc/type_precision.hpp" 3 4
 typedef qua<f32, defaultp> f32quat;



 typedef qua<f32, lowp> lowp_f32quat;



 typedef qua<f64, lowp> lowp_f64quat;



 typedef qua<f32, mediump> mediump_f32quat;





 typedef qua<f64, mediump> mediump_f64quat;



 typedef qua<f32, highp> highp_f32quat;



 typedef qua<f64, highp> highp_f64quat;



 typedef qua<f64, defaultp> f64quat;




}

# 1 "/usr/include/glm/gtc/type_precision.inl" 1 3 4


namespace glm
{

}
# 2095 "/usr/include/glm/gtc/type_precision.hpp" 2 3 4
# 20 "/usr/include/glm/gtx/string_cast.hpp" 2 3 4

# 1 "/usr/include/glm/gtx/dual_quaternion.hpp" 1 3 4
# 16 "/usr/include/glm/gtx/dual_quaternion.hpp" 3 4
       
# 29 "/usr/include/glm/gtx/dual_quaternion.hpp" 3 4
namespace glm
{



 template<typename T, qualifier Q = defaultp>
 struct tdualquat
 {


  typedef T value_type;
  typedef qua<T, Q> part_type;



  qua<T, Q> real, dual;



  typedef length_t length_type;

  [[nodiscard]] static constexpr length_type length(){return 2;}

  [[nodiscard]] part_type & operator[](length_type i);
  [[nodiscard]] part_type const& operator[](length_type i) const;



  constexpr tdualquat() = default;
  constexpr tdualquat(tdualquat<T, Q> const& d) = default;
  template<qualifier P>
  constexpr tdualquat(tdualquat<T, P> const& d);



  constexpr tdualquat(qua<T, Q> const& real);
  constexpr tdualquat(qua<T, Q> const& orientation, vec<3, T, Q> const& translation);
  constexpr tdualquat(qua<T, Q> const& real, qua<T, Q> const& dual);



  template<typename U, qualifier P>
  constexpr tdualquat(tdualquat<U, P> const& q);

  constexpr tdualquat(mat<2, 4, T, Q> const& holder_mat);
  constexpr tdualquat(mat<3, 4, T, Q> const& aug_mat);



  tdualquat<T, Q> & operator=(tdualquat<T, Q> const& m) = default;

  template<typename U>
  tdualquat<T, Q> & operator=(tdualquat<U, Q> const& m);
  template<typename U>
  tdualquat<T, Q> & operator*=(U s);
  template<typename U>
  tdualquat<T, Q> & operator/=(U s);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] tdualquat<T, Q> operator+(tdualquat<T, Q> const& q);

 template<typename T, qualifier Q>
 [[nodiscard]] tdualquat<T, Q> operator-(tdualquat<T, Q> const& q);



 template<typename T, qualifier Q>
 [[nodiscard]] tdualquat<T, Q> operator+(tdualquat<T, Q> const& q, tdualquat<T, Q> const& p);

 template<typename T, qualifier Q>
 [[nodiscard]] tdualquat<T, Q> operator*(tdualquat<T, Q> const& q, tdualquat<T, Q> const& p);

 template<typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> operator*(tdualquat<T, Q> const& q, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> operator*(vec<3, T, Q> const& v, tdualquat<T, Q> const& q);

 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> operator*(tdualquat<T, Q> const& q, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> operator*(vec<4, T, Q> const& v, tdualquat<T, Q> const& q);

 template<typename T, qualifier Q>
 [[nodiscard]] tdualquat<T, Q> operator*(tdualquat<T, Q> const& q, T const& s);

 template<typename T, qualifier Q>
 [[nodiscard]] tdualquat<T, Q> operator*(T const& s, tdualquat<T, Q> const& q);

 template<typename T, qualifier Q>
 [[nodiscard]] tdualquat<T, Q> operator/(tdualquat<T, Q> const& q, T const& s);



 template<typename T, qualifier Q>
 [[nodiscard]] bool operator==(tdualquat<T, Q> const& q1, tdualquat<T, Q> const& q2);

 template<typename T, qualifier Q>
 [[nodiscard]] bool operator!=(tdualquat<T, Q> const& q1, tdualquat<T, Q> const& q2);




 template <typename T, qualifier Q>
 [[nodiscard]] tdualquat<T, Q> dual_quat_identity();




 template<typename T, qualifier Q>
 [[nodiscard]] tdualquat<T, Q> normalize(tdualquat<T, Q> const& q);




 template<typename T, qualifier Q>
 [[nodiscard]] tdualquat<T, Q> lerp(tdualquat<T, Q> const& x, tdualquat<T, Q> const& y, T const& a);




 template<typename T, qualifier Q>
 [[nodiscard]] tdualquat<T, Q> inverse(tdualquat<T, Q> const& q);




 template<typename T, qualifier Q>
 [[nodiscard]] mat<2, 4, T, Q> mat2x4_cast(tdualquat<T, Q> const& x);




 template<typename T, qualifier Q>
 [[nodiscard]] mat<3, 4, T, Q> mat3x4_cast(tdualquat<T, Q> const& x);




 template<typename T, qualifier Q>
 [[nodiscard]] tdualquat<T, Q> dualquat_cast(mat<2, 4, T, Q> const& x);




 template<typename T, qualifier Q>
 [[nodiscard]] tdualquat<T, Q> dualquat_cast(mat<3, 4, T, Q> const& x);





 typedef tdualquat<float, lowp> lowp_dualquat;




 typedef tdualquat<float, mediump> mediump_dualquat;




 typedef tdualquat<float, highp> highp_dualquat;





 typedef tdualquat<float, lowp> lowp_fdualquat;




 typedef tdualquat<float, mediump> mediump_fdualquat;




 typedef tdualquat<float, highp> highp_fdualquat;





 typedef tdualquat<double, lowp> lowp_ddualquat;




 typedef tdualquat<double, mediump> mediump_ddualquat;




 typedef tdualquat<double, highp> highp_ddualquat;






 typedef highp_fdualquat dualquat;




 typedef highp_fdualquat fdualquat;
# 258 "/usr/include/glm/gtx/dual_quaternion.hpp" 3 4
 typedef highp_ddualquat ddualquat;
# 270 "/usr/include/glm/gtx/dual_quaternion.hpp" 3 4
}

# 1 "/usr/include/glm/gtx/dual_quaternion.inl" 1 3 4





namespace glm
{


 template<typename T, qualifier Q>
 inline typename tdualquat<T, Q>::part_type & tdualquat<T, Q>::operator[](typename tdualquat<T, Q>::length_type i)
 {
  (static_cast <bool> (i >= 0 && i < this->length()) ? void (0) : __assert_fail ("i >= 0 && i < this->length()", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  return (&real)[i];
 }

 template<typename T, qualifier Q>
 inline typename tdualquat<T, Q>::part_type const& tdualquat<T, Q>::operator[](typename tdualquat<T, Q>::length_type i) const
 {
  (static_cast <bool> (i >= 0 && i < this->length()) ? void (0) : __assert_fail ("i >= 0 && i < this->length()", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  return (&real)[i];
 }
# 42 "/usr/include/glm/gtx/dual_quaternion.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr tdualquat<T, Q>::tdualquat(tdualquat<T, P> const& d)
  : real(d.real)
  , dual(d.dual)
 {}



 template<typename T, qualifier Q>
 inline constexpr tdualquat<T, Q>::tdualquat(qua<T, Q> const& r)
  : real(r), dual(qua<T, Q>::wxyz(0, 0, 0, 0))
 {}

 template<typename T, qualifier Q>
 inline constexpr tdualquat<T, Q>::tdualquat(qua<T, Q> const& q, vec<3, T, Q> const& p)
  : real(q), dual(qua<T, Q>::wxyz(
   T(-0.5) * ( p.x*q.x + p.y*q.y + p.z*q.z),
   T(+0.5) * ( p.x*q.w + p.y*q.z - p.z*q.y),
   T(+0.5) * (-p.x*q.z + p.y*q.w + p.z*q.x),
   T(+0.5) * ( p.x*q.y - p.y*q.x + p.z*q.w)))
 {}

 template<typename T, qualifier Q>
 inline constexpr tdualquat<T, Q>::tdualquat(qua<T, Q> const& r, qua<T, Q> const& d)
  : real(r), dual(d)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr tdualquat<T, Q>::tdualquat(tdualquat<U, P> const& q)
  : real(q.real)
  , dual(q.dual)
 {}

 template<typename T, qualifier Q>
 inline constexpr tdualquat<T, Q>::tdualquat(mat<2, 4, T, Q> const& m)
 {
  *this = dualquat_cast(m);
 }

 template<typename T, qualifier Q>
 inline constexpr tdualquat<T, Q>::tdualquat(mat<3, 4, T, Q> const& m)
 {
  *this = dualquat_cast(m);
 }
# 103 "/usr/include/glm/gtx/dual_quaternion.inl" 3 4
 template<typename T, qualifier Q>
 template<typename U>
 inline tdualquat<T, Q> & tdualquat<T, Q>::operator=(tdualquat<U, Q> const& q)
 {
  this->real = q.real;
  this->dual = q.dual;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline tdualquat<T, Q> & tdualquat<T, Q>::operator*=(U s)
 {
  this->real *= static_cast<T>(s);
  this->dual *= static_cast<T>(s);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline tdualquat<T, Q> & tdualquat<T, Q>::operator/=(U s)
 {
  this->real /= static_cast<T>(s);
  this->dual /= static_cast<T>(s);
  return *this;
 }



 template<typename T, qualifier Q>
 inline tdualquat<T, Q> operator+(tdualquat<T, Q> const& q)
 {
  return q;
 }

 template<typename T, qualifier Q>
 inline tdualquat<T, Q> operator-(tdualquat<T, Q> const& q)
 {
  return tdualquat<T, Q>(-q.real, -q.dual);
 }



 template<typename T, qualifier Q>
 inline tdualquat<T, Q> operator+(tdualquat<T, Q> const& q, tdualquat<T, Q> const& p)
 {
  return tdualquat<T, Q>(q.real + p.real,q.dual + p.dual);
 }

 template<typename T, qualifier Q>
 inline tdualquat<T, Q> operator*(tdualquat<T, Q> const& p, tdualquat<T, Q> const& o)
 {
  return tdualquat<T, Q>(p.real * o.real,p.real * o.dual + p.dual * o.real);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator*(tdualquat<T, Q> const& q, vec<3, T, Q> const& v)
 {
  vec<3, T, Q> const real_v3(q.real.x,q.real.y,q.real.z);
  vec<3, T, Q> const dual_v3(q.dual.x,q.dual.y,q.dual.z);
  return (cross(real_v3, cross(real_v3,v) + v * q.real.w + dual_v3) + dual_v3 * q.real.w - real_v3 * q.dual.w) * T(2) + v;
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator*(vec<3, T, Q> const& v, tdualquat<T, Q> const& q)
 {
  return glm::inverse(q) * v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator*(tdualquat<T, Q> const& q, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(q * vec<3, T, Q>(v), v.w);
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator*(vec<4, T, Q> const& v, tdualquat<T, Q> const& q)
 {
  return glm::inverse(q) * v;
 }

 template<typename T, qualifier Q>
 inline tdualquat<T, Q> operator*(tdualquat<T, Q> const& q, T const& s)
 {
  return tdualquat<T, Q>(q.real * s, q.dual * s);
 }

 template<typename T, qualifier Q>
 inline tdualquat<T, Q> operator*(T const& s, tdualquat<T, Q> const& q)
 {
  return q * s;
 }

 template<typename T, qualifier Q>
 inline tdualquat<T, Q> operator/(tdualquat<T, Q> const& q, T const& s)
 {
  return tdualquat<T, Q>(q.real / s, q.dual / s);
 }



 template<typename T, qualifier Q>
 inline bool operator==(tdualquat<T, Q> const& q1, tdualquat<T, Q> const& q2)
 {
  return (q1.real == q2.real) && (q1.dual == q2.dual);
 }

 template<typename T, qualifier Q>
 inline bool operator!=(tdualquat<T, Q> const& q1, tdualquat<T, Q> const& q2)
 {
  return (q1.real != q2.real) || (q1.dual != q2.dual);
 }



 template<typename T, qualifier Q>
 inline tdualquat<T, Q> dual_quat_identity()
 {
  return tdualquat<T, Q>(
   qua<T, Q>::wxyz(static_cast<T>(1), static_cast<T>(0), static_cast<T>(0), static_cast<T>(0)),
   qua<T, Q>::wxyz(static_cast<T>(0), static_cast<T>(0), static_cast<T>(0), static_cast<T>(0)));
 }

 template<typename T, qualifier Q>
 inline tdualquat<T, Q> normalize(tdualquat<T, Q> const& q)
 {
  return q / length(q.real);
 }

 template<typename T, qualifier Q>
 inline tdualquat<T, Q> lerp(tdualquat<T, Q> const& x, tdualquat<T, Q> const& y, T const& a)
 {


  (static_cast <bool> (a >= static_cast<T>(0)) ? void (0) : __assert_fail ("a >= static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (a <= static_cast<T>(1)) ? void (0) : __assert_fail ("a <= static_cast<T>(1)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  T const k = dot(x.real,y.real) < static_cast<T>(0) ? -a : a;
  T const one(1);
  return tdualquat<T, Q>(x * (one - a) + y * k);
 }

 template<typename T, qualifier Q>
 inline tdualquat<T, Q> inverse(tdualquat<T, Q> const& q)
 {
  const glm::qua<T, Q> real = conjugate(q.real);
  const glm::qua<T, Q> dual = conjugate(q.dual);
  return tdualquat<T, Q>(real, dual + (real * (-2.0f * dot(real,dual))));
 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q> mat2x4_cast(tdualquat<T, Q> const& x)
 {
  return mat<2, 4, T, Q>( x[0].x, x[0].y, x[0].z, x[0].w, x[1].x, x[1].y, x[1].z, x[1].w );
 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q> mat3x4_cast(tdualquat<T, Q> const& x)
 {
  qua<T, Q> r = x.real / length2(x.real);

  qua<T, Q> const rr(r.w * x.real.w, r.x * x.real.x, r.y * x.real.y, r.z * x.real.z);
  r *= static_cast<T>(2);

  T const xy = r.x * x.real.y;
  T const xz = r.x * x.real.z;
  T const yz = r.y * x.real.z;
  T const wx = r.w * x.real.x;
  T const wy = r.w * x.real.y;
  T const wz = r.w * x.real.z;

  vec<4, T, Q> const a(
   rr.w + rr.x - rr.y - rr.z,
   xy - wz,
   xz + wy,
   -(x.dual.w * r.x - x.dual.x * r.w + x.dual.y * r.z - x.dual.z * r.y));

  vec<4, T, Q> const b(
   xy + wz,
   rr.w + rr.y - rr.x - rr.z,
   yz - wx,
   -(x.dual.w * r.y - x.dual.x * r.z - x.dual.y * r.w + x.dual.z * r.x));

  vec<4, T, Q> const c(
   xz - wy,
   yz + wx,
   rr.w + rr.z - rr.x - rr.y,
   -(x.dual.w * r.z + x.dual.x * r.y - x.dual.y * r.x - x.dual.z * r.w));

  return mat<3, 4, T, Q>(a, b, c);
 }

 template<typename T, qualifier Q>
 inline tdualquat<T, Q> dualquat_cast(mat<2, 4, T, Q> const& x)
 {
  return tdualquat<T, Q>(
   qua<T, Q>::wxyz( x[0].w, x[0].x, x[0].y, x[0].z ),
   qua<T, Q>::wxyz( x[1].w, x[1].x, x[1].y, x[1].z ));
 }

 template<typename T, qualifier Q>
 inline tdualquat<T, Q> dualquat_cast(mat<3, 4, T, Q> const& x)
 {
  qua<T, Q> real;

  T const trace = x[0].x + x[1].y + x[2].z;
  if(trace > static_cast<T>(0))
  {
   T const r = sqrt(T(1) + trace);
   T const invr = static_cast<T>(0.5) / r;
   real.w = static_cast<T>(0.5) * r;
   real.x = (x[2].y - x[1].z) * invr;
   real.y = (x[0].z - x[2].x) * invr;
   real.z = (x[1].x - x[0].y) * invr;
  }
  else if(x[0].x > x[1].y && x[0].x > x[2].z)
  {
   T const r = sqrt(T(1) + x[0].x - x[1].y - x[2].z);
   T const invr = static_cast<T>(0.5) / r;
   real.x = static_cast<T>(0.5)*r;
   real.y = (x[1].x + x[0].y) * invr;
   real.z = (x[0].z + x[2].x) * invr;
   real.w = (x[2].y - x[1].z) * invr;
  }
  else if(x[1].y > x[2].z)
  {
   T const r = sqrt(T(1) + x[1].y - x[0].x - x[2].z);
   T const invr = static_cast<T>(0.5) / r;
   real.x = (x[1].x + x[0].y) * invr;
   real.y = static_cast<T>(0.5) * r;
   real.z = (x[2].y + x[1].z) * invr;
   real.w = (x[0].z - x[2].x) * invr;
  }
  else
  {
   T const r = sqrt(T(1) + x[2].z - x[0].x - x[1].y);
   T const invr = static_cast<T>(0.5) / r;
   real.x = (x[0].z + x[2].x) * invr;
   real.y = (x[2].y + x[1].z) * invr;
   real.z = static_cast<T>(0.5) * r;
   real.w = (x[1].x - x[0].y) * invr;
  }

  qua<T, Q> dual;
  dual.x = static_cast<T>(0.5) * ( x[0].w * real.w + x[1].w * real.z - x[2].w * real.y);
  dual.y = static_cast<T>(0.5) * (-x[0].w * real.z + x[1].w * real.w + x[2].w * real.x);
  dual.z = static_cast<T>(0.5) * ( x[0].w * real.y - x[1].w * real.x + x[2].w * real.w);
  dual.w = -static_cast<T>(0.5) * ( x[0].w * real.x + x[1].w * real.y + x[2].w * real.z);
  return tdualquat<T, Q>(real, dual);
 }
}
# 273 "/usr/include/glm/gtx/dual_quaternion.hpp" 2 3 4
# 22 "/usr/include/glm/gtx/string_cast.hpp" 2 3 4

# 1 "/usr/include/c++/14.2.1/cmath" 1 3 4
# 39 "/usr/include/c++/14.2.1/cmath" 3 4
       
# 40 "/usr/include/c++/14.2.1/cmath" 3
# 24 "/usr/include/glm/gtx/string_cast.hpp" 2 3 4
# 1 "/usr/include/c++/14.2.1/cstring" 1 3 4
# 39 "/usr/include/c++/14.2.1/cstring" 3 4
       
# 40 "/usr/include/c++/14.2.1/cstring" 3


# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 43 "/usr/include/c++/14.2.1/cstring" 2 3
# 25 "/usr/include/glm/gtx/string_cast.hpp" 2 3 4







namespace glm
{





 template<typename genType>
 [[nodiscard]] std::string to_string(genType const& x);


}

# 1 "/usr/include/glm/gtx/string_cast.inl" 1 3 4


# 1 "/usr/include/c++/14.2.1/cstdarg" 1 3 4
# 39 "/usr/include/c++/14.2.1/cstdarg" 3 4
       
# 40 "/usr/include/c++/14.2.1/cstdarg" 3



# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stdarg.h" 1 3 4
# 44 "/usr/include/c++/14.2.1/cstdarg" 2 3
# 53 "/usr/include/c++/14.2.1/cstdarg" 3
namespace std
{
  using ::va_list;
}
# 4 "/usr/include/glm/gtx/string_cast.inl" 2 3 4
# 1 "/usr/include/c++/14.2.1/cstdio" 1 3 4
# 39 "/usr/include/c++/14.2.1/cstdio" 3 4
       
# 40 "/usr/include/c++/14.2.1/cstdio" 3
# 5 "/usr/include/glm/gtx/string_cast.inl" 2 3 4

namespace glm{
namespace detail
{
 template <typename T>
 struct cast
 {
  typedef T value_type;
 };

 template <>
 struct cast<float>
 {
  typedef double value_type;
 };

 inline std::string format(const char* message, ...) {
  std::size_t const STRING_BUFFER(4096);

  (static_cast <bool> (message != __null) ? void (0) : __assert_fail ("message != NULL", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (strlen(message) < STRING_BUFFER) ? void (0) : __assert_fail ("strlen(message) < STRING_BUFFER", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  char buffer[STRING_BUFFER];
  va_list list;






  __builtin_va_start(list,message);
  vsnprintf(buffer, STRING_BUFFER, message, list);
  __builtin_va_end(list);





  return buffer;
 }

 static const char* LabelTrue = "true";
 static const char* LabelFalse = "false";

 template<typename T, bool isFloat = false>
 struct literal
 {
  inline static char const * value() {return "%d";}
 };

 template<typename T>
 struct literal<T, true>
 {
  inline static char const * value() {return "%f";}
 };
# 75 "/usr/include/glm/gtx/string_cast.inl" 3 4
 template<typename T>
 struct prefix{};

 template<>
 struct prefix<float>
 {
  inline static char const * value() {return "";}
 };

 template<>
 struct prefix<double>
 {
  inline static char const * value() {return "d";}
 };

 template<>
 struct prefix<bool>
 {
  inline static char const * value() {return "b";}
 };

 template<>
 struct prefix<uint8_t>
 {
  inline static char const * value() {return "u8";}
 };

 template<>
 struct prefix<int8_t>
 {
  inline static char const * value() {return "i8";}
 };

 template<>
 struct prefix<uint16_t>
 {
  inline static char const * value() {return "u16";}
 };

 template<>
 struct prefix<int16_t>
 {
  inline static char const * value() {return "i16";}
 };

 template<>
 struct prefix<uint32_t>
 {
  inline static char const * value() {return "u";}
 };

 template<>
 struct prefix<int32_t>
 {
  inline static char const * value() {return "i";}
 };

 template<>
 struct prefix<uint64_t>
 {
  inline static char const * value() {return "u64";}
 };

 template<>
 struct prefix<int64_t>
 {
  inline static char const * value() {return "i64";}
 };

 template<typename matType>
 struct compute_to_string
 {};

 template<qualifier Q>
 struct compute_to_string<vec<1, bool, Q> >
 {
  inline static std::string call(vec<1, bool, Q> const& x)
  {
   return detail::format("bvec1(%s)",
    x[0] ? detail::LabelTrue : detail::LabelFalse);
  }
 };

 template<qualifier Q>
 struct compute_to_string<vec<2, bool, Q> >
 {
  inline static std::string call(vec<2, bool, Q> const& x)
  {
   return detail::format("bvec2(%s, %s)",
    x[0] ? detail::LabelTrue : detail::LabelFalse,
    x[1] ? detail::LabelTrue : detail::LabelFalse);
  }
 };

 template<qualifier Q>
 struct compute_to_string<vec<3, bool, Q> >
 {
  inline static std::string call(vec<3, bool, Q> const& x)
  {
   return detail::format("bvec3(%s, %s, %s)",
    x[0] ? detail::LabelTrue : detail::LabelFalse,
    x[1] ? detail::LabelTrue : detail::LabelFalse,
    x[2] ? detail::LabelTrue : detail::LabelFalse);
  }
 };

 template<qualifier Q>
 struct compute_to_string<vec<4, bool, Q> >
 {
  inline static std::string call(vec<4, bool, Q> const& x)
  {
   return detail::format("bvec4(%s, %s, %s, %s)",
    x[0] ? detail::LabelTrue : detail::LabelFalse,
    x[1] ? detail::LabelTrue : detail::LabelFalse,
    x[2] ? detail::LabelTrue : detail::LabelFalse,
    x[3] ? detail::LabelTrue : detail::LabelFalse);
  }
 };

 template<typename T, qualifier Q>
 struct compute_to_string<vec<1, T, Q> >
 {
  inline static std::string call(vec<1, T, Q> const& x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%svec1(%s)",
    PrefixStr,
    LiteralStr));

   return detail::format(FormatStr.c_str(),
    static_cast<typename cast<T>::value_type>(x[0]));
  }
 };

 template<typename T, qualifier Q>
 struct compute_to_string<vec<2, T, Q> >
 {
  inline static std::string call(vec<2, T, Q> const& x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%svec2(%s, %s)",
    PrefixStr,
    LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    static_cast<typename cast<T>::value_type>(x[0]),
    static_cast<typename cast<T>::value_type>(x[1]));
  }
 };

 template<typename T, qualifier Q>
 struct compute_to_string<vec<3, T, Q> >
 {
  inline static std::string call(vec<3, T, Q> const& x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%svec3(%s, %s, %s)",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    static_cast<typename cast<T>::value_type>(x[0]),
    static_cast<typename cast<T>::value_type>(x[1]),
    static_cast<typename cast<T>::value_type>(x[2]));
  }
 };

 template<typename T, qualifier Q>
 struct compute_to_string<vec<4, T, Q> >
 {
  inline static std::string call(vec<4, T, Q> const& x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%svec4(%s, %s, %s, %s)",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    static_cast<typename cast<T>::value_type>(x[0]),
    static_cast<typename cast<T>::value_type>(x[1]),
    static_cast<typename cast<T>::value_type>(x[2]),
    static_cast<typename cast<T>::value_type>(x[3]));
  }
 };


 template<typename T, qualifier Q>
 struct compute_to_string<mat<2, 2, T, Q> >
 {
  inline static std::string call(mat<2, 2, T, Q> const& x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat2x2((%s, %s), (%s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    static_cast<typename cast<T>::value_type>(x[0][0]), static_cast<typename cast<T>::value_type>(x[0][1]),
    static_cast<typename cast<T>::value_type>(x[1][0]), static_cast<typename cast<T>::value_type>(x[1][1]));
  }
 };

 template<typename T, qualifier Q>
 struct compute_to_string<mat<2, 3, T, Q> >
 {
  inline static std::string call(mat<2, 3, T, Q> const& x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat2x3((%s, %s, %s), (%s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    static_cast<typename cast<T>::value_type>(x[0][0]), static_cast<typename cast<T>::value_type>(x[0][1]), static_cast<typename cast<T>::value_type>(x[0][2]),
    static_cast<typename cast<T>::value_type>(x[1][0]), static_cast<typename cast<T>::value_type>(x[1][1]), static_cast<typename cast<T>::value_type>(x[1][2]));
  }
 };

 template<typename T, qualifier Q>
 struct compute_to_string<mat<2, 4, T, Q> >
 {
  inline static std::string call(mat<2, 4, T, Q> const& x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat2x4((%s, %s, %s, %s), (%s, %s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    static_cast<typename cast<T>::value_type>(x[0][0]), static_cast<typename cast<T>::value_type>(x[0][1]), static_cast<typename cast<T>::value_type>(x[0][2]), static_cast<typename cast<T>::value_type>(x[0][3]),
    static_cast<typename cast<T>::value_type>(x[1][0]), static_cast<typename cast<T>::value_type>(x[1][1]), static_cast<typename cast<T>::value_type>(x[1][2]), static_cast<typename cast<T>::value_type>(x[1][3]));
  }
 };

 template<typename T, qualifier Q>
 struct compute_to_string<mat<3, 2, T, Q> >
 {
  inline static std::string call(mat<3, 2, T, Q> const& x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat3x2((%s, %s), (%s, %s), (%s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    static_cast<typename cast<T>::value_type>(x[0][0]), static_cast<typename cast<T>::value_type>(x[0][1]),
    static_cast<typename cast<T>::value_type>(x[1][0]), static_cast<typename cast<T>::value_type>(x[1][1]),
    static_cast<typename cast<T>::value_type>(x[2][0]), static_cast<typename cast<T>::value_type>(x[2][1]));
  }
 };

 template<typename T, qualifier Q>
 struct compute_to_string<mat<3, 3, T, Q> >
 {
  inline static std::string call(mat<3, 3, T, Q> const& x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat3x3((%s, %s, %s), (%s, %s, %s), (%s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    static_cast<typename cast<T>::value_type>(x[0][0]), static_cast<typename cast<T>::value_type>(x[0][1]), static_cast<typename cast<T>::value_type>(x[0][2]),
    static_cast<typename cast<T>::value_type>(x[1][0]), static_cast<typename cast<T>::value_type>(x[1][1]), static_cast<typename cast<T>::value_type>(x[1][2]),
    static_cast<typename cast<T>::value_type>(x[2][0]), static_cast<typename cast<T>::value_type>(x[2][1]), static_cast<typename cast<T>::value_type>(x[2][2]));
  }
 };

 template<typename T, qualifier Q>
 struct compute_to_string<mat<3, 4, T, Q> >
 {
  inline static std::string call(mat<3, 4, T, Q> const& x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat3x4((%s, %s, %s, %s), (%s, %s, %s, %s), (%s, %s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    static_cast<typename cast<T>::value_type>(x[0][0]), static_cast<typename cast<T>::value_type>(x[0][1]), static_cast<typename cast<T>::value_type>(x[0][2]), static_cast<typename cast<T>::value_type>(x[0][3]),
    static_cast<typename cast<T>::value_type>(x[1][0]), static_cast<typename cast<T>::value_type>(x[1][1]), static_cast<typename cast<T>::value_type>(x[1][2]), static_cast<typename cast<T>::value_type>(x[1][3]),
    static_cast<typename cast<T>::value_type>(x[2][0]), static_cast<typename cast<T>::value_type>(x[2][1]), static_cast<typename cast<T>::value_type>(x[2][2]), static_cast<typename cast<T>::value_type>(x[2][3]));
  }
 };

 template<typename T, qualifier Q>
 struct compute_to_string<mat<4, 2, T, Q> >
 {
  inline static std::string call(mat<4, 2, T, Q> const& x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat4x2((%s, %s), (%s, %s), (%s, %s), (%s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    static_cast<typename cast<T>::value_type>(x[0][0]), static_cast<typename cast<T>::value_type>(x[0][1]),
    static_cast<typename cast<T>::value_type>(x[1][0]), static_cast<typename cast<T>::value_type>(x[1][1]),
    static_cast<typename cast<T>::value_type>(x[2][0]), static_cast<typename cast<T>::value_type>(x[2][1]),
    static_cast<typename cast<T>::value_type>(x[3][0]), static_cast<typename cast<T>::value_type>(x[3][1]));
  }
 };

 template<typename T, qualifier Q>
 struct compute_to_string<mat<4, 3, T, Q> >
 {
  inline static std::string call(mat<4, 3, T, Q> const& x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat4x3((%s, %s, %s), (%s, %s, %s), (%s, %s, %s), (%s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    static_cast<typename cast<T>::value_type>(x[0][0]), static_cast<typename cast<T>::value_type>(x[0][1]), static_cast<typename cast<T>::value_type>(x[0][2]),
    static_cast<typename cast<T>::value_type>(x[1][0]), static_cast<typename cast<T>::value_type>(x[1][1]), static_cast<typename cast<T>::value_type>(x[1][2]),
    static_cast<typename cast<T>::value_type>(x[2][0]), static_cast<typename cast<T>::value_type>(x[2][1]), static_cast<typename cast<T>::value_type>(x[2][2]),
    static_cast<typename cast<T>::value_type>(x[3][0]), static_cast<typename cast<T>::value_type>(x[3][1]), static_cast<typename cast<T>::value_type>(x[3][2]));
  }
 };

 template<typename T, qualifier Q>
 struct compute_to_string<mat<4, 4, T, Q> >
 {
  inline static std::string call(mat<4, 4, T, Q> const& x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat4x4((%s, %s, %s, %s), (%s, %s, %s, %s), (%s, %s, %s, %s), (%s, %s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    static_cast<typename cast<T>::value_type>(x[0][0]), static_cast<typename cast<T>::value_type>(x[0][1]), static_cast<typename cast<T>::value_type>(x[0][2]), static_cast<typename cast<T>::value_type>(x[0][3]),
    static_cast<typename cast<T>::value_type>(x[1][0]), static_cast<typename cast<T>::value_type>(x[1][1]), static_cast<typename cast<T>::value_type>(x[1][2]), static_cast<typename cast<T>::value_type>(x[1][3]),
    static_cast<typename cast<T>::value_type>(x[2][0]), static_cast<typename cast<T>::value_type>(x[2][1]), static_cast<typename cast<T>::value_type>(x[2][2]), static_cast<typename cast<T>::value_type>(x[2][3]),
    static_cast<typename cast<T>::value_type>(x[3][0]), static_cast<typename cast<T>::value_type>(x[3][1]), static_cast<typename cast<T>::value_type>(x[3][2]), static_cast<typename cast<T>::value_type>(x[3][3]));
  }
 };


 template<typename T, qualifier Q>
 struct compute_to_string<qua<T, Q> >
 {
  inline static std::string call(qua<T, Q> const& q)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%squat(%s, {%s, %s, %s})",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    static_cast<typename cast<T>::value_type>(q.w),
    static_cast<typename cast<T>::value_type>(q.x),
    static_cast<typename cast<T>::value_type>(q.y),
    static_cast<typename cast<T>::value_type>(q.z));
  }
 };

 template<typename T, qualifier Q>
 struct compute_to_string<tdualquat<T, Q> >
 {
  inline static std::string call(tdualquat<T, Q> const& x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%sdualquat((%s, {%s, %s, %s}), (%s, {%s, %s, %s}))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    static_cast<typename cast<T>::value_type>(x.real.w),
    static_cast<typename cast<T>::value_type>(x.real.x),
    static_cast<typename cast<T>::value_type>(x.real.y),
    static_cast<typename cast<T>::value_type>(x.real.z),
    static_cast<typename cast<T>::value_type>(x.dual.w),
    static_cast<typename cast<T>::value_type>(x.dual.x),
    static_cast<typename cast<T>::value_type>(x.dual.y),
    static_cast<typename cast<T>::value_type>(x.dual.z));
  }
 };

}

template<class matType>
 inline std::string to_string(matType const& x)
{
 return detail::compute_to_string<matType>::call(x);
}

}
# 46 "/usr/include/glm/gtx/string_cast.hpp" 2 3 4
# 11 "/home/tayler/projects/marmalade/src/graphics/shader.cpp" 2


# 12 "/home/tayler/projects/marmalade/src/graphics/shader.cpp"
Shader::Shader(const char *vPath, const char *fPath) {
    std::string vCode;
    std::string fCode;
    std::ifstream vFile;
    std::ifstream fFile;

    vFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
    fFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);

    try {
        vFile.open(vPath);
        fFile.open(fPath);

        std::stringstream vStream, fStream;
        vStream << vFile.rdbuf();
        fStream << fFile.rdbuf();

        vFile.close();
        fFile.close();

        vCode = vStream.str();
        fCode = fStream.str();
    } catch (std::ifstream::failure& e) {
        std::cout << "ERROR::SHADER::FILE_NOT_SUCCESSFULLY_READ: " << e.what() << std::endl;
    }

    const char* vSCode = vCode.c_str();
    const char* fSCode = fCode.c_str();
    unsigned int vertex, fragment;

    vertex = glad_glCreateShader(0x8B31);
    glad_glShaderSource(vertex, 1, &vSCode, 
# 43 "/home/tayler/projects/marmalade/src/graphics/shader.cpp" 3 4
                                      __null
# 43 "/home/tayler/projects/marmalade/src/graphics/shader.cpp"
                                          );
    glad_glCompileShader(vertex);
    GetError(vertex, "VERTEX");

    fragment = glad_glCreateShader(0x8B30);
    glad_glShaderSource(fragment, 1, &fSCode, 
# 48 "/home/tayler/projects/marmalade/src/graphics/shader.cpp" 3 4
                                        __null
# 48 "/home/tayler/projects/marmalade/src/graphics/shader.cpp"
                                            );
    glad_glCompileShader(fragment);
    GetError(fragment, "FRAGMENT");

    ID = glad_glCreateProgram();
    glad_glAttachShader(ID, vertex);
    glad_glAttachShader(ID, fragment);
    glad_glLinkProgram(ID);
    GetError(ID, "PROGRAM");

    glad_glDeleteShader(vertex);
    glad_glDeleteShader(fragment);
}

void Shader::Use() {
    glad_glUseProgram(ID);
}

void Shader::SetBool(const std::string &name, bool value) const {
    glad_glUniform1i(glad_glGetUniformLocation(ID, name.c_str()), (int)value);
}

void Shader::SetInt(const std::string& name, int value) const {
    glad_glUniform1i(glad_glGetUniformLocation(ID, name.c_str()), value);
}

void Shader::SetFloat(const std::string& name, float value) const {
    glad_glUniform1f(glad_glGetUniformLocation(ID, name.c_str()), value);
}

void Shader::SetMat4(const std::string& name, const glm::mat4& mat) const {
    int loc = glad_glGetUniformLocation(ID, name.c_str());
    glad_glUniformMatrix4fv(loc, 1, 0, glm::value_ptr(mat));
}

void Shader::GetError(unsigned int shader, std::string type) {
    int success;
    char infoLog[1024];
    if (type != "PROGRAM") {
        glad_glGetShaderiv(shader, 0x8B81, &success);
        if (!success) {
            glad_glGetShaderInfoLog(shader, 1024, 
# 89 "/home/tayler/projects/marmalade/src/graphics/shader.cpp" 3 4
                                            __null
# 89 "/home/tayler/projects/marmalade/src/graphics/shader.cpp"
                                                , infoLog);
            std::cout << "ERROR::SHADER_COMPILATION_ERROR of type: " << type << "\n" << infoLog << "\n -- --------------------------------------------------- -- " << std::endl;
        }
    } else {
        glad_glGetProgramiv(shader, 0x8B82, &success);
        if (!success) {
            glad_glGetProgramInfoLog(shader, 1024, 
# 95 "/home/tayler/projects/marmalade/src/graphics/shader.cpp" 3 4
                                             __null
# 95 "/home/tayler/projects/marmalade/src/graphics/shader.cpp"
                                                 , infoLog);
            std::cout << "ERROR::PROGRAM_LINKING_ERROR of type: " << type << "\n" << infoLog << "\n -- --------------------------------------------------- -- " << std::endl;
        }
    }
}
